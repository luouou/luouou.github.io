<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="跳转指令跳转指令用于实现程序流程的跳转，在ARM程序中有以下两种方法可以实现程序流程的跳转：  使用跳转指令，可以从当前指令向前或向后的32MB的地址空间的跳转 直接向程序计数器PC写入跳转地址值，通过向程序计数器PC写入跳转地址值，可以实现在4GB的地址空间中的任意跳转，在跳转之前结合使用MOV LR，PC等类似指令，可以保存将来的返回地址值，从而实现在4GB连续的线性地址空间的子程序调用。">
<meta property="og:type" content="article">
<meta property="og:title" content="ARM指令集">
<meta property="og:url" content="http://example.com/2023/03/01/cpu/asm/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:description" content="跳转指令跳转指令用于实现程序流程的跳转，在ARM程序中有以下两种方法可以实现程序流程的跳转：  使用跳转指令，可以从当前指令向前或向后的32MB的地址空间的跳转 直接向程序计数器PC写入跳转地址值，通过向程序计数器PC写入跳转地址值，可以实现在4GB的地址空间中的任意跳转，在跳转之前结合使用MOV LR，PC等类似指令，可以保存将来的返回地址值，从而实现在4GB连续的线性地址空间的子程序调用。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-01T10:57:32.054Z">
<meta property="article:modified_time" content="2023-03-01T10:57:32.054Z">
<meta property="article:author" content="ubun2">
<meta property="article:tag" content="asm">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/03/01/cpu/asm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>ARM指令集 | nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/cpu/asm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ARM指令集
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-01 18:57:32" itemprop="dateCreated datePublished" datetime="2023-03-01T18:57:32+08:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><p>跳转指令用于实现程序流程的跳转，在ARM程序中有以下两种方法可以实现程序流程的跳转：</p>
<ul>
<li>使用跳转指令，可以从当前指令向前或向后的32MB的地址空间的跳转</li>
<li>直接向程序计数器PC写入跳转地址值，通过向程序计数器PC写入跳转地址值，可以实现在4GB的地址空间中的任意跳转，在跳转之前结合使用MOV LR，PC等类似指令，可以保存将来的返回地址值，从而实现在4GB连续的线性地址空间的子程序调用。</li>
</ul>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>B指令立即跳转到给定的目标地址，从那里继续执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BL"><a href="#BL" class="headerlink" title="BL"></a>BL</h3><p>BL跳转到某地址（有返回），先将下一指令地址（即函数返回地址）保存到寄存器 lr (x30)中，再进行跳转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BL&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BLR"><a href="#BLR" class="headerlink" title="BLR"></a>BLR</h3><p>跳转到 某寄存器 (的值)指向的地址（有返回），先将下一指令地址（即函数返回地址）保存到寄存器  lr (x30)中，再进行跳转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blr x20       ; 先将下一指令地址（‘x20’指向的函数调用后的返回地址）保存到寄存器 ‘lr’ 中，然后再调用 ‘x20’ 指向的函数</span><br></pre></td></tr></table></figure>

<h3 id="BLX"><a href="#BLX" class="headerlink" title="BLX"></a>BLX</h3><p>BLX指令从ARM指令集跳转到指令中所指定的目标地址，并将处理器的工作状态有ARM状态切换到Thumb状态，该指令同时将PC的当前内容保存到寄存器R14中。因此，当子程序使用Thumb指令集，而调用者使用ARM指令集时，可以通过BLX指令实现子程序的调用和处理器工作状态的切换。同时，子程序的返回可以通过将寄存器R14值复制到PC中来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLX 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BX"><a href="#BX" class="headerlink" title="BX"></a>BX</h3><p>BX指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BX&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BR"><a href="#BR" class="headerlink" title="BR"></a>BR</h3><p>跳转到某寄存器(的值)指向的地址（无返回）, 不会改变 lr (x30) 寄存器的值。</p>
<h3 id="RET"><a href="#RET" class="headerlink" title="RET"></a>RET</h3><p>子程序（函数调用）返回指令，返回地址已默认保存在寄存器 lr (x30) 中。</p>
<h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><h3 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h3><p>MOV指令可完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV&#123;条件&#125;&#123;S&#125; 目的寄存器，源操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>S选项决定指令的操作是否影响CPSR中条件标志位的值，当没有S 时指令不更新CPSR中条件标志位的值。</li>
</ul>
<h3 id="MVN"><a href="#MVN" class="headerlink" title="MVN"></a>MVN</h3><p>MVN取反移动指令可完成从另一个寄存器、被移位的寄存器、或将一个立即数加载到目的寄存器，与MOV指令不同之处是在传送之前按位被取反了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVN&#123;条件&#125;&#123;S&#125; 目的寄存器，源操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>S决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVN R0，#0   ; 将立即数0取反传送到寄存器R0中，完成后R0=-1</span><br></pre></td></tr></table></figure>

<h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><h3 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h3><p>CMP指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较（操作数1 - 操作数2），同时更新CPSR中条件标志位的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<p>该指令进行一次减法运算，但不存储结果，只更改条件标志位。 标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT后缀的指令将可以执行。</p>
<h3 id="CMN"><a href="#CMN" class="headerlink" title="CMN"></a>CMN</h3><p>CMN指令用于把一个寄存器的内容和另一个寄存器的内容或立即数取反后进行比较，同时更新CPSR中条件标志位的值。该指令实际完成操作数1和操作数2相加，并根据结果更改条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMN&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<h3 id="TST"><a href="#TST" class="headerlink" title="TST"></a>TST</h3><p>TST指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的与运算，并根据运算结果更新CPSR中条件标志位的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TST&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1是要测试的数据，而操作数2是一个位掩码，该指令一般用来检测是否设置了特定的位。</li>
</ul>
<h3 id="TEQ"><a href="#TEQ" class="headerlink" title="TEQ"></a>TEQ</h3><p>TEQ是相等测试指令，用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位异或运算，并根据结果设置CPSR的标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEQ&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD指令用于把两个操作数相加，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<h3 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h3><p>ADC是带进位相加指令，用于把两个操作数相加，再加上CPSR中的C条件标志位的值，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>它使用一个进位标志位，这样就可以做比32位大的数的加法，注意不要忘记设置S后缀来更改进位标志。</li>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一 个寄存器，被移位的寄存器，或一个立即数</li>
</ul>
<p>示例：</p>
<p>以下指令序列完成两个128位数的加法，第一个数由高到低存放在寄存器R7～R4，第二个数由高到低存放在寄存器R11～R8，运算结果由高到低存放在寄 存器R3～R0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADDS    R0，R4，R8         ;  加低端的字</span><br><span class="line">ADCS    R1，R5，R9         ;  加第二个字，带进位</span><br><span class="line">ADCS    R2，R6，R10        ;  加第三个字，带进位</span><br><span class="line">ADC     R3，R7，R11        ;  加第四个字，带进位</span><br></pre></td></tr></table></figure>

<h3 id="SUB"><a href="#SUB" class="headerlink" title="SUB"></a>SUB</h3><p>SUB指令用于把操作数1减去操作数2，并将结果存放到目的寄存器中。该指令可用于有符号数或无符号数的减法运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<h3 id="SBC"><a href="#SBC" class="headerlink" title="SBC"></a>SBC</h3><p>SBC带进位减法指令用于把操作数1减去操作数2，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SBC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。该指令可用于有符号数或无符号数的减法运算。</p>
<h3 id="RSB"><a href="#RSB" class="headerlink" title="RSB"></a>RSB</h3><p>RSB指令称为逆向减法指令，用于把操作数2减去操作数1，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSB&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令可用于有符号数或无符号数的减法运算。</p>
<h3 id="RSC"><a href="#RSC" class="headerlink" title="RSC"></a>RSC</h3><p>RSC反向带进位减法指令用于把操作数2减去操作数1，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器操作</li>
<li>数2可以是一个寄存器，被移位 的寄存器，或一个立即数。</li>
</ul>
<p>该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。该指令可用于有符号数或 无符号数的减法运算。</p>
<p><strong>乘法指令</strong></p>
<p>乘法指令与前面的数据处理指令不同，指令中的所有操作数、目的寄存器 必须为通用寄存器，不能对操作数使用立即数或被移位的寄存器，同时，目的寄存器和操作数1必须是不同的寄存器。</p>
<h3 id="MUL"><a href="#MUL" class="headerlink" title="MUL"></a>MUL</h3><p>MUL指令完成将操作数1与操作数2的乘法运算，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操 作数2均为32位的有符号数或无符号数。</li>
</ul>
<h3 id="MLA"><a href="#MLA" class="headerlink" title="MLA"></a>MLA</h3><p>MLA带累加的相乘指令完成将操作数1与操作数2的乘法运算，再将乘积加上操作数3，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MLA&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2，操作数3</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的有符号数或无符号数。</li>
</ul>
<h3 id="SMULL"><a href="#SMULL" class="headerlink" title="SMULL"></a>SMULL</h3><p>SMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMULL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的有符号数。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMULL   R0，R1，R2，R3     ; R0 = （R2 × R3）的低32位</span><br><span class="line">                          ; R1 = （R2 × R3）的高32位</span><br></pre></td></tr></table></figure>

<h3 id="SMLAL"><a href="#SMLAL" class="headerlink" title="SMLAL"></a>SMLAL</h3><p>SMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMLAL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的有符号数。</li>
<li>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位;</li>
<li>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMLAL   R0，R1，R2，R3       ; R0 = （R2 × R3）的低32位 ＋ R0</span><br><span class="line">                            ; R1 = （R2 × R3）的高32位 ＋ R1</span><br></pre></td></tr></table></figure>

<h3 id="UMULL"><a href="#UMULL" class="headerlink" title="UMULL"></a>UMULL</h3><p>UMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UMULL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的无符号数。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UMULL   R0，R1，R2，R3       ; R0 = （R2 × R3）的低32位</span><br><span class="line">                            ; R1 = （R2 × R3）的高32位</span><br></pre></td></tr></table></figure>

<h3 id="UMLAL"><a href="#UMLAL" class="headerlink" title="UMLAL"></a>UMLAL</h3><p>UMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High 中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UMLAL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的无符号数；</li>
<li>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位;</li>
<li>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UMLAL   R0，R1，R2，R3            ; R0 = （R2 × R3）的低32位 ＋ R0</span><br><span class="line">                                 ; R1 = （R2 × R3）的高32位 ＋ R1</span><br></pre></td></tr></table></figure>

<h3 id="SDIV"><a href="#SDIV" class="headerlink" title="SDIV"></a>SDIV</h3><p>SDIV指令有符号数)将某一寄存器的值和另一个寄存器的值相除 并将结果保存在另一寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIV 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><p>AND指令用于在两个操作数上进行逻辑与运算，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令常用于屏蔽操作数1的某些位。</p>
<h3 id="ORR"><a href="#ORR" class="headerlink" title="ORR"></a>ORR</h3><p>ORR指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORR&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令常用于设置操作数1的某些位。</p>
<h3 id="EOR"><a href="#EOR" class="headerlink" title="EOR"></a>EOR</h3><p>EOR指令用于在两个操作数上进行逻辑异或运算，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EOR&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数</li>
</ul>
<p>该指令常用于反转操作数1的某些位。</p>
<h3 id="BIC"><a href="#BIC" class="headerlink" title="BIC"></a>BIC</h3><p>BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。 操作数2为32位的掩码，如果在掩码中设置了某一位，则清除这一位。未设置的掩码位保持不变。</li>
</ul>
<h3 id="LSL-ASL"><a href="#LSL-ASL" class="headerlink" title="LSL ASL"></a>LSL ASL</h3><p>LSL逻辑左移、ASL算术左移可完成对通用寄存器中的内容进行逻辑（或算术）的左移操作，按操作数所指定的数量向左移位，低位用零来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，LSL/ASL 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   R0, R1, LSL #2          ; 将R1中的内容左移两位后传送到R0 中。</span><br></pre></td></tr></table></figure>

<h3 id="LSR"><a href="#LSR" class="headerlink" title="LSR"></a>LSR</h3><p>LSR逻辑右移可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用零来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，LSR 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   R0, R1, LSR #2         ; 将R1中的内容右移两位后传送到R0 中，左端用零来填充。</span><br></pre></td></tr></table></figure>

<h3 id="ASR"><a href="#ASR" class="headerlink" title="ASR"></a>ASR</h3><p>ASR算术右移可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用第31位的值来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，ASR 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV    R0, R1, ASR #2        ; 将R1中的内容右移两位后传送到R0 中，左端用第31位的值来填充。</span><br></pre></td></tr></table></figure>

<h3 id="ROR"><a href="#ROR" class="headerlink" title="ROR"></a>ROR</h3><p>ROR可完成对通用寄存器中的内容进行循环右移的操作，按操作数所指定的数量向右循环移位，左端用右端移出的位来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，ROR 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>其中，操作数可以是通用寄存器，也可以是立即数（0～31）。显然，当进行32位的循环右移操作时，通用寄存器中的值不改变。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV    R0, R1, ROR #2       ; 将R1中的内容循环右移两位后传送到R0 中。</span><br></pre></td></tr></table></figure>

<h3 id="RRX"><a href="#RRX" class="headerlink" title="RRX"></a>RRX</h3><p>RRX可完成对通用寄存器中的内容进行带扩展的循环右移的操作，按操作数所指定的数量向右循环移位，左端用进位标志位C来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，RRX 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   R0, R1, RRX #2         ; 将R1中的内容进行带扩展的循环右移两位 后传送到R0中。</span><br></pre></td></tr></table></figure>

<h2 id="程序状态寄存器访问指令"><a href="#程序状态寄存器访问指令" class="headerlink" title="程序状态寄存器访问指令"></a>程序状态寄存器访问指令</h2><p>此类指令向通用寄存器或者从通用寄存器往外移动状态寄存器的内容。</p>
<h3 id="MRS"><a href="#MRS" class="headerlink" title="MRS"></a>MRS</h3><p>MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。该指令一般用在以下两种情况：</p>
<ul>
<li>当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器。</li>
<li>当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用该指令读出程序状态寄存器的值，然后保存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRS&#123;条件&#125;  通用寄存器 程序状态寄存器（CPSR或SPSR）</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRS R0，CPSR      ; 传送 CPSR的内容到R0</span><br><span class="line">MRS R0，SPSR      ; 传送 SPSR的内容到R0</span><br></pre></td></tr></table></figure>

<h3 id="MSR"><a href="#MSR" class="headerlink" title="MSR"></a>MSR</h3><p>MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中。其中，操作数可以为通用寄存器或立即数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSR&#123;条件&#125;    程序状态寄存器（CPSR或SPSR）_&lt;域&gt;，操作数</span><br></pre></td></tr></table></figure>

<p>&lt;域&gt;用于设置程序状态寄存器中需要 操作的位，32位的程序状态寄存器可分为4个域：</p>
<ul>
<li>位[31：24]为条件位域，用f表示；</li>
<li>位[23：16]为状态位域，用s表示；</li>
<li>位[15：8] 为扩展位域，用x表示；</li>
<li>位[7：0] 为控制位域，用c表示；</li>
</ul>
<p>该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MSR CPSR，R0        ; 传送R0的内容到CPSR</span><br><span class="line">MSR SPSR，R0        ; 传送R0的内容到SPSR</span><br><span class="line">MSR CPSR_c，R0      ; 传送R0的内容到SPSR，但仅仅修改CPSR中的控制位域</span><br></pre></td></tr></table></figure>

<h2 id="加载-存储指令"><a href="#加载-存储指令" class="headerlink" title="加载/存储指令"></a>加载/存储指令</h2><p>数据在存储器中，都是二进制码，计算机单凭数据本身是无法区分数据格式(有符号、无符号、多少位是一个数据)，甚至无法区分数据和代码的区别。这个取决于我们使用的汇编指令。</p>
<p>ARM微处理器支持加载/存储指令用于在寄存器和存储器之间传送数据：</p>
<ul>
<li>加载指令用于将存储器中的数据传送到寄存器；</li>
<li>存储指令则完成相反的操作。</li>
</ul>
<h3 id="LDR"><a href="#LDR" class="headerlink" title="LDR"></a>LDR</h3><p>LDR(Load Word)指令用于从存储器中将一个32位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR&#123;条件&#125; 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li>
</ul>
<p>该指令在程序设计中比较常用，且寻址方式灵活多样，请读者认真掌握。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LDR R0，[R1]             ; 将存储器地址为R1的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，R2]         ; 将存储器地址为R1+R2的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，#8]         ; 将存储器地址为R1+8的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，R2] ！       ; 将存储器地址为R1+R2的字数据读入寄存器R0，并将新地址R1＋R2写入R1。</span><br><span class="line">LDR R0，[R1，#8] ！       ; 将存储器地址为R1+8的字数据读入寄存器R0，并将新地址 R1＋8写入R1。</span><br><span class="line">LDR R0，[R1]，R2          ; 将存储器地址为R1的字数据读入寄存器R0，并将新地址 R1＋R2写入R1。</span><br><span class="line">LDR R0，[R1，R2，LSL#2]！  ; 将存储器地址为R1＋R2×4的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。</span><br><span class="line">LDR R0，[R1]，R2，LSL#2   ; 将存储器地址为R1的字数据读入 寄存器R0，并将新地址R1＋R2×4写入R1。</span><br></pre></td></tr></table></figure>

<h3 id="LDRB"><a href="#LDRB" class="headerlink" title="LDRB"></a>LDRB</h3><p>LDRB(Load unsigned Byte)指令用于从存储器中将一个8位的字节数据传送到目的寄存器中，同时将寄存器的高24位清零。 该指令通常用于从存储器中读取8位的字节数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR&#123;条件&#125;B 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDRB R0，[R1]           ; 将存储器地址为R1的字节数据读入寄存器R0，并将R0的高24位清零。</span><br><span class="line">LDRB R0，[R1，#8]       ; 将存储器地址为R1＋8的字节数据读入寄存器R0，并将R0的高24位清零。</span><br></pre></td></tr></table></figure>

<h3 id="LDRH"><a href="#LDRH" class="headerlink" title="LDRH"></a>LDRH</h3><p>LDRH(Load unsigned Half Word)指令用于从存储器中将一个16位的半字数据传送到目的寄存器中，同时将寄存器的高16位清零。 该指令通常用于从存储器中读取16位的半字数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR&#123;条件&#125;H 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LDRH   R0，[R1]         ; 将存储器地址为R1的半字数据读入寄存器 R0，并将R0的高16位清零。</span><br><span class="line">LDRH   R0，[R1，#8]     ; 将存储器地址为R1＋8的半字数据读入寄存器R0，并将R0 的高16位清零。</span><br><span class="line">LDRH   R0，[R1，R2]     ; 将存储器地址为R1＋R2的半字数据读入寄存器R0，并将 R0的高16位清零。</span><br></pre></td></tr></table></figure>

<h3 id="STR"><a href="#STR" class="headerlink" title="STR"></a>STR</h3><p>STR(Store Word)指令用于从源寄存器中将一个32位的字数据传送到存储器中。 该指令在程序设计中比较常用，且寻址方式灵活多样，使用方式可参考指令LDR。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR&#123;条件&#125; 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STR R0，[R1]，#8           ; 将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。</span><br><span class="line">STR R0，[R1，#8]           ; 将R0中的字数据写入以R1＋8为地址的存储器中。</span><br></pre></td></tr></table></figure>

<h3 id="STRB"><a href="#STRB" class="headerlink" title="STRB"></a>STRB</h3><p>STRB(Store unsigned Byte)指令用于从源寄存器中将一个8位的字节数据传送到存储器中。该字节数据为源寄存器中的低8位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR&#123;条件&#125;B 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STRB    R0，[R1]             ; 将寄存器R0中的字节数据写入以R1为地 址的存储器中。</span><br><span class="line">STRB    R0，[R1，#8]         ; 将寄存器R0中的字节数据写入以R1＋8为地址的存 储器中。</span><br></pre></td></tr></table></figure>

<h3 id="STRH"><a href="#STRH" class="headerlink" title="STRH"></a>STRH</h3><p>STRH(Store unsigned Half Word)指令用于从源寄存器中将一个16位的半字数据传送到存储器中。该半字数据为源寄存器中的低16位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR&#123;条件&#125;H 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STRH   R0，[R1]            ; 将寄存器R0中的半字数据写入以R1为地址的 存储器中。</span><br><span class="line">STRH   R0，[R1，#8]        ; 将寄存器R0中的半字数据写入以R1＋8 为地址的存储器中。</span><br></pre></td></tr></table></figure>

<h3 id="ADR"><a href="#ADR" class="headerlink" title="ADR"></a>ADR</h3><p>将一个立即值与 pc 值相加，并将结果写入目标寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADR&#123;cond&#125;&#123;.W&#125;  Rd,label</span><br></pre></td></tr></table></figure>

<h3 id="ADRP"><a href="#ADRP" class="headerlink" title="ADRP"></a>ADRP</h3><p>以页为单位的大范围的地址读取指令，这里的P就是page的意思。取得page的基地址存入寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADRP&#123;cond&#125;  Rd  label</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adrp    x2, .LANCHOR0   ; .LANCHOR0是个&lt;lable&gt;——一个大小为4KB的页的基址，指令的作用就是将该页的基址存到寄存器x2中</span><br><span class="line"></span><br><span class="line">adrp    x0, l_.str@PAGE         ; 将符号l.str所在的page基址读入x0</span><br><span class="line">add     x0, x0, l_.str@PAGEOFF  ; x0 = x0 + l.str所在page中的偏移量</span><br></pre></td></tr></table></figure>

<p><strong>批量数据加载/存储指令</strong></p>
<p>ARM微处理器所支持批量数据加载/存储指令可以一次在一片连续的存储器单元和多个寄存器之间传送数据，批量加载指令 用于将一片连续的存储器中的数据传送到多个寄存器，批量数据存储指令则完成相反的操作。</p>
<h3 id="LDM-STM"><a href="#LDM-STM" class="headerlink" title="LDM STM"></a>LDM STM</h3><p>LDM（或STM）指令用于从由基址寄存器所指示的一片连续存储器到寄存器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDM（或STM）&#123;条件&#125;&#123;类型&#125; 基址寄存器&#123;！&#125;，寄存器列表&#123;∧&#125;</span><br></pre></td></tr></table></figure>

<p>类型为以下几种情况：</p>
<ul>
<li>IA 每次传送后地址加1;</li>
<li>IB 每次传送前地址加1;</li>
<li>DA 每次传送后地址减1;</li>
<li>DB 每次传送前地址减1;</li>
<li>FD 满递减堆栈;</li>
<li>ED 空递减堆栈;</li>
<li>FA 满递增堆栈;</li>
<li>EA 空递增堆栈;</li>
</ul>
<p><code>&#123;！&#125;</code>为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。基址寄存器不允许为R15，寄存器列表可以为R0～R15的任意组合。</p>
<p><code>&#123;∧&#125;</code> 为可选后缀，当指令为LDM且寄存器列表中包含R15，选用该后缀时表示：除了正常的数据传送之外，还将SPSR复制到CPSR。同时，该后缀还表 示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STMFD R13!， &#123;R0，R4-R12，LR&#125;        ; 将寄存器列表中的寄存器（R0，R4到R12，LR）存入堆栈。</span><br><span class="line">LDMFD R13!， &#123;R0，R4-R12，PC&#125;        ; 将堆栈内容恢复到寄存器（R0，R4到R12，LR）。</span><br></pre></td></tr></table></figure>

<p><strong>数据交换指令</strong></p>
<p>在寄存器和内存之间交换数据</p>
<h3 id="SWP"><a href="#SWP" class="headerlink" title="SWP"></a>SWP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWP&#123;条件&#125; 目的寄存器，源寄存器1，[源寄存器2]</span><br></pre></td></tr></table></figure>

<p>SWP指令用于将源寄存器2所指向的存储器中的字数据传送到目的寄存器中，同时将源寄存器1中的字数据传送到源寄存器2所指向的存储器中。显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SWP   R0，R1，[R2]     ; 将R2所指向的存储器中的字数据传送到R0，同时将R1 中的字数据传送到R2所指向的存储单元。</span><br><span class="line">SWP   R0，R0，[R1]     ; 该指令完成将R1所指向的存储器中的字数 据与R0中的数据交换。</span><br></pre></td></tr></table></figure>

<p>SWP{B}：B是一个可选的后缀。如果存在 B，则交换一个字节。否则，交换一个32位字。</p>
<h3 id="SWPB"><a href="#SWPB" class="headerlink" title="SWPB"></a>SWPB</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWP&#123;条件&#125;B 目的寄存器，源寄存器1，[源寄存器2]</span><br></pre></td></tr></table></figure>

<p>SWPB指令用于将源寄存器2所指向的存储器中的字节数据传送到目的寄存器中，目的寄存器的高24清零，同时将源寄存器1中的字节数据传送到源寄存器2所指向的存储器中。</p>
<p>显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SWPB   R0，R1，[R2]       ; 将R2所指向的存储器中的字节数据传送到 R0，R0的高24位清零，同时将R1中的低8位数据传送到R2所指向的存储单元。</span><br><span class="line">SWPB   R0，R0，[R1]       ; 该指令完成将R1所指向的存储器中的 字节数据与R0中的低8位数据交换。</span><br></pre></td></tr></table></figure>

<h2 id="入栈出栈指令"><a href="#入栈出栈指令" class="headerlink" title="入栈出栈指令"></a>入栈出栈指令</h2><h3 id="LDP"><a href="#LDP" class="headerlink" title="LDP"></a>LDP</h3><p>出栈指令，ldr 的变种指令，可以同时操作两个寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldp x29, x30, [sp, #0x10]  ; 将 sp 偏移 16 个字节的值取出来，存入寄存器 x29 和寄存器 x30</span><br></pre></td></tr></table></figure>

<h3 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h3><p>入栈指令，str 的变种指令，可以同时操作两个寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stp x29, x30, [sp, #0x10]  ; 将 x29, x30 的值存入 sp 偏移 16 个字节的位置</span><br></pre></td></tr></table></figure>

<h2 id="协处理器指令"><a href="#协处理器指令" class="headerlink" title="协处理器指令"></a>协处理器指令</h2><p>ARM 微处理器可支持多达 16 个协处理器，用于各种协处理操作，在程序执行的过程中，每个协处理器只执行针对自身的协处理指令，忽略 ARM 处理器和其他协处理器的指令。</p>
<p>ARM 的协处理器指令主要用于 ARM 处理器初始化 ARM 协处理器的数据处理操作，以及在ARM 处理器的寄存器和协处理器的寄存器之间传送数据，和在 ARM 协处理器的寄存器和存储器之间传送数据。</p>
<h3 id="CDP"><a href="#CDP" class="headerlink" title="CDP"></a>CDP</h3><p>CDP指令用于ARM处理器通知ARM协处理器执行特定的操作，若协处理器不能成功完成特定的操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CDP&#123;条件&#125; 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure>

<p>其中协处理器操作码1和协处理 器操作码2为协处理器将要执行的操作，目的寄存器和源寄存器均为协处理器的寄存器，指令不涉及ARM处理器的寄存器和存储器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CDP   P3，2，C12，C10，C3，4  ; 该指令完成协处理器P3的初始化 </span><br></pre></td></tr></table></figure>

<h3 id="LDC"><a href="#LDC" class="headerlink" title="LDC"></a>LDC</h3><p>LDC指令用于将源寄存器所指向的存储器中的字数据传送到目的寄存器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDC&#123;条件&#125;&#123;L&#125; 协处理器编码，目的寄存器，[源寄存器]</span><br></pre></td></tr></table></figure>

<p>其中，{L}选项表示指 令为长读取操作，如用于双精度数据的传输。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDC   P3，C4，[R0]        ; 将ARM处理器的寄存器R0所指向的存储器中的字数 据传送到协处理器P3的寄存器C4中。 </span><br></pre></td></tr></table></figure>

<h3 id="STC"><a href="#STC" class="headerlink" title="STC"></a>STC</h3><p>STC指令用于将源寄存器中的字数据传送到目的寄存器所指向的存储器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STC&#123;条件&#125;&#123;L&#125; 协处理器编码，源寄存器，[目的寄存器]</span><br></pre></td></tr></table></figure>

<p>其中，{L}选项表示指 令为长读取操作，如用于双精度数据的传输。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STC   P3，C4，[R0]     ; 将协处理器P3的寄存器C4中的字数据传送到ARM处理 器的寄存器R0所指向的存储器中。 </span><br></pre></td></tr></table></figure>

<h3 id="MCR"><a href="#MCR" class="headerlink" title="MCR"></a>MCR</h3><p>MCR指令用于将ARM处理器寄存器中的数据传送到协处理器寄存器中，若协处理器不能成功完成操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MCR&#123;条件&#125; 协处理器编码，协处理器操作码1，源寄存器，目的寄存器1，目的寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure>

<p>其中协处理器操作码1和协处理 器操作码2为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄 存器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MCR   P3，3，R0，C4，C5，6     ; 将ARM处理器寄存器R0中的数据传送到协处 理器P3的寄存器C4和C5中。 </span><br></pre></td></tr></table></figure>

<h3 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h3><p>MRC指令用于将协处理器寄存器中的数据传送到ARM处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRC&#123;条件&#125; 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure>

<p>其中协处理器操作码1和协处理器操作码2为协处理器将要执行的操作，目的寄存器为ARM处理器的寄存器，源寄存器1和源寄存器2均为协处理器的寄存器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRC   P3，3，R0，C4，C5，6     ; 该指令将协处理器P3的寄存器中的数据传送到 ARM处理器寄存器中。</span><br></pre></td></tr></table></figure>

<h2 id="异常产生指令"><a href="#异常产生指令" class="headerlink" title="异常产生指令"></a>异常产生指令</h2><p>ARM指令集中提供了两条产生异常的指令，通过这两条指令可以用软件的方法实现异常。</p>
<h3 id="SWI"><a href="#SWI" class="headerlink" title="SWI"></a>SWI</h3><p>SWI指令用于产生软件中断，以便用户程序能调用操作系统的系统例程。操作系统在SWI的异常处理程序中提供相应的系统服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWI&#123;条件&#125; 24位的立即数</span><br></pre></td></tr></table></figure>

<p>指令中24位的立即数指定用户程序调用系统例程的类型，相关参数通过通用寄存器传递，当指令中24位的立即数被忽略时，用户程序调用系统例程的类型由通用寄存器R0的内容决定，同时，参数通过其他通用寄存器传递。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWI   0x02     ; 该指令调用操作系统编号位02的系统例程。</span><br></pre></td></tr></table></figure>

<h3 id="BKPT"><a href="#BKPT" class="headerlink" title="BKPT"></a>BKPT</h3><p>BKPT指令产生软件断点中断，可用于程序的调试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BKPT   16位的立即数</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="WFE"><a href="#WFE" class="headerlink" title="WFE"></a>WFE</h3><p>等待事件（Wait For Event）指令。自旋锁就使用到了WFE指令。</p>
<p>ARM架构下，有一个全局的事件寄存器（Event Register），系统中的每一个CPU核在这个寄存器上都有对应的位。当前CPU执行WFE指令的时候，如果事件寄存器对应当前CPU的位没有被设置（也就是0），则当前CPU核会进入低功耗模式，会被挂起，不会再执行其它操作；而如果事件寄存器对应当前CPU的位被设置了（也就是1），则会将事件寄存器对应当前CPU的位清空（设置成0），然后立即返回，继续执行下面的指令，不会进入低功耗模式。</p>
<p>只有在如下情况下才可能被重新唤醒：</p>
<ul>
<li>发生了IRQ中断（前提是没有被屏蔽）；</li>
<li>发生了FIQ中断（前提是没有被屏蔽）；</li>
<li>发生了SError中断（前提是没有被屏蔽）；</li>
<li>事件寄存器对应当前CPU核的位被置位（设置成1），如果是通过这种方式唤醒的，唤醒后会立即将事件寄存器对应当前CPU核的位清0。</li>
</ul>
<h3 id="WFI"><a href="#WFI" class="headerlink" title="WFI"></a>WFI</h3><p>等待中断（Wait For Interrupt）指令。执行WFI指令后，当前CPU核会立即进入低功耗状态。只有在如下情况下才可能被重新唤醒：</p>
<ul>
<li>发生了IRQ中断（不管有没有被屏蔽）；</li>
<li>发生了FIQ中断（不管有没有被屏蔽）；</li>
<li>发生了SError中断（不管有没有被屏蔽）。</li>
</ul>
<h3 id="SEV"><a href="#SEV" class="headerlink" title="SEV"></a>SEV</h3><p>发送事件（Send Event）指令将想系统中的所有CPU核发送事件。对应系统中的每个CPU核，设置事件寄存器（Event Register）相应的位。如果某个CPU核正在等待事件（WFE），那么该CPU核会被立即唤醒，并清除掉表示该CPU的事件寄存器相应的位。</p>
<h3 id="SEVL"><a href="#SEVL" class="headerlink" title="SEVL"></a>SEVL</h3><p>发送本地事件（Send Event Locally）指令。只会向当前CPU核心发送。如果是多核CPU那也只向当前核心，不会向CPU内的其它核心发送。</p>
<p>stp： 入栈指令（str 的变种指令，可以同时操作两个寄存器）</p>
<p>stp x29, x30, [sp, #0x10] ; 将 x29, x30 的值存入 sp 偏移 16 个字节的位置</p>
<p>ldp： 出栈指令（ldr 的变种指令，可以同时操作两个寄存器）</p>
<p>ldp x29, x30, [sp, #0x10] ; 将 sp 偏移 16 个字节的值取出来，存入寄存器 x29 和寄存器 x30</p>
<p>scvtf： (Signed Convert To Float)带符号 定点数 转换为 浮点数</p>
<p>scvtf d1, w0      ; 将寄存器 w0 的值(顶点数，转化成 浮点数) 保存到 向量寄存器/浮点寄存器 d1 中</p>
<p>fcvtzs： (Float Convert To Zero Signed)浮点数 转化为 定点数 （舍入为0）</p>
<p>fcvtzs w0, s0    ; 将向量寄存器 s0 的值(浮点数，转换成 定点数)保存到寄存器 w0 中</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/asm/" rel="tag"># asm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/01/boot/uboot_bootm/" rel="prev" title="uboot引导内核">
      <i class="fa fa-chevron-left"></i> uboot引导内核
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/01/tool/jekyll/" rel="next" title="jekyll 搭建个人博客">
      jekyll 搭建个人博客 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">1.</span> <span class="nav-text">跳转指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B"><span class="nav-number">1.1.</span> <span class="nav-text">B</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BL"><span class="nav-number">1.2.</span> <span class="nav-text">BL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BLR"><span class="nav-number">1.3.</span> <span class="nav-text">BLR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BLX"><span class="nav-number">1.4.</span> <span class="nav-text">BLX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BX"><span class="nav-number">1.5.</span> <span class="nav-text">BX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BR"><span class="nav-number">1.6.</span> <span class="nav-text">BR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RET"><span class="nav-number">1.7.</span> <span class="nav-text">RET</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="nav-number">2.</span> <span class="nav-text">数据传送指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MOV"><span class="nav-number">2.1.</span> <span class="nav-text">MOV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVN"><span class="nav-number">2.2.</span> <span class="nav-text">MVN</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4"><span class="nav-number">3.</span> <span class="nav-text">比较指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CMP"><span class="nav-number">3.1.</span> <span class="nav-text">CMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMN"><span class="nav-number">3.2.</span> <span class="nav-text">CMN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TST"><span class="nav-number">3.3.</span> <span class="nav-text">TST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TEQ"><span class="nav-number">3.4.</span> <span class="nav-text">TEQ</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-number">4.</span> <span class="nav-text">算术运算指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ADD"><span class="nav-number">4.1.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ADC"><span class="nav-number">4.2.</span> <span class="nav-text">ADC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SUB"><span class="nav-number">4.3.</span> <span class="nav-text">SUB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SBC"><span class="nav-number">4.4.</span> <span class="nav-text">SBC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSB"><span class="nav-number">4.5.</span> <span class="nav-text">RSB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSC"><span class="nav-number">4.6.</span> <span class="nav-text">RSC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MUL"><span class="nav-number">4.7.</span> <span class="nav-text">MUL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MLA"><span class="nav-number">4.8.</span> <span class="nav-text">MLA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMULL"><span class="nav-number">4.9.</span> <span class="nav-text">SMULL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMLAL"><span class="nav-number">4.10.</span> <span class="nav-text">SMLAL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UMULL"><span class="nav-number">4.11.</span> <span class="nav-text">UMULL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UMLAL"><span class="nav-number">4.12.</span> <span class="nav-text">UMLAL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDIV"><span class="nav-number">4.13.</span> <span class="nav-text">SDIV</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-number">5.</span> <span class="nav-text">逻辑运算指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AND"><span class="nav-number">5.1.</span> <span class="nav-text">AND</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ORR"><span class="nav-number">5.2.</span> <span class="nav-text">ORR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EOR"><span class="nav-number">5.3.</span> <span class="nav-text">EOR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIC"><span class="nav-number">5.4.</span> <span class="nav-text">BIC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LSL-ASL"><span class="nav-number">5.5.</span> <span class="nav-text">LSL ASL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LSR"><span class="nav-number">5.6.</span> <span class="nav-text">LSR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASR"><span class="nav-number">5.7.</span> <span class="nav-text">ASR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ROR"><span class="nav-number">5.8.</span> <span class="nav-text">ROR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RRX"><span class="nav-number">5.9.</span> <span class="nav-text">RRX</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">6.</span> <span class="nav-text">程序状态寄存器访问指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MRS"><span class="nav-number">6.1.</span> <span class="nav-text">MRS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MSR"><span class="nav-number">6.2.</span> <span class="nav-text">MSR</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">7.</span> <span class="nav-text">加载&#x2F;存储指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LDR"><span class="nav-number">7.1.</span> <span class="nav-text">LDR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LDRB"><span class="nav-number">7.2.</span> <span class="nav-text">LDRB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LDRH"><span class="nav-number">7.3.</span> <span class="nav-text">LDRH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STR"><span class="nav-number">7.4.</span> <span class="nav-text">STR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STRB"><span class="nav-number">7.5.</span> <span class="nav-text">STRB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STRH"><span class="nav-number">7.6.</span> <span class="nav-text">STRH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ADR"><span class="nav-number">7.7.</span> <span class="nav-text">ADR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ADRP"><span class="nav-number">7.8.</span> <span class="nav-text">ADRP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LDM-STM"><span class="nav-number">7.9.</span> <span class="nav-text">LDM STM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SWP"><span class="nav-number">7.10.</span> <span class="nav-text">SWP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SWPB"><span class="nav-number">7.11.</span> <span class="nav-text">SWPB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A5%E6%A0%88%E5%87%BA%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="nav-number">8.</span> <span class="nav-text">入栈出栈指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LDP"><span class="nav-number">8.1.</span> <span class="nav-text">LDP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STP"><span class="nav-number">8.2.</span> <span class="nav-text">STP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">9.</span> <span class="nav-text">协处理器指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CDP"><span class="nav-number">9.1.</span> <span class="nav-text">CDP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LDC"><span class="nav-number">9.2.</span> <span class="nav-text">LDC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STC"><span class="nav-number">9.3.</span> <span class="nav-text">STC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MCR"><span class="nav-number">9.4.</span> <span class="nav-text">MCR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MRC"><span class="nav-number">9.5.</span> <span class="nav-text">MRC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E6%8C%87%E4%BB%A4"><span class="nav-number">10.</span> <span class="nav-text">异常产生指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SWI"><span class="nav-number">10.1.</span> <span class="nav-text">SWI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BKPT"><span class="nav-number">10.2.</span> <span class="nav-text">BKPT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">11.</span> <span class="nav-text"></span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WFE"><span class="nav-number">11.1.</span> <span class="nav-text">WFE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WFI"><span class="nav-number">11.2.</span> <span class="nav-text">WFI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SEV"><span class="nav-number">11.3.</span> <span class="nav-text">SEV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SEVL"><span class="nav-number">11.4.</span> <span class="nav-text">SEVL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#-1"><span class="nav-number">12.</span> <span class="nav-text"></span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">226</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
