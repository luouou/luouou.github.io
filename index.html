<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/19/net/mac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/net/mac/" class="post-title-link" itemprop="url">MAC</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-19 15:08:35 / 修改时间：15:15:55" itemprop="dateCreated datePublished" datetime="2022-11-19T15:08:35+08:00">2022-11-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC(Medium Access Control)媒体访问控制，控制在往媒体上发送数据的先后，防止发生混乱。</p>
<p>MAC 地址共有 48 bit，用来唯一标识设备，在网卡生产时写入 ROM 里的，网卡驱动程序读取并分配给 MAC模块。通过 ARP 可以查询目标路由器的 MAC 地址。</p>
<table>
<thead>
<tr>
<th align="center">bit</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>0 单播地址<br/>1 多播地址</td>
</tr>
<tr>
<td align="center">2</td>
<td>0 全局地址<br/>1 本地地址</td>
</tr>
<tr>
<td align="center">3-24</td>
<td>厂商识别码</td>
</tr>
<tr>
<td align="center">25-48</td>
<td>网卡唯一标识</td>
</tr>
</tbody></table>
<p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，其作用就是将包送达路由器。</p>
<p><img src="/images/net/tcpip/mac_head.png" alt="img"></p>
<h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>网卡驱动从 IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC 模块发送发送包的命令。MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。再将数字信息按每个比特转换成电信号，然后由 PHY信号收发模块发送出去。</p>
<p><img src="/images/net/tcpip/pack.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改MAC地址</span></span><br><span class="line">ifconfig eth0 hw ether 12:34:56:78:90:12</span><br></pre></td></tr></table></figure>

<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机将网络包原样转发到目的地，交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。交换机的 MAC 地址表主要包含两个信息:设备的 MAC 地址，和该设备连接在交换机的端口。</p>
<p>交换机工作在全双工模式。</p>
<p><img src="/images/net/switch.png" alt="img"></p>
<p>交换机会自行更新或删除地址表中的记录，当收到包时会将发送方 MAC 地址以及其输入端口的号码写入MAC 地址表中，当端口上的设备长时间不工作，就会删除记录。</p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃。相对地，交换机的端口不具有 MAC 地址的端口，故不会核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。</p>
<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><p>集线器工作在物理层，会将收到的数据广播给其它端口。集线器里有一张以太网协议的表，根据以太网头部中记录的目的地信息查出相应的传输方向，在子网中将网络包传输到下一个转发设备。</p>
<p>集线器的接口中有一个 MDI/MDI-X 切换开关，MDI 就是对 RJ-45 接口和信号收发模块进行直连接线，而 MDI-X 则是交叉接线。</p>
<p>集线器工作在半双工模式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/30/algo/dynamic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/30/algo/dynamic/" class="post-title-link" itemprop="url">动态规划</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-30 19:29:01" itemprop="dateCreated datePublished" datetime="2022-10-30T19:29:01+08:00">2022-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-26 11:48:32" itemprop="dateModified" datetime="2022-11-26T11:48:32+08:00">2022-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>存在「重叠子问题」，子问题相互独立。</li>
<li>具备「最优子结构」，能通过子问题的最值得到原问题的最值。</li>
<li>列出「状态转移方程」：明确「状态」 -&gt; 定义 dp 数组的含义 -&gt; 明确「选择」-&gt; 明确 base case。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<p>动态规划的核心思想就是穷举求最值，如果暴力穷举的话效率会极其低下，需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。其中带备忘录的递归解法叫做「自顶向下」，动态规划叫做「自底向上」。</p>
<h2 id="菲波那切数列"><a href="#菲波那切数列" class="headerlink" title="菲波那切数列"></a>菲波那切数列</h2><p>斐波那契数列又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，又称为兔子数列。在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）。</p>
<p>暴力递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带备忘录的递归解法(自顶向下，通过备忘录剪枝)</p>
<p><img src="/images/code/algo/fib_memo.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fibonacci_memo</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;memo, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo[n] == <span class="number">-1</span>) &#123;</span><br><span class="line">        memo[n] = <span class="built_in">fibonacci_memo</span>(memo, n - <span class="number">1</span>) + <span class="built_in">fibonacci_memo</span>(memo, n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fibonacciMemo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n+<span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci_memo</span>(memo, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp 数组的迭代解法（自底向上，使用循环迭代）</p>
<p><img src="/images/code/algo/fib_dp.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fibonacci_dp</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h2><p>有k种面值的硬币，面值分别为c1, c2 … ck，每种硬币的数量无限，再给一个总金额amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。</p>
<p>凑零钱问题符合最优子结构，比如求 amount = 11 时的最少硬币数（原问题），如果知道凑出 amount = 10 的最少硬币数（子问题），只需把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。</p>
<ol>
<li><p>先确定「状态」，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额amount。</p>
</li>
<li><p>然后确定dp数组的定义：函数 dp(n)表示，当前的目标金额是n，至少需要dp(n)个硬币凑出该金额。</p>
</li>
<li><p>然后确定「选择」并择优，也就是对于每个状态，可以做出什么选择改变当前状态。无论当前的目标金额是多少，选择就是从面额列表coins中选择一个硬币，然后目标金额就会减少。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="type">int</span>], amount: <span class="type">int</span>)</span>:</span></span><br><span class="line"><span class="function">    # 定义：要凑出金额 n，至少要 dp(n) 个硬币</span></span><br><span class="line"><span class="function">    def dp(n):</span></span><br><span class="line"><span class="function">        # 做选择，需要硬币最少的那个结果就是答案</span></span><br><span class="line"><span class="function">        for coin in coins:</span></span><br><span class="line"><span class="function">            res =</span> <span class="built_in">min</span>(res, <span class="number">1</span> + <span class="built_in">dp</span>(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    # 我们要求目标金额是 amount</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(amount)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最后明确 base case，显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="type">int</span>], amount: <span class="type">int</span>)</span>:</span></span><br><span class="line"><span class="function">    def dp(n):</span></span><br><span class="line"><span class="function">        # base case</span></span><br><span class="line"><span class="function">        if n =</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        # 求最小值，所以初始化为正无穷</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> coin in coins:</span><br><span class="line">            subproblem = <span class="built_in">dp</span>(n - coin)</span><br><span class="line">            # 子问题无解，跳过</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(amount)</span><br></pre></td></tr></table></figure>

<p><img src="/images/code/algo/coin.png" alt="img"></p>
<p>带备忘录的递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="type">int</span>], amount: <span class="type">int</span>)</span>:</span></span><br><span class="line"><span class="function">    # 备忘录</span></span><br><span class="line"><span class="function">    memo =</span> <span class="built_in">dict</span>()</span><br><span class="line">    <span class="function">def <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">        # 查备忘录，避免重复计算</span></span><br><span class="line"><span class="function">        if n in memo: return memo[n]</span></span><br><span class="line"><span class="function">        if n =</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> coin in coins:</span><br><span class="line">            subproblem = <span class="built_in">dp</span>(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line">        # 记入备忘录</span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(amount)</span><br></pre></td></tr></table></figure>

<p>dp 数组迭代解法</p>
<p><img src="/images/code/algo/coin_dp.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 在求所有子问题 + 1 的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？</p>
<p>明确两点，「状态」和「选择」。</p>
<ol>
<li><p>明确状态，状态有两个，就是「背包的容量」和「可选择的物品」。</p>
</li>
<li><p>明确选择，就是「装进背包」或者「不装进背包」。</p>
</li>
<li><p>明确 dp 数组的定义：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = <span class="built_in">max</span>(</span><br><span class="line">            dp[i<span class="number">-1</span>][w],  <span class="comment">// 不把物品 i 装进背包</span></span><br><span class="line">            dp[i<span class="number">-1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>]  <span class="comment">// 把物品 i 装进背包</span></span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>明确base case，就是 dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, vector&lt;<span class="type">int</span>&gt;&amp; wt, vector&lt;<span class="type">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case 已初始化</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这种情况下只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子集背包问题"><a href="#子集背包问题" class="headerlink" title="子集背包问题"></a>子集背包问题</h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<ol>
<li><p>明确「状态」和「选择」，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p>
</li>
<li><p>明确dp数组的定义，dp[i][j] = x表示：对于前i个物品，当前背包的容量为j时，若x为true，则说明可以恰好将背包装满，若x为false，则说明不能恰好将背包装满。根据这个定义，我们想求的最终答案就是dp[N][sum/2]。</p>
</li>
<li><p>base case 就是dp[..][0] = true和dp[0][..] = false，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        sum += num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和为奇数时，不可能划分成两个和相等的集合</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(sum + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">               <span class="comment">// 背包容量不足，不能装入第 i 个物品</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或不装入背包</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到dp[i][j]都是通过上一行dp[i-1][..]转移过来的，之前的数据都不会再使用了。所以可以进行状态压缩，将二维dp数组压缩为一维，节约空间复杂度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        sum += num;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = sum; j &gt;= <span class="number">0</span>; j--) </span><br><span class="line">            <span class="keyword">if</span> (j - nums[i] &gt;= <span class="number">0</span>) </span><br><span class="line">                dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>有一个背包，最大容量为amount，有一系列物品coins，每个物品的重量为coins[i]，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？</p>
<ol>
<li><p>明确「状态」和「选择」，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p>
</li>
<li><p>明确 dp[i][j]数组的定义：若只使用前i个物品，当背包容量为j时，有dp[i][j]种方法可以装满背包。</p>
</li>
<li><p>base case 为dp[0][..] = 0， dp[..][0] = 1。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么不用装就满了。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= coins[i<span class="number">-1</span>])</span><br><span class="line">                <span class="comment">//把这第i个物品装入背包，装入第i种商品后还可以再继续装入第i种商品。</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i<span class="number">-1</span>]]; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">//不把这第i个物品装入背包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察可以发现，dp数组的转移只和dp[i][..]和dp[i-1][..]有关，所以可以压缩状态，进一步降低算法的空间复杂度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="type">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">            <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[j] = dp[j] + dp[j-coins[i]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/algo/heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/algo/heap/" class="post-title-link" itemprop="url">堆</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-25 21:32:48" itemprop="dateCreated datePublished" datetime="2022-09-25T21:32:48+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-04 16:17:22" itemprop="dateModified" datetime="2022-10-04T16:17:22+08:00">2022-10-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>堆是一种完全二叉树，每个节点的值都大于等于（或小于等于）其子树节点的值。</p>
<ul>
<li>对于每个节点的值都大于等于子树中每个节点值的堆叫<strong>大顶堆</strong>，</li>
<li>对于每个节点的值都小于等于子树中每个节点值的堆叫<strong>小顶堆</strong>。</li>
</ul>
<p>堆比较适合用数组来存储。</p>
<p><img src="/images/code/algo/heap/heap.png" alt="heap"></p>
<h2 id="堆化"><a href="#堆化" class="headerlink" title="堆化"></a>堆化</h2><p>堆的元素变动后，不符合堆定义的话，就需要进行调整，让其重新满足堆的特性，这个过程叫作堆化。堆化就是顺着节点所在的路径，向上或者向下进行对比，然后交换。</p>
<p><strong>插入元素</strong></p>
<p>插入的元素直接放到堆的最后，从下往上堆化，让新插入的节点与父节点对比大小，如果不满足子节点小于等于父节点的大小关系，就互换两个节点。一直重复这个过程，直到比对到根节点。</p>
<p><img src="/images/code/algo/heap/add.png" alt="堆化"></p>
<p><strong>删除堆顶元素</strong></p>
<p>删除堆顶元素后，就需要把第二大的元素放到堆顶，然后再迭代地删除第二大节点，以此类推，直到叶子节点被删除，但这样操作完成后的堆不再满足完全二叉树的特性。</p>
<p><img src="/images/code/algo/heap/del1.png" alt="堆化"></p>
<p>正确做法是先把最后一个节点放到堆顶，然后从上往下的堆化。</p>
<p><img src="/images/code/algo/heap/del2.png" alt="堆化"></p>
<p>一个包含 $n$ 个节点的完全二叉树高度小于 $log_{2}n$，堆化的时间复杂度跟树的高度成正比等于 $O(log\ n)$。</p>
<h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p>建堆就是将数组原地建成一个堆，从后往前处理数组，找到第一个非叶子节点，然后依次从上往下堆化，堆化过程只要比较和交换数组元素。</p>
<p><img src="/images/code/algo/heap/create.png" alt="建堆"></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>建堆后，如果是个大顶堆，那么排序步骤如下：</p>
<ol>
<li><p>取堆顶元素，与数组下标最后的元素交换位置，因为就是堆顶就是最大的元素，这样就排好了最大元素。</p>
</li>
<li><p>堆顶元素移除后发生堆化，将剩下的n−1个元素重新构建成堆。</p>
</li>
<li><p>再取堆顶的元素，交换至下标为 $n−1$ 的位置，一直重复这个过程，直到最后堆中只剩下标为 $1$ 的一个元素。</p>
</li>
</ol>
<p><img src="/images/code/algo/heap/sort.png" alt="排序"></p>
<p>堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 $O(n)$，排序过程的时间复杂度是 $O(nlog \  n)$，所以，堆排序整体的时间复杂度是 $O(nlog \  n)$。</p>
<p>堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/cpu/TrustZone/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/cpu/TrustZone/" class="post-title-link" itemprop="url">TrustZone</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-25 16:27:12 / 修改时间：20:37:37" itemprop="dateCreated datePublished" datetime="2022-09-25T16:27:12+08:00">2022-09-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TrustZone是ARM针对消费电子设备设计的一种硬件架构，其目的是为消费电子产品构建一个安全框架来抵御各种可能的攻击。</p>
<p>TrustZone在概念上将SoC的硬件和软件资源划分为Secure World和Normal World两个世界，所有需要保密的操作在安全世界执行（如指纹识别、密码处理、数据加解密、安全认证等），其余操作在非安全世界执行（如用户操作系统、各种应用程序等），安全世界和非安全世界通过一个名为Monitor Mode的模式进行转换。</p>
<p>实现TrustZone需要组件有：</p>
<ul>
<li>AMBA3 AXI总线，安全机制的基础设施。</li>
<li>虚拟化的ARM Core，虚拟安全和非安全核。</li>
<li>TZPC (TrustZone Protection Controller)，根据需要控制外设的安全特性。</li>
<li>TZASC (TrustZone Address Space Controller)，对内存进行安全和非安全区域划分和保护。</li>
<li>TZMA (TrustZone Memory Adapter)，片上ROM或RAM安全区域和非安全区域的划分和保护，可选。</li>
<li>AXI-to-APB bridge，桥接APB总线，配合TZPC使APB总线外设支持TrustZone安全特性，可选。</li>
</ul>
<p><img src="/images/cpu/arm/TrustZone.png" alt="img"></p>
<h2 id="总线设计"><a href="#总线设计" class="headerlink" title="总线设计"></a>总线设计</h2><p>AMBA3 AXI(AMBA3 Advanced eXtensible Interface)系统总线作为TrustZone的基础架构设施，提供了安全世界和非安全世界的隔离机制，确保非安全核只能访问非安全世界的系统资源，而安全核能访问所有资源。</p>
<p>AMBA-AXI总线的扩展，增加了标志secure读和写地址线：AWPROT[1]和ARPROT[1]。</p>
<p>TrustZone 在系统总线上针对每一个信道的读写增加了一个额外的控制信号位，这个控制位叫做Non-Secure或者NS位。所有非安全世界的主设备在操作时必须将信号的NS位置高，而NS位置高又使得其无法访问总线上安全世界的从设备，简单来说就是对非安全世界主设备发出的地址信号进行解码时在安全世界中找不到对应的从设备，从而导致操作失败。当然，非安全世界的主设备尝试访问安全世界的从设备会引发访问错误。</p>
<p>在TrustZone出现前，ARM的外设基于AMBA2 APB (Advanced Peripheral Bus)总线协议，由于APB总线的设备不支持AXI总线的NS控制信号，所以AXI到APB总线需要AXI-to-APB bridge设备连接。AXI-to-APB bridge负责管理APB总线设备的安全事宜，其会拒绝不合理的安全请求，保证这些请求不会被转发到相应的外设。</p>
<h2 id="处理器设计"><a href="#处理器设计" class="headerlink" title="处理器设计"></a>处理器设计</h2><p>TrustZone将每个物理核虚拟为两个核，非安全核，运行非安全世界的代码；和安全核，运行安全世界的代码。两个虚拟的核以基于时间片的方式运行，根据需要实时占用物理核，并通过Monitor Mode实现了同一CPU上两个操作系统间的切换。</p>
<p>安全世界和非安全世界都有自己的虚拟MMU，各自管理物理地址的映射。实际上只是两个世界都有一份TTBR0、TTBR1、TTBCR寄存器，因此就会对应两个MMU表。尽管MMU有两套，但TBL缓存硬件上只有一套，因此TBL对于两个世界来说是共享的，其通过NS位来标志其每一项具体属于哪一个世界。这样在两个世界间进行切换时不再需要重新刷新TLB，提高执行效率。</p>
<p>Cache也是两个世界共享，具体Cache数据属于哪一个世界也由其NS位指定，在世界间切换也不需要刷新Cache。</p>
<p>在gicv2、gicv3的版本中，都增加了对安全扩展的支持:</p>
<p>在gicv2/gicv3中，支持了安全中断，配置有如下：<br>gicv2分组</p>
<ul>
<li>group0：安全中断，由nFIQ驱动</li>
<li>group1：非安全中断，由nIRQ驱动</li>
</ul>
<p>gicv3分组</p>
<ul>
<li>group0：安全中断</li>
<li>non-secure group1：非安全中断</li>
<li>secure group1：安全中断</li>
</ul>
<h2 id="隔离机制"><a href="#隔离机制" class="headerlink" title="隔离机制"></a>隔离机制</h2><p>内存隔离和保护通过总线组件TZASC和TZMA的设置来实现。</p>
<ul>
<li><p>TZASC (TrustZone Address Space Controller)可以把外部DDR分成多个区域，每个区域可以单独配置为安全或非安全区域，非安全世界的代码和应用只能访问非安全区域。TZASC只能用于内存设备，不适合用于配置块设备，如Nand Flash。</p>
</li>
<li><p>TZMA (TrustZone Memory Adapter)可以把片上ROM和SRAM隔离出安全和非安全区域。TZMA最大可以将片上存储的低2MB配置为安全区域，其余部分配置为非安全区域。大小划分上，片上安全区域可以在芯片出厂前设置为固定大小，或运行时通过TZPC动态配置。TZMA使用上有些限制，其不适用于外部内存划分，而且也只能配置一个安全区域。</p>
</li>
</ul>
<p>在外设上需要TZPC (TrustZone Protection Controller) 来向APB总线上的设备提供类似AXI上的NS控制信号。由于TZPC可以在运行时动态设置，这就决定了外设的安全特性是动态变化的，例如键盘平时可以作为非安全的输入设备，在输入密码时可以配置为安全设备，只允许安全世界访问。</p>
<h2 id="安全启动"><a href="#安全启动" class="headerlink" title="安全启动"></a>安全启动</h2><p>系统上电复位后，先从安全世界开始执行。安全世界会对非安全世界的bootloader进行验证，确保非安全世界执行的代码经过授权而没有被篡改过。然后非安全世界的bootloader会加载非安全世界的OS，完成整个系统的启动。下一级的安全依赖于上一级的验证，逐级的验证构成了整个系统的信任链。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/cpu/ATF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/cpu/ATF/" class="post-title-link" itemprop="url">ARM Trusted Firmware</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-25 16:26:11 / 修改时间：21:26:56" itemprop="dateCreated datePublished" datetime="2022-09-25T16:26:11+08:00">2022-09-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ARM Trusted Firmware启动实现分为5个步骤：</p>
<p><img src="/images/cpu/arm/ATF3.png" alt="img"><br><img src="/images/cpu/arm/ATF2.jpg" alt="img"></p>
<h2 id="BL1"><a href="#BL1" class="headerlink" title="BL1"></a>BL1</h2><p>BL1是Trusted Boot ROM，就是BootRom，是信任链的根所在，位于ROM中。BL1主要目的是建立Trusted SRAM、exception vector、初始化串口等。然后找到并验证BL2（验签CSF头），然后跳转过去。</p>
<ul>
<li>决定启动路径：冷启动还是热启动。</li>
<li>架构初始化：异常向量、CPU复位处理函数配置、控制寄存器设置(SCRLR_EL3/SCR_EL3/CPTR_EL3/DAIF)</li>
<li>平台初始化：使能Trusted Watchdog、初始化控制台、配置硬件一致性互联、配置MMU、初始化相关存储设备。</li>
<li>固件更新处理</li>
<li>BL2镜像加载和执行</li>
</ul>
<p>bl1_main()开始就是c程序了，那c运行依靠的堆和栈空间在哪里呢？在CPU内部的SRAM里。SRAM一启动就已经可以访问了，bl1_plat_arch_setup（）简单地在其中划分出来一块作为Trusted SRAM给c程序用，而不用像x86在cache里面扣一块出来，简单了很多。</p>
<p>BL1镜像的异常向量表初始化了两个：一个是入口bl1_entrypoint，EL1镜像正常执行流程；另一个是SMC调用接口，EL2执行结束会通过SMC返回执行BL31。</p>
<h2 id="BL2"><a href="#BL2" class="headerlink" title="BL2"></a>BL2</h2><p>BL2在Flash上，作为Trusted Boot Firmware，也叫Trusted Bootloader。</p>
<ul>
<li>架构初始化：EL1/EL0使能浮点单元和ASMID。</li>
<li>平台初始化：控制台初始化、相关存储设备初始化、MMU、相关设备安全配置、</li>
<li>SCP_BL2：系统控制核镜像加载，单独核处理系统功耗、时钟、复位等控制。</li>
<li>寻找BL31，BL32和BL33镜像加载到RAM中，验签并运行BL31。</li>
</ul>
<h2 id="BL31"><a href="#BL31" class="headerlink" title="BL31"></a>BL31</h2><p>BL31是EL3 Runtime Firmware，一般为SML，管理SMC执行处理和中断，运行在secure monitor中，通过SMC指令在Secure World和Non-Secure World之间进行切换。它的主要任务是找到BL32，验签，并运行BL32。</p>
<ul>
<li>PSCI服务初始化，后续提供CPU功耗管理操作。</li>
<li>BL32镜像运行初始化。</li>
<li>初始化非安全EL2或EL1，跳转到BL33执行。</li>
<li>负责安全非安全世界切换。</li>
<li>进行安全服务请求的分发。</li>
</ul>
<h2 id="BL32"><a href="#BL32" class="headerlink" title="BL32"></a>BL32</h2><p>BL32是Trust OS，，它是一个可信安全的OS运行在EL1并在EL0启动可信任APP（如指纹信息，移动支付的密码等），并在Trust OS运行完成后通过SMC指令返回BL31，BL31找到BL33，验签并切换到Non-Seucre World运行BL33。</p>
<h2 id="BL33"><a href="#BL33" class="headerlink" title="BL33"></a>BL33</h2><p>BL33运行的都是非安全固件，如UEFI 或u-boot。</p>
<p><img src="/images/cpu/arm/ATF.jpg" alt="img"><br><img src="/images/cpu/arm/ATF.png" alt="img"></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/14175126.html">https://www.cnblogs.com/arnoldlu/p/14175126.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/cpu/armv8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/cpu/armv8/" class="post-title-link" itemprop="url">ARMv8 架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-25 15:35:42 / 修改时间：16:52:22" itemprop="dateCreated datePublished" datetime="2022-09-25T15:35:42+08:00">2022-09-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="特权等级"><a href="#特权等级" class="headerlink" title="特权等级"></a>特权等级</h2><p>ARMv8中，引入了Secure World和Non-Secure World（Normal World）两种安全状态，四种异常级别。</p>
<ul>
<li><p>EL0是无特权模式，就是用户空间，运行应用程序，在Secure world就是Trust Application。</p>
</li>
<li><p>EL1是一个特权模式，能够执行一些特权指令，用于运行操作系统，在Secure World则就是Trusted OS，比如OP-TEE，豌豆荚的TEE等。</p>
</li>
<li><p>EL2提供了对虚拟化的支持，只在Noraml world使用。</p>
</li>
<li><p>EL3具有最高管理权限，负责安全监测和Secure World和Normal World之间的切换。当noraml world想要访问Secure world需要通过安全监视器调用SMC指令进入监视模式然后切换。</p>
</li>
</ul>
<p>安全状态主要是影响资源的访问，比如memory，系统寄存器等。</p>
<p>对于memory，有时候需要做数据隔离，用于保护数据的安全性。因此就可以将memory分成两个区域，secure区域和non-secure区域。对于secure的memory区域，只允许secure状态去访问，而对于non-secure的memory区域，允许secure状态和non-secure状态都可访问。这样可以保护数据的安全。</p>
<p>对于系统寄存器，有些系统寄存器限制了最低EL的访问，这样可以有效的保护系统。不让低EL运行的程序，误操作这些系统寄存器而使整个系统崩溃掉。</p>
<p>对于EL1和EL0，可以是non-secure状态，也可以是secure状态。对于EL2，只能是non-secure状态。对于EL3，只能是secure状态。</p>
<p>secure和non-secure状态的切换，只能通过EL3进行切换，也就是如果想从non-secure的EL0切换到secure的EL0，首先要先从non-secure的EL0，通过异常切换到EL3，然后再通过异常，返回到secure的EL0。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/cpu/armv8_reg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/cpu/armv8_reg/" class="post-title-link" itemprop="url">ARMv8 寄存器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-25 15:11:47" itemprop="dateCreated datePublished" datetime="2022-09-25T15:11:47+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 12:50:26" itemprop="dateModified" datetime="2022-10-30T12:50:26+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="执行状态"><a href="#执行状态" class="headerlink" title="执行状态"></a>执行状态</h2><p>在 ARMv8 架构定义了两种执行状态：AArch64 以及 AArch32。这两种执行状态分别用于描述执行使用 64 位宽的通用寄存器或者使用 32 位宽的通用寄存器。系统运行在 64 位状态下的时候名字叫 Xn，运行在 32 位的时候就叫 Wn。</p>
<p>32位W寄存器使用对应64位X寄存器的低32位，即W0对应X0的低32位，W1对应X1的低32位，以此类推。读取W寄存器时，将会舍弃高32位的数据。写入W寄存器时，会将高32位清0，例如将0xFFFFFFFF写入W0后，X0中的值位0x00000000FFFFFFFF。</p>
<p><img src="/images/cpu/arm/reg.png" alt="img"></p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p><img src="/images/cpu/arm/reg2.png" alt="img"><br><img src="/images/cpu/arm/armv8_register.png" alt="img"></p>
<p>AArch64执行状态拥有 31 个通用寄存器，可以在任何时间和所有异常级别访问。</p>
<ul>
<li><p>X0-X7：参数/结果寄存器，被调用子程序返回前无需恢复。</p>
</li>
<li><p>X8：间接结果未知寄存器，用于保存子程序返回地址，尽量不使用</p>
</li>
<li><p>X9-X15：临时寄存器，使用需要保存现场，返回时需要恢复现场。</p>
</li>
<li><p>X16 X17：程序内调用临时寄存器，使用需要保存现场，返回时需要恢复现场。</p>
</li>
<li><p>X18：平台寄存器，保留用于平台 ABI，尽量不使用</p>
</li>
<li><p>X19-X28：被保存的寄存器，这些寄存器保存在被调用者帧中。使用需要保存现场，返回时需要恢复现场。</p>
</li>
<li><p>X29：帧指针寄存器（FP），保存函数栈基地址。</p>
</li>
<li><p>X30：链接寄存器（LR）</p>
</li>
<li><p>X31：堆栈指针寄存器 SP 或零寄存器 ZXR</p>
</li>
</ul>
<h2 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h2><p><strong>Zero register(WZR, XZR)</strong></p>
<p>当访问zero寄存器，所有的写入都被丢弃，所有的读取都返回0，AArch32执行状态使用WZR指令访问zero寄存器，AArch64执行状态使用XZR访问zero寄存器。</p>
<p><img src="/images/cpu/arm/armv8%E7%89%B9%E6%AE%8A%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="img"></p>
<p><strong>Program Counter(PC)</strong></p>
<p>程序计数寄存器，是一个各个异常级别通用的一个寄存器。PC寄存器不能作为命名寄存器访问，而是通过确定的指令隐含的访问，如相对PC的加载和产生地址。PC寄存器不能明确的作为数据处理指令或加载指令的目的寄存器。</p>
<p><strong>Stack Pointer(SP)</strong></p>
<p>栈顶指针寄存器，用来描述各个栈顶的指针寄存器。每个异常级别都拥有一个SP寄存器：SP_EL0, SP_EL1, SP_EL2, SP_EL3. 通过此寄存器就可以确定当前在那个EL。AArch32执行状态使用WSP访问当前栈指针寄存器，AArch64执行状态使用SP访问当前栈指针寄存器。</p>
<p><strong>Saved Program Status Register(SPSR)</strong></p>
<p>当异常发生时，处理器的状态将会被保存到相应异常级别的SPSR寄存器中。异常发生后，在处理异常之前，处理器会自动的将PSTATE寄存器的内容保存到SPSR中，异常返回时，会将SPSR保存的处理器状态恢复到PSTATE中。ARMv8定义的SPSR寄存器兼容ARMv7中的SPSR寄存器，只使用低32位。</p>
<p><img src="/images/cpu/arm/SPSR.png" alt="img"></p>
<p>各个位域定义如下：</p>
<ul>
<li>N 符号位（N flag）</li>
<li>Z 0标志（Z flag）</li>
<li>C 操作进位（C flag）</li>
<li>V 溢出标志（V flag）</li>
<li>SS 用于软件调试。异常发生的时候，通过设置MDSCR_EL1.SS为1启动单步调试机制</li>
<li>IL 不合法的执行状态（非法异常），保存自PSTATE.IL</li>
<li>D 处理器状态调试掩码。指示是否屏蔽来自观察点、断点和软件步骤调试事件的调试异常</li>
<li>A 软件错误掩码位</li>
<li>I IRQ掩码位</li>
<li>F FIQ掩码位</li>
<li>M[4] 发生异常时处理器的执行状态，0表示AArch64</li>
<li>M[3:0] M[3:2]发生异常的级别；M[1]保留；M[0]根据此选择栈指针寄存器，0表示t，1表示h。可以通过异常级别的栈指针后缀表明所选的栈指针。</li>
</ul>
<p><strong>Exception Link Register (ELR)</strong></p>
<p>异常链接寄存器，保存着异常返回地址。</p>
<p>比如当一个异常发生时，处理器必须去处理异常。处理异常时候就需要使用SPSR寄存器保存异常处理前的处理器状态，就是所谓的硬件上保存现场。当处理器处理完异常后，就需要从异常返回，则就需要从ELR寄存器中返回，然后再使用SPSR寄存器恢复现场即可。</p>
<h2 id="Processor-state-PSTATE"><a href="#Processor-state-PSTATE" class="headerlink" title="Processor state(PSTATE)"></a>Processor state(PSTATE)</h2><p>在AArch64执行状态中，处理器的状态使用PSTATE描述，但PSTATE不是寄存器，而是处理器状态各个位域的总称。</p>
<p>在AArch64执行状态中，使用ERET命令从异常中返回，即将SPSR_ELn寄存器中保存的发生异常时的处理器状态恢复到PSTATE中。SPSR_ELn中保存了发生异常时ALU的标志、执行状态、异常级别及处理器branches。处理器从异常返回后的执行地址保存在ELR_ELn中。</p>
<h2 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h2><table>
<thead>
<tr>
<th>名称</th>
<th>寄存器</th>
<th>描述</th>
<th>允许的异常级别</th>
</tr>
</thead>
<tbody><tr>
<td>ACTLR_ELn</td>
<td>辅助控制寄存器</td>
<td>控制处理器详细的特性</td>
<td>1，2，3</td>
</tr>
<tr>
<td>CCSIDR_ELn</td>
<td>当前Cache Size ID寄存器</td>
<td>当前架构所选择cache的信息</td>
<td>1</td>
</tr>
<tr>
<td>CLIDR_ELn</td>
<td>Cache Level ID寄存器</td>
<td>每个级别的cache类型及实现</td>
<td>1，2，3</td>
</tr>
<tr>
<td>CNTFRQ_ELn</td>
<td>计时器频率寄存器</td>
<td>反应了系统定时器的频率</td>
<td>0</td>
</tr>
<tr>
<td>CNTPCT_ELn</td>
<td>计时器物理计数寄存器</td>
<td>保存了当前64位计数值</td>
<td>0</td>
</tr>
<tr>
<td>CNTKCTL_ELn</td>
<td>内核计时器控制寄存器</td>
<td>控制从虚拟计数器生成事件流</td>
<td>1</td>
</tr>
<tr>
<td>CPACR_ELn</td>
<td>协处理器访问控制寄存器</td>
<td>控制访问Trace、 floating-point及NEON</td>
<td>1</td>
</tr>
<tr>
<td>CSSELR_ELn</td>
<td>Cache Size选择寄存器</td>
<td>定义了要求的cache级别、cache类型及指令cache或数据cache</td>
<td>1</td>
</tr>
<tr>
<td>CNTP_CTL_ELn</td>
<td>物理计时器控制寄存器</td>
<td>EL1物理计时器的控制寄存器</td>
<td>0</td>
</tr>
<tr>
<td>ELR_ELn</td>
<td>Exception Link Register</td>
<td>保存异常返回地址</td>
<td>1，2，3</td>
</tr>
<tr>
<td>ESR_ELn</td>
<td>Exception Syndrome Register</td>
<td>保存了发生异常的原因</td>
<td>1，2，3</td>
</tr>
<tr>
<td>FAR_ELn</td>
<td>Fault Address Register</td>
<td>保存了virtual faulting address</td>
<td>1，2，3</td>
</tr>
<tr>
<td>SCTLR_ELn</td>
<td>系统控制寄存器</td>
<td>控制架构特性，如MMU、caches及对齐检查</td>
<td>0，1，2，3</td>
</tr>
<tr>
<td>SPSR_ELn</td>
<td>Saved Program Status Registe</td>
<td>发生异常时，保存处理器的状态</td>
<td>abt，fiq，irq， und，1，2，3</td>
</tr>
</tbody></table>
<h2 id="NEON和浮点寄存器"><a href="#NEON和浮点寄存器" class="headerlink" title="NEON和浮点寄存器"></a>NEON和浮点寄存器</h2><p>armV8有32个128bit的浮点寄存器 V0-V31， 这些寄存器用来处理标量浮点运算时保存浮点操作数，或NEON 操作时保存标量和向量操作数。</p>
<p><img src="/images/cpu/arm/armv8_simd_reg.png" alt="img"></p>
<h2 id="兼容ARMv7"><a href="#兼容ARMv7" class="headerlink" title="兼容ARMv7"></a>兼容ARMv7</h2><p><img src="/images/cpu/arm/armv8_reg_map.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/cpu/armv7_reg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/cpu/armv7_reg/" class="post-title-link" itemprop="url">ARMv7 寄存器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-25 14:54:02 / 修改时间：15:28:13" itemprop="dateCreated datePublished" datetime="2022-09-25T14:54:02+08:00">2022-09-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ARMv7寄存器"><a href="#ARMv7寄存器" class="headerlink" title="ARMv7寄存器"></a>ARMv7寄存器</h2><p>ARM处理器共有37个寄存器。其中包括：31个通用寄存器（包括PC在内）和6个状态寄存器。</p>
<p><img src="/images/cpu/arm/reg.jpg" alt="img"></p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器包括R0-R15，均为32位寄存器，可以分为3类：</p>
<p><strong>未分组寄存器(R0-R7)</strong></p>
<p>在所有运行模式下，未分组寄存器都指向同一个物理寄存器。在中断或异常处理进行异常模式转换时，由于不同的处理器运行模式均使用相同的物理寄存器，所以可能造成寄存器中数据的破坏。</p>
<p><strong>分组寄存器(R8-R14)</strong></p>
<p>对于分组寄存器，他们每次所访问的物理寄存器都与当前的处理器运行模式相关。</p>
<p>R13常用作存放堆栈指针，用户也可以使用其他寄存器存放堆栈指针，但在Thumb指令集下，某些指令强制要求使用R13存放堆栈指针。</p>
<p>R14称为链接寄存器（LR，Link Register），当执行子程序时，R14可得到R15（PC）的备份，执行完子程序后，又将R14的值复制回PC，即使用R14保存返回地址。</p>
<p><strong>程序计数器PC（R15）</strong></p>
<p>寄存器R15用作程序计数器（PC），在ARM状态下，位[1:0]为0，位[31:2]用于保存PC；在Thumb状态下,位[0]为0，位[31:1]用于保存PC。</p>
<p>由于ARM体系结构采用了多级流水线技术，对于ARM指令集而言，PC总是指向当前指令的下两条指令的地址，即PC的值为当前指令的地址值加8个字节。</p>
<h3 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h3><ul>
<li>CPSR（Current Program Status Register）当前程序状态寄存器1个。</li>
<li>SPSR（Saved Progarm Status Register）备份程序状态寄存器6个，用于异常发生时保存CPSR的值，异常退出时恢复CPSR。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/cpu/arm-arch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/cpu/arm-arch/" class="post-title-link" itemprop="url">arm体系架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-25 11:23:54 / 修改时间：15:11:00" itemprop="dateCreated datePublished" datetime="2022-09-25T11:23:54+08:00">2022-09-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ARM指令集架构命名"><a href="#ARM指令集架构命名" class="headerlink" title="ARM指令集架构命名"></a>ARM指令集架构命名</h2><blockquote>
<p>| ARMv | n | variants | x（variants） |</p>
</blockquote>
<ul>
<li>ARMv – 固定字符，即ARM Version</li>
<li>n – 指令集版本号。迄今为之，ARM架构版本发布了8个系列，所以n=[1:8]。</li>
<li>variants – 变种</li>
<li>x（variants） – 排除x后指定的变种</li>
</ul>
<p>常见的variants有以下字母可选：</p>
<ul>
<li>T – Thumb指令集</li>
<li>M – 长乘法指令</li>
<li>E – 增强型DSP指令</li>
<li>J – Java加速器Jazelle</li>
<li>SIMD – ARM媒体功能扩展</li>
<li>D – Debug，提供调试支持</li>
<li>I – 芯片上带有内置的ICE，从而支持程序内的断点和数据空间的观察点设置。</li>
</ul>
<p>比如：ARMv5TxM表示ARM指令集版本为5，支持T变种，不支持M变种。</p>
<h2 id="ARM体系变种"><a href="#ARM体系变种" class="headerlink" title="ARM体系变种"></a>ARM体系变种</h2><p><strong>T变种</strong></p>
<p>thumb指令集是ARM指令集的一个子集重新编码而成的。它使ARM更加高效地进行运作。</p>
<p>ARM的指令长度为32位，而Thumb指令长度只有16位，对于一些冗余空余位的操作来讲的话，在使用16位的基础上，明显比使用32位更加高效。但是thumb自身也有一定的局限性：</p>
<ul>
<li><p>完成相同的操作时，Thumb指令通常情况下需要比ARM更多的指令。</p>
</li>
<li><p>Thumb指令集是不包含异常处理时的一些指令的</p>
</li>
</ul>
<p>因此ARM是不能舍弃ARM的32位指令的，它与16位的Thumb指令配合才能更加有效率地执行。</p>
<p><strong>M变种</strong></p>
<p>增加了两条长乘法的ARM指令：</p>
<ul>
<li><p>长乘法操作：32位整数乘以32位整数，生成64位整数</p>
</li>
<li><p>长乘加操作：32位整数乘以32位整数，然后加上加上32位整数，生成64位整数</p>
</li>
</ul>
<p>它其实做版本3中正式引入，版本2的时候仅是有了这个思想的，然后在版本4以后，M变种就变成了系统中的标准部分。我们也不再说M变种了，因为我们在开发ARM过程中直接是使用相应的指令的。</p>
<p><strong>E变种</strong></p>
<p>增强型DSP指令，针对于ARM的应用范围越来越广阔，为了满足DSP算法，就需要增强这个算法的处理性能。</p>
<ul>
<li><p>增加了新的16位数据乘法与乘加操作指令</p>
</li>
<li><p>实现饱和的带符号数的加减法操作指令</p>
</li>
<li><p>进行双字数据操作的指令，包含LDRD、STDR、MCRR\MRRC</p>
</li>
<li><p>cache预取指令PLD</p>
</li>
</ul>
<p>E变种是在版本5T中开始使用的。值得注意的是：早期的E变种未有包含LDRD、STRD、MCRR\MRRC、PLD。</p>
<p><strong>J变种</strong></p>
<p>ARM能跑android和java不得不归功于这个变种——java加数器jazelle，与一般的java虚拟机相比，它将java代码运行速度提高了整整8倍，而功耗竟降低了80%。</p>
<p><strong>SIMD变种</strong></p>
<p>媒体功能扩展，它将音频\视频处理性能提高了4倍。</p>
<ul>
<li>音频\视频处理性能提高了4倍</li>
<li>提供小数算术运算</li>
<li>可同时进行两个16位操作数或者4个8位操作数的运算</li>
<li>用户可以定义饱和运算模式</li>
<li>两套16位操作数的乘加/乘减运算</li>
<li>32位乘以32位的小数MAC</li>
</ul>
<h2 id="ARM处理器系列命名"><a href="#ARM处理器系列命名" class="headerlink" title="ARM处理器系列命名"></a>ARM处理器系列命名</h2><p>在 ARMv3 ~ ARMv6 时期规则：</p>
<blockquote>
<p>ARM{x}{y}{z}{T}{D}{M}{I}{E}{J}{F}{-S}</p>
</blockquote>
<ul>
<li>x – 处理器系列</li>
<li>y – 存储管理/保护单元</li>
<li>z – cache</li>
<li>T – 支持Thumb指令集</li>
<li>D – 支持片上调试</li>
<li>M – 支持快速乘法器</li>
<li>I – 支持Embedded ICE，支持嵌入式跟踪调试</li>
<li>E – 支持增强型DSP指令</li>
<li>J – 支持Jazelle</li>
<li>F – 具备向量浮点单元VFP</li>
<li>-S – 可综合版本</li>
</ul>
<p>比如：ARM926 是 ARM9系列的，2个存储管理/保护单元，6个Cache</p>
<p>在 ARMv7 后期，统一用 <strong>Cortex</strong> 作为主名，分为了3个款式：A、R、M &amp; SC：</p>
<ul>
<li>A 系列，应用级处理器，手机。</li>
<li>R 系列，实时处理器，执行一个指令段的耗时是固定时钟周期数。</li>
<li>M 系列，微处理器单片机。</li>
<li>SC（SecurCore）系列，主打安全，面向支付、政府、SIM 卡。</li>
</ul>
<h2 id="ARM处理器工作模式"><a href="#ARM处理器工作模式" class="headerlink" title="ARM处理器工作模式"></a>ARM处理器工作模式</h2><ul>
<li><p>用户模式（usr，User Mode）：ARM处理器正常的程序执行状态。</p>
</li>
<li><p>快速中断模式（fiq，Fast Interrupt Request Mode）：用于高速数据传输或通道处理。当触发快速中断时进入此模式。</p>
</li>
<li><p>外部中断模式（irq，Interrupt Request Mode）：用于通用的中断处理。当触发外部中断时进入此模式。</p>
</li>
<li><p>管理模式（svc，Supervisor Mode）：操作系统使用的保护模式。在系统复位或执行软件中断指令SWI时进入。</p>
</li>
<li><p>数据访问中止模式（abt，Abort Mode）：当数据或指令预取中止时进入该模式，可用于虚拟存储及存储保护。</p>
</li>
<li><p>系统模式（sys，System Mode）：运行具有特权的操作系统任务。</p>
</li>
<li><p>未定义指令中止模式（und，Undefined Mode）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。</p>
</li>
</ul>
<p>除了用户模式之外，其余六种模式都是特权模式。除了用户模式和系统模式之外，其余五种模式都是异常模式。</p>
<p>在特权模式下程序可以访问所有的系统资源。非特权模式和特权模式之间的区别在于有些操作只能在特权模式下才被允许，例如直接改变模式和中断使能等。而且为了保证数据安全，一般MMU会对地址空间进行划分，只有特权模式才能访问所有的地址空间。而用户模式如果需要访问硬件，必须切换到特权模式下，才允许访问硬件。</p>
<p><strong>工作模式的切换</strong></p>
<ul>
<li><p>执行软中断（SWI）或复位命令（Reset）指令。如果在用户模式下执行SWI指令，CPU就进入管理（Supervisor）模式。当然，在其他模式下执行SWI，也会进入该模式，不过一般操作系统不会这么做，因为除了用户模式属于非特权模式，其他模式都属于特权模式。执行SWI指令一般是为了访问系统资源，而在特权模式下可以访问所有的系统资源。SWI指令一般用来为操作系统提供API接口。</p>
</li>
<li><p>外部中断。如果发生了外部中断，CPU就会进入IRQ或FIQ模式。</p>
</li>
<li><p>CPU执行过程中产生异常。最典型的异常是由于MMU保护所引起的内存访问异常，此时CPU会切换到Abort模式。如果是无效指令，则会进入Undefined模式。</p>
</li>
<li><p>有一种模式是CPU无法自动进入的，这种模式就是System模式，要进入System模式必须由程序员编写指令来实现。要进入System模式只需改变CPSR的模式位为System模式对应的模式位即可。进入System模式一般是为了利用System模式和用户模式下的寄存器相同的特点，因此一般情况下，操作系统在通过SWI进入Supervisor模式后，做一些操作后，就进入System模式。</p>
</li>
<li><p>在任何特权模式下，都可以通过修改CPSR的MODE域来进入其他模式。不过需要注意的是由于修改的CPSR是该模式下的影子CPSR，即SPSR，因此并不是实际的CPSR，所以一般的做法是修改影子CPSR，然后执行一个MOVS指令来恢复执行某个断点并切换到新模式。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/cpu/cpu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/cpu/cpu/" class="post-title-link" itemprop="url">处理器设计</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-25 11:13:36" itemprop="dateCreated datePublished" datetime="2022-09-25T11:13:36+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-26 10:21:23" itemprop="dateModified" datetime="2022-11-26T10:21:23+08:00">2022-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h2><p>ISA（Instruction Set Architecture）指令集架构定义了一个处理器支持的指令和指令的字节级编码，包括很多个部分：</p>
<ul>
<li>指令集</li>
<li>指令集编码</li>
<li>基本数据类型</li>
<li>一组编程规范</li>
<li>寄存器</li>
<li>寻址模式</li>
<li>存储体系</li>
<li>异常事件处理</li>
<li>中断</li>
<li>外部I/O</li>
</ul>
<p><strong>CISC</strong>（Complex Instruction Set Computer，复杂指令集计算机）的每个指令可执行若干低阶操作，诸如从内存读取、储存、和计算操作，全部集于单一指令之中。CISC特点：</p>
<ul>
<li><p>指令系统庞大，指令功能复杂，指令格式、寻址方式多；</p>
</li>
<li><p>绝大多数指令需多个机器周期完成；- 各种指令都可访问存储器；</p>
</li>
<li><p>采用微程序控制；</p>
</li>
<li><p>有专用寄存器，少量；</p>
</li>
<li><p>难以用优化编译技术生成高效的目标代码程序；</p>
</li>
</ul>
<p>在CISC指令集的各种指令中，大约有20%的指令会被反复使用，占整个程序代码的80%。而余下的80%的指令却不经常使用，在程序设计中只占20%。</p>
<p><strong>RISC</strong>（Reduced Instruction Set Computer，精简指令集计算机）对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。它能够以更快的速度执行操作。RISC设计的根本原则量对流水线的优化。RISC特点：</p>
<ul>
<li>统一指令编码（例如，所有指令中的op-code永远位于同样的位元位置、等长指令），可快速解译；</li>
<li>泛用的暂存器，所有暂存器可用于所有内容，以及编译器设计的单纯化（不过暂存器中区分了整数和浮点数）；</li>
<li>单纯的寻址模式（复杂寻址模式以简单计算指令序列取代）。</li>
<li>硬件中支援少数资料型别（例如，一些CISC电脑中存有处理字节字串的指令。这在RISC电脑中不太可能出现）。</li>
<li>所有计算都要在寄存器中完成。而寄存器和内存的通信则由单独的指令完成。</li>
<li>有非常多的通用寄存器，并采用了重叠寄存器窗口和寄存器堆等技术使寄存器资源得到充分的利用。</li>
</ul>
<p><strong>CISC和RISC的区别</strong></p>
<ul>
<li>指令系统：RISC设计者把主要精力放在那些经常使用的指令上，尽量使它们具有简单高效的特色。对不常用的功能，常通过组合指令来完成。因此，在RISC机器上实现特殊功能时，效率可能较低。但可以利用流水技术和超标量技术加以改进和弥补。而CISC计算机的指令系统比较丰富，有专用指令来完成特定的功能。因此，处理特殊任务效率较高。</li>
<li>存储器操作：RISC对存储器操作有限制，使控制简单化；而CISC机器的存储器操作指令多，操作直接。</li>
<li>程序：RISC汇编语言程序一般需要较大的内存空间，实现特殊功能时程序复杂，不易设计；而CISC汇编语言程序编程相对简单，科学计算及复杂操作的程序社设计相对容易，效率较高。</li>
<li>中断：RISC机器在一条指令执行的适当地方可以响应中断；而CISC机器是在一条指令执行结束后响应中断。</li>
<li>CPU：RISC CPU包含有较少的单元电路，因而面积小、功耗低；而CISCCPU包含有丰富的电路单元，因而功能强、面积大、功耗大。</li>
<li>设计周期：RISC微处理器结构简单，布局紧凑，设计周期短，且易于采用最新技术；CISC微处理器结构复杂，设计周期长。</li>
<li>用户使用：RISC微处理器结构简单，指令规整，性能容易把握，易学易用；CISC微处理器结构复杂，功能强大，实现特殊功能容易。</li>
<li>应用范围：由于RISC指令系统的确定与特定的应用领域有关，故RISC机器更适合于专用机；而CISC机器则更适合于通用机。</li>
</ul>
<h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>MIPS处理器在设计时，将处理器的执行过程划分为5个阶段：IF取指、ID译码、EX执行、MEM内存数据读或写、WB数据写回到通用寄存器中。</p>
<p><img src="/images/cpu/%E6%B5%81%E6%B0%B4%E7%BA%BF.jpg" alt="img"></p>
<p>流水线在实际执行过程中会遇到一些因素导致流水线停顿，这些就被称为流水线冒险。</p>
<p><strong>结构冒险</strong></p>
<p>流水线中取指阶段和读写存储器阶段都需要访问存储器，处理器中，程序和数据存储器没有分开，IF和MEM操作同时访问存储器导致其中一个操作要等待。哈弗架构不存在这个问题。</p>
<p><strong>数据冒险</strong></p>
<p>由于从指令取指到数据更新至存储器/寄存器之间具有时钟延迟，当出现某些指令的组合时，可能会导致后面的指令使用了错误的数据。</p>
<p>解决方法一是加入几个cycle的等待，但这影响了执行效率。另一种更好的解决办法是使用直通（Forwarding）技术。当硬件检测到当前指令的源操作数正好在EX/MEM流水线寄存器中时，就直接将EX/MEM寄存器的值传递给ALU的输入，而不是从寄存器堆中读数据。</p>
<p><strong>控制冒险</strong></p>
<p>由于使用流水线操作，在当前指令正在执行时，后面的很多条指令已经完成了取指和译码等步骤。然而，程序中有很多跳转语句，如果程序的实际执行路径是要跳转到其它的地址去执行，那么流水线中已经做的这些取指和译码工作就白做了，这就是流水线的控制冒险。</p>
<p>此时处理器需要排空流水线，跳转到新的地址处重新进入流水线。x86处理器使用硬件冲刷流水线来保证发生跳转时，流水线能正确执行。在TI的DSP中，硬件不处理这些冒险，而是通过软件的方式，在跳转语句后增加5个NOP操作来保证流水线正确，编译器也可以将指令乱序，用有效指令代替NOP指令。</p>
<h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>流水线的控制冒险将可能引起流水线排空，这对程序性能的损害是巨大的，流水线越深，损害越大。现代的很多处理器采用了分支预测技术来避免跳转带来的损失。</p>
<p>采用分支预测，处理器猜测进入哪个分支，并且基于预测的结果来取指、译码。如果猜测正确，就能节省时间，若果猜测错误，则刷新流水线，在新的地址上取指、译码。因此，分支预测需要有足够的准确性。</p>
<p>介绍两种简单的分支预测算法：</p>
<ul>
<li><p>1位预测：如果该跳转指令上一次发生跳转，就预测这一次也会跳转，如果上一次没有跳转，就预测这一次也没有跳转。</p>
</li>
<li><p>2位预测：用2bit计数器保存跳转信息，如果跳转执行就加1，跳转未执行就减1,。当计数器值为0和1时，就预测该分支不执行；当计数器值为2和3时，就预测这个分支执行。</p>
</li>
</ul>
<p>分支预测会消耗大量的资源，很多低功耗处理器没有分支预测，取而代之的是使用条件执行来减少跳转指令，如TI的DSP和ARM的cortex系列内核等。</p>
<h2 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h2><p>指令在执行时常常因为一些限制而等待，后面的指令都要等待。如果处理器足够智能，就可以先执行后面不依赖该数据的指令，这就是处理器的乱序执行（out -of-order execution）。</p>
<p>乱序执行最大的障碍就是指令间的相关性。指令间相关大致有三种情况：</p>
<ul>
<li>寄存器相关，即前后指令使用了相同的寄存器。</li>
<li>控制相关，跳转指令之后执行哪些指令需要依赖于跳转的结果。</li>
<li>数据相关，即后面指令需要的数据依赖于前面指令的计算结果。</li>
</ul>
<p>对于寄存器相关，处理器通过<strong>寄存器重命名</strong>技术解决这一问题。相同的ISA寄存器可以映射到不同的物理寄存器，经过映射后，新的指令就可以使用不同的物理寄存器，指令间的相关性依赖也就消除了。</p>
<p>对于控制相关，处理器通过分支预测来决定哪些指令将会得到执行。</p>
<p>对于数据相关，这往往是由程序算法特性以及程序的设计共同决定的，它和处理器无关，和程序员以及编译器有关。在很多时候，编程人员可以通过调整代码设计将数据间的相关性降至最小。如下面这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = a + b;</span><br><span class="line">y = x + c;</span><br><span class="line">z = y + d;</span><br></pre></td></tr></table></figure>

<p>可以改写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = a + b;</span><br><span class="line">y = c + d;</span><br><span class="line">z = x + y;</span><br></pre></td></tr></table></figure>

<p>乱序执行比顺序执行要耗费更多的处理器资源，通常只有高端处理器才会使用。</p>
<h2 id="并行设计"><a href="#并行设计" class="headerlink" title="并行设计"></a>并行设计</h2><p><strong>指令并行</strong></p>
<p>多发射是指将多条指令同时发射到不同的译码器或者后续处理流水线中。</p>
<p>超标量是指一个时钟周期内能发射多条指令的流水线架构，内部有多个执行单元，</p>
<p><strong>数据并行</strong></p>
<p>SIMD（Single Instruction Multiple Data，单指令多数据）指令通过一条语句处理多个数据。在多媒体应用中，同一操作会重复处理多个数据，SIMD指令就特别适合处理这一类数据。</p>
<p><strong>线程并行</strong></p>
<p>线程并行的方式有：单核内多线程、多核、多处理器。</p>
<p>流水线是一种在垂直方向上对指令处理进行重叠来提升性能的技术，相对地，在水平方向上将指令进行重叠的技术称为<strong>超标量</strong>（superscalar），每个核内放置冗余单元如ALU，同一时钟内可以执行多条指令。</p>
<p>超线程是Intel公司提出的一种提高CPU性能的技术，利用特殊的硬件指令，把两个逻辑内核模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和应用软件，减少CPU的闲置时间，提高CPU的运行效率。</p>
<h2 id="核间通信"><a href="#核间通信" class="headerlink" title="核间通信"></a>核间通信</h2><p>多核处理器的多个核之间会共用处理器的外设与接口，如内存控制器、PCI-E接口等，通常也会共享一段Cache。核与核之间有时需要交换信息，因此核间连接/通信方式的选取也很关键。常见的几种多核组织结构：</p>
<ul>
<li><p>Bus结构比较简单，缺点是每两个内核通信都要占用总线，导致其它核不能通信，通信效率低。</p>
</li>
<li><p>Switch结构通信效率最高。但如果核太多，这种连接方式需耗费大量的互联资源，通常4个核左右的处理器采用这种方式。</p>
</li>
<li><p>Ring结构介于Bus和Switch结构之间。1和3通信需要经过2，越近的两个核通信效率越高，通信连线并不复杂，实现成本也低。通常8个核左右采用这种方式，Intel的很多处理器采用这种结构。</p>
</li>
<li><p>Mesh结构适用于核数非常多的情况，类似于二维的Ring结构。</p>
</li>
</ul>
<p><img src="/images/cpu/%E5%A4%9A%E6%A0%B8%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.jpg" alt="img"></p>
<p>因为核间通信会影响内核的运算效率，1个核可以做5件事情，并不代表4个核可以做20件事情，核越多时，数据交换延时越长。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
