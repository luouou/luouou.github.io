<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/02/boot/uboot-make/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/02/boot/uboot-make/" class="post-title-link" itemprop="url">uboot编译与配置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-02 20:04:02 / 修改时间：20:05:09" itemprop="dateCreated datePublished" datetime="2023-01-02T20:04:02+08:00">2023-01-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uboot/" itemprop="url" rel="index"><span itemprop="name">uboot</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Makefile-分析"><a href="#Makefile-分析" class="headerlink" title="Makefile 分析"></a>Makefile 分析</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">VERSION = 2013    <span class="comment">#主版本号</span></span><br><span class="line">PATCHLEVEL = 10   <span class="comment">#次版本号</span></span><br><span class="line">SUBLEVEL =        <span class="comment">#子版本号</span></span><br><span class="line">EXTRAVERSION =    <span class="comment">#附加的版本信息</span></span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;<span class="variable">$(SUBLEVEL)</span>&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">U_BOOT_VERSION = <span class="variable">$(VERSION)</span>.<span class="variable">$(PATCHLEVEL)</span>.<span class="variable">$(SUBLEVEL)</span><span class="variable">$(EXTRAVERSION)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">U_BOOT_VERSION = <span class="variable">$(VERSION)</span>.<span class="variable">$(PATCHLEVEL)</span><span class="variable">$(EXTRAVERSION)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">TIMESTAMP_FILE = <span class="variable">$(obj)</span><span class="keyword">include</span>/generated/timestamp_autogenerated.h</span><br><span class="line">VERSION_FILE = <span class="variable">$(obj)</span><span class="keyword">include</span>/generated/version_autogenerated.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (,<span class="variable">$(<span class="built_in">findstring</span> s,<span class="variable">$(MAKEFLAGS)</span>)</span>)</span><br><span class="line">XECHO = echo</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">XECHO = :</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>uboot编译时，会将版本信息输出到 include\generated\version_autogenerated.h 文件中。<code>make -s</code> 可以使 XECHO 变量为空，关闭编译信息打印。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MKCONFIG := <span class="variable">$(SRCTREE)</span>/mkconfig</span><br><span class="line"><span class="keyword">export</span> MKCONFIG</span><br><span class="line"></span><br><span class="line"><span class="section">unconfig:</span></span><br><span class="line">    @rm -f <span class="variable">$(obj)</span><span class="keyword">include</span>/config.h <span class="variable">$(obj)</span><span class="keyword">include</span>/config.mk \</span><br><span class="line">        <span class="variable">$(obj)</span>board/*/config.tmp <span class="variable">$(obj)</span>board/*/*/config.tmp \</span><br><span class="line">        <span class="variable">$(obj)</span><span class="keyword">include</span>/autoconf.mk <span class="variable">$(obj)</span><span class="keyword">include</span>/autoconf.mk.dep \</span><br><span class="line">        <span class="variable">$(obj)</span><span class="keyword">include</span>/spl-autoconf.mk \</span><br><span class="line">        <span class="variable">$(obj)</span><span class="keyword">include</span>/tpl-autoconf.mk</span><br><span class="line">        </span><br><span class="line"><span class="section">%_config:: unconfig</span></span><br><span class="line">    @<span class="variable">$(MKCONFIG)</span> -A $(@:_config=)</span><br></pre></td></tr></table></figure>

<p>设置[mkconfig](#mkconfig 分析)脚本的路径。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(obj)</span><span class="keyword">include</span>/autoconf.mk.dep</span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(obj)</span><span class="keyword">include</span>/autoconf.mk</span><br></pre></td></tr></table></figure>

<p>导入include/autoconf.mk文件，由配置脚本根据inlcude/configs/xxx.h 头文件生成的，里面包含与开发板相关的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYS_TEXT_BASE=0x34800000</span><br><span class="line">CONFIG_COMMON_BOOT=&quot;&quot;console=ttySAC0,115200n8 mem=128M  &quot; MTDPARTS_DEFAULT&quot;</span><br><span class="line">CONFIG_BOOTARGS=&quot;&quot;root=/dev/mtdblock5 ubi.mtd=4 rootfstype=cramfs &quot; CONFIG_COMMON_BOOT&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(obj)</span><span class="keyword">include</span>/config.mk</span><br><span class="line"><span class="keyword">export</span> ARCH CPU BOARD VENDOR SOC</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(TOPDIR)</span>/config.mk</span><br></pre></td></tr></table></figure>

<p>导入include/config.mk文件，里面包含ARCH, BOARD, VENDOR, SOC 和 CPU 变量，这是配置过程自动生成的。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ARCH   = arm</span><br><span class="line">CPU    = armv7</span><br><span class="line">BOARD  = smdkc100</span><br><span class="line">VENDOR = samsung</span><br><span class="line">SOC    = s5pc1xx</span><br></pre></td></tr></table></figure>

<p>导入config.mk文件，里面定义编译工具配置项。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CC = <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">CPP = <span class="variable">$(CC)</span> -E</span><br><span class="line">AR = <span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">NM = <span class="variable">$(CROSS_COMPILE)</span>nm</span><br><span class="line">LDR = <span class="variable">$(CROSS_COMPILE)</span>ldr</span><br><span class="line">STRIP = <span class="variable">$(CROSS_COMPILE)</span>strip</span><br><span class="line">OBJCOPY = <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP = <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line">RANLIB = <span class="variable">$(CROSS_COMPILE)</span>RANLIB</span><br><span class="line"></span><br><span class="line">LDFLAGS_u-boot += -T <span class="variable">$(obj)</span>u-boot.lds <span class="variable">$(LDFLAGS_FINAL)</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(CONFIG_SYS_TEXT_BASE)</span>,)</span><br><span class="line">LDFLAGS_u-boot += -Ttext <span class="variable">$(CONFIG_SYS_TEXT_BASE)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p><code>-Ttext</code>用 来指定uboot的链接起始地址，链接脚本也可以指定，但最终以这个为准。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> LDSCRIPT</span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_NAND_U_BOOT)</span>,y)</span><br><span class="line">        LDSCRIPT := <span class="variable">$(TOPDIR)</span>/board/<span class="variable">$(BOARDDIR)</span>/u-boot-nand.lds</span><br><span class="line">        <span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LDSCRIPT)</span>)</span>,)</span><br><span class="line">            LDSCRIPT := <span class="variable">$(TOPDIR)</span>/<span class="variable">$(CPUDIR)</span>/u-boot-nand.lds</span><br><span class="line">        <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LDSCRIPT)</span>)</span>,)</span><br><span class="line">        LDSCRIPT := <span class="variable">$(TOPDIR)</span>/board/<span class="variable">$(BOARDDIR)</span>/u-boot.lds</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LDSCRIPT)</span>)</span>,)</span><br><span class="line">        LDSCRIPT := <span class="variable">$(TOPDIR)</span>/<span class="variable">$(CPUDIR)</span>/u-boot.lds</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LDSCRIPT)</span>)</span>,)</span><br><span class="line">        LDSCRIPT := <span class="variable">$(TOPDIR)</span>/arch/<span class="variable">$(ARCH)</span>/cpu/u-boot.lds</span><br><span class="line">        <span class="comment"># We don&#x27;t expect a Makefile here</span></span><br><span class="line">        LDSCRIPT_MAKEFILE_DIR =</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LDSCRIPT)</span>)</span>,)</span><br><span class="line"><span class="variable">$(<span class="built_in">error</span> could not find linker script)</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>指定链接脚本，如果定义了 CONFIG_NAND_U_BOOT 宏，则链接脚本叫 u-boot-nand.lds，如果未定义这个宏则链接脚本叫 u-boot.lds。查找顺序为 board/, cpu_xxx/, arch/。</p>
<h3 id="mkconfig-分析"><a href="#mkconfig-分析" class="headerlink" title="mkconfig 分析"></a>mkconfig 分析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if [ \( $# -eq 2 \) -a \( &quot;$1&quot; = &quot;-A&quot; \) ] ; then</span><br><span class="line">    # Automatic mode</span><br><span class="line">    line=`awk &#x27;($0 !~ /^#/ &amp;&amp; $7 ~ /^&#x27;&quot;$2&quot;&#x27;$/) &#123; print $1, $2, $3, $4, $5, $6, $7, $8 &#125;&#x27; boards.cfg`</span><br><span class="line">    if [ -z &quot;$line&quot; ] ; then</span><br><span class="line">        echo &quot;make: *** No rule to make target \`$2_config&#x27;.  Stop.&quot; &gt;&amp;2</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    set $&#123;line&#125;</span><br><span class="line">    # add default board name if needed</span><br><span class="line">    [ $# = 3 ] &amp;&amp; set $&#123;line&#125; $&#123;1&#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>boards.cfg 文件定义了一张 board 与arch, cpu, soc, vendor 对应的表。通过解析 boards.cfg 文件可获得相应的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Active  arm         armv7          s5pc1xx     samsung         smdkc100            smdkc100                                                </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$SRCTREE&quot; != &quot;$OBJTREE&quot; ] ; then</span><br><span class="line">    mkdir -p $&#123;OBJTREE&#125;/include</span><br><span class="line">    mkdir -p $&#123;OBJTREE&#125;/include2</span><br><span class="line">    cd $&#123;OBJTREE&#125;/include2</span><br><span class="line">    rm -f asm</span><br><span class="line">    ln -s $&#123;SRCTREE&#125;/arch/$&#123;arch&#125;/include/asm asm</span><br><span class="line">    LNPREFIX=$&#123;SRCTREE&#125;/arch/$&#123;arch&#125;/include/asm/</span><br><span class="line">    cd ../include</span><br><span class="line">    mkdir -p asm</span><br><span class="line">else</span><br><span class="line">    cd ./include</span><br><span class="line">    rm -f asm</span><br><span class="line">    ln -s ../arch/$&#123;arch&#125;/include/asm asm</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">rm -f asm/arch</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$&#123;soc&#125;&quot; ] ; then</span><br><span class="line">    ln -s $&#123;LNPREFIX&#125;arch-$&#123;cpu&#125; asm/arch</span><br><span class="line">else</span><br><span class="line">    ln -s $&#123;LNPREFIX&#125;arch-$&#123;soc&#125; asm/arch</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$&#123;arch&#125;&quot; = &quot;arm&quot; ] ; then</span><br><span class="line">    rm -f asm/proc</span><br><span class="line">    ln -s $&#123;LNPREFIX&#125;proc-armv asm/proc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>创建 asm, arch, proc 3个指向具体平台的软连接。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">( echo &quot;ARCH   = $&#123;arch&#125;&quot;</span><br><span class="line">    if [ ! -z &quot;$spl_cpu&quot; ] ; then</span><br><span class="line">    echo &#x27;ifeq ($(CONFIG_SPL_BUILD),y)&#x27;</span><br><span class="line">    echo &quot;CPU    = $&#123;spl_cpu&#125;&quot;</span><br><span class="line">    echo &quot;else&quot;</span><br><span class="line">    echo &quot;CPU    = $&#123;cpu&#125;&quot;</span><br><span class="line">    echo &quot;endif&quot;</span><br><span class="line">    else</span><br><span class="line">    echo &quot;CPU    = $&#123;cpu&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    echo &quot;BOARD  = $&#123;board&#125;&quot;</span><br><span class="line"></span><br><span class="line">    [ &quot;$&#123;vendor&#125;&quot; ] &amp;&amp; echo &quot;VENDOR = $&#123;vendor&#125;&quot;</span><br><span class="line">    [ &quot;$&#123;soc&#125;&quot;    ] &amp;&amp; echo &quot;SOC    = $&#123;soc&#125;&quot;</span><br><span class="line">    exit 0 ) &gt; config.mk</span><br></pre></td></tr></table></figure>

<p>创建 include/config.mk 文件，被主 Makefile 包含。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/* Automatically generated - do not edit */&quot; &gt;&gt;config.h</span><br><span class="line"></span><br><span class="line">for i in $&#123;TARGETS&#125; ; do</span><br><span class="line">    i=&quot;`echo $&#123;i&#125; | sed &#x27;/=/ &#123;s/=/	/;q; &#125; ; &#123; s/$/	1/; &#125;&#x27;`&quot;</span><br><span class="line">    echo &quot;#define CONFIG_$&#123;i&#125;&quot; &gt;&gt;config.h ;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;#define CONFIG_SYS_ARCH  \&quot;$&#123;arch&#125;\&quot;&quot;  &gt;&gt; config.h</span><br><span class="line">echo &quot;#define CONFIG_SYS_CPU   \&quot;$&#123;cpu&#125;\&quot;&quot;   &gt;&gt; config.h</span><br><span class="line">echo &quot;#define CONFIG_SYS_BOARD \&quot;$&#123;board&#125;\&quot;&quot; &gt;&gt; config.h</span><br><span class="line"></span><br><span class="line">[ &quot;$&#123;vendor&#125;&quot; ] &amp;&amp; echo &quot;#define CONFIG_SYS_VENDOR \&quot;$&#123;vendor&#125;\&quot;&quot; &gt;&gt; config.h</span><br><span class="line"></span><br><span class="line">[ &quot;$&#123;soc&#125;&quot;    ] &amp;&amp; echo &quot;#define CONFIG_SYS_SOC    \&quot;$&#123;soc&#125;\&quot;&quot;    &gt;&gt; config.h</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt;&gt; config.h</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define CONFIG_BOARDDIR board/<span class="variable">$BOARDDIR</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;config_cmd_defaults.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;config_defaults.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;configs/<span class="variable">$&#123;CONFIG_NAME&#125;</span>.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;asm/config.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;config_fallbacks.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;config_uncmd_spl.h&gt;</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>创建或追加(make -a) include/config.h 头文件，这个文件会被大部分c文件包含。</p>
<h3 id="u-boot-lds"><a href="#u-boot-lds" class="headerlink" title="u-boot.lds"></a>u-boot.lds</h3><p>arch/arm/cpu/u-boot.lds 是ld连接器的脚本文件，描述如何连接目标文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/* 指定输出可执行文件是 elf 格式,32 位 ARM 指令,小端 */</span><br><span class="line">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)</span><br><span class="line"></span><br><span class="line">/* 指定输出可执行文件的平台架构为 ARM 架构 */</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line"></span><br><span class="line">/* 指定程序的起始代码段为_start */</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x00000000;  @ 指定程序的链接地址</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);  @ 4字节对齐</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        cpu/arm920t/start.o(.text)  @ 首先编译start.S</span><br><span class="line">        *(.text)  @ 所有的其他程序的代码段以4字节对齐放在它后面</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .got : &#123; *(.got) &#125;</span><br><span class="line"></span><br><span class="line">    . = .;</span><br><span class="line">    __u_boot_cmd_start = .;  @ 把__u_boot_cmd_start赋值为当前位置，即起始位置</span><br><span class="line">    .u_boot_cmd : &#123; *(.u_boot_cmd) &#125;  @ 指定 u_boot_cmd段，把所有的uboot命令放在该段</span><br><span class="line">    __u_boot_cmd_end = .;  @ 把 __u_boot_cmd_end赋值为当前位置，即结束位置</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss (NOLOAD) : &#123; *(.bss) . = ALIGN(4); &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由.text段的编译顺序可知，uboot 首先运行的是 _start 符号处的代码，在 arch/arm/cpu/arm920t/<a href="#start.S">start.S</a> 文件中定义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/31/algo/tree-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/31/algo/tree-code/" class="post-title-link" itemprop="url">二叉树算法题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-31 22:09:51 / 修改时间：22:21:32" itemprop="dateCreated datePublished" datetime="2022-12-31T22:09:51+08:00">2022-12-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">MaxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">MaxDepth</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MAX</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Flip</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Flip</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">Flip</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相同的二叉树"><a href="#相同的二叉树" class="headerlink" title="相同的二叉树"></a>相同的二叉树</h2><p>(1)如果两棵树的根结点都为空，则两棵树相同。<br>(2)如果两棵树的根结点有一个为空，则两棵树必然不相同。<br>(3)如果两棵树都不为空，则判断根结点的值是否相同，不相同则这两棵树必然不相同。<br>(4)如果两棵树根结点的值相同，则需要判断两棵树的左右子树是否相同，如果相同则这两棵树相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == q &amp;&amp; p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;                                                            <span class="comment">//(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                                                           <span class="comment">//(2)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                                                           <span class="comment">//(3)</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);      <span class="comment">//(4)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="另一棵树的子树"><a href="#另一棵树的子树" class="headerlink" title="另一棵树的子树"></a>另一棵树的子树</h2><p>判断一棵树是否为另一棵树的子树我们可以基于判断两棵树是否相同去做。<br>(1)如果<code>root</code>与<code>subRoot</code>的地址相同，则说明两棵树是同一棵树，那么<code>subRoot</code>肯定是<code>root</code>的子树。<br>(2)如果<code>root</code>与<code>subRoot</code>有一棵树是空，那么<code>subRoot</code>必然不是<code>root</code>的子树。<br>(3)如果<code>root</code>与<code>subRoot</code>相同，那么<code>subRoot</code>肯定是<code>root</code>的子树。<br>(4)如果<code>root</code>的子树含有与<code>subRoot</code>相同的树，那么<code>subRoot</code>肯定是<code>root</code>的子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="comment">//判断两棵树是否相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == q &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == subRoot) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || subRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//整棵树是否与subRoot相同</span></span><br><span class="line">        <span class="keyword">if</span> (isSameTree(root, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//subRoot是否是左子树的子树</span></span><br><span class="line">        <span class="keyword">if</span> (isSubtree(root.left, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//subRoot是否是右子树的子树</span></span><br><span class="line">        <span class="keyword">if</span> (isSubtree(root.right, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//上面都不满足，则subRoot不是该树的子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>判断一棵树是否是对称二叉树，其实就是判断这棵树的左右子树是否相同，如果相同则该二叉树对称，反之不对称，当然如果这棵二叉树是空树，那这棵树也是对称的。所以这又回到比较两棵树是否相等这个题目上去了。<br>(1)如果二叉树为空，返回<code>true</code>。<br>(2)比较左右子树是否相等，相等返回<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//(2)判断左右子树是否相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetricChild</span><span class="params">(TreeNode leftTree,TreeNode rightTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftTree == rightTree &amp;&amp; leftTree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftTree == <span class="literal">null</span> || rightTree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftTree.val != rightTree.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricChild(leftTree.left, rightTree.right) &amp;&amp; isSymmetricChild(leftTree.right, rightTree.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">//(1)</span></span><br><span class="line">        <span class="keyword">return</span> isSymmetricChild(root.left,root.right);<span class="comment">//(2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h2><p>(1)如果树为空，则这棵树是平衡二叉树。<br>(2)获取该树左右子树的高度差的绝对值，如果大于1，则这棵树肯定不是平衡二叉树。<br>(3)如果高度差绝对值不大于1，再判断该树的左右子树是否都是平衡二叉树，如果是，则这一整棵树是平衡二叉树。</p>
<p>所以这道题最终回到了求二叉树的高度上来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//获取二叉树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDeep</span><span class="params">(TreeNode subtree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subtree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDeep(subtree.left), maxDeep(subtree.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;            <span class="comment">//(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Math.abs(maxDeep(root.left) - maxDeep(root.right));       <span class="comment">//(2)</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right)) &#123;  <span class="comment">//(3)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h2><p>当遍历当前层时如果遇到空节点，如果该空节点右侧还有节点，说明该树一定不是完全二叉树，直接返回false，遍历完返回true；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">isCompleteTree</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 层次遍历方法</span></span><br><span class="line">        <span class="comment">// 标记空节点</span></span><br><span class="line">        boolean target = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.<span class="built_in">offer</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            TreeNode cur = queue.<span class="built_in">poll</span>();</span><br><span class="line">            <span class="comment">//如果当前结点为空结点，将标记位left设置为false</span></span><br><span class="line">            <span class="keyword">if</span>(cur == null)&#123;</span><br><span class="line">                target = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">// 遇到空节点直接返回false</span></span><br><span class="line">                <span class="keyword">if</span>(target == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                queue.<span class="built_in">offer</span>(cur.left);</span><br><span class="line">                queue.<span class="built_in">offer</span>(cur.right);</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断二叉搜索树"><a href="#判断二叉搜索树" class="headerlink" title="判断二叉搜索树"></a>判断二叉搜索树</h2><p>提前设置最小值pre<br>1、先判断空<br>2、进行递归左子树，如果不满足，返回false<br>3、判断当前root值和pre值大小，如果root&lt;pre,则返回false<br>4、更新pre值<br>5、然后递归右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param root TreeNode类 </span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> pre = Integer.MIN_VALUE; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValidBST</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先判断为空</span></span><br><span class="line">        <span class="keyword">if</span>(root ==null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isValidBST</span>(root.left))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 更新最值</span></span><br><span class="line">        pre = root.val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36317312/article/details/124026664">https://blog.csdn.net/qq_36317312/article/details/124026664</a></p>
<p><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-172f0/">https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-172f0/</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/357408">https://bbs.huaweicloud.com/blogs/357408</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/31/cpu/asm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/31/cpu/asm/" class="post-title-link" itemprop="url">ARM指令集</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-31 20:37:59 / 修改时间：22:05:44" itemprop="dateCreated datePublished" datetime="2022-12-31T20:37:59+08:00">2022-12-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><p>跳转指令用于实现程序流程的跳转，在ARM程序中有以下两种方法可以实现程序流程的跳转：</p>
<ul>
<li>使用跳转指令，可以从当前指令向前或向后的32MB的地址空间的跳转</li>
<li>直接向程序计数器PC写入跳转地址值，通过向程序计数器PC写入跳转地址值，可以实现在4GB的地址空间中的任意跳转，在跳转之前结合使用MOV LR，PC等类似指令，可以保存将来的返回地址值，从而实现在4GB连续的线性地址空间的子程序调用。</li>
</ul>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>B指令立即跳转到给定的目标地址，从那里继续执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BL"><a href="#BL" class="headerlink" title="BL"></a>BL</h3><p>BL跳转到某地址（有返回），先将下一指令地址（即函数返回地址）保存到寄存器 lr (x30)中，再进行跳转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BL&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BLX"><a href="#BLX" class="headerlink" title="BLX"></a>BLX</h3><p>BLX指令从ARM指令集跳转到指令中所指定的目标地址，并将处理器的工作状态有ARM状态切换到Thumb状态，该指令同时将PC的当前内容保存到寄存器R14中。因此，当子程序使用Thumb指令集，而调用者使用ARM指令集时，可以通过BLX指令实现子程序的调用和处理器工作状态的切换。同时，子程序的返回可以通过将寄存器R14值复制到PC中来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLX 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BX"><a href="#BX" class="headerlink" title="BX"></a>BX</h3><p>BX指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BX&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BR"><a href="#BR" class="headerlink" title="BR"></a>BR</h3><p>跳转到某寄存器(的值)指向的地址（无返回）, 不会改变 lr (x30) 寄存器的值。</p>
<h3 id="RET"><a href="#RET" class="headerlink" title="RET"></a>RET</h3><p>子程序（函数调用）返回指令，返回地址已默认保存在寄存器 lr (x30) 中。</p>
<h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><h3 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h3><p>MOV指令可完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV&#123;条件&#125;&#123;S&#125; 目的寄存器，源操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>S选项决定指令的操作是否影响CPSR中条件标志位的值，当没有S 时指令不更新CPSR中条件标志位的值。</li>
</ul>
<h3 id="MVN"><a href="#MVN" class="headerlink" title="MVN"></a>MVN</h3><p>MVN取反移动指令可完成从另一个寄存器、被移位的寄存器、或将一个立即数加载到目的寄存器，与MOV指令不同之处是在传送之前按位被取反了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVN&#123;条件&#125;&#123;S&#125; 目的寄存器，源操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>S决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVN R0，#0   ; 将立即数0取反传送到寄存器R0中，完成后R0=-1</span><br></pre></td></tr></table></figure>

<h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><h3 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h3><p>CMP指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较（操作数1 - 操作数2），同时更新CPSR中条件标志位的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<p>该指令进行一次减法运算，但不存储结果，只更改条件标志位。 标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT后缀的指令将可以执行。</p>
<h3 id="CMN"><a href="#CMN" class="headerlink" title="CMN"></a>CMN</h3><p>CMN指令用于把一个寄存器的内容和另一个寄存器的内容或立即数取反后进行比较，同时更新CPSR中条件标志位的值。该指令实际完成操作数1和操作数2相加，并根据结果更改条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMN&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<h3 id="TST"><a href="#TST" class="headerlink" title="TST"></a>TST</h3><p>TST指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的与运算，并根据运算结果更新CPSR中条件标志位的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TST&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1是要测试的数据，而操作数2是一个位掩码，该指令一般用来检测是否设置了特定的位。</li>
</ul>
<h3 id="TEQ"><a href="#TEQ" class="headerlink" title="TEQ"></a>TEQ</h3><p>TEQ是相等测试指令，用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位异或运算，并根据结果设置CPSR的标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEQ&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD指令用于把两个操作数相加，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<h3 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h3><p>ADC是带进位相加指令，用于把两个操作数相加，再加上CPSR中的C条件标志位的值，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>它使用一个进位标志位，这样就可以做比32位大的数的加法，注意不要忘记设置S后缀来更改进位标志。</li>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一 个寄存器，被移位的寄存器，或一个立即数</li>
</ul>
<p>示例：</p>
<p>以下指令序列完成两个128位数的加法，第一个数由高到低存放在寄存器R7～R4，第二个数由高到低存放在寄存器R11～R8，运算结果由高到低存放在寄 存器R3～R0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADDS    R0，R4，R8         ;  加低端的字</span><br><span class="line">ADCS    R1，R5，R9         ;  加第二个字，带进位</span><br><span class="line">ADCS    R2，R6，R10        ;  加第三个字，带进位</span><br><span class="line">ADC     R3，R7，R11        ;  加第四个字，带进位</span><br></pre></td></tr></table></figure>

<h3 id="SUB"><a href="#SUB" class="headerlink" title="SUB"></a>SUB</h3><p>SUB指令用于把操作数1减去操作数2，并将结果存放到目的寄存器中。该指令可用于有符号数或无符号数的减法运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<h3 id="SBC"><a href="#SBC" class="headerlink" title="SBC"></a>SBC</h3><p>SBC带进位减法指令用于把操作数1减去操作数2，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SBC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。该指令可用于有符号数或无符号数的减法运算。</p>
<h3 id="RSB"><a href="#RSB" class="headerlink" title="RSB"></a>RSB</h3><p>RSB指令称为逆向减法指令，用于把操作数2减去操作数1，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSB&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令可用于有符号数或无符号数的减法运算。</p>
<h3 id="RSC"><a href="#RSC" class="headerlink" title="RSC"></a>RSC</h3><p>RSC反向带进位减法指令用于把操作数2减去操作数1，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器操作</li>
<li>数2可以是一个寄存器，被移位 的寄存器，或一个立即数。</li>
</ul>
<p>该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。该指令可用于有符号数或 无符号数的减法运算。</p>
<p><strong>乘法指令</strong></p>
<p>乘法指令与前面的数据处理指令不同，指令中的所有操作数、目的寄存器 必须为通用寄存器，不能对操作数使用立即数或被移位的寄存器，同时，目的寄存器和操作数1必须是不同的寄存器。</p>
<h3 id="MUL"><a href="#MUL" class="headerlink" title="MUL"></a>MUL</h3><p>MUL指令完成将操作数1与操作数2的乘法运算，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操 作数2均为32位的有符号数或无符号数。</li>
</ul>
<h3 id="MLA"><a href="#MLA" class="headerlink" title="MLA"></a>MLA</h3><p>MLA带累加的相乘指令完成将操作数1与操作数2的乘法运算，再将乘积加上操作数3，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MLA&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2，操作数3</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的有符号数或无符号数。</li>
</ul>
<h3 id="SMULL"><a href="#SMULL" class="headerlink" title="SMULL"></a>SMULL</h3><p>SMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMULL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的有符号数。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMULL   R0，R1，R2，R3     ; R0 = （R2 × R3）的低32位</span><br><span class="line">                          ; R1 = （R2 × R3）的高32位</span><br></pre></td></tr></table></figure>

<h3 id="SMLAL"><a href="#SMLAL" class="headerlink" title="SMLAL"></a>SMLAL</h3><p>SMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMLAL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的有符号数。</li>
<li>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位;</li>
<li>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMLAL   R0，R1，R2，R3       ; R0 = （R2 × R3）的低32位 ＋ R0</span><br><span class="line">                            ; R1 = （R2 × R3）的高32位 ＋ R1</span><br></pre></td></tr></table></figure>

<h3 id="UMULL"><a href="#UMULL" class="headerlink" title="UMULL"></a>UMULL</h3><p>UMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UMULL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的无符号数。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UMULL   R0，R1，R2，R3       ; R0 = （R2 × R3）的低32位</span><br><span class="line">                            ; R1 = （R2 × R3）的高32位</span><br></pre></td></tr></table></figure>

<h3 id="UMLAL"><a href="#UMLAL" class="headerlink" title="UMLAL"></a>UMLAL</h3><p>UMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High 中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UMLAL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的无符号数；</li>
<li>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位;</li>
<li>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UMLAL   R0，R1，R2，R3            ; R0 = （R2 × R3）的低32位 ＋ R0</span><br><span class="line">                                 ; R1 = （R2 × R3）的高32位 ＋ R1</span><br></pre></td></tr></table></figure>

<h3 id="SDIV"><a href="#SDIV" class="headerlink" title="SDIV"></a>SDIV</h3><p>SDIV指令有符号数)将某一寄存器的值和另一个寄存器的值相除 并将结果保存在另一寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIV 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><p>AND指令用于在两个操作数上进行逻辑与运算，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令常用于屏蔽操作数1的某些位。</p>
<h3 id="ORR"><a href="#ORR" class="headerlink" title="ORR"></a>ORR</h3><p>ORR指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORR&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令常用于设置操作数1的某些位。</p>
<h3 id="EOR"><a href="#EOR" class="headerlink" title="EOR"></a>EOR</h3><p>EOR指令用于在两个操作数上进行逻辑异或运算，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EOR&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数</li>
</ul>
<p>该指令常用于反转操作数1的某些位。</p>
<h3 id="BIC指令"><a href="#BIC指令" class="headerlink" title="BIC指令"></a>BIC指令</h3><p>BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。 操作数2为32位的掩码，如果在掩码中设置了某一位，则清除这一位。未设置的掩码位保持不变。</li>
</ul>
<h3 id="LSL-ASL"><a href="#LSL-ASL" class="headerlink" title="LSL ASL"></a>LSL ASL</h3><p>LSL逻辑左移、ASL算术左移可完成对通用寄存器中的内容进行逻辑（或算术）的左移操作，按操作数所指定的数量向左移位，低位用零来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，LSL/ASL 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   R0, R1, LSL #2          ; 将R1中的内容左移两位后传送到R0 中。</span><br></pre></td></tr></table></figure>

<h3 id="LSR"><a href="#LSR" class="headerlink" title="LSR"></a>LSR</h3><p>LSR逻辑右移可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用零来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，LSR 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   R0, R1, LSR #2         ; 将R1中的内容右移两位后传送到R0 中，左端用零来填充。</span><br></pre></td></tr></table></figure>

<h3 id="ASR"><a href="#ASR" class="headerlink" title="ASR"></a>ASR</h3><p>ASR算术右移可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用第31位的值来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，ASR 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV    R0, R1, ASR #2        ; 将R1中的内容右移两位后传送到R0 中，左端用第31位的值来填充。</span><br></pre></td></tr></table></figure>

<h3 id="ROR"><a href="#ROR" class="headerlink" title="ROR"></a>ROR</h3><p>ROR可完成对通用寄存器中的内容进行循环右移的操作，按操作数所指定的数量向右循环移位，左端用右端移出的位来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，ROR 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>其中，操作数可以是通用寄存器，也可以是立即数（0～31）。显然，当进行32位的循环右移操作时，通用寄存器中的值不改变。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV    R0, R1, ROR #2       ; 将R1中的内容循环右移两位后传送到R0 中。</span><br></pre></td></tr></table></figure>

<h3 id="RRX"><a href="#RRX" class="headerlink" title="RRX"></a>RRX</h3><p>RRX可完成对通用寄存器中的内容进行带扩展的循环右移的操作，按操作数所指定的数量向右循环移位，左端用进位标志位C来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，RRX 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   R0, R1, RRX #2         ; 将R1中的内容进行带扩展的循环右移两位 后传送到R0中。</span><br></pre></td></tr></table></figure>

<h2 id="程序状态寄存器访问指令"><a href="#程序状态寄存器访问指令" class="headerlink" title="程序状态寄存器访问指令"></a>程序状态寄存器访问指令</h2><p>此类指令向通用寄存器或者从通用寄存器往外移动状态寄存器的内容。</p>
<h3 id="MRS指令"><a href="#MRS指令" class="headerlink" title="MRS指令"></a>MRS指令</h3><p>MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。该指令一般用在以下两种情况：</p>
<ul>
<li>当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器。</li>
<li>当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用该指令读出程序状态寄存器的值，然后保存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRS&#123;条件&#125;  通用寄存器 程序状态寄存器（CPSR或SPSR）</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRS R0，CPSR      ; 传送 CPSR的内容到R0</span><br><span class="line">MRS R0，SPSR      ; 传送 SPSR的内容到R0</span><br></pre></td></tr></table></figure>

<h3 id="MSR指令"><a href="#MSR指令" class="headerlink" title="MSR指令"></a>MSR指令</h3><p>MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中。其中，操作数可以为通用寄存器或立即数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSR&#123;条件&#125;    程序状态寄存器（CPSR或SPSR）_&lt;域&gt;，操作数</span><br></pre></td></tr></table></figure>

<p>&lt;域&gt;用于设置程序状态寄存器中需要 操作的位，32位的程序状态寄存器可分为4个域：</p>
<ul>
<li>位[31：24]为条件位域，用f表示；</li>
<li>位[23：16]为状态位域，用s表示；</li>
<li>位[15：8] 为扩展位域，用x表示；</li>
<li>位[7：0] 为控制位域，用c表示；</li>
</ul>
<p>该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MSR CPSR，R0        ; 传送R0的内容到CPSR</span><br><span class="line">MSR SPSR，R0        ; 传送R0的内容到SPSR</span><br><span class="line">MSR CPSR_c，R0      ; 传送R0的内容到SPSR，但仅仅修改CPSR中的控制位域</span><br></pre></td></tr></table></figure>

<h2 id="加载-存储指令"><a href="#加载-存储指令" class="headerlink" title="加载/存储指令"></a>加载/存储指令</h2><p>数据在存储器中，都是二进制码，计算机单凭数据本身是无法区分数据格式(有符号、无符号、多少位是一个数据)，甚至无法区分数据和代码的区别。这个取决于我们使用的汇编指令。</p>
<p>ARM微处理器支持加载/存储指令用于在寄存器和存储器之间传送数据：</p>
<ul>
<li>加载指令用于将存储器中的数据传送到寄存器；</li>
<li>存储指令则完成相反的操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ldr = Load Word</span><br><span class="line">ldrh = Load unsigned Half Word</span><br><span class="line">ldrsh = Load signed Half Word</span><br><span class="line">ldrb = Load unsigned Byte</span><br><span class="line">ldrsb = Load signed Bytes</span><br><span class="line"></span><br><span class="line">str = Store Word</span><br><span class="line">strh = Store unsigned Half Word</span><br><span class="line">strsh = Store signed Half Word</span><br><span class="line">strb = Store unsigned Byte</span><br><span class="line">strsb = Store signed Byte</span><br></pre></td></tr></table></figure>

<h3 id="LDR"><a href="#LDR" class="headerlink" title="LDR"></a>LDR</h3><p>LDR(Load Word)指令用于从存储器中将一个32位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR&#123;条件&#125; 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li>
</ul>
<p>该指令在程序设计中比较常用，且寻址方式灵活多样，请读者认真掌握。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LDR R0，[R1]             ; 将存储器地址为R1的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，R2]         ; 将存储器地址为R1+R2的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，#8]         ; 将存储器地址为R1+8的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，R2] ！       ; 将存储器地址为R1+R2的字数据读入寄存器R0，并将新地址R1＋R2写入R1。</span><br><span class="line">LDR R0，[R1，#8] ！       ; 将存储器地址为R1+8的字数据读入寄存器R0，并将新地址 R1＋8写入R1。</span><br><span class="line">LDR R0，[R1]，R2          ; 将存储器地址为R1的字数据读入寄存器R0，并将新地址 R1＋R2写入R1。</span><br><span class="line">LDR R0，[R1，R2，LSL#2]！  ; 将存储器地址为R1＋R2×4的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。</span><br><span class="line">LDR R0，[R1]，R2，LSL#2   ; 将存储器地址为R1的字数据读入 寄存器R0，并将新地址R1＋R2×4写入R1。</span><br></pre></td></tr></table></figure>

<h3 id="LDRB"><a href="#LDRB" class="headerlink" title="LDRB"></a>LDRB</h3><p>LDRB(Load unsigned Byte)指令用于从存储器中将一个8位的字节数据传送到目的寄存器中，同时将寄存器的高24位清零。 该指令通常用于从存储器中读取8位的字节数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR&#123;条件&#125;B 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDRB R0，[R1]           ; 将存储器地址为R1的字节数据读入寄存器R0，并将R0的高24位清零。</span><br><span class="line">LDRB R0，[R1，#8]       ; 将存储器地址为R1＋8的字节数据读入寄存器R0，并将R0的高24位清零。</span><br></pre></td></tr></table></figure>

<h3 id="LDRH"><a href="#LDRH" class="headerlink" title="LDRH"></a>LDRH</h3><p>LDRH(Load unsigned Half Word)指令用于从存储器中将一个16位的半字数据传送到目的寄存器中，同时将寄存器的高16位清零。 该指令通常用于从存储器中读取16位的半字数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR&#123;条件&#125;H 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LDRH   R0，[R1]         ; 将存储器地址为R1的半字数据读入寄存器 R0，并将R0的高16位清零。</span><br><span class="line">LDRH   R0，[R1，#8]     ; 将存储器地址为R1＋8的半字数据读入寄存器R0，并将R0 的高16位清零。</span><br><span class="line">LDRH   R0，[R1，R2]     ; 将存储器地址为R1＋R2的半字数据读入寄存器R0，并将 R0的高16位清零。</span><br></pre></td></tr></table></figure>

<h3 id="STR"><a href="#STR" class="headerlink" title="STR"></a>STR</h3><p>STR(Store Word)指令用于从源寄存器中将一个32位的字数据传送到存储器中。 该指令在程序设计中比较常用，且寻址方式灵活多样，使用方式可参考指令LDR。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR&#123;条件&#125; 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STR R0，[R1]，#8           ; 将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。</span><br><span class="line">STR R0，[R1，#8]           ; 将R0中的字数据写入以R1＋8为地址的存储器中。</span><br></pre></td></tr></table></figure>

<h3 id="STRB"><a href="#STRB" class="headerlink" title="STRB"></a>STRB</h3><p>STRB(Store unsigned Byte)指令用于从源寄存器中将一个8位的字节数据传送到存储器中。该字节数据为源寄存器中的低8位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR&#123;条件&#125;B 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STRB    R0，[R1]             ; 将寄存器R0中的字节数据写入以R1为地 址的存储器中。</span><br><span class="line">STRB    R0，[R1，#8]         ; 将寄存器R0中的字节数据写入以R1＋8为地址的存 储器中。</span><br></pre></td></tr></table></figure>

<h3 id="STRH"><a href="#STRH" class="headerlink" title="STRH"></a>STRH</h3><p>STRH(Store unsigned Half Word)指令用于从源寄存器中将一个16位的半字数据传送到存储器中。该半字数据为源寄存器中的低16位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR&#123;条件&#125;H 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STRH   R0，[R1]            ; 将寄存器R0中的半字数据写入以R1为地址的 存储器中。</span><br><span class="line">STRH   R0，[R1，#8]        ; 将寄存器R0中的半字数据写入以R1＋8 为地址的存储器中。</span><br></pre></td></tr></table></figure>

<h3 id="ADR"><a href="#ADR" class="headerlink" title="ADR"></a>ADR</h3><p>将一个立即值与 pc 值相加，并将结果写入目标寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADR&#123;cond&#125;&#123;.W&#125;  Rd,label</span><br></pre></td></tr></table></figure>

<h3 id="ADRP"><a href="#ADRP" class="headerlink" title="ADRP"></a>ADRP</h3><p>以页为单位的大范围的地址读取指令，这里的P就是page的意思。取得page的基地址存入寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADRP&#123;cond&#125;  Rd  label</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adrp    x2, .LANCHOR0   ; .LANCHOR0是个&lt;lable&gt;——一个大小为4KB的页的基址，指令的作用就是将该页的基址存到寄存器x2中</span><br><span class="line"></span><br><span class="line">adrp    x0, l_.str@PAGE         ; 将符号l.str所在的page基址读入x0</span><br><span class="line">add     x0, x0, l_.str@PAGEOFF  ; x0 = x0 + l.str所在page中的偏移量</span><br></pre></td></tr></table></figure>

<p><strong>批量数据加载/存储指令</strong></p>
<p>ARM微处理器所支持批量数据加载/存储指令可以一次在一片连续的存储器单元和多个寄存器之间传送数据，批量加载指令 用于将一片连续的存储器中的数据传送到多个寄存器，批量数据存储指令则完成相反的操作。</p>
<h3 id="LDM-STM-指令（加载、存储多个寄存器）"><a href="#LDM-STM-指令（加载、存储多个寄存器）" class="headerlink" title="LDM(STM)指令（加载、存储多个寄存器）"></a>LDM(STM)指令（加载、存储多个寄存器）</h3><p>LDM（或STM）指令用于从由基址寄存器所指示的一片连续存储器到寄存器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDM（或STM）&#123;条件&#125;&#123;类型&#125; 基址寄存器&#123;！&#125;，寄存器列表&#123;∧&#125;</span><br></pre></td></tr></table></figure>

<p>类型为以下几种情况：</p>
<ul>
<li>IA 每次传送后地址加1;</li>
<li>IB 每次传送前地址加1;</li>
<li>DA 每次传送后地址减1;</li>
<li>DB 每次传送前地址减1;</li>
<li>FD 满递减堆栈;</li>
<li>ED 空递减堆栈;</li>
<li>FA 满递增堆栈;</li>
<li>EA 空递增堆栈;</li>
</ul>
<p><code>&#123;！&#125;</code>为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。基址寄存器不允许为R15，寄存器列表可以为R0～R15的任意组合。</p>
<p><code>&#123;∧&#125;</code> 为可选后缀，当指令为LDM且寄存器列表中包含R15，选用该后缀时表示：除了正常的数据传送之外，还将SPSR复制到CPSR。同时，该后缀还表 示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STMFD R13!， &#123;R0，R4-R12，LR&#125;        ; 将寄存器列表中的寄存器（R0，R4到R12，LR）存入堆栈。</span><br><span class="line">LDMFD R13!， &#123;R0，R4-R12，PC&#125;        ; 将堆栈内容恢复到寄存器（R0，R4到R12，LR）。</span><br></pre></td></tr></table></figure>

<p><strong>数据交换指令</strong></p>
<p>在寄存器和内存之间交换数据</p>
<h3 id="SWP"><a href="#SWP" class="headerlink" title="SWP"></a>SWP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWP&#123;条件&#125; 目的寄存器，源寄存器1，[源寄存器2]</span><br></pre></td></tr></table></figure>

<p>SWP指令用于将源寄存器2所指向的存储器中的字数据传送到目的寄存器中，同时将源寄存器1中的字数据传送到源寄存器2所指向的存储器中。显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SWP   R0，R1，[R2]     ; 将R2所指向的存储器中的字数据传送到R0，同时将R1 中的字数据传送到R2所指向的存储单元。</span><br><span class="line">SWP   R0，R0，[R1]     ; 该指令完成将R1所指向的存储器中的字数 据与R0中的数据交换。</span><br></pre></td></tr></table></figure>

<p>SWP{B}：B是一个可选的后缀。如果存在 B，则交换一个字节。否则，交换一个32位字。</p>
<h3 id="SWPB"><a href="#SWPB" class="headerlink" title="SWPB"></a>SWPB</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWP&#123;条件&#125;B 目的寄存器，源寄存器1，[源寄存器2]</span><br></pre></td></tr></table></figure>

<p>SWPB指令用于将源寄存器2所指向的存储器中的字节数据传送到目的寄存器中，目的寄存器的高24清零，同时将源寄存器1中的字节数据传送到源寄存器2所指向的存储器中。</p>
<p>显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SWPB   R0，R1，[R2]       ; 将R2所指向的存储器中的字节数据传送到 R0，R0的高24位清零，同时将R1中的低8位数据传送到R2所指向的存储单元。</span><br><span class="line">SWPB   R0，R0，[R1]       ; 该指令完成将R1所指向的存储器中的 字节数据与R0中的低8位数据交换。</span><br></pre></td></tr></table></figure>

<h2 id="协处理器指令"><a href="#协处理器指令" class="headerlink" title="协处理器指令"></a>协处理器指令</h2><p>ARM 微处理器可支持多达 16 个协处理器，用于各种协处理操作，在程序执行的过程中，每个协处理器只执行针对自身的协处理指令，忽略 ARM 处理器和其他协处理器的指令。</p>
<p>ARM 的协处理器指令主要用于 ARM 处理器初始化 ARM 协处理器的数据处理操作，以及在ARM 处理器的寄存器和协处理器的寄存器之间传送数据，和在 ARM 协处理器的寄存器和存储器之间传送数据。</p>
<h3 id="CDP"><a href="#CDP" class="headerlink" title="CDP"></a>CDP</h3><p>CDP指令用于ARM处理器通知ARM协处理器执行特定的操作，若协处理器不能成功完成特定的操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CDP&#123;条件&#125; 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure>

<p>其中协处理器操作码1和协处理 器操作码2为协处理器将要执行的操作，目的寄存器和源寄存器均为协处理器的寄存器，指令不涉及ARM处理器的寄存器和存储器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CDP   P3，2，C12，C10，C3，4  ; 该指令完成协处理器P3的初始化 </span><br></pre></td></tr></table></figure>

<h3 id="LDC"><a href="#LDC" class="headerlink" title="LDC"></a>LDC</h3><p>LDC指令用于将源寄存器所指向的存储器中的字数据传送到目的寄存器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDC&#123;条件&#125;&#123;L&#125; 协处理器编码，目的寄存器，[源寄存器]</span><br></pre></td></tr></table></figure>

<p>其中，{L}选项表示指 令为长读取操作，如用于双精度数据的传输。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDC   P3，C4，[R0]        ; 将ARM处理器的寄存器R0所指向的存储器中的字数 据传送到协处理器P3的寄存器C4中。 </span><br></pre></td></tr></table></figure>

<h3 id="STC"><a href="#STC" class="headerlink" title="STC"></a>STC</h3><p>STC指令用于将源寄存器中的字数据传送到目的寄存器所指向的存储器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STC&#123;条件&#125;&#123;L&#125; 协处理器编码，源寄存器，[目的寄存器]</span><br></pre></td></tr></table></figure>

<p>其中，{L}选项表示指 令为长读取操作，如用于双精度数据的传输。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STC   P3，C4，[R0]     ; 将协处理器P3的寄存器C4中的字数据传送到ARM处理 器的寄存器R0所指向的存储器中。 </span><br></pre></td></tr></table></figure>

<h3 id="MCR"><a href="#MCR" class="headerlink" title="MCR"></a>MCR</h3><p>MCR指令用于将ARM处理器寄存器中的数据传送到协处理器寄存器中，若协处理器不能成功完成操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MCR&#123;条件&#125; 协处理器编码，协处理器操作码1，源寄存器，目的寄存器1，目的寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure>

<p>其中协处理器操作码1和协处理 器操作码2为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄 存器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MCR   P3，3，R0，C4，C5，6     ; 将ARM处理器寄存器R0中的数据传送到协处 理器P3的寄存器C4和C5中。 </span><br></pre></td></tr></table></figure>

<h3 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h3><p>MRC指令用于将协处理器寄存器中的数据传送到ARM处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRC&#123;条件&#125; 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure>

<p>其中协处理器操作码1和协处理器操作码2为协处理器将要执行的操作，目的寄存器为ARM处理器的寄存器，源寄存器1和源寄存器2均为协处理器的寄存器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRC   P3，3，R0，C4，C5，6     ; 该指令将协处理器P3的寄存器中的数据传送到 ARM处理器寄存器中。</span><br></pre></td></tr></table></figure>

<h2 id="异常产生指令"><a href="#异常产生指令" class="headerlink" title="异常产生指令"></a>异常产生指令</h2><p>ARM指令集中提供了两条产生异常的指令，通过这两条指令可以用软件的方法实现异常。</p>
<h3 id="SWI"><a href="#SWI" class="headerlink" title="SWI"></a>SWI</h3><p>SWI指令用于产生软件中断，以便用户程序能调用操作系统的系统例程。操作系统在SWI的异常处理程序中提供相应的系统服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWI&#123;条件&#125; 24位的立即数</span><br></pre></td></tr></table></figure>

<p>指令中24位的立即数指定用户程序调用系统例程的类型，相关参数通过通用寄存器传递，当指令中24位的立即数被忽略时，用户程序调用系统例程的类型由通用寄存器R0的内容决定，同时，参数通过其他通用寄存器传递。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWI   0x02     ; 该指令调用操作系统编号位02的系统例程。</span><br></pre></td></tr></table></figure>

<h3 id="BKPT"><a href="#BKPT" class="headerlink" title="BKPT"></a>BKPT</h3><p>BKPT指令产生软件断点中断，可用于程序的调试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BKPT   16位的立即数</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="WFE"><a href="#WFE" class="headerlink" title="WFE"></a>WFE</h3><p>等待事件（Wait For Event）指令。自旋锁就使用到了WFE指令。</p>
<p>ARM架构下，有一个全局的事件寄存器（Event Register），系统中的每一个CPU核在这个寄存器上都有对应的位。当前CPU执行WFE指令的时候，如果事件寄存器对应当前CPU的位没有被设置（也就是0），则当前CPU核会进入低功耗模式，会被挂起，不会再执行其它操作；而如果事件寄存器对应当前CPU的位被设置了（也就是1），则会将事件寄存器对应当前CPU的位清空（设置成0），然后立即返回，继续执行下面的指令，不会进入低功耗模式。</p>
<p>只有在如下情况下才可能被重新唤醒：</p>
<ul>
<li>发生了IRQ中断（前提是没有被屏蔽）；</li>
<li>发生了FIQ中断（前提是没有被屏蔽）；</li>
<li>发生了SError中断（前提是没有被屏蔽）；</li>
<li>事件寄存器对应当前CPU核的位被置位（设置成1），如果是通过这种方式唤醒的，唤醒后会立即将事件寄存器对应当前CPU核的位清0。</li>
</ul>
<h3 id="WFI"><a href="#WFI" class="headerlink" title="WFI"></a>WFI</h3><p>等待中断（Wait For Interrupt）指令。执行WFI指令后，当前CPU核会立即进入低功耗状态。只有在如下情况下才可能被重新唤醒：</p>
<ul>
<li>发生了IRQ中断（不管有没有被屏蔽）；</li>
<li>发生了FIQ中断（不管有没有被屏蔽）；</li>
<li>发生了SError中断（不管有没有被屏蔽）。</li>
</ul>
<h3 id="SEV"><a href="#SEV" class="headerlink" title="SEV"></a>SEV</h3><p>发送事件（Send Event）指令将想系统中的所有CPU核发送事件。对应系统中的每个CPU核，设置事件寄存器（Event Register）相应的位。如果某个CPU核正在等待事件（WFE），那么该CPU核会被立即唤醒，并清除掉表示该CPU的事件寄存器相应的位。</p>
<h3 id="SEVL"><a href="#SEVL" class="headerlink" title="SEVL"></a>SEVL</h3><p>发送本地事件（Send Event Locally）指令。只会向当前CPU核心发送。如果是多核CPU那也只向当前核心，不会向CPU内的其它核心发送。</p>
<p>stp： 入栈指令（str 的变种指令，可以同时操作两个寄存器）</p>
<p>stp x29, x30, [sp, #0x10]     ; 将 x29, x30 的值存入 sp 偏移 16 个字节的位置 </p>
<p>ldp： 出栈指令（ldr 的变种指令，可以同时操作两个寄存器）</p>
<p>ldp x29, x30, [sp, #0x10]     ; 将 sp 偏移 16 个字节的值取出来，存入寄存器 x29 和寄存器 x30 </p>
<p>scvtf： (Signed Convert To Float)带符号 定点数 转换为 浮点数</p>
<p>scvtf    d1, w0      ; 将寄存器 w0 的值(顶点数，转化成 浮点数) 保存到 向量寄存器/浮点寄存器 d1 中</p>
<p>fcvtzs： (Float Convert To Zero Signed)浮点数 转化为 定点数 （舍入为0）</p>
<p>fcvtzs w0, s0        ; 将向量寄存器 s0 的值(浮点数，转换成 定点数)保存到寄存器 w0 中</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/17/algo/tree_search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/17/algo/tree_search/" class="post-title-link" itemprop="url">二叉搜索树</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-17 11:15:01" itemprop="dateCreated datePublished" datetime="2022-12-17T11:15:01+08:00">2022-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-31 19:38:57" itemprop="dateModified" datetime="2022-12-31T19:38:57+08:00">2022-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>二叉搜索树（Binary Search Tree， BST）支持动态数据集合的快速插入、删除、查找操作，是一棵空树或者有如下性质的二叉树：</p>
<ul>
<li>若任意节点的左子树不空，其左子树中的每个节点的值都小于这个节点的值；</li>
<li>若任意节点的右子树不空，其右子树每个节点的值都大于这个节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ul>
<p>不管操作是插入、删除还是查找，其时间复杂度其实都跟树的高度成正比， O(height)。</p>
<p>将二叉搜索树进行中序亢奋可以等到由小到大的顺序排序。</p>
<p><strong>查找操作</strong></p>
<p>先取根节点，如果它等于要查找的数据就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<p><img src="/images/code/algo/tree/findtree.png" alt="二叉搜索树"></p>
<p><strong>插入操作</strong></p>
<p>二叉查找树的插入过程需要从根节点开始，依次比较要插入的数据和节点的大小关系：</p>
<ol>
<li><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</p>
</li>
<li><p>如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
</li>
</ol>
<p><img src="/images/code/algo/tree/findtree-add.png" alt="img"></p>
<p><strong>删除操作</strong></p>
<p>针对要删除节点的子节点个数的不同需要分2种情况来处理:</p>
<ol>
<li><p>如果要删除的节点只有一个子节点或没有子节点，只需要要将要删除节点的父节点的指针指向要删除节点的子节点。比如下图中删除节点 55、 13。</p>
</li>
<li><p>如果要删除的节点有两个子节点。需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再按照上面方法删除掉这个最小节点。比如下图中的删除节点 18。（用左子树的最大节点进行替换也可以）。</p>
</li>
</ol>
<p><img src="/images/code/algo/tree/findtree-del.png" alt="img"></p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>为了解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。平衡二叉查找树就是让整棵树左右看起来比较平衡，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p>
<p>任何节点的左右子树高度相差不超过 1，完全二叉树、满二叉树都是平衡二叉树，非完全二叉树有可能是平衡二叉树。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一颗特殊的二叉查找树，除了二叉查找树的要求外，它还具有以下特性：</p>
<ul>
<li>每个节点是黑色或者红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点(NIL，空节点)是黑色。</li>
<li>从根节点到叶子节点，不会出现两个连续的红色节点。如果一个节点是红色的，则它的子节点必是黑色。</li>
<li>从任何节点到叶子节点，这条路径上有相同数目的黑色节点。</li>
</ul>
<p><strong>旋转</strong></p>
<p>左旋就是当新加入节点之后，树的高度及颜色不再满足红黑树定义规则后；将不满足的节点进行左旋转，使得它取代之前它的父节点，同时它的父节点变为它的左子节点，最后调整颜色的过程。</p>
<p><img src="/images/code/algo/tree/rbtree.png" alt="img"></p>
<p>对x左旋，意味着降低x节点的高度，将x变成一个左节点，提升x节点右节点y的高度。</p>
<ol>
<li>x的右子树指向y的左子树</li>
<li>本来指向x结点的父指针，改成指向y</li>
<li>y的左子树指向x结点</li>
</ol>
<p><img src="/images/code/algo/tree/rbtree2.png" alt="img"></p>
<p>右旋就是以某节点为中心进行向右的旋转，取代并成为之前自己的父节点，然后把之前的父节点变为自己的右子节点，最后调整颜色的过程。</p>
<ol>
<li>x的左子树指向y的右子树</li>
<li>本来指向x结点的父指针，改成指向y</li>
<li>y的右子树指向x结点</li>
</ol>
<hr>
<h2 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h2><p>带权路径最短的二叉树称为哈夫曼树或最优二叉树。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuqinglong/p/9709048.html">https://www.cnblogs.com/wuqinglong/p/9709048.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/11/algo/divided/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/11/algo/divided/" class="post-title-link" itemprop="url">分治算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-11 19:04:14" itemprop="dateCreated datePublished" datetime="2022-12-11T19:04:14+08:00">2022-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-31 19:05:31" itemprop="dateModified" datetime="2022-12-31T19:05:31+08:00">2022-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>分治算法的基本思想是将一个规模为N的问题，分解为K个规模较小的子问题，这些子问题相互独立且原问题性质相同。分而治之，逐个击破，递归解决子问题，然后合并得到原问题的解。</p>
<h2 id="二分法搜索"><a href="#二分法搜索" class="headerlink" title="二分法搜索"></a>二分法搜索</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (min &lt;= max) &#123;</span><br><span class="line">        mid = (min + max) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; data) &#123;</span><br><span class="line">            max = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; data) &#123;</span><br><span class="line">            min = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种取中位数的方式，当 min 和 max 很大的时候，会出现溢出的情况，从而导致数组访问出错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid = (min + max) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>改进的办法是将加法变成减法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止溢出</span></span><br><span class="line">mid =  min + (max - min) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="寻找假币"><a href="#寻找假币" class="headerlink" title="寻找假币"></a>寻找假币</h2><p>有N个硬币，其中有一个质量较轻的假币，如何通过一个天平将假币挑出。</p>
<p>将硬币分成2份去称，轻的寻一半包含假币，再将轻的那一份又分为2份，直到最后剩下两枚，轻的那一枚即为假币。考虑到硬币个数为奇数的情况，照样分为两半，剩下一个多余的，如果两半相等，多余那个就是假币，否则处理那两半。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FakeCoin</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = end - start + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; end &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> coins[start] &lt; coins[end] ? start : end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = num / <span class="number">2</span> + start;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; mid; ++i) &#123;</span><br><span class="line">            left += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &lt;= end; ++i) &#123;</span><br><span class="line">            right += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot;) --&gt; &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, mid, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; mid; ++i) &#123;</span><br><span class="line">            left += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">            right += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot;) --&gt; &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; coins = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; coins = &#123;1, 1, 1, 1, 0, 1, 1, 1, 1&#125;;</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt; coins = &#123;1, 1, 1, 1, 1, 1, 1, 1, 0&#125;;</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">FakeCoin</span>(coins, <span class="number">0</span>, coins.<span class="built_in">size</span>() - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p>从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的3个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。</p>
<p>实现汉诺塔算法只需要以下三个步骤：</p>
<p>​ 1.利用目标柱为媒介，将上面n-1个圆盘从原始柱暂时移动到辅助柱</p>
<p>​ 2.将原始柱上的最后一个最大的圆盘移动到目标柱上</p>
<p>​ 3.将暂存在辅助柱上的n-1个柱子全部移动到目标柱上</p>
<p><img src="/images/code/algo/hanoi.png" alt="汉诺塔"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">char</span> src, <span class="type">char</span> dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;move &quot;</span> &lt;&lt; src &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; dest &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> src, <span class="type">char</span> dest, <span class="type">char</span> tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">Move</span>(src, dest);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Hanoi</span>(n - <span class="number">1</span>, src, tmp, dest);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Move</span>(src, dest);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Hanoi</span>(n - <span class="number">1</span>, tmp, dest, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/11/algo/backtrack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/11/algo/backtrack/" class="post-title-link" itemprop="url">回溯算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-11 18:28:30 / 修改时间：19:03:45" itemprop="dateCreated datePublished" datetime="2022-12-11T18:28:30+08:00">2022-12-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>回溯算法是从一条路往前走，能进则进，走不通就退回，换一条路再试，实际 上就是一个决策树的遍历过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtrack</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表 &#123;</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表); <span class="comment">// 路径就是已经做出的选择</span></span><br><span class="line">        回溯撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p>给定2个整数n和k，返回范围[1,n]中所有可能的k的个数从小到大顺序的组合<br>输入：n = 4, k = 2<br>输出：[[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]</p>
<p><img src="/images/code/algo/backtrack.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;<span class="type">int</span>&gt; &amp;tmp, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : tmp) &#123;</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == target) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, tmp, i+<span class="number">1</span>);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    target = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// target = 3;</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">backtrack</span>(nums, tmp, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vec : res) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">            cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/05/algo/Greedy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/05/algo/Greedy/" class="post-title-link" itemprop="url">贪心算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-05 22:14:25" itemprop="dateCreated datePublished" datetime="2022-12-05T22:14:25+08:00">2022-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-11 18:25:29" itemprop="dateModified" datetime="2022-12-11T18:25:29+08:00">2022-12-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>贪心算法是指在对问题求解时，总是做出局部最优的选择，通过每一步贪心选择，最终可得到问题的一个整体最优解。</p>
<p>贪心算法和动态规划对比：</p>
<ul>
<li>贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。</li>
<li>贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。</li>
<li>动态规划主要运用于二维或三维问题，而贪心一般是一维问题。</li>
</ul>
<h2 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h2><p>给定多个形如[start, end]的闭区间，请计算出最多有多少个互不相交的区间。</p>
<ol>
<li>从排序后的区间中选出end最小的区间x</li>
<li>把所有与x区间相交的区间删除</li>
<li>重复步骤1和2，直到最后一个区间。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">interval</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector&lt;struct interval&gt; vec = &#123;&#123;1, 3&#125;, &#123;4, 6&#125;, &#123;2, 4&#125;&#125;;</span></span><br><span class="line">    vector&lt;<span class="keyword">struct</span> interval&gt; vec = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">        cout &lt;&lt; it.start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; it.end &lt;&lt; it.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [] (<span class="keyword">struct</span> interval a, <span class="keyword">struct</span> interval b) &#123; <span class="keyword">return</span> a.end &lt; b.end; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">        cout &lt;&lt; it.start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; it.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end = vec[<span class="number">0</span>].end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vec[i].start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec[i].end &lt;&lt; <span class="string">&quot; ==&gt; &quot;</span> &lt;&lt; end &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (vec[i].start &gt; end) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            end = vec[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
<ol>
<li><p>从后往前选择，先找到一个可以一步跳到结尾的位置n，如果有多个，就选择距离结尾最远的那个n-1。然后找到可以跳到n-1处的最远的地方n-2。依次类推，最终找到开头位置。</p>
</li>
<li><p>从前往后选择，在当前位置可以跳的步数范围内，选择下一跳可以跳到的最远的那个步数，来决定当前跳多少步。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; nums = &#123;2, 3, 1, 1, 4&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums[cur]; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[cur+i] &gt;= max) &#123;</span><br><span class="line">                max = nums[cur+i];</span><br><span class="line">                distance = i;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; cur &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; --&gt; &quot;</span> &lt;&lt; nums[cur+i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        cur += distance;</span><br><span class="line">        step++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;index = &quot;</span> &lt;&lt; cur &lt;&lt; <span class="string">&quot;, step = &quot;</span> &lt;&lt; step &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; step &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/04/algo/SlideWindow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/04/algo/SlideWindow/" class="post-title-link" itemprop="url">滑动窗口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-04 22:30:17" itemprop="dateCreated datePublished" datetime="2022-12-04T22:30:17+08:00">2022-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-07 22:57:06" itemprop="dateModified" datetime="2022-12-07T22:57:06+08:00">2022-12-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>滑动窗口就是维护一个窗口(队列/数组)，通过双指针同向移动不断滑动，然后更新答案，主要用来处理连续问题。</p>
<p><strong>固定窗口大小</strong></p>
<ol>
<li>left 初始化为 0，初始化 right，使得 right - left + 1 等于窗口大小。</li>
<li>同时移动 left 和 right，判断窗口内的连续元素是否满足限定条件。</li>
<li>如果满足，再判断是否需要更新最优解，如果不满足，则继续。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定窗口大小为 k</span></span><br><span class="line"><span class="comment">// 在 s 中寻找窗口大小为 k 时的所包含最大元音字母个数</span></span><br><span class="line">string s;</span><br><span class="line">window window;</span><br><span class="line"><span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    window.<span class="built_in">add</span>(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    <span class="comment">// 如果符合要求，说明窗口构造完成，</span></span><br><span class="line">    <span class="keyword">if</span> (right&gt;=k) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 把 right -k 位置元素从窗口里面移除</span></span><br><span class="line">        window.<span class="built_in">remove</span>(s[right -k]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p><strong>可变窗口大小</strong></p>
<ol>
<li>left 和 right 都初始化为 0。</li>
<li>right 指针剃每向右移动一步，就判断窗口内的连续元素是否满足限定条件。</li>
<li>如果满足，再判断是否需要更新最优解，通过移动 left 指针收缩窗口。 如果不满足，则继续。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建窗口window容器保存窗口内元素，可以采用数组、hashset、hashmap等</span></span><br><span class="line">window window;</span><br><span class="line"><span class="comment">//保存最优结果、最大或最小等</span></span><br><span class="line"><span class="type">int</span> result = defaltValue;</span><br><span class="line"><span class="comment">//构造窗口的左右边界指针</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.<span class="built_in">add</span>(s[right]);</span><br><span class="line">    <span class="comment">// 如果符合要求，说明窗口构造完成，移动 left 缩小窗口</span></span><br><span class="line">    <span class="keyword">while</span> (window 符合要求) &#123;</span><br><span class="line">        <span class="comment">// 如果这个窗口的条件更优，则更新result</span></span><br><span class="line">        result = <span class="built_in">maxOrMin</span>(result, window);</span><br><span class="line">        <span class="comment">//移出左指针元素</span></span><br><span class="line">        window.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和≥ s的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<p>输入: s = 7, nums = [2,3,1,2,4,3]<br>输出: 2<br>解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line">cin &gt;&gt; target;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = INT16_MAX;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    sum += nums[right];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">        res = <span class="built_in">MIN</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">        sum -= nums[left];</span><br><span class="line">        left++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;---- &quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot; res = &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot;   sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    right++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (res == INT16_MAX ? <span class="number">0</span> : res) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>给定一个字符串 s 、一个字符串 t ，返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”</p>
<p><img src="/images/code/algo/slide-window.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &amp;window, <span class="type">const</span> unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &amp;target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : target) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;        &quot; &lt;&lt; it.first &lt;&lt; &quot; : &quot; &lt;&lt; window[it.first] &lt;&lt; &quot;, &quot; &lt;&lt; it.second &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (window[it.first] &lt; it.second) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;ADOBECODEBANC&quot;</span>;</span><br><span class="line">    string t = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">        target[c]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> len = UINT16_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        window[s[right]]++;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;    &quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot; &quot; &lt;&lt; s[right] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">Check</span>(window, target)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            window[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">substr</span>(start, len) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/19/net/mac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/net/mac/" class="post-title-link" itemprop="url">MAC</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-19 15:08:35 / 修改时间：15:15:55" itemprop="dateCreated datePublished" datetime="2022-11-19T15:08:35+08:00">2022-11-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC(Medium Access Control)媒体访问控制，控制在往媒体上发送数据的先后，防止发生混乱。</p>
<p>MAC 地址共有 48 bit，用来唯一标识设备，在网卡生产时写入 ROM 里的，网卡驱动程序读取并分配给 MAC模块。通过 ARP 可以查询目标路由器的 MAC 地址。</p>
<table>
<thead>
<tr>
<th align="center">bit</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>0 单播地址<br/>1 多播地址</td>
</tr>
<tr>
<td align="center">2</td>
<td>0 全局地址<br/>1 本地地址</td>
</tr>
<tr>
<td align="center">3-24</td>
<td>厂商识别码</td>
</tr>
<tr>
<td align="center">25-48</td>
<td>网卡唯一标识</td>
</tr>
</tbody></table>
<p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，其作用就是将包送达路由器。</p>
<p><img src="/images/net/tcpip/mac_head.png" alt="img"></p>
<h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>网卡驱动从 IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC 模块发送发送包的命令。MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。再将数字信息按每个比特转换成电信号，然后由 PHY信号收发模块发送出去。</p>
<p><img src="/images/net/tcpip/pack.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改MAC地址</span></span><br><span class="line">ifconfig eth0 hw ether 12:34:56:78:90:12</span><br></pre></td></tr></table></figure>

<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机将网络包原样转发到目的地，交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。交换机的 MAC 地址表主要包含两个信息:设备的 MAC 地址，和该设备连接在交换机的端口。</p>
<p>交换机工作在全双工模式。</p>
<p><img src="/images/net/switch.png" alt="img"></p>
<p>交换机会自行更新或删除地址表中的记录，当收到包时会将发送方 MAC 地址以及其输入端口的号码写入MAC 地址表中，当端口上的设备长时间不工作，就会删除记录。</p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃。相对地，交换机的端口不具有 MAC 地址的端口，故不会核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。</p>
<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><p>集线器工作在物理层，会将收到的数据广播给其它端口。集线器里有一张以太网协议的表，根据以太网头部中记录的目的地信息查出相应的传输方向，在子网中将网络包传输到下一个转发设备。</p>
<p>集线器的接口中有一个 MDI/MDI-X 切换开关，MDI 就是对 RJ-45 接口和信号收发模块进行直连接线，而 MDI-X 则是交叉接线。</p>
<p>集线器工作在半双工模式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/30/algo/dynamic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/30/algo/dynamic/" class="post-title-link" itemprop="url">动态规划</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-30 19:29:01" itemprop="dateCreated datePublished" datetime="2022-10-30T19:29:01+08:00">2022-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-05 22:06:02" itemprop="dateModified" datetime="2022-12-05T22:06:02+08:00">2022-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>动态规划的核心思想就是穷举求最值，如果暴力穷举的话效率会极其低下，需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。其中带备忘录的递归解法叫做「自顶向下」，动态规划叫做「自底向上」。</p>
<p>动态规划问题的特征：</p>
<ol>
<li>存在重复子问题，子问题相互独立。</li>
<li>具备最优子结构，可通过子问题的最优解得到原问题的最优解。</li>
<li>无后效性：某阶段状态一旦确定，就不受之后阶段的决策影响。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<h2 id="菲波那切数列"><a href="#菲波那切数列" class="headerlink" title="菲波那切数列"></a>菲波那切数列</h2><p>斐波那契数列又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，又称为兔子数列。在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）。</p>
<p>暴力递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带备忘录的递归解法(自顶向下，通过备忘录剪枝)</p>
<p><img src="/images/code/algo/fib_memo.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fibonacci_memo</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;memo, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo[n] == <span class="number">-1</span>) &#123;</span><br><span class="line">        memo[n] = <span class="built_in">fibonacci_memo</span>(memo, n - <span class="number">1</span>) + <span class="built_in">fibonacci_memo</span>(memo, n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fibonacciMemo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n+<span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci_memo</span>(memo, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp 数组的迭代解法（自底向上，使用循环迭代）</p>
<p><img src="/images/code/algo/fib_dp.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fibonacci_dp</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h2><p>有k种面值的硬币，面值分别为c1, c2 … ck，每种硬币的数量无限，再给一个总金额amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。</p>
<p>凑零钱问题符合最优子结构，比如求 amount = 11 时的最少硬币数（原问题），如果知道凑出 amount = 10 的最少硬币数（子问题），只需把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。</p>
<ol>
<li><p>先确定「状态」，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额amount。</p>
</li>
<li><p>然后确定dp数组的定义：函数 dp(n)表示，当前的目标金额是n，至少需要dp(n)个硬币凑出该金额。</p>
</li>
<li><p>然后确定「选择」并择优，也就是对于每个状态，可以做出什么选择改变当前状态。无论当前的目标金额是多少，选择就是从面额列表coins中选择一个硬币，然后目标金额就会减少。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="type">int</span>], amount: <span class="type">int</span>)</span>:</span></span><br><span class="line"><span class="function">    # 定义：要凑出金额 n，至少要 dp(n) 个硬币</span></span><br><span class="line"><span class="function">    def dp(n):</span></span><br><span class="line"><span class="function">        # 做选择，需要硬币最少的那个结果就是答案</span></span><br><span class="line"><span class="function">        for coin in coins:</span></span><br><span class="line"><span class="function">            res =</span> <span class="built_in">min</span>(res, <span class="number">1</span> + <span class="built_in">dp</span>(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    # 我们要求目标金额是 amount</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(amount)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最后明确 base case，显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="type">int</span>], amount: <span class="type">int</span>)</span>:</span></span><br><span class="line"><span class="function">    def dp(n):</span></span><br><span class="line"><span class="function">        # base case</span></span><br><span class="line"><span class="function">        if n =</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        # 求最小值，所以初始化为正无穷</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> coin in coins:</span><br><span class="line">            subproblem = <span class="built_in">dp</span>(n - coin)</span><br><span class="line">            # 子问题无解，跳过</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(amount)</span><br></pre></td></tr></table></figure>

<p><img src="/images/code/algo/coin.png" alt="img"></p>
<p>带备忘录的递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="type">int</span>], amount: <span class="type">int</span>)</span>:</span></span><br><span class="line"><span class="function">    # 备忘录</span></span><br><span class="line"><span class="function">    memo =</span> <span class="built_in">dict</span>()</span><br><span class="line">    <span class="function">def <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">        # 查备忘录，避免重复计算</span></span><br><span class="line"><span class="function">        if n in memo: return memo[n]</span></span><br><span class="line"><span class="function">        if n =</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> coin in coins:</span><br><span class="line">            subproblem = <span class="built_in">dp</span>(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line">        # 记入备忘录</span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(amount)</span><br></pre></td></tr></table></figure>

<p>dp 数组迭代解法</p>
<p><img src="/images/code/algo/coin_dp.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 在求所有子问题 + 1 的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？</p>
<p>明确两点，「状态」和「选择」。</p>
<ol>
<li><p>明确状态，状态有两个，就是「背包的容量」和「可选择的物品」。</p>
</li>
<li><p>明确选择，就是「装进背包」或者「不装进背包」。</p>
</li>
<li><p>明确 dp 数组的定义：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = <span class="built_in">max</span>(</span><br><span class="line">            dp[i<span class="number">-1</span>][w],  <span class="comment">// 不把物品 i 装进背包</span></span><br><span class="line">            dp[i<span class="number">-1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>]  <span class="comment">// 把物品 i 装进背包</span></span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>明确base case，就是 dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, vector&lt;<span class="type">int</span>&gt;&amp; wt, vector&lt;<span class="type">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case 已初始化</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这种情况下只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子集背包问题"><a href="#子集背包问题" class="headerlink" title="子集背包问题"></a>子集背包问题</h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<ol>
<li><p>明确「状态」和「选择」，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p>
</li>
<li><p>明确dp数组的定义，dp[i][j] = x表示：对于前i个物品，当前背包的容量为j时，若x为true，则说明可以恰好将背包装满，若x为false，则说明不能恰好将背包装满。根据这个定义，我们想求的最终答案就是dp[N][sum/2]。</p>
</li>
<li><p>base case 就是dp[..][0] = true和dp[0][..] = false，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        sum += num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和为奇数时，不可能划分成两个和相等的集合</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(sum + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">               <span class="comment">// 背包容量不足，不能装入第 i 个物品</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或不装入背包</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到dp[i][j]都是通过上一行dp[i-1][..]转移过来的，之前的数据都不会再使用了。所以可以进行状态压缩，将二维dp数组压缩为一维，节约空间复杂度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        sum += num;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = sum; j &gt;= <span class="number">0</span>; j--) </span><br><span class="line">            <span class="keyword">if</span> (j - nums[i] &gt;= <span class="number">0</span>) </span><br><span class="line">                dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>有一个背包，最大容量为amount，有一系列物品coins，每个物品的重量为coins[i]，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？</p>
<ol>
<li><p>明确「状态」和「选择」，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p>
</li>
<li><p>明确 dp[i][j]数组的定义：若只使用前i个物品，当背包容量为j时，有dp[i][j]种方法可以装满背包。</p>
</li>
<li><p>base case 为dp[0][..] = 0， dp[..][0] = 1。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么不用装就满了。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= coins[i<span class="number">-1</span>])</span><br><span class="line">                <span class="comment">//把这第i个物品装入背包，装入第i种商品后还可以再继续装入第i种商品。</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i<span class="number">-1</span>]]; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">//不把这第i个物品装入背包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察可以发现，dp数组的转移只和dp[i][..]和dp[i-1][..]有关，所以可以压缩状态，进一步降低算法的空间复杂度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="type">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">            <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[j] = dp[j] + dp[j-coins[i]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">222</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
