<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DFS深度优先算法</title>
    <url>/2022/09/24/algo/DFS/</url>
    <content><![CDATA[<p>深度优先遍历主要思路是从图中一个未访问的顶点开始，沿着一条路一直走到底，不撞南墙不回头，先走完一条路，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底，不断递归重复此过程，直到所有的顶点都遍历完成。</p>
<p>深度优先搜索采用回溯思想，适合用递归或栈来实现。遍历得到的路径并不是最短路径。</p>
<p><strong>树的遍历</strong></p>
<p>对于二叉树，深度优先的递归实现其实就是前序遍历。</p>
<p><img src="/images/code/algo/search/DFS.png" alt="img"></p>
<p>非递归实现利用栈来将要遍历的节点压栈，然后出栈后检查此节点是否还有未遍历的节点，有的话压栈，没有的话不断出栈。</p>
<ol>
<li>先遍历当前节点，然后把右节点压栈，再压左节点。</li>
<li>弹栈，拿到栈顶的节点，如果节点不为空，重复步骤1， 如果为空，结束遍历。</li>
</ol>
<p><img src="/images/code/algo/search/DFS.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfsWithStack</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 先把根节点压栈</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">treeNode</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">// 遍历节点</span></span><br><span class="line">        process(treeNode);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 先压右节点</span></span><br><span class="line">        <span class="keyword">if</span> (treeNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(treeNode.right);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 再压左节点</span></span><br><span class="line">        <span class="keyword">if</span> (treeNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(treeNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>图的遍历</strong></p>
<h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) (a&gt;b ? a:b)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DIRS[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> col, row;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mat, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mat[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    mat[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">        <span class="type">int</span> dx = x + DIRS[k][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dy = y + DIRS[k][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (dx &gt;= <span class="number">0</span> &amp;&amp; dx &lt; row &amp;&amp; dy &gt;= <span class="number">0</span> &amp;&amp; dy &lt; col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[dx][dy] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(mat, dx, dy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    col = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    row = mat.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span>(mat, i, j);</span><br><span class="line">            num++;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;    num  = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿最大面积"><a href="#岛屿最大面积" class="headerlink" title="岛屿最大面积"></a>岛屿最大面积</h2><p>给定一个包含了一些 0 和 1的非空二维数组，一个岛屿是由四个方向 (水平或垂直) 的 1 (代表土地)构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。求给定的二维数组中最大的岛屿面积。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) (a&gt;b ? a:b)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DIRS[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> col, row;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mat, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> &amp;num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mat[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    mat[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    num2++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">        <span class="type">int</span> dx = x + DIRS[k][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dy = y + DIRS[k][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (dx &gt;= <span class="number">0</span> &amp;&amp; dx &lt; row &amp;&amp; dy &gt;= <span class="number">0</span> &amp;&amp; dy &lt; col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[dx][dy] == <span class="number">1</span>) &#123;</span><br><span class="line">                num += <span class="built_in">dfs</span>(mat, dx, dy, num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    col = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    row = mat.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> num = <span class="built_in">dfs</span>(mat, i, j, num2);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;    num  = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;    num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// res = MAX(res, num);</span></span><br><span class="line">            res = <span class="built_in">MAX</span>(res, num2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>BFS广度优先算法</title>
    <url>/2022/09/24/algo/BFS/</url>
    <content><![CDATA[<p>广度优先搜索采用地毯式层层推进策略，从起始顶点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点，依次往外遍历。</p>
<p>广度优先搜索需要借助队列来实现，遍历得到的路径就是起始顶点到终止顶点的最短路径。</p>
<p><strong>树的遍历</strong></p>
<p>对于二叉树，广度优先遍历其实就是层序遍历。</p>
<p><img src="/images/code/algo/search/BFS.gif" alt="img"></p>
<p><strong>图的遍历</strong></p>
<p><img src="/images/code/algo/search/BFS2.png" alt="img"></p>
<h2 id="01矩阵"><a href="#01矩阵" class="headerlink" title="01矩阵"></a>01矩阵</h2><p>给定一个由0和1组成的矩阵mat，请输出一个大小相同的矩阵，其中每一个格子是mat中对应位置元素到最近的 0 的距离，只考虑上下左右四个方向。</p>
<p>输入：<br>0 0 0<br>0 1 0<br>1 1 1</p>
<p>输出：<br>0 0 0<br>0 1 0<br>1 2 1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> col = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> row = mat.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> stop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            stop = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (mat[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> pos = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> x = pos.first;</span><br><span class="line">                    <span class="type">int</span> y = pos.second;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        <span class="type">int</span> dx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="type">int</span> dy = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (dx &gt;= <span class="number">0</span> &amp;&amp; dx &lt; row &amp;&amp; dy &gt;= <span class="number">0</span> &amp;&amp; dy &lt; col) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mat[dx][dy] == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mat[dx][dy] != <span class="number">0</span> &amp;&amp; dx != i &amp;&amp; dy != j) &#123;</span><br><span class="line">                                q.<span class="built_in">push</span>(&#123;dx, dy&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                            stop++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mat[i][j] += stop;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(mat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : mat) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : v) &#123;</span><br><span class="line">            cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h2><p>给定一个只包含0或1的二维数组，其中0表示可以走的道路，1表示墙壁不可通过。求从左上角移动到右下角需要移动的次数。</p>
<p>输入：<br>0 1 0 0 0<br>0 1 0 1 0<br>0 0 0 0 0<br>0 1 1 1 0<br>0 0 0 1 0</p>
<p>输出：8</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> col = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> row = mat.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">stop</span>(col, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(row, <span class="number">-1</span>));</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">route</span>(col, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;(row, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;));</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;); </span><br><span class="line">    stop[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> x = pos.first;</span><br><span class="line">        <span class="type">int</span> y = pos.second;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="type">int</span> dx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> dy = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dx &gt;= <span class="number">0</span> &amp;&amp; dx &lt; row &amp;&amp; dy &gt;= <span class="number">0</span> &amp;&amp; dy &lt; col) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mat[dx][dy] == <span class="number">0</span>) &amp;&amp; (stop[dx][dy] == <span class="number">-1</span>)) &#123;</span><br><span class="line">                    stop[dx][dy] = stop[x][y] + <span class="number">1</span>;</span><br><span class="line">                    route[dx][dy] = &#123;x, y&#125;;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dx, dy&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : stop) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : v) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d &quot;</span>, it);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = col - <span class="number">1</span>, y = row - <span class="number">1</span>; (x != <span class="number">0</span> || y != <span class="number">0</span>);) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) &lt;- &quot;</span>, x, y);</span><br><span class="line">        <span class="keyword">auto</span> tmp = route[x][y];</span><br><span class="line">        x = tmp.first;</span><br><span class="line">        y = tmp.second;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(0, 0)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stop[col<span class="number">-1</span>][row<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(mat) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿最大面积"><a href="#岛屿最大面积" class="headerlink" title="岛屿最大面积"></a>岛屿最大面积</h2><p>给定一个包含了一些 0 和 1的非空二维数组，一个岛屿是由四个方向 (水平或垂直) 的 1 (代表土地)构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。求给定的二维数组中最大的岛屿面积。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) (a&gt;b ? a:b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> col = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> row = mat.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> pos = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> x = pos.first;</span><br><span class="line">                    <span class="type">int</span> y = pos.second;</span><br><span class="line">                    mat[x][y] = <span class="number">0</span>;</span><br><span class="line">                    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        <span class="type">int</span> dx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="type">int</span> dy = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (dx &gt;= <span class="number">0</span> &amp;&amp; dx &lt; row &amp;&amp; dy &gt;= <span class="number">0</span> &amp;&amp; dy &lt; col) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mat[dx][dy] == <span class="number">1</span>) &#123;</span><br><span class="line">                                num++;</span><br><span class="line">                                q.<span class="built_in">push</span>(&#123;dx, dy&#125;);</span><br><span class="line">                                mat[dx][dy] = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;    num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">                res = <span class="built_in">MAX</span>(res, num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                               &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(mat) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>算法基础</title>
    <url>/2022/09/04/algo/algorithm/</url>
    <content><![CDATA[<h2 id="算法的特点"><a href="#算法的特点" class="headerlink" title="算法的特点"></a>算法的特点</h2><p>算法的特性:</p>
<ul>
<li>输入与输出，具有零个或多个输入，至少有一个或多个输出。</li>
<li>有穷性，算法能在特定时间内完成，不会出现无限循环。</li>
<li>确定性，算法相同的输入得到的输出也相同，不会出现二义性。</li>
<li>可行性，算法的每一步都是可以用程序实现的。</li>
</ul>
<p>算法设计的要求：正确性、健壮性、可读性、时间效率高和存储量低。</p>
<p><img src="/images/code/algo/datastruct_algo.jpg" alt="数据结构与算法"></p>
<h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><ol>
<li>只关注循环执行次数最多的一段代码。</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度。</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</li>
<li>越高阶复杂度的算法，其执行效率越低，计算时只保留最高阶项。</li>
</ol>
<p>常见的时间复杂度所消耗的时间从小到大依次是：<br><code>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2^) &lt; O(n^3^) &lt; O(2^n^) &lt; O(n!) &lt; O(n^n^)</code><br><img src="/images/code/algo/algo.png" alt="复杂度"></p>
<ul>
<li>常数阶 Ο(1)</li>
</ul>
<p>只要算法中不存在循环语句、递归语句，即使有多少行的代码，其时间复杂度都是Ο(1)。</p>
<ul>
<li>线性阶 O(n)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    a = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将常数复杂度的语句循环n次，所以这段代码的时间复杂度就是 O(n)。</p>
<ul>
<li>平方阶 O(n^2^) O(n * m)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用乘法法则将嵌套内外的代码复杂度相乘，所以这段代码的时间复杂度就是 O(n * m)，当n=m时，就是O(n^2^)。</p>
<p>下面这段代码也是如此：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; m; j++) &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当i=0时，循环执行n次，当i=1时，循环执行n-1次，所以总执行次数为：n + (n-1) + (n-2) + … + 1 = n(n+1)/2 = n^2^/2 + n/2。去除常数，只保留最高阶，最终代码的时间复杂度为O(n^2^)。</p>
<ul>
<li>对数阶 O(logn) O(nlogn)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 i 从 1 开始，每次循环乘以 2。当大于 n 时，循环结束。通过等式 2x=n，可以求得代码的循环次数x=log2n，所以这段代码的时间复杂度就是 O(log2n)。</p>
<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。因为对数之间是可以互相转换的，log3n 就等于 log32 * log2n，所以 O(log3n) = O(C * log2n)，其中常数C可以忽略，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2022/06/07/algo/find/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>查找算法</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>查找条件</th>
</tr>
</thead>
<tbody><tr>
<td>顺序查找</td>
<td>O(n)</td>
<td>O(1)</td>
<td>无序或有序</td>
</tr>
<tr>
<td>二分查找</td>
<td>O(log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td>插值查找</td>
<td>O(log<sub>2</sub>(log<sub>2</sub>n))</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td>斐波那契查找</td>
<td>O(log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td>哈希查找</td>
<td>O(1)</td>
<td>O(n)</td>
<td>无序或有序</td>
</tr>
<tr>
<td>二叉查找树</td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>红黑树</td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2-3树</td>
<td>O(log<sub>2</sub>n - log<sub>3</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B树/B+树</td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="图搜索算法"><a href="#图搜索算法" class="headerlink" title="图搜索算法"></a>图搜索算法</h3><table>
<thead>
<tr>
<th>图搜索算法</th>
<th>数据结构</th>
<th>遍历时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>BFS广度优先搜索</td>
<td>邻接矩阵<br/>邻接链表</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
</tr>
<tr>
<td>DFS深度优先搜索</td>
<td>邻接矩阵<br/>邻接链表</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
</tr>
</tbody></table>
<h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><table>
<thead>
<tr>
<th>算法</th>
<th>思想</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td>[分治法</td>
<td>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</td>
<td>循环赛日程安排问题、排序算法（快速排序、归并排序）</td>
</tr>
<tr>
<td>动态规划</td>
<td>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题</td>
<td>背包问题、斐波那契数列</td>
</tr>
<tr>
<td>贪心法</td>
<td>一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法</td>
<td>旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>图</title>
    <url>/2022/06/07/algo/graph/</url>
    <content><![CDATA[<h2 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h2><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>
<p>树中的元素称为节点，图中的元素叫作<strong>顶点</strong>。图一个顶点可以与任意其他顶点建立连接关系，这种建立的关系叫<strong>边</strong>。顶点相连接的边的条数，顶点的<strong>度</strong>。</p>
<p>边有方向的图叫作<strong>有向图</strong>，边没有方向的图就叫作<strong>无向图</strong>。</p>
<p>无向图中的<strong>度</strong>表示一个顶点有多少条边，在有向图中，顶点的<strong>入度</strong>表示有多少条边指向这个顶点，顶点的<strong>出度</strong>表示有多少条边是以这个顶点为起点指向其他顶点。</p>
<p><strong>无向边</strong>：顶点vi到vj之间的边没有方向，则称这条边为无向边，用无序偶对(Vi,Vj)来表示。</p>
<p><strong>无向图</strong>：图中的任意两个顶点之间的边都是无向边。</p>
<p><img src="/images/code/algo/graph/undir.png" alt="无向图"></p>
<p>上图的无向图G1，可以表示成：G1=(V1,{E1})，其中顶点集合V1={A,B,C,D}；边集合E1={(A,B),(B,C)(C,D),(D,A),(A,C)}。</p>
<p><strong>有向边</strong>：顶点vi到vj的边有方向。 也称为<strong>弧</strong>。有向边用带尖括号的有序偶对&lt;vi,vj&gt;来表示。其中vi称为弧尾，vj称为弧头。</p>
<p><strong>有向图</strong>：图中任意两个顶点之间都是有向边。</p>
<p><img src="/images/code/algo/graph/dir.png" alt="有向图"></p>
<p>上图的有向图G2，可以表示成：G2=(V2,{E2})，其中顶点集合V2={A,B,C,D}；弧集合E2={(A,D),(B,A)(C,A),(B,C)}。</p>
<p><strong>简单图</strong>：在图中，如果不存在顶点到其自身的边，且同一条边不重复出现。</p>
<p><strong>无向完全图</strong>：在无向图中，任意两个顶点之间都存在边，也就是说每个顶点都要与除它以外的顶点连线。此时边的数量公式为：n(n-1)/2 。</p>
<p><img src="/images/code/algo/graph/allundir.png" alt="无向完全图"></p>
<p><strong>有向完全图</strong>：在有向图中，任意两个顶点之间都存在方向互为相反的两条弧。此时弧的数量公式为：n(n-1)。</p>
<p><img src="/images/code/algo/graph/alldir.png" alt="有向完全图"></p>
<p>对于一个具有n个顶点和e条边的图，存在这样的边界：无向图：0&lt;=e&lt;=n(n-1)/2，有向图：0&lt;=e&lt;=n(n-1)。</p>
<p>有很少条边或弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong>，这是一个很模糊的概念。</p>
<p><strong>子图</strong>：假设两个图G=(V,{E})和G’=(V’,{E’})，如果集合V’⊆V，且集合E’⊆E，则称G’是G的子图。</p>
<p>图的边或弧都有一个权重的图称为<strong>网</strong>。</p>
<p><strong>路径</strong></p>
<p><strong>路径（Path）</strong>：图中从顶点v到v’的顶点序列。在树中根结点到任意结点的路径是唯一的，但在图中顶点与顶点之间的路径并不唯一。</p>
<p><strong>路径长度</strong>：路径上的边或弧的数目。</p>
<p><strong>回路（Cycle）</strong>：路径中第一个顶点到最后一个顶都是同一个顶点。<strong>简单路径</strong>：路径中不存在重复出现顶点。<strong>简单回路</strong>：除了第一个顶点和最后一个顶点，路径中不存在重复出现顶点，也称<strong>简单环</strong>。</p>
<p><strong>连通图</strong></p>
<p>在无向图中如果顶点v到顶点v’有路径，则称v和v’是连通的。如果图中任意两个顶点vi、vj∈E，且vi和vj都是连通的。则称该图为<strong>连通图（connected graph）</strong>。无向图中的极大连通子图称为<strong>连通分量</strong>，它强调：</p>
<ul>
<li>要是子图</li>
<li>子图要是连通的</li>
<li>连通子图含有极大顶点数</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边</li>
</ul>
<p>任何连通图的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。</p>
<p>在有向图G中，如果对于每一对、∈V、≠，从到和从到都存在路径，则称G是<strong>强连通图</strong>。有向图中的极大强连通子图称做有向图的<strong>强连通分量</strong>。</p>
<p><strong>连通图生成树</strong></p>
<p><strong>生成树</strong>(SpanningTree)是连通图的包含图中的所有顶点的极小连通子图。即生成树包含图中的全部的n个顶点，但只有足以构成一棵树的n-1条边。图的生成树不惟一。从不同的顶点出发进行遍历，可以得到不同的生成树。</p>
<p>如果一个有向图恰有一个顶点的入度为0（根结点），其余顶点的入度均为1，则是一棵<strong>有向树</strong>。一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p>
<h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 $A[i][j]$ 和 $A[j][i]$ 标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 $A[i][j]$ 标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 $A[j][i]$ 标记为 1。对于带权图，数组中就存储相应的权重。</p>
<p><img src="/images/code/algo/graph/AdjacencyMatrix.png" alt="邻接矩阵"></p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表的每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。</p>
<p><img src="/images/code/algo/graph/AdjacencyList.png" alt="邻接表"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2022/09/25/algo/heap/</url>
    <content><![CDATA[<p>堆是一种完全二叉树，每个节点的值都大于等于（或小于等于）其子树节点的值。</p>
<ul>
<li>对于每个节点的值都大于等于子树中每个节点值的堆叫<strong>大顶堆</strong>，</li>
<li>对于每个节点的值都小于等于子树中每个节点值的堆叫<strong>小顶堆</strong>。</li>
</ul>
<p>堆比较适合用数组来存储。</p>
<p><img src="/images/code/algo/heap/heap.png" alt="heap"></p>
<p>堆典型应用场景：实现优先队列、求 Top N 、求中位数。</p>
<h2 id="堆化"><a href="#堆化" class="headerlink" title="堆化"></a>堆化</h2><p>堆的元素变动后，不符合堆定义的话，就需要进行调整，让其重新满足堆的特性，这个过程叫作堆化。堆化就是顺着节点所在的路径，向上或者向下进行对比，然后交换。</p>
<p><strong>插入元素</strong></p>
<p>插入的元素直接放到堆的最后，从下往上堆化，让新插入的节点与父节点对比大小，如果不满足子节点小于等于父节点的大小关系，就互换两个节点。一直重复这个过程，直到比对到根节点。</p>
<p><img src="/images/code/algo/heap/add.png" alt="堆化"></p>
<p><strong>删除堆顶元素</strong></p>
<p>删除堆顶元素后，就需要把第二大的元素放到堆顶，然后再迭代地删除第二大节点，以此类推，直到叶子节点被删除，但这样操作完成后的堆不再满足完全二叉树的特性。</p>
<p><img src="/images/code/algo/heap/del1.png" alt="堆化"></p>
<p>正确做法是先把最后一个节点放到堆顶，然后从上往下的堆化。</p>
<p><img src="/images/code/algo/heap/del2.png" alt="堆化"></p>
<p>一个包含 $n$ 个节点的完全二叉树高度小于 $log_{2}n$，堆化的时间复杂度跟树的高度成正比等于 $O(log\ n)$。</p>
<h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p>建堆就是将数组原地建成一个堆，从后往前处理数组，找到第一个非叶子节点，然后依次从上往下堆化，堆化过程只要比较和交换数组元素。</p>
<p><img src="/images/code/algo/heap/create.png" alt="建堆"></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>建堆后，如果是个大顶堆，那么排序步骤如下：</p>
<ol>
<li><p>取堆顶元素，与数组下标最后的元素交换位置，因为就是堆顶就是最大的元素，这样就排好了最大元素。</p>
</li>
<li><p>堆顶元素移除后发生堆化，将剩下的n−1个元素重新构建成堆。</p>
</li>
<li><p>再取堆顶的元素，交换至下标为 $n−1$ 的位置，一直重复这个过程，直到最后堆中只剩下标为 $1$ 的一个元素。</p>
</li>
</ol>
<p><img src="/images/code/algo/heap/sort.png" alt="排序"></p>
<p>堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 $O(n)$，排序过程的时间复杂度是 $O(nlog \  n)$，所以，堆排序整体的时间复杂度是 $O(nlog \  n)$。</p>
<p>堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2022/09/04/algo/sqlist/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组（Array）是一种线性表数据结构，用来存储一组具有相同类型的数据，它的内存空间是连续的，支持随机访问，但插入与删除操作需要移动大量结点，同时不能预先确定分配的空间大小，会造成空间的浪费。</p>
<p><img src="/images/code/algo/sqlist/array.jpg" alt="img"></p>
<p>数组根据下标随机访问的时间复杂度为 O(1)。排好序的数组用二分查找，时间复杂度是 O(logn)。顺序查找，最好时间复杂度为 O(1)，最差时间复杂度为O(n)，平均时间复杂度为O(n)。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><img src="/images/code/algo/sqlist/list.jpg" alt="img"></p>
<p>删除给定值的结点，各种链表都需要从头结点开始遍历对比，直到找到值等于给定值的结点，然后再删除。单纯的删除操作时间复杂度是 O(1)，但遍历查找对应的时间复杂度为 O(n)。链表操作的总时间复杂度为 O(n)。</p>
<p>删除给定指针指向的结点，删除某个结点需要知道其前驱结点，而单链表并不支持直接获取前驱结点，还是要从头结点开始遍历链表，时间复杂度 O(n)。而双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历，只要 O(1) 的时间复杂度。</p>
<p><img src="/images/code/algo/sqlist/list-del.png" alt="img"><br><img src="/images/code/algo/sqlist/list-add.png" alt="img"></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种后进先出、先进后出的结构。</p>
<p><img src="/images/code/algo/sqlist/stack.jpg" alt="img"></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出、后进后出的结构。</p>
<p><img src="/images/code/algo/sqlist/queue.png" alt="img"><br><img src="/images/code/algo/sqlist/ringbuf.png" alt="img"></p>
<p>环形队列为空的判断条件是<code>head == tail</code>，满的条件是<code>(tail+1) % n = head</code>。</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>跳表就是链表 + 多级索引，其插入、删除操作的时间复杂度是 O(logn)。空间复杂度是 O(n)。</p>
<p><img src="/images/code/algo/sqlist/inode.png" alt="img"></p>
<p>加一层索引之后，查找一个结点需要遍历的结点个数就减少了。比如要查找16，当在索引层遍历到13时，发现索引层下一个节点是17大于目标16，则可从13的down指针下降到下一层索引继续遍历，最终从原始链表中找到16。</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表利用了数组按照下标随机访问的时候时间复杂度是 O(1) 的特性。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查询元素时，用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p>
<p><img src="/images/code/algo/sqlist/HashTable.png" alt="img"></p>
<p>散列表两个核心问题是<strong>散列函数设计</strong>和<strong>散列冲突解决</strong>。解决散列冲突方法有开放寻址法和链表法。散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/06/07/algo/sort/</url>
    <content><![CDATA[<p><img src="/images/code/algo/sort/sort_algo.png" alt="排序算法"></p>
<p>排序算法执行效率的评判标准：</p>
<ul>
<li>最好情况、最坏情况、平均情况时间复杂度</li>
<li>时间复杂度</li>
<li>空间复杂度</li>
<li>比较次数和交换或移动次数</li>
</ul>
<p><strong>原地排序算法</strong>就是特指空间复杂度是 O(1) 的排序算法。</p>
<p>排序算法的<strong>稳定性</strong>，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最差时间复杂度</th>
<th>最差时间复杂度</th>
<th>空间复杂度</th>
<th>数据对象稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>数组不稳定、链表稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(log<sub>2</sub>n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n*log<sup>2</sup>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(m)</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(k*n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(k*n)</td>
<td></td>
<td>稳定</td>
</tr>
</tbody></table>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p><img src="/images/code/algo/sort/bubble.gif" alt="冒泡排序"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sort_bubble</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">bool</span> swap_flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        swap_flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; size - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j<span class="number">-1</span>] &gt; <span class="built_in">array</span>[j]) &#123;     <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">                SWAP(<span class="built_in">array</span>[j<span class="number">-1</span>], <span class="built_in">array</span>[j]);</span><br><span class="line">                swap_flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过设置哨兵，提前感知前面的序列已经是排序好的，就直接跳出完成排序</span></span><br><span class="line">        <span class="keyword">if</span> (!swap_flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序的过程只涉及数据的交换操作，所以它的空间复杂度为 O(1)，是一个原地排序算法。当有相邻的两个元素大小相等时不做交换，所以是稳定的排序算法。</p>
<p>最好情况下，要排序的数据已经是有序的了，只需要进行一次冒泡操作，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序(Selection-sort)首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾，直到所有元素均排序完毕。<br>￼<br><img src="/images/code/algo/sort/select.gif" alt="选择排序"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sort_selection</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SWAP(<span class="built_in">array</span>[i], <span class="built_in">array</span>[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序是一种原地排序算法。每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性，不是稳定的排序算法。最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（Insertion Sort）取未排序区间中元素，将其插入已经排序的有序表中，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空。就跟打扑克摸牌放牌一样。</p>
<p><img src="/images/code/algo/sort/insertion.gif" alt="插入排序"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sort_insertion</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        tmp = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; <span class="built_in">array</span>[j]) &#123;</span><br><span class="line">                <span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[j];  <span class="comment">// 数据移动</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[j+<span class="number">1</span>] = tmp;  <span class="comment">// 插入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，是一个原地排序算法。</p>
<p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
<p>最好情况时间复杂度是 O(n)，而最坏情况时间复杂度为 O(n2)。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序（Shell Sort）1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素，又叫缩小增量排序。</p>
<p><img src="/images/code/algo/sort/shell.gif" alt="希尔排序"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/images/code/algo/sort/quick.gif" alt="快速排序"></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="/images/code/algo/sort/heap.gif" alt="堆排序"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2022/10/30/algo/dynamic/</url>
    <content><![CDATA[<p>动态规划的核心思想就是穷举求最值，如果暴力穷举的话效率会极其低下，需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。其中带备忘录的递归解法叫做「自顶向下」，动态规划叫做「自底向上」。</p>
<p>动态规划问题的特征：</p>
<ol>
<li>存在重复子问题，子问题相互独立。</li>
<li>具备最优子结构，可通过子问题的最优解得到原问题的最优解。</li>
<li>无后效性：某阶段状态一旦确定，就不受之后阶段的决策影响。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<h2 id="菲波那切数列"><a href="#菲波那切数列" class="headerlink" title="菲波那切数列"></a>菲波那切数列</h2><p>斐波那契数列又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，又称为兔子数列。在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）。</p>
<p>暴力递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带备忘录的递归解法(自顶向下，通过备忘录剪枝)</p>
<p><img src="/images/code/algo/fib_memo.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fibonacci_memo</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;memo, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo[n] == <span class="number">-1</span>) &#123;</span><br><span class="line">        memo[n] = <span class="built_in">fibonacci_memo</span>(memo, n - <span class="number">1</span>) + <span class="built_in">fibonacci_memo</span>(memo, n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fibonacciMemo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n+<span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci_memo</span>(memo, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp 数组的迭代解法（自底向上，使用循环迭代）</p>
<p><img src="/images/code/algo/fib_dp.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fibonacci_dp</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h2><p>有k种面值的硬币，面值分别为c1, c2 … ck，每种硬币的数量无限，再给一个总金额amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。</p>
<p>凑零钱问题符合最优子结构，比如求 amount = 11 时的最少硬币数（原问题），如果知道凑出 amount = 10 的最少硬币数（子问题），只需把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。</p>
<ol>
<li><p>先确定「状态」，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额amount。</p>
</li>
<li><p>然后确定dp数组的定义：函数 dp(n)表示，当前的目标金额是n，至少需要dp(n)个硬币凑出该金额。</p>
</li>
<li><p>然后确定「选择」并择优，也就是对于每个状态，可以做出什么选择改变当前状态。无论当前的目标金额是多少，选择就是从面额列表coins中选择一个硬币，然后目标金额就会减少。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="type">int</span>], amount: <span class="type">int</span>)</span>:</span></span><br><span class="line"><span class="function">    # 定义：要凑出金额 n，至少要 dp(n) 个硬币</span></span><br><span class="line"><span class="function">    def dp(n):</span></span><br><span class="line"><span class="function">        # 做选择，需要硬币最少的那个结果就是答案</span></span><br><span class="line"><span class="function">        for coin in coins:</span></span><br><span class="line"><span class="function">            res =</span> <span class="built_in">min</span>(res, <span class="number">1</span> + <span class="built_in">dp</span>(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    # 我们要求目标金额是 amount</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(amount)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最后明确 base case，显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="type">int</span>], amount: <span class="type">int</span>)</span>:</span></span><br><span class="line"><span class="function">    def dp(n):</span></span><br><span class="line"><span class="function">        # base case</span></span><br><span class="line"><span class="function">        if n =</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        # 求最小值，所以初始化为正无穷</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> coin in coins:</span><br><span class="line">            subproblem = <span class="built_in">dp</span>(n - coin)</span><br><span class="line">            # 子问题无解，跳过</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(amount)</span><br></pre></td></tr></table></figure>

<p><img src="/images/code/algo/coin.png" alt="img"></p>
<p>带备忘录的递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="type">int</span>], amount: <span class="type">int</span>)</span>:</span></span><br><span class="line"><span class="function">    # 备忘录</span></span><br><span class="line"><span class="function">    memo =</span> <span class="built_in">dict</span>()</span><br><span class="line">    <span class="function">def <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">        # 查备忘录，避免重复计算</span></span><br><span class="line"><span class="function">        if n in memo: return memo[n]</span></span><br><span class="line"><span class="function">        if n =</span>= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> coin in coins:</span><br><span class="line">            subproblem = <span class="built_in">dp</span>(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line">        # 记入备忘录</span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(amount)</span><br></pre></td></tr></table></figure>

<p>dp 数组迭代解法</p>
<p><img src="/images/code/algo/coin_dp.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 在求所有子问题 + 1 的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？</p>
<p>明确两点，「状态」和「选择」。</p>
<ol>
<li><p>明确状态，状态有两个，就是「背包的容量」和「可选择的物品」。</p>
</li>
<li><p>明确选择，就是「装进背包」或者「不装进背包」。</p>
</li>
<li><p>明确 dp 数组的定义：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = <span class="built_in">max</span>(</span><br><span class="line">            dp[i<span class="number">-1</span>][w],  <span class="comment">// 不把物品 i 装进背包</span></span><br><span class="line">            dp[i<span class="number">-1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>]  <span class="comment">// 把物品 i 装进背包</span></span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>明确base case，就是 dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, vector&lt;<span class="type">int</span>&gt;&amp; wt, vector&lt;<span class="type">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case 已初始化</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这种情况下只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子集背包问题"><a href="#子集背包问题" class="headerlink" title="子集背包问题"></a>子集背包问题</h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<ol>
<li><p>明确「状态」和「选择」，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p>
</li>
<li><p>明确dp数组的定义，dp[i][j] = x表示：对于前i个物品，当前背包的容量为j时，若x为true，则说明可以恰好将背包装满，若x为false，则说明不能恰好将背包装满。根据这个定义，我们想求的最终答案就是dp[N][sum/2]。</p>
</li>
<li><p>base case 就是dp[..][0] = true和dp[0][..] = false，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        sum += num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和为奇数时，不可能划分成两个和相等的集合</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(sum + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">               <span class="comment">// 背包容量不足，不能装入第 i 个物品</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或不装入背包</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到dp[i][j]都是通过上一行dp[i-1][..]转移过来的，之前的数据都不会再使用了。所以可以进行状态压缩，将二维dp数组压缩为一维，节约空间复杂度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        sum += num;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = sum; j &gt;= <span class="number">0</span>; j--) </span><br><span class="line">            <span class="keyword">if</span> (j - nums[i] &gt;= <span class="number">0</span>) </span><br><span class="line">                dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>有一个背包，最大容量为amount，有一系列物品coins，每个物品的重量为coins[i]，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？</p>
<ol>
<li><p>明确「状态」和「选择」，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p>
</li>
<li><p>明确 dp[i][j]数组的定义：若只使用前i个物品，当背包容量为j时，有dp[i][j]种方法可以装满背包。</p>
</li>
<li><p>base case 为dp[0][..] = 0， dp[..][0] = 1。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么不用装就满了。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= coins[i<span class="number">-1</span>])</span><br><span class="line">                <span class="comment">//把这第i个物品装入背包，装入第i种商品后还可以再继续装入第i种商品。</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i<span class="number">-1</span>]]; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">//不把这第i个物品装入背包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察可以发现，dp数组的转移只和dp[i][..]和dp[i-1][..]有关，所以可以压缩状态，进一步降低算法的空间复杂度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="type">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">            <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[j] = dp[j] + dp[j-coins[i]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>二维数据作函数参数</title>
    <url>/2022/06/07/c/array-as-function-param/</url>
    <content><![CDATA[<h2 id="二维数组作为函数参数"><a href="#二维数组作为函数参数" class="headerlink" title="二维数组作为函数参数"></a>二维数组作为函数参数</h2><p><strong>1. 二维数组在栈上分配，二维数组作为参数</strong></p>
<p>在栈上分配的二维数组，其各行地址空间是连续的，可以看作是一行排列的一维数组。其中二维数组的行数是可以省略的，所以也需要将行数作为参数传递。数组作为函数参数，其实传递的是指针，sizeof一下就知道了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">char</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">char</span> <span class="built_in">array</span>[][<span class="number">3</span>], <span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> array1[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125; &#125;;</span><br><span class="line">    func1(array1);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> array2[][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125; &#125;;</span><br><span class="line">    func2(array2, (<span class="keyword">sizeof</span>(array2) / <span class="keyword">sizeof</span>(array2[<span class="number">0</span>][<span class="number">0</span>]) / <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 二维数组在栈上分配，指向一维数组的指针作为参数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">(<span class="type">char</span> (*<span class="built_in">array</span>)[<span class="number">3</span>], <span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> array1[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125; &#125;;</span><br><span class="line">    <span class="type">char</span> (*array3)[<span class="number">3</span>] = &amp;array1[<span class="number">0</span>];</span><br><span class="line">    func3(array3, (<span class="keyword">sizeof</span>(array1) / <span class="keyword">sizeof</span>(array1[<span class="number">0</span>][<span class="number">0</span>]) / <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 二维数组在栈上分配，指向数组类型的指针作为参数</strong></p>
<p>需要将二维数组的首元素地址、行数、列数参数传入函数，通过加减指针再解引用来获取二维数组的値。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func4</span><span class="params">(<span class="type">char</span> *<span class="built_in">array</span>, <span class="type">int</span> N, <span class="type">int</span> M)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(<span class="built_in">array</span> + i * M + j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i * M + j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> array1[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125; &#125;;</span><br><span class="line">    <span class="type">char</span> *array4 = &amp;array1[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    func4(array4, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 二维数组在栈上分配，指向数组类型的指针的指针作为参数</strong></p>
<p>因为可以当成一维数组来看，所以p[0][n]这样的取値方式也是可以的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func5</span><span class="params">(<span class="type">char</span> **<span class="built_in">array</span>, <span class="type">int</span> N, <span class="type">int</span> M)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = *<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">char</span> *tmp = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        tmp = p + i * M;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tmp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>][i * M + j]);</span><br><span class="line">            <span class="comment">// printf(&quot;%d &quot;, *(*array + i * M + j));  // also</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> array1[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125; &#125;;</span><br><span class="line">    <span class="type">char</span> *array4 = &amp;array1[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">char</span> **array5 = &amp;array4;</span><br><span class="line">    func5(array5, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 在堆上分配二维数组，指向数组类型的指针的指针作为参数</strong></p>
<p>在堆上分配的二维数组，各行地址空间不一定连续，但内存是固定的，可以使用p[n][m]这样方式取数组值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">oid <span class="title function_">func6</span><span class="params">(<span class="type">char</span> **<span class="built_in">array</span>, <span class="type">int</span> N, <span class="type">int</span> M)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*(<span class="built_in">array</span> + i) + j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> **array6 = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">char</span> *));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        array6[i] = (<span class="type">char</span> *)<span class="built_in">malloc</span>(i * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            array6[i][j] = i * <span class="number">3</span> + j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func6(array6, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 在堆上分配一维数组当作二维数组，指向数组类型的指针的指针作为参数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func7</span><span class="params">(<span class="type">char</span> **<span class="built_in">array</span>, <span class="type">int</span> N, <span class="type">int</span> M)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*<span class="built_in">array</span> + i*M + j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>][i * M + j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *array7 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            array7[i * <span class="number">3</span> + j] = i * <span class="number">3</span> + j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func7(&amp;array7, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2022/09/24/algo/tree/</url>
    <content><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>树是 n (n &gt;= 0)个节点的有限集合，当n = 0 时称为空树，在任意一棵非空树中都应满足：</p>
<ol>
<li>有且仅有一个根节点。</li>
<li>当 n &gt; 1 时，其余节点可分为 m ( m &gt; 0)个互不相交的有限集合T1,T2,T3, …. Tm ，其中每一个集合本身又是一棵树。</li>
</ol>
<ul>
<li><p>父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点</p>
</li>
<li><p>子节点：一个节点含有的子树的根节点称为该节点的子节点</p>
</li>
<li><p>叶子节点：度为零的节点</p>
</li>
<li><p>兄弟节点：拥有共同父节点的节点</p>
</li>
<li><p>祖先：对任意节点x，从根节点到节点x的所有节点都是x的祖先（节点x也是自己的祖先）</p>
</li>
<li><p>后代：对任意节点x，从节点x到叶子节点的所有节点都是x的后代（节点x也是自己的后代）</p>
</li>
<li><p>森林：m颗互不相交的树构成的集合就是森林</p>
</li>
<li><p>节点深度：根节点到这个节点所经历的边的个数，从根结点开始向下度量。</p>
</li>
<li><p>节点高度：节点到根节点的最长路径(边数)</p>
</li>
<li><p>节点的层次：从根结点开始向下度量，计数起点为1。</p>
</li>
<li><p>树的深度：一棵树中节点的最大深度</p>
</li>
<li><p>度：节点的子树数目</p>
</li>
</ul>
<p><img src="/images/code/algo/tree/tree.png" alt="树定义"></p>
<p>二叉树是n（n&gt;=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>
<p>二叉树是树的一种，特点是每个节点最多有两个子节点，分别是左子节点和右子节点，有的只有左子节点，有的只有右子节点。</p>
<ul>
<li>每个节点最多有两个子节点，度小于2。</li>
<li>二叉树的第i层上至多有2^i-1^个节点(i&gt;=1)。</li>
<li>深度为k的二叉树至多有2^k^-1个节点(k&gt;=1)。</li>
<li>对任何一棵二叉树，如果其终端节点数为n<del>0</del>，度为2的节点数为n<del>2</del>，则n<del>0</del> = n<del>2</del> + 1。</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><strong>链式存储法</strong>：每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。从根节点开始可以通过左右子节点的指针，把整棵树都串起来。</p>
<p><img src="/images/code/algo/tree/list.png" alt="链式存储"></p>
<p><strong>数组顺序存储法</strong>：把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置，以此类推。</p>
<p><img src="/images/code/algo/tree/array.png" alt="顺序存储"></p>
<p>如果节点 X 存储在数组中下标为 i 的位置，左子节点的下标为 2 * i ，右子节点的下标为 2 * i + 1。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），就可以通过下标计算，把整棵树都串起来。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>二叉树遍历过程中每个节点最多会被访问两次，所以遍历操作的时间复杂度跟节点的个数 n 成正比，二叉树遍历的时间复杂度是 O(n)。</p>
<p><img src="/images/code/algo/tree/foreach.png" alt="二叉树的遍历"></p>
<ul>
<li><p>前序遍历规则是若树为空，则空操作返回，否则先访问根节点，然后依次访问的左子树和右子树。</p>
</li>
<li><p>中序遍历规则是若树为空，则空操作返回，否则从根节点开始，先遍历根节点的左子树，然后访问根节点，最后访问右子树。</p>
</li>
<li><p>后序遍历规则是若树为空，则空操作返回，否则从左到右先叶子后节点的方式遍历访问左右子树，最后访问根节点。</p>
</li>
<li><p>层序遍历规则是若树为空，则空操作返回，否则从根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对节点逐个访问。</p>
</li>
</ul>
<p><img src="/images/code/algo/tree/foreach2.png" alt="层序遍历"></p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;date);</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Preorder_DFS</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; tree;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        tree.<span class="built_in">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!tree.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *node = tree.<span class="built_in">top</span>();</span><br><span class="line">        tree.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;date);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tree.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tree.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Inorder(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    if (root == nullptr) &#123;</span><br><span class="line">        printf(&quot;x &quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Inorder(root-&gt;left);</span><br><span class="line">    printf(&quot;%d &quot;, root-&gt;date);</span><br><span class="line">    Inorder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Postorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">Postorder</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Levelorder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; tree;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        tree.<span class="built_in">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!tree.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *node = tree.<span class="built_in">front</span>();</span><br><span class="line">        tree.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;date);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tree.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tree.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>叶子节点全都在同一层，并且除了叶子节点之外，每个节点都有左右两个子节点的二叉树。</p>
<p><img src="/images/code/algo/tree/fulltree.png" alt="满二叉树"></p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大（构成满二叉树）。</p>
<p><img src="/images/code/algo/tree/alltree.png" alt="完全二叉树"></p>
<ul>
<li><p>叶子节点只能出现在最下两层。</p>
</li>
<li><p>最下层的叶子一定集中在左部连续位置。</p>
</li>
<li><p>倒数二层，若有叶子节点，一定都在右部连续位置。</p>
</li>
<li><p>如果节点度数为1,则该节点只有左子树，即不存在只有右子树的情况。</p>
</li>
<li><p>同样节点数的二叉树，完全二叉树的深度最小。</p>
</li>
<li><p>具有n个结点的完全二叉树的深度为不大于log2^n^的最大整数 + 1 。</p>
</li>
<li><p>对一棵有n个结点的完全二叉树的结点按层序编号（从第一层到最后一层，每层从左到右），对任一结点i（1&lt;=i&lt;=n）有：</p>
</li>
</ul>
<ol>
<li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点 ⌊ i/2 ⌋ 。</li>
<li>如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i 。</li>
<li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1 。</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>c语言数据类型</title>
    <url>/2022/06/07/c/datatype/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Data Type</th>
<th align="center">ILP32</th>
<th align="center">LP32</th>
<th align="center">ILP64</th>
<th align="center">LP64</th>
<th align="center">LLP64</th>
</tr>
</thead>
<tbody><tr>
<td align="center">宏定义</td>
<td align="center">_</td>
<td align="center">_</td>
<td align="center">_</td>
<td align="center"><strong>LP64</strong></td>
<td align="center"><strong>LLP64</strong></td>
</tr>
<tr>
<td align="center">平台</td>
<td align="center">Win32 API  / Unix 和 Unix 类的系统 （Linux，Mac OS X）</td>
<td align="center">Win16 API</td>
<td align="center"></td>
<td align="center">Unix 和 Unix 类的系统 （Linux，Mac OS X)</td>
<td align="center">Win64 API</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32</td>
<td align="center">16</td>
<td align="center">64</td>
<td align="center">32</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">pointer</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">32</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">64</td>
<td align="center"></td>
</tr>
</tbody></table>
<ol>
<li>格式化打印，long使用%ld或%lx，指针使用%p</li>
<li>对于long类型，常量要加L，如：long a = 1L&lt;&lt;32</li>
<li>ssize_t在32位机器上等同与int，在64位机器上等同与long，size_t是无符号型的ssize_t。</li>
<li>指针大小在32位机器上是4字节，64位是8字节。指针p+1 = p + sizeof(p指向的数据类型)。</li>
<li>int, short, long都是signed的，char可能是signed的，也可能是unsigned的，由编译器决定，一般x86上是有符号，arm上是无符号的。</li>
</ol>
<p>stdint.h 里定义了一些数据类型的别名和范围。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span>    <span class="type">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span>      <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>            <span class="type">int32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span>       <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>    <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>        <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>   <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>         <span class="type">uint32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>   <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>  <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span>            <span class="type">intptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>   <span class="type">uintptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>                 <span class="type">intptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>        <span class="type">uintptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT8_MIN        (-128)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT16_MIN       (-32767-1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT32_MIN       (-2147483647-1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT64_MIN       (-__INT64_C(9223372036854775807)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT8_MAX        (127)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT16_MAX       (32767)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT32_MAX       (2147483647)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT64_MAX       (__INT64_C(9223372036854775807))</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT8_MAX        (255)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT16_MAX       (65535)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT32_MAX       (4294967295U)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT64_MAX       (__UINT64_C(18446744073709551615))</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>字符编码</title>
    <url>/2022/06/07/c/char-encode/</url>
    <content><![CDATA[<p>中文编码有ASCII，GB2312，GBK和GB18030编码。兼容性关系是GB18030兼容GBK，GBK兼容GB2312，GB2312兼容ASCII。</p>
<p><img src="/images/code/char_code.jpg" alt="字符编码"></p>
<p>从图中我们可以一目了然地看到为什么GB18030可以兼容GBK，GB2312和ASCII了。他们几种编码之间前两位没有重合部分。需要注意的是ASCII只有1byte，所以是没有第二位的。另外GB18030在上图中占的面积虽然很小，但是它是4bytes编码，这图只展示了前两位。如果后两位也算上，GB18030的字数要远多于GBK。由于GBK兼容GB2312，因此属于GB2312的蓝色区域其实也可以算作是GBK的区域。同理GBK的区域理论上也属于GB18030的区域。上表中只是展示了多出来的部分。</p>
<h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>ASCII每个字符占据1bytes，用二进制表示的话最高位必须为0（扩展的ASCII不在考虑范围内），因此ASCII只能表示128个字。</p>
<table class="toolTable table" width="100%" cellspacing="0" cellpadding="0">
                <tr>
                    <th class="separateColor">ASCII值</th>
                    <th>控制字符</th>
                    <th class="separateColor">ASCII值</th>
                    <th>控制字符</th>
                    <th class="separateColor">ASCII值</th>
                    <th>控制字符</th>
                    <th class="separateColor">ASCII值</th>
                    <th>控制字符</th>
                </tr>
                <tr>
                    <td class="separateColor">0</td>
                    <td>NUT</td>
                    <td class="separateColor">32</td>
                    <td>space</td>
                    <td class="separateColor">64</td>
                    <td>@</td>
                    <td class="separateColor">96</td>
                    <td>、</td>
                </tr>
                <tr>
                    <td class="separateColor">1</td>
                    <td>SOH</td>
                    <td class="separateColor">33</td>
                    <td>!</td>
                    <td class="separateColor">65</td>
                    <td>A</td>
                    <td class="separateColor">97</td>
                    <td>a</td>
                </tr>
                <tr>
                    <td class="separateColor">2</td>
                    <td>STX</td>
                    <td class="separateColor">34</td>
                    <td>"</td>
                    <td class="separateColor">66</td>
                    <td>B</td>
                    <td class="separateColor">98</td>
                    <td>b</td>
                </tr>
                <tr>
                    <td class="separateColor">3</td>
                    <td>ETX</td>
                    <td class="separateColor">35</td>
                    <td>#</td>
                    <td class="separateColor">67</td>
                    <td>C</td>
                    <td class="separateColor">99</td>
                    <td>c</td>
                </tr>
                <tr>
                    <td class="separateColor">4</td>
                    <td>EOT</td>
                    <td class="separateColor">36</td>
                    <td>$</td>
                    <td class="separateColor">68</td>
                    <td>D</td>
                    <td class="separateColor">100</td>
                    <td>d</td>
                </tr>
                <tr>
                    <td class="separateColor">5</td>
                    <td>ENQ</td>
                    <td class="separateColor">37</td>
                    <td>%</td>
                    <td class="separateColor">69</td>
                    <td>E</td>
                    <td class="separateColor">101</td>
                    <td>e</td>
                </tr>
                <tr>
                    <td class="separateColor">6</td>
                    <td>ACK</td>
                    <td class="separateColor">38</td>
                    <td>&</td>
                    <td class="separateColor">70</td>
                    <td>F</td>
                    <td class="separateColor">102</td>
                    <td>f</td>
                </tr>
                <tr>
                    <td class="separateColor">7</td>
                    <td>BEL</td>
                    <td class="separateColor">39</td>
                    <td>,</td>
                    <td class="separateColor">71</td>
                    <td>G</td>
                    <td class="separateColor">103</td>
                    <td>g</td>
                </tr>
                <tr>
                    <td class="separateColor">8</td>
                    <td>BS</td>
                    <td class="separateColor">40</td>
                    <td>(</td>
                    <td class="separateColor">72</td>
                    <td>H</td>
                    <td class="separateColor">104</td>
                    <td>h</td>
                </tr>
                <tr>
                    <td class="separateColor">9</td>
                    <td>HT</td>
                    <td class="separateColor">41</td>
                    <td>)</td>
                    <td class="separateColor">73</td>
                    <td>I</td>
                    <td class="separateColor">105</td>
                    <td>i</td>
                </tr>
                <tr>
                    <td class="separateColor">10</td>
                    <td>LF</td>
                    <td class="separateColor">42</td>
                    <td>*</td>
                    <td class="separateColor">74</td>
                    <td>J</td>
                    <td class="separateColor">106</td>
                    <td>j</td>
                </tr>
                <tr>
                    <td class="separateColor">11</td>
                    <td>VT</td>
                    <td class="separateColor">43</td>
                    <td>+</td>
                    <td class="separateColor">75</td>
                    <td>K</td>
                    <td class="separateColor">107</td>
                    <td>k</td>
                </tr>
                <tr>
                    <td class="separateColor">12</td>
                    <td>FF</td>
                    <td class="separateColor">44</td>
                    <td>,</td>
                    <td class="separateColor">76</td>
                    <td>L</td>
                    <td class="separateColor">108</td>
                    <td>l</td>
                </tr>
                <tr>
                    <td class="separateColor">13</td>
                    <td>CR</td>
                    <td class="separateColor">45</td>
                    <td>-</td>
                    <td class="separateColor">77</td>
                    <td>M</td>
                    <td class="separateColor">109</td>
                    <td>m</td>
                </tr>
                <tr>
                    <td class="separateColor">14</td>
                    <td>SO</td>
                    <td class="separateColor">46</td>
                    <td>.</td>
                    <td class="separateColor">78</td>
                    <td>N</td>
                    <td class="separateColor">110</td>
                    <td>n</td>
                </tr>
                <tr>
                    <td class="separateColor">15</td>
                    <td>SI</td>
                    <td class="separateColor">47</td>
                    <td>/</td>
                    <td class="separateColor">79</td>
                    <td>O</td>
                    <td class="separateColor">111</td>
                    <td>o</td>
                </tr>
                <tr>
                    <td class="separateColor">16</td>
                    <td>DLE</td>
                    <td class="separateColor">48</td>
                    <td>0</td>
                    <td class="separateColor">80</td>
                    <td>P</td>
                    <td class="separateColor">112</td>
                    <td>p</td>
                </tr>
                <tr>
                    <td class="separateColor">17</td>
                    <td>DCI</td>
                    <td class="separateColor">49</td>
                    <td>1</td>
                    <td class="separateColor">81</td>
                    <td>Q</td>
                    <td class="separateColor">113</td>
                    <td>q</td>
                </tr>
                <tr>
                    <td class="separateColor">18</td>
                    <td>DC2</td>
                    <td class="separateColor">50</td>
                    <td>2</td>
                    <td class="separateColor">82</td>
                    <td>R</td>
                    <td class="separateColor">114</td>
                    <td>r</td>
                </tr>
                <tr>
                    <td class="separateColor">19</td>
                    <td>DC3</td>
                    <td class="separateColor">51</td>
                    <td>3</td>
                    <td class="separateColor">83</td>
                    <td>S</td>
                    <td class="separateColor">115</td>
                    <td>s</td>
                </tr>
                <tr>
                    <td class="separateColor">20</td>
                    <td>DC4</td>
                    <td class="separateColor">52</td>
                    <td>4</td>
                    <td class="separateColor">84</td>
                    <td>T</td>
                    <td class="separateColor">116</td>
                    <td>t</td>
                </tr>
                <tr>
                    <td class="separateColor">21</td>
                    <td>NAK</td>
                    <td class="separateColor">53</td>
                    <td>5</td>
                    <td class="separateColor">85</td>
                    <td>U</td>
                    <td class="separateColor">117</td>
                    <td>u</td>
                </tr>
                <tr>
                    <td class="separateColor">22</td>
                    <td>SYN</td>
                    <td class="separateColor">54</td>
                    <td>6</td>
                    <td class="separateColor">86</td>
                    <td>V</td>
                    <td class="separateColor">118</td>
                    <td>v</td>
                </tr>
                <tr>
                    <td class="separateColor">23</td>
                    <td>TB</td>
                    <td class="separateColor">55</td>
                    <td>7</td>
                    <td class="separateColor">87</td>
                    <td>W</td>
                    <td class="separateColor">119</td>
                    <td>w</td>
                </tr>
                <tr>
                    <td class="separateColor">24</td>
                    <td>CAN</td>
                    <td class="separateColor">56</td>
                    <td>8</td>
                    <td class="separateColor">88</td>
                    <td>X</td>
                    <td class="separateColor">120</td>
                    <td>x</td>
                </tr>
                <tr>
                    <td class="separateColor">25</td>
                    <td>EM</td>
                    <td class="separateColor">57</td>
                    <td>9</td>
                    <td class="separateColor">89</td>
                    <td>Y</td>
                    <td class="separateColor">121</td>
                    <td>y</td>
                </tr>
                <tr>
                    <td class="separateColor">26</td>
                    <td>SUB</td>
                    <td class="separateColor">58</td>
                    <td>:</td>
                    <td class="separateColor">90</td>
                    <td>Z</td>
                    <td class="separateColor">122</td>
                    <td>z</td>
                </tr>
                <tr>
                    <td class="separateColor">27</td>
                    <td>ESC</td>
                    <td class="separateColor">59</td>
                    <td>;</td>
                    <td class="separateColor">91</td>
                    <td>[</td>    
                    <td class="separateColor">123</td>
                    <td>{</td>
                </tr>
                <tr>
                    <td class="separateColor">28</td>
                    <td>FS</td>
                    <td class="separateColor">60</td>
                    <td>&lt;</td>
                    <td class="separateColor">92</td>
                    <td>/</td>    
                    <td class="separateColor">124</td>
                    <td>|</td>
                </tr>
                <tr>
                    <td class="separateColor">29</td>
                    <td>GS</td>
                    <td class="separateColor">61</td>
                    <td>=</td>
                    <td class="separateColor">93</td>
                    <td>]</td>
                    <td class="separateColor">125</td>
                    <td>}</td>
                </tr>
                <tr>
                    <td class="separateColor">30</td>
                    <td>RS</td>
                    <td class="separateColor">62</td>
                    <td>></td>
                    <td class="separateColor">94</td>
                    <td>^</td>
                    <td class="separateColor">126</td>
                    <td>`</td>
                </tr>
                <tr>
                    <td class="separateColor">31</td>
                    <td>US</td>
                    <td class="separateColor">63</td>
                    <td>?</td>
                    <td class="separateColor">95</td>
                    <td>_</td>
                    <td class="separateColor">127</td>
                    <td>DEL</td>
                </tr>
            </table>

<p>​        </p>
<div class="toolUsing clearfix">
            <table class="toolTable" width="100%" cellspacing="0" cellpadding="0">
                <caption>特殊字符解释</caption>
                <tr>
                    <th>NUL空</th>
                    <th>VT 垂直制表</th>
                    <th>SYN 空转同步</th>
                </tr>
                <tr>
                    <td>STX  正文开始</td>
                    <td>CR   回车</td>
                    <td>CAN  作废</td>
                </tr>
                    <tr>
                    <td>ETX  正文结束</td>
                    <td>SO   移位输出</td>
                    <td>EM   纸尽</td>
                </tr>
                    <tr>
                    <td>EOY  传输结束</td>
                    <td>SI    移位输入</td>
                    <td>SUB  换置</td>
                </tr>
                    <tr>
                    <td>ENQ  询问字符</td>
                    <td>DLE  空格</td>
                    <td>ESC  换码</td>
                </tr>
                    <tr>
                    <td>ACK  承认</td>
                    <td>DC1  设备控制1</td>
                    <td>FS   文字分隔符</td>
                </tr>
                    <tr>
                    <td>BEL  报警</td>
                    <td>DC2  设备控制2</td>
                    <td>GS   组分隔符</td>
                </tr>
                    <tr>
                    <td>BS   退一格</td>
                    <td>DC3  设备控制3</td>
                    <td>RS   记录分隔符</td>
                </tr>
                    <tr>
                    <td>HT   横向列表</td>
                    <td>DC4  设备控制4</td>
                    <td>US   单元分隔符</td>
                </tr>
                    <tr>
                    <td>LF   换行</td>
                    <td>NAK  否定</td>
                    <td>DEL  删除</td>
                </tr>
            </table>
        </div>

<h2 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h2><p>GB2312每个字占据2bytes。由于要和ASCII兼容，这2bytes最高位不可为0。共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时，GB 2312收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。整个字符集分成94个区，每区有94个位。</p>
<ul>
<li>GB2312，又称为GB0，由中国国家标准总局发布，1981年5月1日实施</li>
<li>GB2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个</li>
<li>GB2312是一种区位码。分为94个区(01-94)，每区94个字符(01-94)</li>
<li>01-09区为特殊符号</li>
<li>10-15区没有编码</li>
<li>16-55区为一级汉字，按拼音排序，共3755个</li>
<li>56-87区为二级汉字，按部首／笔画排序，共3008个</li>
<li>88-94区没有编码</li>
<li>GB2312只是编码表，在计算机中通常都是用”EUC-CN”表示法，即在每个区位加上0xA0来表示。区和位分别占用一个字节。</li>
</ul>
<table><tbody><tr><th>第01区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>A1A0</th>
            <td> </td>
            <td> </td>
            <td>、</td>
            <td>。</td>
            <td>・</td>
            <td>ˉ</td>
            <td>ˇ</td>
            <td>¨</td>
            <td>〃</td>
            <td>々</td>
            <td>―</td>
            <td>～</td>
            <td>‖</td>
            <td>…</td>
            <td>‘</td>
            <td>’</td>
        </tr><tr><th>A1B0</th>
            <td>“</td>
            <td>”</td>
            <td>〔</td>
            <td>〕</td>
            <td>〈</td>
            <td>〉</td>
            <td>《</td>
            <td>》</td>
            <td>「</td>
            <td>」</td>
            <td>『</td>
            <td>』</td>
            <td>〖</td>
            <td>〗</td>
            <td>【</td>
            <td>】</td>
        </tr><tr><th>A1C0</th>
            <td>±</td>
            <td>×</td>
            <td>÷</td>
            <td>∶</td>
            <td>∧</td>
            <td>∨</td>
            <td>∑</td>
            <td>∏</td>
            <td>∪</td>
            <td>∩</td>
            <td>∈</td>
            <td>∷</td>
            <td>√</td>
            <td>⊥</td>
            <td>∥</td>
            <td>∠</td>
        </tr><tr><th>A1D0</th>
            <td>⌒</td>
            <td>⊙</td>
            <td>∫</td>
            <td>∮</td>
            <td>≡</td>
            <td>≌</td>
            <td>≈</td>
            <td>∽</td>
            <td>∝</td>
            <td>≠</td>
            <td>≮</td>
            <td>≯</td>
            <td>≤</td>
            <td>≥</td>
            <td>∞</td>
            <td>∵</td>
        </tr><tr><th>A1E0</th>
            <td>∴</td>
            <td>♂</td>
            <td>♀</td>
            <td>°</td>
            <td>′</td>
            <td>″</td>
            <td>℃</td>
            <td>＄</td>
            <td>¤</td>
            <td>￠</td>
            <td>￡</td>
            <td>‰</td>
            <td>§</td>
            <td>№</td>
            <td>☆</td>
            <td>★</td>
        </tr><tr><th>A1F0</th>
            <td>○</td>
            <td>●</td>
            <td>◎</td>
            <td>◇</td>
            <td>◆</td>
            <td>□</td>
            <td>■</td>
            <td>△</td>
            <td>▲</td>
            <td>※</td>
            <td>→</td>
            <td>←</td>
            <td>↑</td>
            <td>↓</td>
            <td>〓</td>
            <td> </td>
        </tr><tr><th>第02区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>A2A0</th>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>A2B0</th>
            <td> </td>
            <td>⒈</td>
            <td>⒉</td>
            <td>⒊</td>
            <td>⒋</td>
            <td>⒌</td>
            <td>⒍</td>
            <td>⒎</td>
            <td>⒏</td>
            <td>⒐</td>
            <td>⒑</td>
            <td>⒒</td>
            <td>⒓</td>
            <td>⒔</td>
            <td>⒕</td>
            <td>⒖</td>
        </tr><tr><th>A2C0</th>
            <td>⒗</td>
            <td>⒘</td>
            <td>⒙</td>
            <td>⒚</td>
            <td>⒛</td>
            <td>⑴</td>
            <td>⑵</td>
            <td>⑶</td>
            <td>⑷</td>
            <td>⑸</td>
            <td>⑹</td>
            <td>⑺</td>
            <td>⑻</td>
            <td>⑼</td>
            <td>⑽</td>
            <td>⑾</td>
        </tr><tr><th>A2D0</th>
            <td>⑿</td>
            <td>⒀</td>
            <td>⒁</td>
            <td>⒂</td>
            <td>⒃</td>
            <td>⒄</td>
            <td>⒅</td>
            <td>⒆</td>
            <td>⒇</td>
            <td>①</td>
            <td>②</td>
            <td>③</td>
            <td>④</td>
            <td>⑤</td>
            <td>⑥</td>
            <td>⑦</td>
        </tr><tr><th>A2E0</th>
            <td>⑧</td>
            <td>⑨</td>
            <td>⑩</td>
            <td> </td>
            <td> </td>
            <td>㈠</td>
            <td>㈡</td>
            <td>㈢</td>
            <td>㈣</td>
            <td>㈤</td>
            <td>㈥</td>
            <td>㈦</td>
            <td>㈧</td>
            <td>㈨</td>
            <td>㈩</td>
            <td> </td>
        </tr><tr><th>A2F0</th>
            <td> </td>
            <td>Ⅰ</td>
            <td>Ⅱ</td>
            <td>Ⅲ</td>
            <td>Ⅳ</td>
            <td>Ⅴ</td>
            <td>Ⅵ</td>
            <td>Ⅶ</td>
            <td>Ⅷ</td>
            <td>Ⅸ</td>
            <td>Ⅹ</td>
            <td>Ⅺ</td>
            <td>Ⅻ</td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>第03区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>A3A0</th>
            <td> </td>
            <td>！</td>
            <td>＂</td>
            <td>＃</td>
            <td>￥</td>
            <td>％</td>
            <td>＆</td>
            <td>＇</td>
            <td>（</td>
            <td>）</td>
            <td>＊</td>
            <td>＋</td>
            <td>，</td>
            <td>－</td>
            <td>．</td>
            <td>／</td>
        </tr><tr><th>A3B0</th>
            <td>０</td>
            <td>１</td>
            <td>２</td>
            <td>３</td>
            <td>４</td>
            <td>５</td>
            <td>６</td>
            <td>７</td>
            <td>８</td>
            <td>９</td>
            <td>：</td>
            <td>；</td>
            <td>＜</td>
            <td>＝</td>
            <td>＞</td>
            <td>？</td>
        </tr><tr><th>A3C0</th>
            <td>＠</td>
            <td>Ａ</td>
            <td>Ｂ</td>
            <td>Ｃ</td>
            <td>Ｄ</td>
            <td>Ｅ</td>
            <td>Ｆ</td>
            <td>Ｇ</td>
            <td>Ｈ</td>
            <td>Ｉ</td>
            <td>Ｊ</td>
            <td>Ｋ</td>
            <td>Ｌ</td>
            <td>Ｍ</td>
            <td>Ｎ</td>
            <td>Ｏ</td>
        </tr><tr><th>A3D0</th>
            <td>Ｐ</td>
            <td>Ｑ</td>
            <td>Ｒ</td>
            <td>Ｓ</td>
            <td>Ｔ</td>
            <td>Ｕ</td>
            <td>Ｖ</td>
            <td>Ｗ</td>
            <td>Ｘ</td>
            <td>Ｙ</td>
            <td>Ｚ</td>
            <td>［</td>
            <td>＼</td>
            <td>］</td>
            <td>＾</td>
            <td>＿</td>
        </tr><tr><th>A3E0</th>
            <td>｀</td>
            <td>ａ</td>
            <td>ｂ</td>
            <td>ｃ</td>
            <td>ｄ</td>
            <td>ｅ</td>
            <td>ｆ</td>
            <td>ｇ</td>
            <td>ｈ</td>
            <td>ｉ</td>
            <td>ｊ</td>
            <td>ｋ</td>
            <td>ｌ</td>
            <td>ｍ</td>
            <td>ｎ</td>
            <td>ｏ</td>
        </tr><tr><th>A3F0</th>
            <td>ｐ</td>
            <td>ｑ</td>
            <td>ｒ</td>
            <td>ｓ</td>
            <td>ｔ</td>
            <td>ｕ</td>
            <td>ｖ</td>
            <td>ｗ</td>
            <td>ｘ</td>
            <td>ｙ</td>
            <td>ｚ</td>
            <td>｛</td>
            <td>｜</td>
            <td>｝</td>
            <td>￣</td>
            <td> </td>
        </tr><tr><th>第04区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>A4A0</th>
            <td> </td>
            <td>ぁ</td>
            <td>あ</td>
            <td>ぃ</td>
            <td>い</td>
            <td>ぅ</td>
            <td>う</td>
            <td>ぇ</td>
            <td>え</td>
            <td>ぉ</td>
            <td>お</td>
            <td>か</td>
            <td>が</td>
            <td>き</td>
            <td>ぎ</td>
            <td>く</td>
        </tr><tr><th>A4B0</th>
            <td>ぐ</td>
            <td>け</td>
            <td>げ</td>
            <td>こ</td>
            <td>ご</td>
            <td>さ</td>
            <td>ざ</td>
            <td>し</td>
            <td>じ</td>
            <td>す</td>
            <td>ず</td>
            <td>せ</td>
            <td>ぜ</td>
            <td>そ</td>
            <td>ぞ</td>
            <td>た</td>
        </tr><tr><th>A4C0</th>
            <td>だ</td>
            <td>ち</td>
            <td>ぢ</td>
            <td>っ</td>
            <td>つ</td>
            <td>づ</td>
            <td>て</td>
            <td>で</td>
            <td>と</td>
            <td>ど</td>
            <td>な</td>
            <td>に</td>
            <td>ぬ</td>
            <td>ね</td>
            <td>の</td>
            <td>は</td>
        </tr><tr><th>A4D0</th>
            <td>ば</td>
            <td>ぱ</td>
            <td>ひ</td>
            <td>び</td>
            <td>ぴ</td>
            <td>ふ</td>
            <td>ぶ</td>
            <td>ぷ</td>
            <td>へ</td>
            <td>べ</td>
            <td>ぺ</td>
            <td>ほ</td>
            <td>ぼ</td>
            <td>ぽ</td>
            <td>ま</td>
            <td>み</td>
        </tr><tr><th>A4E0</th>
            <td>む</td>
            <td>め</td>
            <td>も</td>
            <td>ゃ</td>
            <td>や</td>
            <td>ゅ</td>
            <td>ゆ</td>
            <td>ょ</td>
            <td>よ</td>
            <td>ら</td>
            <td>り</td>
            <td>る</td>
            <td>れ</td>
            <td>ろ</td>
            <td>ゎ</td>
            <td>わ</td>
        </tr><tr><th>A4F0</th>
            <td>ゐ</td>
            <td>ゑ</td>
            <td>を</td>
            <td>ん</td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>第05区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>A5A0</th>
            <td> </td>
            <td>ァ</td>
            <td>ア</td>
            <td>ィ</td>
            <td>イ</td>
            <td>ゥ</td>
            <td>ウ</td>
            <td>ェ</td>
            <td>エ</td>
            <td>ォ</td>
            <td>オ</td>
            <td>カ</td>
            <td>ガ</td>
            <td>キ</td>
            <td>ギ</td>
            <td>ク</td>
        </tr><tr><th>A5B0</th>
            <td>グ</td>
            <td>ケ</td>
            <td>ゲ</td>
            <td>コ</td>
            <td>ゴ</td>
            <td>サ</td>
            <td>ザ</td>
            <td>シ</td>
            <td>ジ</td>
            <td>ス</td>
            <td>ズ</td>
            <td>セ</td>
            <td>ゼ</td>
            <td>ソ</td>
            <td>ゾ</td>
            <td>タ</td>
        </tr><tr><th>A5C0</th>
            <td>ダ</td>
            <td>チ</td>
            <td>ヂ</td>
            <td>ッ</td>
            <td>ツ</td>
            <td>ヅ</td>
            <td>テ</td>
            <td>デ</td>
            <td>ト</td>
            <td>ド</td>
            <td>ナ</td>
            <td>ニ</td>
            <td>ヌ</td>
            <td>ネ</td>
            <td>ノ</td>
            <td>ハ</td>
        </tr><tr><th>A5D0</th>
            <td>バ</td>
            <td>パ</td>
            <td>ヒ</td>
            <td>ビ</td>
            <td>ピ</td>
            <td>フ</td>
            <td>ブ</td>
            <td>プ</td>
            <td>ヘ</td>
            <td>ベ</td>
            <td>ペ</td>
            <td>ホ</td>
            <td>ボ</td>
            <td>ポ</td>
            <td>マ</td>
            <td>ミ</td>
        </tr><tr><th>A5E0</th>
            <td>ム</td>
            <td>メ</td>
            <td>モ</td>
            <td>ャ</td>
            <td>ヤ</td>
            <td>ュ</td>
            <td>ユ</td>
            <td>ョ</td>
            <td>ヨ</td>
            <td>ラ</td>
            <td>リ</td>
            <td>ル</td>
            <td>レ</td>
            <td>ロ</td>
            <td>ヮ</td>
            <td>ワ</td>
        </tr><tr><th>A5F0</th>
            <td>ヰ</td>
            <td>ヱ</td>
            <td>ヲ</td>
            <td>ン</td>
            <td>ヴ</td>
            <td>ヵ</td>
            <td>ヶ</td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>第06区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>A6A0</th>
            <td> </td>
            <td>Α</td>
            <td>Β</td>
            <td>Γ</td>
            <td>Δ</td>
            <td>Ε</td>
            <td>Ζ</td>
            <td>Η</td>
            <td>Θ</td>
            <td>Ι</td>
            <td>Κ</td>
            <td>Λ</td>
            <td>Μ</td>
            <td>Ν</td>
            <td>Ξ</td>
            <td>Ο</td>
        </tr><tr><th>A6B0</th>
            <td>Π</td>
            <td>Ρ</td>
            <td>Σ</td>
            <td>Τ</td>
            <td>Υ</td>
            <td>Φ</td>
            <td>Χ</td>
            <td>Ψ</td>
            <td>Ω</td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>A6C0</th>
            <td> </td>
            <td>α</td>
            <td>β</td>
            <td>γ</td>
            <td>δ</td>
            <td>ε</td>
            <td>ζ</td>
            <td>η</td>
            <td>θ</td>
            <td>ι</td>
            <td>κ</td>
            <td>λ</td>
            <td>μ</td>
            <td>ν</td>
            <td>ξ</td>
            <td>ο</td>
        </tr><tr><th>A6D0</th>
            <td>π</td>
            <td>ρ</td>
            <td>σ</td>
            <td>τ</td>
            <td>υ</td>
            <td>φ</td>
            <td>χ</td>
            <td>ψ</td>
            <td>ω</td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>A6E0</th>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>A6F0</th>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>第07区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>A7A0</th>
            <td> </td>
            <td>А</td>
            <td>Б</td>
            <td>В</td>
            <td>Г</td>
            <td>Д</td>
            <td>Е</td>
            <td>Ё</td>
            <td>Ж</td>
            <td>З</td>
            <td>И</td>
            <td>Й</td>
            <td>К</td>
            <td>Л</td>
            <td>М</td>
            <td>Н</td>
        </tr><tr><th>A7B0</th>
            <td>О</td>
            <td>П</td>
            <td>Р</td>
            <td>С</td>
            <td>Т</td>
            <td>У</td>
            <td>Ф</td>
            <td>Х</td>
            <td>Ц</td>
            <td>Ч</td>
            <td>Ш</td>
            <td>Щ</td>
            <td>Ъ</td>
            <td>Ы</td>
            <td>Ь</td>
            <td>Э</td>
        </tr><tr><th>A7C0</th>
            <td>Ю</td>
            <td>Я</td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>A7D0</th>
            <td> </td>
            <td>а</td>
            <td>б</td>
            <td>в</td>
            <td>г</td>
            <td>д</td>
            <td>е</td>
            <td>ё</td>
            <td>ж</td>
            <td>з</td>
            <td>и</td>
            <td>й</td>
            <td>к</td>
            <td>л</td>
            <td>м</td>
            <td>н</td>
        </tr><tr><th>A7E0</th>
            <td>о</td>
            <td>п</td>
            <td>р</td>
            <td>с</td>
            <td>т</td>
            <td>у</td>
            <td>ф</td>
            <td>х</td>
            <td>ц</td>
            <td>ч</td>
            <td>ш</td>
            <td>щ</td>
            <td>ъ</td>
            <td>ы</td>
            <td>ь</td>
            <td>э</td>
        </tr><tr><th>A7F0</th>
            <td>ю</td>
            <td>я</td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>第08区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>A8A0</th>
            <td> </td>
            <td>ā</td>
            <td>á</td>
            <td>ǎ</td>
            <td>à</td>
            <td>ē</td>
            <td>é</td>
            <td>ě</td>
            <td>è</td>
            <td>ī</td>
            <td>í</td>
            <td>ǐ</td>
            <td>ì</td>
            <td>ō</td>
            <td>ó</td>
            <td>ǒ</td>
        </tr><tr><th>A8B0</th>
            <td>ò</td>
            <td>ū</td>
            <td>ú</td>
            <td>ǔ</td>
            <td>ù</td>
            <td>ǖ</td>
            <td>ǘ</td>
            <td>ǚ</td>
            <td>ǜ</td>
            <td>ü</td>
            <td>ê</td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>A8C0</th>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td>ㄅ</td>
            <td>ㄆ</td>
            <td>ㄇ</td>
            <td>ㄈ</td>
            <td>ㄉ</td>
            <td>ㄊ</td>
            <td>ㄋ</td>
            <td>ㄌ</td>
            <td>ㄍ</td>
            <td>ㄎ</td>
            <td>ㄏ</td>
        </tr><tr><th>A8D0</th>
            <td>ㄐ</td>
            <td>ㄑ</td>
            <td>ㄒ</td>
            <td>ㄓ</td>
            <td>ㄔ</td>
            <td>ㄕ</td>
            <td>ㄖ</td>
            <td>ㄗ</td>
            <td>ㄘ</td>
            <td>ㄙ</td>
            <td>ㄚ</td>
            <td>ㄛ</td>
            <td>ㄜ</td>
            <td>ㄝ</td>
            <td>ㄞ</td>
            <td>ㄟ</td>
        </tr><tr><th>A8E0</th>
            <td>ㄠ</td>
            <td>ㄡ</td>
            <td>ㄢ</td>
            <td>ㄣ</td>
            <td>ㄤ</td>
            <td>ㄥ</td>
            <td>ㄦ</td>
            <td>ㄧ</td>
            <td>ㄨ</td>
            <td>ㄩ</td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>A8F0</th>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>第09区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>A9A0</th>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td>─</td>
            <td>━</td>
            <td>│</td>
            <td>┃</td>
            <td>┄</td>
            <td>┅</td>
            <td>┆</td>
            <td>┇</td>
            <td>┈</td>
            <td>┉</td>
            <td>┊</td>
            <td>┋</td>
        </tr><tr><th>A9B0</th>
            <td>┌</td>
            <td>┍</td>
            <td>┎</td>
            <td>┏</td>
            <td>┐</td>
            <td>┑</td>
            <td>┒</td>
            <td>┓</td>
            <td>└</td>
            <td>┕</td>
            <td>┖</td>
            <td>┗</td>
            <td>┘</td>
            <td>┙</td>
            <td>┚</td>
            <td>┛</td>
        </tr><tr><th>A9C0</th>
            <td>├</td>
            <td>┝</td>
            <td>┞</td>
            <td>┟</td>
            <td>┠</td>
            <td>┡</td>
            <td>┢</td>
            <td>┣</td>
            <td>┤</td>
            <td>┥</td>
            <td>┦</td>
            <td>┧</td>
            <td>┨</td>
            <td>┩</td>
            <td>┪</td>
            <td>┫</td>
        </tr><tr><th>A9D0</th>
            <td>┬</td>
            <td>┭</td>
            <td>┮</td>
            <td>┯</td>
            <td>┰</td>
            <td>┱</td>
            <td>┲</td>
            <td>┳</td>
            <td>┴</td>
            <td>┵</td>
            <td>┶</td>
            <td>┷</td>
            <td>┸</td>
            <td>┹</td>
            <td>┺</td>
            <td>┻</td>
        </tr><tr><th>A9E0</th>
            <td>┼</td>
            <td>┽</td>
            <td>┾</td>
            <td>┿</td>
            <td>╀</td>
            <td>╁</td>
            <td>╂</td>
            <td>╃</td>
            <td>╄</td>
            <td>╅</td>
            <td>╆</td>
            <td>╇</td>
            <td>╈</td>
            <td>╉</td>
            <td>╊</td>
            <td>╋</td>
        </tr><tr><th>A9F0</th>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>第10区</th>
            <th>AAA0-AAFF</th>
            <td>没有编码</td>
        </tr><tr><th>第11区</th>
            <th>ABA0-ABFF</th>
            <td>没有编码</td>
        </tr><tr><th>第12区</th>
            <th>ACA0-ACFF</th>
            <td>没有编码</td>
        </tr><tr><th>第13区</th>
            <th>ADA0-ADFF</th>
            <td>没有编码</td>
        </tr><tr><th>第14区</th>
            <th>AEA0-AEFF</th>
            <td>没有编码</td>
        </tr><tr><th>第15区</th>
            <th>AFA0-AFFF</th>
            <td>没有编码</td>
        </tr><tr><th>第16区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>B0A0</th>
            <td> </td>
            <td>啊</td>
            <td>阿</td>
            <td>埃</td>
            <td>挨</td>
            <td>哎</td>
            <td>唉</td>
            <td>哀</td>
            <td>皑</td>
            <td>癌</td>
            <td>蔼</td>
            <td>矮</td>
            <td>艾</td>
            <td>碍</td>
            <td>爱</td>
            <td>隘</td>
        </tr><tr><th>B0B0</th>
            <td>鞍</td>
            <td>氨</td>
            <td>安</td>
            <td>俺</td>
            <td>按</td>
            <td>暗</td>
            <td>岸</td>
            <td>胺</td>
            <td>案</td>
            <td>肮</td>
            <td>昂</td>
            <td>盎</td>
            <td>凹</td>
            <td>敖</td>
            <td>熬</td>
            <td>翱</td>
        </tr><tr><th>B0C0</th>
            <td>袄</td>
            <td>傲</td>
            <td>奥</td>
            <td>懊</td>
            <td>澳</td>
            <td>芭</td>
            <td>捌</td>
            <td>扒</td>
            <td>叭</td>
            <td>吧</td>
            <td>笆</td>
            <td>八</td>
            <td>疤</td>
            <td>巴</td>
            <td>拔</td>
            <td>跋</td>
        </tr><tr><th>B0D0</th>
            <td>靶</td>
            <td>把</td>
            <td>耙</td>
            <td>坝</td>
            <td>霸</td>
            <td>罢</td>
            <td>爸</td>
            <td>白</td>
            <td>柏</td>
            <td>百</td>
            <td>摆</td>
            <td>佰</td>
            <td>败</td>
            <td>拜</td>
            <td>稗</td>
            <td>斑</td>
        </tr><tr><th>B0E0</th>
            <td>班</td>
            <td>搬</td>
            <td>扳</td>
            <td>般</td>
            <td>颁</td>
            <td>板</td>
            <td>版</td>
            <td>扮</td>
            <td>拌</td>
            <td>伴</td>
            <td>瓣</td>
            <td>半</td>
            <td>办</td>
            <td>绊</td>
            <td>邦</td>
            <td>帮</td>
        </tr><tr><th>B0F0</th>
            <td>梆</td>
            <td>榜</td>
            <td>膀</td>
            <td>绑</td>
            <td>棒</td>
            <td>磅</td>
            <td>蚌</td>
            <td>镑</td>
            <td>傍</td>
            <td>谤</td>
            <td>苞</td>
            <td>胞</td>
            <td>包</td>
            <td>褒</td>
            <td>剥</td>
            <td> </td>
        </tr><tr><th>第17区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>B1A0</th>
            <td> </td>
            <td>薄</td>
            <td>雹</td>
            <td>保</td>
            <td>堡</td>
            <td>饱</td>
            <td>宝</td>
            <td>抱</td>
            <td>报</td>
            <td>暴</td>
            <td>豹</td>
            <td>鲍</td>
            <td>爆</td>
            <td>杯</td>
            <td>碑</td>
            <td>悲</td>
        </tr><tr><th>B1B0</th>
            <td>卑</td>
            <td>北</td>
            <td>辈</td>
            <td>背</td>
            <td>贝</td>
            <td>钡</td>
            <td>倍</td>
            <td>狈</td>
            <td>备</td>
            <td>惫</td>
            <td>焙</td>
            <td>被</td>
            <td>奔</td>
            <td>苯</td>
            <td>本</td>
            <td>笨</td>
        </tr><tr><th>B1C0</th>
            <td>崩</td>
            <td>绷</td>
            <td>甭</td>
            <td>泵</td>
            <td>蹦</td>
            <td>迸</td>
            <td>逼</td>
            <td>鼻</td>
            <td>比</td>
            <td>鄙</td>
            <td>笔</td>
            <td>彼</td>
            <td>碧</td>
            <td>蓖</td>
            <td>蔽</td>
            <td>毕</td>
        </tr><tr><th>B1D0</th>
            <td>毙</td>
            <td>毖</td>
            <td>币</td>
            <td>庇</td>
            <td>痹</td>
            <td>闭</td>
            <td>敝</td>
            <td>弊</td>
            <td>必</td>
            <td>辟</td>
            <td>壁</td>
            <td>臂</td>
            <td>避</td>
            <td>陛</td>
            <td>鞭</td>
            <td>边</td>
        </tr><tr><th>B1E0</th>
            <td>编</td>
            <td>贬</td>
            <td>扁</td>
            <td>便</td>
            <td>变</td>
            <td>卞</td>
            <td>辨</td>
            <td>辩</td>
            <td>辫</td>
            <td>遍</td>
            <td>标</td>
            <td>彪</td>
            <td>膘</td>
            <td>表</td>
            <td>鳖</td>
            <td>憋</td>
        </tr><tr><th>B1F0</th>
            <td>别</td>
            <td>瘪</td>
            <td>彬</td>
            <td>斌</td>
            <td>濒</td>
            <td>滨</td>
            <td>宾</td>
            <td>摈</td>
            <td>兵</td>
            <td>冰</td>
            <td>柄</td>
            <td>丙</td>
            <td>秉</td>
            <td>饼</td>
            <td>炳</td>
            <td> </td>
        </tr><tr><th>第18区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>B2A0</th>
            <td> </td>
            <td>病</td>
            <td>并</td>
            <td>玻</td>
            <td>菠</td>
            <td>播</td>
            <td>拨</td>
            <td>钵</td>
            <td>波</td>
            <td>博</td>
            <td>勃</td>
            <td>搏</td>
            <td>铂</td>
            <td>箔</td>
            <td>伯</td>
            <td>帛</td>
        </tr><tr><th>B2B0</th>
            <td>舶</td>
            <td>脖</td>
            <td>膊</td>
            <td>渤</td>
            <td>泊</td>
            <td>驳</td>
            <td>捕</td>
            <td>卜</td>
            <td>哺</td>
            <td>补</td>
            <td>埠</td>
            <td>不</td>
            <td>布</td>
            <td>步</td>
            <td>簿</td>
            <td>部</td>
        </tr><tr><th>B2C0</th>
            <td>怖</td>
            <td>擦</td>
            <td>猜</td>
            <td>裁</td>
            <td>材</td>
            <td>才</td>
            <td>财</td>
            <td>睬</td>
            <td>踩</td>
            <td>采</td>
            <td>彩</td>
            <td>菜</td>
            <td>蔡</td>
            <td>餐</td>
            <td>参</td>
            <td>蚕</td>
        </tr><tr><th>B2D0</th>
            <td>残</td>
            <td>惭</td>
            <td>惨</td>
            <td>灿</td>
            <td>苍</td>
            <td>舱</td>
            <td>仓</td>
            <td>沧</td>
            <td>藏</td>
            <td>操</td>
            <td>糙</td>
            <td>槽</td>
            <td>曹</td>
            <td>草</td>
            <td>厕</td>
            <td>策</td>
        </tr><tr><th>B2E0</th>
            <td>侧</td>
            <td>册</td>
            <td>测</td>
            <td>层</td>
            <td>蹭</td>
            <td>插</td>
            <td>叉</td>
            <td>茬</td>
            <td>茶</td>
            <td>查</td>
            <td>碴</td>
            <td>搽</td>
            <td>察</td>
            <td>岔</td>
            <td>差</td>
            <td>诧</td>
        </tr><tr><th>B2F0</th>
            <td>拆</td>
            <td>柴</td>
            <td>豺</td>
            <td>搀</td>
            <td>掺</td>
            <td>蝉</td>
            <td>馋</td>
            <td>谗</td>
            <td>缠</td>
            <td>铲</td>
            <td>产</td>
            <td>阐</td>
            <td>颤</td>
            <td>昌</td>
            <td>猖</td>
            <td> </td>
        </tr><tr><th>第19区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>B3A0</th>
            <td> </td>
            <td>场</td>
            <td>尝</td>
            <td>常</td>
            <td>长</td>
            <td>偿</td>
            <td>肠</td>
            <td>厂</td>
            <td>敞</td>
            <td>畅</td>
            <td>唱</td>
            <td>倡</td>
            <td>超</td>
            <td>抄</td>
            <td>钞</td>
            <td>朝</td>
        </tr><tr><th>B3B0</th>
            <td>嘲</td>
            <td>潮</td>
            <td>巢</td>
            <td>吵</td>
            <td>炒</td>
            <td>车</td>
            <td>扯</td>
            <td>撤</td>
            <td>掣</td>
            <td>彻</td>
            <td>澈</td>
            <td>郴</td>
            <td>臣</td>
            <td>辰</td>
            <td>尘</td>
            <td>晨</td>
        </tr><tr><th>B3C0</th>
            <td>忱</td>
            <td>沉</td>
            <td>陈</td>
            <td>趁</td>
            <td>衬</td>
            <td>撑</td>
            <td>称</td>
            <td>城</td>
            <td>橙</td>
            <td>成</td>
            <td>呈</td>
            <td>乘</td>
            <td>程</td>
            <td>惩</td>
            <td>澄</td>
            <td>诚</td>
        </tr><tr><th>B3D0</th>
            <td>承</td>
            <td>逞</td>
            <td>骋</td>
            <td>秤</td>
            <td>吃</td>
            <td>痴</td>
            <td>持</td>
            <td>匙</td>
            <td>池</td>
            <td>迟</td>
            <td>弛</td>
            <td>驰</td>
            <td>耻</td>
            <td>齿</td>
            <td>侈</td>
            <td>尺</td>
        </tr><tr><th>B3E0</th>
            <td>赤</td>
            <td>翅</td>
            <td>斥</td>
            <td>炽</td>
            <td>充</td>
            <td>冲</td>
            <td>虫</td>
            <td>崇</td>
            <td>宠</td>
            <td>抽</td>
            <td>酬</td>
            <td>畴</td>
            <td>踌</td>
            <td>稠</td>
            <td>愁</td>
            <td>筹</td>
        </tr><tr><th>B3F0</th>
            <td>仇</td>
            <td>绸</td>
            <td>瞅</td>
            <td>丑</td>
            <td>臭</td>
            <td>初</td>
            <td>出</td>
            <td>橱</td>
            <td>厨</td>
            <td>躇</td>
            <td>锄</td>
            <td>雏</td>
            <td>滁</td>
            <td>除</td>
            <td>楚</td>
            <td> </td>
        </tr><tr><th>第20区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>B4A0</th>
            <td> </td>
            <td>础</td>
            <td>储</td>
            <td>矗</td>
            <td>搐</td>
            <td>触</td>
            <td>处</td>
            <td>揣</td>
            <td>川</td>
            <td>穿</td>
            <td>椽</td>
            <td>传</td>
            <td>船</td>
            <td>喘</td>
            <td>串</td>
            <td>疮</td>
        </tr><tr><th>B4B0</th>
            <td>窗</td>
            <td>幢</td>
            <td>床</td>
            <td>闯</td>
            <td>创</td>
            <td>吹</td>
            <td>炊</td>
            <td>捶</td>
            <td>锤</td>
            <td>垂</td>
            <td>春</td>
            <td>椿</td>
            <td>醇</td>
            <td>唇</td>
            <td>淳</td>
            <td>纯</td>
        </tr><tr><th>B4C0</th>
            <td>蠢</td>
            <td>戳</td>
            <td>绰</td>
            <td>疵</td>
            <td>茨</td>
            <td>磁</td>
            <td>雌</td>
            <td>辞</td>
            <td>慈</td>
            <td>瓷</td>
            <td>词</td>
            <td>此</td>
            <td>刺</td>
            <td>赐</td>
            <td>次</td>
            <td>聪</td>
        </tr><tr><th>B4D0</th>
            <td>葱</td>
            <td>囱</td>
            <td>匆</td>
            <td>从</td>
            <td>丛</td>
            <td>凑</td>
            <td>粗</td>
            <td>醋</td>
            <td>簇</td>
            <td>促</td>
            <td>蹿</td>
            <td>篡</td>
            <td>窜</td>
            <td>摧</td>
            <td>崔</td>
            <td>催</td>
        </tr><tr><th>B4E0</th>
            <td>脆</td>
            <td>瘁</td>
            <td>粹</td>
            <td>淬</td>
            <td>翠</td>
            <td>村</td>
            <td>存</td>
            <td>寸</td>
            <td>磋</td>
            <td>撮</td>
            <td>搓</td>
            <td>措</td>
            <td>挫</td>
            <td>错</td>
            <td>搭</td>
            <td>达</td>
        </tr><tr><th>B4F0</th>
            <td>答</td>
            <td>瘩</td>
            <td>打</td>
            <td>大</td>
            <td>呆</td>
            <td>歹</td>
            <td>傣</td>
            <td>戴</td>
            <td>带</td>
            <td>殆</td>
            <td>代</td>
            <td>贷</td>
            <td>袋</td>
            <td>待</td>
            <td>逮</td>
            <td> </td>
        </tr><tr><th>第21区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>B5A0</th>
            <td> </td>
            <td>怠</td>
            <td>耽</td>
            <td>担</td>
            <td>丹</td>
            <td>单</td>
            <td>郸</td>
            <td>掸</td>
            <td>胆</td>
            <td>旦</td>
            <td>氮</td>
            <td>但</td>
            <td>惮</td>
            <td>淡</td>
            <td>诞</td>
            <td>弹</td>
        </tr><tr><th>B5B0</th>
            <td>蛋</td>
            <td>当</td>
            <td>挡</td>
            <td>党</td>
            <td>荡</td>
            <td>档</td>
            <td>刀</td>
            <td>捣</td>
            <td>蹈</td>
            <td>倒</td>
            <td>岛</td>
            <td>祷</td>
            <td>导</td>
            <td>到</td>
            <td>稻</td>
            <td>悼</td>
        </tr><tr><th>B5C0</th>
            <td>道</td>
            <td>盗</td>
            <td>德</td>
            <td>得</td>
            <td>的</td>
            <td>蹬</td>
            <td>灯</td>
            <td>登</td>
            <td>等</td>
            <td>瞪</td>
            <td>凳</td>
            <td>邓</td>
            <td>堤</td>
            <td>低</td>
            <td>滴</td>
            <td>迪</td>
        </tr><tr><th>B5D0</th>
            <td>敌</td>
            <td>笛</td>
            <td>狄</td>
            <td>涤</td>
            <td>翟</td>
            <td>嫡</td>
            <td>抵</td>
            <td>底</td>
            <td>地</td>
            <td>蒂</td>
            <td>第</td>
            <td>帝</td>
            <td>弟</td>
            <td>递</td>
            <td>缔</td>
            <td>颠</td>
        </tr><tr><th>B5E0</th>
            <td>掂</td>
            <td>滇</td>
            <td>碘</td>
            <td>点</td>
            <td>典</td>
            <td>靛</td>
            <td>垫</td>
            <td>电</td>
            <td>佃</td>
            <td>甸</td>
            <td>店</td>
            <td>惦</td>
            <td>奠</td>
            <td>淀</td>
            <td>殿</td>
            <td>碉</td>
        </tr><tr><th>B5F0</th>
            <td>叼</td>
            <td>雕</td>
            <td>凋</td>
            <td>刁</td>
            <td>掉</td>
            <td>吊</td>
            <td>钓</td>
            <td>调</td>
            <td>跌</td>
            <td>爹</td>
            <td>碟</td>
            <td>蝶</td>
            <td>迭</td>
            <td>谍</td>
            <td>叠</td>
            <td> </td>
        </tr><tr><th>第22区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>B6A0</th>
            <td> </td>
            <td>丁</td>
            <td>盯</td>
            <td>叮</td>
            <td>钉</td>
            <td>顶</td>
            <td>鼎</td>
            <td>锭</td>
            <td>定</td>
            <td>订</td>
            <td>丢</td>
            <td>东</td>
            <td>冬</td>
            <td>董</td>
            <td>懂</td>
            <td>动</td>
        </tr><tr><th>B6B0</th>
            <td>栋</td>
            <td>侗</td>
            <td>恫</td>
            <td>冻</td>
            <td>洞</td>
            <td>兜</td>
            <td>抖</td>
            <td>斗</td>
            <td>陡</td>
            <td>豆</td>
            <td>逗</td>
            <td>痘</td>
            <td>都</td>
            <td>督</td>
            <td>毒</td>
            <td>犊</td>
        </tr><tr><th>B6C0</th>
            <td>独</td>
            <td>读</td>
            <td>堵</td>
            <td>睹</td>
            <td>赌</td>
            <td>杜</td>
            <td>镀</td>
            <td>肚</td>
            <td>度</td>
            <td>渡</td>
            <td>妒</td>
            <td>端</td>
            <td>短</td>
            <td>锻</td>
            <td>段</td>
            <td>断</td>
        </tr><tr><th>B6D0</th>
            <td>缎</td>
            <td>堆</td>
            <td>兑</td>
            <td>队</td>
            <td>对</td>
            <td>墩</td>
            <td>吨</td>
            <td>蹲</td>
            <td>敦</td>
            <td>顿</td>
            <td>囤</td>
            <td>钝</td>
            <td>盾</td>
            <td>遁</td>
            <td>掇</td>
            <td>哆</td>
        </tr><tr><th>B6E0</th>
            <td>多</td>
            <td>夺</td>
            <td>垛</td>
            <td>躲</td>
            <td>朵</td>
            <td>跺</td>
            <td>舵</td>
            <td>剁</td>
            <td>惰</td>
            <td>堕</td>
            <td>蛾</td>
            <td>峨</td>
            <td>鹅</td>
            <td>俄</td>
            <td>额</td>
            <td>讹</td>
        </tr><tr><th>B6F0</th>
            <td>娥</td>
            <td>恶</td>
            <td>厄</td>
            <td>扼</td>
            <td>遏</td>
            <td>鄂</td>
            <td>饿</td>
            <td>恩</td>
            <td>而</td>
            <td>儿</td>
            <td>耳</td>
            <td>尔</td>
            <td>饵</td>
            <td>洱</td>
            <td>二</td>
            <td> </td>
        </tr><tr><th>第23区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>B7A0</th>
            <td> </td>
            <td>贰</td>
            <td>发</td>
            <td>罚</td>
            <td>筏</td>
            <td>伐</td>
            <td>乏</td>
            <td>阀</td>
            <td>法</td>
            <td>珐</td>
            <td>藩</td>
            <td>帆</td>
            <td>番</td>
            <td>翻</td>
            <td>樊</td>
            <td>矾</td>
        </tr><tr><th>B7B0</th>
            <td>钒</td>
            <td>繁</td>
            <td>凡</td>
            <td>烦</td>
            <td>反</td>
            <td>返</td>
            <td>范</td>
            <td>贩</td>
            <td>犯</td>
            <td>饭</td>
            <td>泛</td>
            <td>坊</td>
            <td>芳</td>
            <td>方</td>
            <td>肪</td>
            <td>房</td>
        </tr><tr><th>B7C0</th>
            <td>防</td>
            <td>妨</td>
            <td>仿</td>
            <td>访</td>
            <td>纺</td>
            <td>放</td>
            <td>菲</td>
            <td>非</td>
            <td>啡</td>
            <td>飞</td>
            <td>肥</td>
            <td>匪</td>
            <td>诽</td>
            <td>吠</td>
            <td>肺</td>
            <td>废</td>
        </tr><tr><th>B7D0</th>
            <td>沸</td>
            <td>费</td>
            <td>芬</td>
            <td>酚</td>
            <td>吩</td>
            <td>氛</td>
            <td>分</td>
            <td>纷</td>
            <td>坟</td>
            <td>焚</td>
            <td>汾</td>
            <td>粉</td>
            <td>奋</td>
            <td>份</td>
            <td>忿</td>
            <td>愤</td>
        </tr><tr><th>B7E0</th>
            <td>粪</td>
            <td>丰</td>
            <td>封</td>
            <td>枫</td>
            <td>蜂</td>
            <td>峰</td>
            <td>锋</td>
            <td>风</td>
            <td>疯</td>
            <td>烽</td>
            <td>逢</td>
            <td>冯</td>
            <td>缝</td>
            <td>讽</td>
            <td>奉</td>
            <td>凤</td>
        </tr><tr><th>B7F0</th>
            <td>佛</td>
            <td>否</td>
            <td>夫</td>
            <td>敷</td>
            <td>肤</td>
            <td>孵</td>
            <td>扶</td>
            <td>拂</td>
            <td>辐</td>
            <td>幅</td>
            <td>氟</td>
            <td>符</td>
            <td>伏</td>
            <td>俘</td>
            <td>服</td>
            <td> </td>
        </tr><tr><th>第24区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C th&gt;</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>B8A0</th>
            <td> </td>
            <td>浮</td>
            <td>涪</td>
            <td>福</td>
            <td>袱</td>
            <td>弗</td>
            <td>甫</td>
            <td>抚</td>
            <td>辅</td>
            <td>俯</td>
            <td>釜</td>
            <td>斧</td>
            <td>脯</td>
            <td>腑</td>
            <td>府</td>
            <td>腐</td>
        </tr><tr><th>B8B0</th>
            <td>赴</td>
            <td>副</td>
            <td>覆</td>
            <td>赋</td>
            <td>复</td>
            <td>傅</td>
            <td>付</td>
            <td>阜</td>
            <td>父</td>
            <td>腹</td>
            <td>负</td>
            <td>富</td>
            <td>讣</td>
            <td>附</td>
            <td>妇</td>
            <td>缚</td>
        </tr><tr><th>B8C0</th>
            <td>咐</td>
            <td>噶</td>
            <td>嘎</td>
            <td>该</td>
            <td>改</td>
            <td>概</td>
            <td>钙</td>
            <td>盖</td>
            <td>溉</td>
            <td>干</td>
            <td>甘</td>
            <td>杆</td>
            <td>柑</td>
            <td>竿</td>
            <td>肝</td>
            <td>赶</td>
        </tr><tr><th>B8D0</th>
            <td>感</td>
            <td>秆</td>
            <td>敢</td>
            <td>赣</td>
            <td>冈</td>
            <td>刚</td>
            <td>钢</td>
            <td>缸</td>
            <td>肛</td>
            <td>纲</td>
            <td>岗</td>
            <td>港</td>
            <td>杠</td>
            <td>篙</td>
            <td>皋</td>
            <td>高</td>
        </tr><tr><th>B8E0</th>
            <td>膏</td>
            <td>羔</td>
            <td>糕</td>
            <td>搞</td>
            <td>镐</td>
            <td>稿</td>
            <td>告</td>
            <td>哥</td>
            <td>歌</td>
            <td>搁</td>
            <td>戈</td>
            <td>鸽</td>
            <td>胳</td>
            <td>疙</td>
            <td>割</td>
            <td>革</td>
        </tr><tr><th>B8F0</th>
            <td>葛</td>
            <td>格</td>
            <td>蛤</td>
            <td>阁</td>
            <td>隔</td>
            <td>铬</td>
            <td>个</td>
            <td>各</td>
            <td>给</td>
            <td>根</td>
            <td>跟</td>
            <td>耕</td>
            <td>更</td>
            <td>庚</td>
            <td>羹</td>
            <td> </td>
        </tr><tr><th>第25区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>B9A0</th>
            <td> </td>
            <td>埂</td>
            <td>耿</td>
            <td>梗</td>
            <td>工</td>
            <td>攻</td>
            <td>功</td>
            <td>恭</td>
            <td>龚</td>
            <td>供</td>
            <td>躬</td>
            <td>公</td>
            <td>宫</td>
            <td>弓</td>
            <td>巩</td>
            <td>汞</td>
        </tr><tr><th>B9B0</th>
            <td>拱</td>
            <td>贡</td>
            <td>共</td>
            <td>钩</td>
            <td>勾</td>
            <td>沟</td>
            <td>苟</td>
            <td>狗</td>
            <td>垢</td>
            <td>构</td>
            <td>购</td>
            <td>够</td>
            <td>辜</td>
            <td>菇</td>
            <td>咕</td>
            <td>箍</td>
        </tr><tr><th>B9C0</th>
            <td>估</td>
            <td>沽</td>
            <td>孤</td>
            <td>姑</td>
            <td>鼓</td>
            <td>古</td>
            <td>蛊</td>
            <td>骨</td>
            <td>谷</td>
            <td>股</td>
            <td>故</td>
            <td>顾</td>
            <td>固</td>
            <td>雇</td>
            <td>刮</td>
            <td>瓜</td>
        </tr><tr><th>B9D0</th>
            <td>剐</td>
            <td>寡</td>
            <td>挂</td>
            <td>褂</td>
            <td>乖</td>
            <td>拐</td>
            <td>怪</td>
            <td>棺</td>
            <td>关</td>
            <td>官</td>
            <td>冠</td>
            <td>观</td>
            <td>管</td>
            <td>馆</td>
            <td>罐</td>
            <td>惯</td>
        </tr><tr><th>B9E0</th>
            <td>灌</td>
            <td>贯</td>
            <td>光</td>
            <td>广</td>
            <td>逛</td>
            <td>瑰</td>
            <td>规</td>
            <td>圭</td>
            <td>硅</td>
            <td>归</td>
            <td>龟</td>
            <td>闺</td>
            <td>轨</td>
            <td>鬼</td>
            <td>诡</td>
            <td>癸</td>
        </tr><tr><th>B9F0</th>
            <td>桂</td>
            <td>柜</td>
            <td>跪</td>
            <td>贵</td>
            <td>刽</td>
            <td>辊</td>
            <td>滚</td>
            <td>棍</td>
            <td>锅</td>
            <td>郭</td>
            <td>国</td>
            <td>果</td>
            <td>裹</td>
            <td>过</td>
            <td>哈</td>
            <td> </td>
        </tr><tr><th>第26区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>BAA0</th>
            <td> </td>
            <td>骸</td>
            <td>孩</td>
            <td>海</td>
            <td>氦</td>
            <td>亥</td>
            <td>害</td>
            <td>骇</td>
            <td>酣</td>
            <td>憨</td>
            <td>邯</td>
            <td>韩</td>
            <td>含</td>
            <td>涵</td>
            <td>寒</td>
            <td>函</td>
        </tr><tr><th>BAB0</th>
            <td>喊</td>
            <td>罕</td>
            <td>翰</td>
            <td>撼</td>
            <td>捍</td>
            <td>旱</td>
            <td>憾</td>
            <td>悍</td>
            <td>焊</td>
            <td>汗</td>
            <td>汉</td>
            <td>夯</td>
            <td>杭</td>
            <td>航</td>
            <td>壕</td>
            <td>嚎</td>
        </tr><tr><th>BAC0</th>
            <td>豪</td>
            <td>毫</td>
            <td>郝</td>
            <td>好</td>
            <td>耗</td>
            <td>号</td>
            <td>浩</td>
            <td>呵</td>
            <td>喝</td>
            <td>荷</td>
            <td>菏</td>
            <td>核</td>
            <td>禾</td>
            <td>和</td>
            <td>何</td>
            <td>合</td>
        </tr><tr><th>BAD0</th>
            <td>盒</td>
            <td>貉</td>
            <td>阂</td>
            <td>河</td>
            <td>涸</td>
            <td>赫</td>
            <td>褐</td>
            <td>鹤</td>
            <td>贺</td>
            <td>嘿</td>
            <td>黑</td>
            <td>痕</td>
            <td>很</td>
            <td>狠</td>
            <td>恨</td>
            <td>哼</td>
        </tr><tr><th>BAE0</th>
            <td>亨</td>
            <td>横</td>
            <td>衡</td>
            <td>恒</td>
            <td>轰</td>
            <td>哄</td>
            <td>烘</td>
            <td>虹</td>
            <td>鸿</td>
            <td>洪</td>
            <td>宏</td>
            <td>弘</td>
            <td>红</td>
            <td>喉</td>
            <td>侯</td>
            <td>猴</td>
        </tr><tr><th>BAF0</th>
            <td>吼</td>
            <td>厚</td>
            <td>候</td>
            <td>后</td>
            <td>呼</td>
            <td>乎</td>
            <td>忽</td>
            <td>瑚</td>
            <td>壶</td>
            <td>葫</td>
            <td>胡</td>
            <td>蝴</td>
            <td>狐</td>
            <td>糊</td>
            <td>湖</td>
            <td> </td>
        </tr><tr><th>第27区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>BBA0</th>
            <td> </td>
            <td>弧</td>
            <td>虎</td>
            <td>唬</td>
            <td>护</td>
            <td>互</td>
            <td>沪</td>
            <td>户</td>
            <td>花</td>
            <td>哗</td>
            <td>华</td>
            <td>猾</td>
            <td>滑</td>
            <td>画</td>
            <td>划</td>
            <td>化</td>
        </tr><tr><th>BBB0</th>
            <td>话</td>
            <td>槐</td>
            <td>徊</td>
            <td>怀</td>
            <td>淮</td>
            <td>坏</td>
            <td>欢</td>
            <td>环</td>
            <td>桓</td>
            <td>还</td>
            <td>缓</td>
            <td>换</td>
            <td>患</td>
            <td>唤</td>
            <td>痪</td>
            <td>豢</td>
        </tr><tr><th>BBC0</th>
            <td>焕</td>
            <td>涣</td>
            <td>宦</td>
            <td>幻</td>
            <td>荒</td>
            <td>慌</td>
            <td>黄</td>
            <td>磺</td>
            <td>蝗</td>
            <td>簧</td>
            <td>皇</td>
            <td>凰</td>
            <td>惶</td>
            <td>煌</td>
            <td>晃</td>
            <td>幌</td>
        </tr><tr><th>BBD0</th>
            <td>恍</td>
            <td>谎</td>
            <td>灰</td>
            <td>挥</td>
            <td>辉</td>
            <td>徽</td>
            <td>恢</td>
            <td>蛔</td>
            <td>回</td>
            <td>毁</td>
            <td>悔</td>
            <td>慧</td>
            <td>卉</td>
            <td>惠</td>
            <td>晦</td>
            <td>贿</td>
        </tr><tr><th>BBE0</th>
            <td>秽</td>
            <td>会</td>
            <td>烩</td>
            <td>汇</td>
            <td>讳</td>
            <td>诲</td>
            <td>绘</td>
            <td>荤</td>
            <td>昏</td>
            <td>婚</td>
            <td>魂</td>
            <td>浑</td>
            <td>混</td>
            <td>豁</td>
            <td>活</td>
            <td>伙</td>
        </tr><tr><th>BBF0</th>
            <td>火</td>
            <td>获</td>
            <td>或</td>
            <td>惑</td>
            <td>霍</td>
            <td>货</td>
            <td>祸</td>
            <td>击</td>
            <td>圾</td>
            <td>基</td>
            <td>机</td>
            <td>畸</td>
            <td>稽</td>
            <td>积</td>
            <td>箕</td>
            <td> </td>
        </tr><tr><th>第28区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>BCA0</th>
            <td> </td>
            <td>肌</td>
            <td>饥</td>
            <td>迹</td>
            <td>激</td>
            <td>讥</td>
            <td>鸡</td>
            <td>姬</td>
            <td>绩</td>
            <td>缉</td>
            <td>吉</td>
            <td>极</td>
            <td>棘</td>
            <td>辑</td>
            <td>籍</td>
            <td>集</td>
        </tr><tr><th>BCB0</th>
            <td>及</td>
            <td>急</td>
            <td>疾</td>
            <td>汲</td>
            <td>即</td>
            <td>嫉</td>
            <td>级</td>
            <td>挤</td>
            <td>几</td>
            <td>脊</td>
            <td>己</td>
            <td>蓟</td>
            <td>技</td>
            <td>冀</td>
            <td>季</td>
            <td>伎</td>
        </tr><tr><th>BCC0</th>
            <td>祭</td>
            <td>剂</td>
            <td>悸</td>
            <td>济</td>
            <td>寄</td>
            <td>寂</td>
            <td>计</td>
            <td>记</td>
            <td>既</td>
            <td>忌</td>
            <td>际</td>
            <td>妓</td>
            <td>继</td>
            <td>纪</td>
            <td>嘉</td>
            <td>枷</td>
        </tr><tr><th>BCD0</th>
            <td>夹</td>
            <td>佳</td>
            <td>家</td>
            <td>加</td>
            <td>荚</td>
            <td>颊</td>
            <td>贾</td>
            <td>甲</td>
            <td>钾</td>
            <td>假</td>
            <td>稼</td>
            <td>价</td>
            <td>架</td>
            <td>驾</td>
            <td>嫁</td>
            <td>歼</td>
        </tr><tr><th>BCE0</th>
            <td>监</td>
            <td>坚</td>
            <td>尖</td>
            <td>笺</td>
            <td>间</td>
            <td>煎</td>
            <td>兼</td>
            <td>肩</td>
            <td>艰</td>
            <td>奸</td>
            <td>缄</td>
            <td>茧</td>
            <td>检</td>
            <td>柬</td>
            <td>碱</td>
            <td>硷</td>
        </tr><tr><th>BCF0</th>
            <td>拣</td>
            <td>捡</td>
            <td>简</td>
            <td>俭</td>
            <td>剪</td>
            <td>减</td>
            <td>荐</td>
            <td>槛</td>
            <td>鉴</td>
            <td>践</td>
            <td>贱</td>
            <td>见</td>
            <td>键</td>
            <td>箭</td>
            <td>件</td>
            <td> </td>
        </tr><tr><th>第29区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>BDA0</th>
            <td> </td>
            <td>健</td>
            <td>舰</td>
            <td>剑</td>
            <td>饯</td>
            <td>渐</td>
            <td>溅</td>
            <td>涧</td>
            <td>建</td>
            <td>僵</td>
            <td>姜</td>
            <td>将</td>
            <td>浆</td>
            <td>江</td>
            <td>疆</td>
            <td>蒋</td>
        </tr><tr><th>BDB0</th>
            <td>桨</td>
            <td>奖</td>
            <td>讲</td>
            <td>匠</td>
            <td>酱</td>
            <td>降</td>
            <td>蕉</td>
            <td>椒</td>
            <td>礁</td>
            <td>焦</td>
            <td>胶</td>
            <td>交</td>
            <td>郊</td>
            <td>浇</td>
            <td>骄</td>
            <td>娇</td>
        </tr><tr><th>BDC0</th>
            <td>嚼</td>
            <td>搅</td>
            <td>铰</td>
            <td>矫</td>
            <td>侥</td>
            <td>脚</td>
            <td>狡</td>
            <td>角</td>
            <td>饺</td>
            <td>缴</td>
            <td>绞</td>
            <td>剿</td>
            <td>教</td>
            <td>酵</td>
            <td>轿</td>
            <td>较</td>
        </tr><tr><th>BDD0</th>
            <td>叫</td>
            <td>窖</td>
            <td>揭</td>
            <td>接</td>
            <td>皆</td>
            <td>秸</td>
            <td>街</td>
            <td>阶</td>
            <td>截</td>
            <td>劫</td>
            <td>节</td>
            <td>桔</td>
            <td>杰</td>
            <td>捷</td>
            <td>睫</td>
            <td>竭</td>
        </tr><tr><th>BDE0</th>
            <td>洁</td>
            <td>结</td>
            <td>解</td>
            <td>姐</td>
            <td>戒</td>
            <td>藉</td>
            <td>芥</td>
            <td>界</td>
            <td>借</td>
            <td>介</td>
            <td>疥</td>
            <td>诫</td>
            <td>届</td>
            <td>巾</td>
            <td>筋</td>
            <td>斤</td>
        </tr><tr><th>BDF0</th>
            <td>金</td>
            <td>今</td>
            <td>津</td>
            <td>襟</td>
            <td>紧</td>
            <td>锦</td>
            <td>仅</td>
            <td>谨</td>
            <td>进</td>
            <td>靳</td>
            <td>晋</td>
            <td>禁</td>
            <td>近</td>
            <td>烬</td>
            <td>浸</td>
            <td> </td>
        </tr><tr><th>第30区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>BEA0</th>
            <td> </td>
            <td>尽</td>
            <td>劲</td>
            <td>荆</td>
            <td>兢</td>
            <td>茎</td>
            <td>睛</td>
            <td>晶</td>
            <td>鲸</td>
            <td>京</td>
            <td>惊</td>
            <td>精</td>
            <td>粳</td>
            <td>经</td>
            <td>井</td>
            <td>警</td>
        </tr><tr><th>BEB0</th>
            <td>景</td>
            <td>颈</td>
            <td>静</td>
            <td>境</td>
            <td>敬</td>
            <td>镜</td>
            <td>径</td>
            <td>痉</td>
            <td>靖</td>
            <td>竟</td>
            <td>竞</td>
            <td>净</td>
            <td>炯</td>
            <td>窘</td>
            <td>揪</td>
            <td>究</td>
        </tr><tr><th>BEC0</th>
            <td>纠</td>
            <td>玖</td>
            <td>韭</td>
            <td>久</td>
            <td>灸</td>
            <td>九</td>
            <td>酒</td>
            <td>厩</td>
            <td>救</td>
            <td>旧</td>
            <td>臼</td>
            <td>舅</td>
            <td>咎</td>
            <td>就</td>
            <td>疚</td>
            <td>鞠</td>
        </tr><tr><th>BED0</th>
            <td>拘</td>
            <td>狙</td>
            <td>疽</td>
            <td>居</td>
            <td>驹</td>
            <td>菊</td>
            <td>局</td>
            <td>咀</td>
            <td>矩</td>
            <td>举</td>
            <td>沮</td>
            <td>聚</td>
            <td>拒</td>
            <td>据</td>
            <td>巨</td>
            <td>具</td>
        </tr><tr><th>BEE0</th>
            <td>距</td>
            <td>踞</td>
            <td>锯</td>
            <td>俱</td>
            <td>句</td>
            <td>惧</td>
            <td>炬</td>
            <td>剧</td>
            <td>捐</td>
            <td>鹃</td>
            <td>娟</td>
            <td>倦</td>
            <td>眷</td>
            <td>卷</td>
            <td>绢</td>
            <td>撅</td>
        </tr><tr><th>BEF0</th>
            <td>攫</td>
            <td>抉</td>
            <td>掘</td>
            <td>倔</td>
            <td>爵</td>
            <td>觉</td>
            <td>决</td>
            <td>诀</td>
            <td>绝</td>
            <td>均</td>
            <td>菌</td>
            <td>钧</td>
            <td>军</td>
            <td>君</td>
            <td>峻</td>
            <td> </td>
        </tr><tr><th>第31区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>BFA0</th>
            <td> </td>
            <td>俊</td>
            <td>竣</td>
            <td>浚</td>
            <td>郡</td>
            <td>骏</td>
            <td>喀</td>
            <td>咖</td>
            <td>卡</td>
            <td>咯</td>
            <td>开</td>
            <td>揩</td>
            <td>楷</td>
            <td>凯</td>
            <td>慨</td>
            <td>刊</td>
        </tr><tr><th>BFB0</th>
            <td>堪</td>
            <td>勘</td>
            <td>坎</td>
            <td>砍</td>
            <td>看</td>
            <td>康</td>
            <td>慷</td>
            <td>糠</td>
            <td>扛</td>
            <td>抗</td>
            <td>亢</td>
            <td>炕</td>
            <td>考</td>
            <td>拷</td>
            <td>烤</td>
            <td>靠</td>
        </tr><tr><th>BFC0</th>
            <td>坷</td>
            <td>苛</td>
            <td>柯</td>
            <td>棵</td>
            <td>磕</td>
            <td>颗</td>
            <td>科</td>
            <td>壳</td>
            <td>咳</td>
            <td>可</td>
            <td>渴</td>
            <td>克</td>
            <td>刻</td>
            <td>客</td>
            <td>课</td>
            <td>肯</td>
        </tr><tr><th>BFD0</th>
            <td>啃</td>
            <td>垦</td>
            <td>恳</td>
            <td>坑</td>
            <td>吭</td>
            <td>空</td>
            <td>恐</td>
            <td>孔</td>
            <td>控</td>
            <td>抠</td>
            <td>口</td>
            <td>扣</td>
            <td>寇</td>
            <td>枯</td>
            <td>哭</td>
            <td>窟</td>
        </tr><tr><th>BFE0</th>
            <td>苦</td>
            <td>酷</td>
            <td>库</td>
            <td>裤</td>
            <td>夸</td>
            <td>垮</td>
            <td>挎</td>
            <td>跨</td>
            <td>胯</td>
            <td>块</td>
            <td>筷</td>
            <td>侩</td>
            <td>快</td>
            <td>宽</td>
            <td>款</td>
            <td>匡</td>
        </tr><tr><th>BFF0</th>
            <td>筐</td>
            <td>狂</td>
            <td>框</td>
            <td>矿</td>
            <td>眶</td>
            <td>旷</td>
            <td>况</td>
            <td>亏</td>
            <td>盔</td>
            <td>岿</td>
            <td>窥</td>
            <td>葵</td>
            <td>奎</td>
            <td>魁</td>
            <td>傀</td>
            <td> </td>
        </tr><tr><th>第32区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>C0A0</th>
            <td> </td>
            <td>馈</td>
            <td>愧</td>
            <td>溃</td>
            <td>坤</td>
            <td>昆</td>
            <td>捆</td>
            <td>困</td>
            <td>括</td>
            <td>扩</td>
            <td>廓</td>
            <td>阔</td>
            <td>垃</td>
            <td>拉</td>
            <td>喇</td>
            <td>蜡</td>
        </tr><tr><th>C0B0</th>
            <td>腊</td>
            <td>辣</td>
            <td>啦</td>
            <td>莱</td>
            <td>来</td>
            <td>赖</td>
            <td>蓝</td>
            <td>婪</td>
            <td>栏</td>
            <td>拦</td>
            <td>篮</td>
            <td>阑</td>
            <td>兰</td>
            <td>澜</td>
            <td>谰</td>
            <td>揽</td>
        </tr><tr><th>C0C0</th>
            <td>览</td>
            <td>懒</td>
            <td>缆</td>
            <td>烂</td>
            <td>滥</td>
            <td>琅</td>
            <td>榔</td>
            <td>狼</td>
            <td>廊</td>
            <td>郎</td>
            <td>朗</td>
            <td>浪</td>
            <td>捞</td>
            <td>劳</td>
            <td>牢</td>
            <td>老</td>
        </tr><tr><th>C0D0</th>
            <td>佬</td>
            <td>姥</td>
            <td>酪</td>
            <td>烙</td>
            <td>涝</td>
            <td>勒</td>
            <td>乐</td>
            <td>雷</td>
            <td>镭</td>
            <td>蕾</td>
            <td>磊</td>
            <td>累</td>
            <td>儡</td>
            <td>垒</td>
            <td>擂</td>
            <td>肋</td>
        </tr><tr><th>C0E0</th>
            <td>类</td>
            <td>泪</td>
            <td>棱</td>
            <td>楞</td>
            <td>冷</td>
            <td>厘</td>
            <td>梨</td>
            <td>犁</td>
            <td>黎</td>
            <td>篱</td>
            <td>狸</td>
            <td>离</td>
            <td>漓</td>
            <td>理</td>
            <td>李</td>
            <td>里</td>
        </tr><tr><th>C0F0</th>
            <td>鲤</td>
            <td>礼</td>
            <td>莉</td>
            <td>荔</td>
            <td>吏</td>
            <td>栗</td>
            <td>丽</td>
            <td>厉</td>
            <td>励</td>
            <td>砾</td>
            <td>历</td>
            <td>利</td>
            <td>傈</td>
            <td>例</td>
            <td>俐</td>
            <td> </td>
        </tr><tr><th>第33区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>C1A0</th>
            <td> </td>
            <td>痢</td>
            <td>立</td>
            <td>粒</td>
            <td>沥</td>
            <td>隶</td>
            <td>力</td>
            <td>璃</td>
            <td>哩</td>
            <td>俩</td>
            <td>联</td>
            <td>莲</td>
            <td>连</td>
            <td>镰</td>
            <td>廉</td>
            <td>怜</td>
        </tr><tr><th>C1B0</th>
            <td>涟</td>
            <td>帘</td>
            <td>敛</td>
            <td>脸</td>
            <td>链</td>
            <td>恋</td>
            <td>炼</td>
            <td>练</td>
            <td>粮</td>
            <td>凉</td>
            <td>梁</td>
            <td>粱</td>
            <td>良</td>
            <td>两</td>
            <td>辆</td>
            <td>量</td>
        </tr><tr><th>C1C0</th>
            <td>晾</td>
            <td>亮</td>
            <td>谅</td>
            <td>撩</td>
            <td>聊</td>
            <td>僚</td>
            <td>疗</td>
            <td>燎</td>
            <td>寥</td>
            <td>辽</td>
            <td>潦</td>
            <td>了</td>
            <td>撂</td>
            <td>镣</td>
            <td>廖</td>
            <td>料</td>
        </tr><tr><th>C1D0</th>
            <td>列</td>
            <td>裂</td>
            <td>烈</td>
            <td>劣</td>
            <td>猎</td>
            <td>琳</td>
            <td>林</td>
            <td>磷</td>
            <td>霖</td>
            <td>临</td>
            <td>邻</td>
            <td>鳞</td>
            <td>淋</td>
            <td>凛</td>
            <td>赁</td>
            <td>吝</td>
        </tr><tr><th>C1E0</th>
            <td>拎</td>
            <td>玲</td>
            <td>菱</td>
            <td>零</td>
            <td>龄</td>
            <td>铃</td>
            <td>伶</td>
            <td>羚</td>
            <td>凌</td>
            <td>灵</td>
            <td>陵</td>
            <td>岭</td>
            <td>领</td>
            <td>另</td>
            <td>令</td>
            <td>溜</td>
        </tr><tr><th>C1F0</th>
            <td>琉</td>
            <td>榴</td>
            <td>硫</td>
            <td>馏</td>
            <td>留</td>
            <td>刘</td>
            <td>瘤</td>
            <td>流</td>
            <td>柳</td>
            <td>六</td>
            <td>龙</td>
            <td>聋</td>
            <td>咙</td>
            <td>笼</td>
            <td>窿</td>
            <td> </td>
        </tr><tr><th>第34区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>C2A0</th>
            <td> </td>
            <td>隆</td>
            <td>垄</td>
            <td>拢</td>
            <td>陇</td>
            <td>楼</td>
            <td>娄</td>
            <td>搂</td>
            <td>篓</td>
            <td>漏</td>
            <td>陋</td>
            <td>芦</td>
            <td>卢</td>
            <td>颅</td>
            <td>庐</td>
            <td>炉</td>
        </tr><tr><th>C2B0</th>
            <td>掳</td>
            <td>卤</td>
            <td>虏</td>
            <td>鲁</td>
            <td>麓</td>
            <td>碌</td>
            <td>露</td>
            <td>路</td>
            <td>赂</td>
            <td>鹿</td>
            <td>潞</td>
            <td>禄</td>
            <td>录</td>
            <td>陆</td>
            <td>戮</td>
            <td>驴</td>
        </tr><tr><th>C2C0</th>
            <td>吕</td>
            <td>铝</td>
            <td>侣</td>
            <td>旅</td>
            <td>履</td>
            <td>屡</td>
            <td>缕</td>
            <td>虑</td>
            <td>氯</td>
            <td>律</td>
            <td>率</td>
            <td>滤</td>
            <td>绿</td>
            <td>峦</td>
            <td>挛</td>
            <td>孪</td>
        </tr><tr><th>C2D0</th>
            <td>滦</td>
            <td>卵</td>
            <td>乱</td>
            <td>掠</td>
            <td>略</td>
            <td>抡</td>
            <td>轮</td>
            <td>伦</td>
            <td>仑</td>
            <td>沦</td>
            <td>纶</td>
            <td>论</td>
            <td>萝</td>
            <td>螺</td>
            <td>罗</td>
            <td>逻</td>
        </tr><tr><th>C2E0</th>
            <td>锣</td>
            <td>箩</td>
            <td>骡</td>
            <td>裸</td>
            <td>落</td>
            <td>洛</td>
            <td>骆</td>
            <td>络</td>
            <td>妈</td>
            <td>麻</td>
            <td>玛</td>
            <td>码</td>
            <td>蚂</td>
            <td>马</td>
            <td>骂</td>
            <td>嘛</td>
        </tr><tr><th>C2F0</th>
            <td>吗</td>
            <td>埋</td>
            <td>买</td>
            <td>麦</td>
            <td>卖</td>
            <td>迈</td>
            <td>脉</td>
            <td>瞒</td>
            <td>馒</td>
            <td>蛮</td>
            <td>满</td>
            <td>蔓</td>
            <td>曼</td>
            <td>慢</td>
            <td>漫</td>
            <td> </td>
        </tr><tr><th>第35区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>C3A0</th>
            <td> </td>
            <td>谩</td>
            <td>芒</td>
            <td>茫</td>
            <td>盲</td>
            <td>氓</td>
            <td>忙</td>
            <td>莽</td>
            <td>猫</td>
            <td>茅</td>
            <td>锚</td>
            <td>毛</td>
            <td>矛</td>
            <td>铆</td>
            <td>卯</td>
            <td>茂</td>
        </tr><tr><th>C3B0</th>
            <td>冒</td>
            <td>帽</td>
            <td>貌</td>
            <td>贸</td>
            <td>么</td>
            <td>玫</td>
            <td>枚</td>
            <td>梅</td>
            <td>酶</td>
            <td>霉</td>
            <td>煤</td>
            <td>没</td>
            <td>眉</td>
            <td>媒</td>
            <td>镁</td>
            <td>每</td>
        </tr><tr><th>C3C0</th>
            <td>美</td>
            <td>昧</td>
            <td>寐</td>
            <td>妹</td>
            <td>媚</td>
            <td>门</td>
            <td>闷</td>
            <td>们</td>
            <td>萌</td>
            <td>蒙</td>
            <td>檬</td>
            <td>盟</td>
            <td>锰</td>
            <td>猛</td>
            <td>梦</td>
            <td>孟</td>
        </tr><tr><th>C3D0</th>
            <td>眯</td>
            <td>醚</td>
            <td>靡</td>
            <td>糜</td>
            <td>迷</td>
            <td>谜</td>
            <td>弥</td>
            <td>米</td>
            <td>秘</td>
            <td>觅</td>
            <td>泌</td>
            <td>蜜</td>
            <td>密</td>
            <td>幂</td>
            <td>棉</td>
            <td>眠</td>
        </tr><tr><th>C3E0</th>
            <td>绵</td>
            <td>冕</td>
            <td>免</td>
            <td>勉</td>
            <td>娩</td>
            <td>缅</td>
            <td>面</td>
            <td>苗</td>
            <td>描</td>
            <td>瞄</td>
            <td>藐</td>
            <td>秒</td>
            <td>渺</td>
            <td>庙</td>
            <td>妙</td>
            <td>蔑</td>
        </tr><tr><th>C3F0</th>
            <td>灭</td>
            <td>民</td>
            <td>抿</td>
            <td>皿</td>
            <td>敏</td>
            <td>悯</td>
            <td>闽</td>
            <td>明</td>
            <td>螟</td>
            <td>鸣</td>
            <td>铭</td>
            <td>名</td>
            <td>命</td>
            <td>谬</td>
            <td>摸</td>
            <td> </td>
        </tr><tr><th>第36区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>C4A0</th>
            <td> </td>
            <td>摹</td>
            <td>蘑</td>
            <td>模</td>
            <td>膜</td>
            <td>磨</td>
            <td>摩</td>
            <td>魔</td>
            <td>抹</td>
            <td>末</td>
            <td>莫</td>
            <td>墨</td>
            <td>默</td>
            <td>沫</td>
            <td>漠</td>
            <td>寞</td>
        </tr><tr><th>C4B0</th>
            <td>陌</td>
            <td>谋</td>
            <td>牟</td>
            <td>某</td>
            <td>拇</td>
            <td>牡</td>
            <td>亩</td>
            <td>姆</td>
            <td>母</td>
            <td>墓</td>
            <td>暮</td>
            <td>幕</td>
            <td>募</td>
            <td>慕</td>
            <td>木</td>
            <td>目</td>
        </tr><tr><th>C4C0</th>
            <td>睦</td>
            <td>牧</td>
            <td>穆</td>
            <td>拿</td>
            <td>哪</td>
            <td>呐</td>
            <td>钠</td>
            <td>那</td>
            <td>娜</td>
            <td>纳</td>
            <td>氖</td>
            <td>乃</td>
            <td>奶</td>
            <td>耐</td>
            <td>奈</td>
            <td>南</td>
        </tr><tr><th>C4D0</th>
            <td>男</td>
            <td>难</td>
            <td>囊</td>
            <td>挠</td>
            <td>脑</td>
            <td>恼</td>
            <td>闹</td>
            <td>淖</td>
            <td>呢</td>
            <td>馁</td>
            <td>内</td>
            <td>嫩</td>
            <td>能</td>
            <td>妮</td>
            <td>霓</td>
            <td>倪</td>
        </tr><tr><th>C4E0</th>
            <td>泥</td>
            <td>尼</td>
            <td>拟</td>
            <td>你</td>
            <td>匿</td>
            <td>腻</td>
            <td>逆</td>
            <td>溺</td>
            <td>蔫</td>
            <td>拈</td>
            <td>年</td>
            <td>碾</td>
            <td>撵</td>
            <td>捻</td>
            <td>念</td>
            <td>娘</td>
        </tr><tr><th>C4F0</th>
            <td>酿</td>
            <td>鸟</td>
            <td>尿</td>
            <td>捏</td>
            <td>聂</td>
            <td>孽</td>
            <td>啮</td>
            <td>镊</td>
            <td>镍</td>
            <td>涅</td>
            <td>您</td>
            <td>柠</td>
            <td>狞</td>
            <td>凝</td>
            <td>宁</td>
            <td> </td>
        </tr><tr><th>第37区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>C5A0</th>
            <td> </td>
            <td>拧</td>
            <td>泞</td>
            <td>牛</td>
            <td>扭</td>
            <td>钮</td>
            <td>纽</td>
            <td>脓</td>
            <td>浓</td>
            <td>农</td>
            <td>弄</td>
            <td>奴</td>
            <td>努</td>
            <td>怒</td>
            <td>女</td>
            <td>暖</td>
        </tr><tr><th>C5B0</th>
            <td>虐</td>
            <td>疟</td>
            <td>挪</td>
            <td>懦</td>
            <td>糯</td>
            <td>诺</td>
            <td>哦</td>
            <td>欧</td>
            <td>鸥</td>
            <td>殴</td>
            <td>藕</td>
            <td>呕</td>
            <td>偶</td>
            <td>沤</td>
            <td>啪</td>
            <td>趴</td>
        </tr><tr><th>C5C0</th>
            <td>爬</td>
            <td>帕</td>
            <td>怕</td>
            <td>琶</td>
            <td>拍</td>
            <td>排</td>
            <td>牌</td>
            <td>徘</td>
            <td>湃</td>
            <td>派</td>
            <td>攀</td>
            <td>潘</td>
            <td>盘</td>
            <td>磐</td>
            <td>盼</td>
            <td>畔</td>
        </tr><tr><th>C5D0</th>
            <td>判</td>
            <td>叛</td>
            <td>乓</td>
            <td>庞</td>
            <td>旁</td>
            <td>耪</td>
            <td>胖</td>
            <td>抛</td>
            <td>咆</td>
            <td>刨</td>
            <td>炮</td>
            <td>袍</td>
            <td>跑</td>
            <td>泡</td>
            <td>呸</td>
            <td>胚</td>
        </tr><tr><th>C5E0</th>
            <td>培</td>
            <td>裴</td>
            <td>赔</td>
            <td>陪</td>
            <td>配</td>
            <td>佩</td>
            <td>沛</td>
            <td>喷</td>
            <td>盆</td>
            <td>砰</td>
            <td>抨</td>
            <td>烹</td>
            <td>澎</td>
            <td>彭</td>
            <td>蓬</td>
            <td>棚</td>
        </tr><tr><th>C5F0</th>
            <td>硼</td>
            <td>篷</td>
            <td>膨</td>
            <td>朋</td>
            <td>鹏</td>
            <td>捧</td>
            <td>碰</td>
            <td>坯</td>
            <td>砒</td>
            <td>霹</td>
            <td>批</td>
            <td>披</td>
            <td>劈</td>
            <td>琵</td>
            <td>毗</td>
            <td> </td>
        </tr><tr><th>第38区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>C6A0</th>
            <td> </td>
            <td>啤</td>
            <td>脾</td>
            <td>疲</td>
            <td>皮</td>
            <td>匹</td>
            <td>痞</td>
            <td>僻</td>
            <td>屁</td>
            <td>譬</td>
            <td>篇</td>
            <td>偏</td>
            <td>片</td>
            <td>骗</td>
            <td>飘</td>
            <td>漂</td>
        </tr><tr><th>C6B0</th>
            <td>瓢</td>
            <td>票</td>
            <td>撇</td>
            <td>瞥</td>
            <td>拼</td>
            <td>频</td>
            <td>贫</td>
            <td>品</td>
            <td>聘</td>
            <td>乒</td>
            <td>坪</td>
            <td>苹</td>
            <td>萍</td>
            <td>平</td>
            <td>凭</td>
            <td>瓶</td>
        </tr><tr><th>C6C0</th>
            <td>评</td>
            <td>屏</td>
            <td>坡</td>
            <td>泼</td>
            <td>颇</td>
            <td>婆</td>
            <td>破</td>
            <td>魄</td>
            <td>迫</td>
            <td>粕</td>
            <td>剖</td>
            <td>扑</td>
            <td>铺</td>
            <td>仆</td>
            <td>莆</td>
            <td>葡</td>
        </tr><tr><th>C6D0</th>
            <td>菩</td>
            <td>蒲</td>
            <td>埔</td>
            <td>朴</td>
            <td>圃</td>
            <td>普</td>
            <td>浦</td>
            <td>谱</td>
            <td>曝</td>
            <td>瀑</td>
            <td>期</td>
            <td>欺</td>
            <td>栖</td>
            <td>戚</td>
            <td>妻</td>
            <td>七</td>
        </tr><tr><th>C6E0</th>
            <td>凄</td>
            <td>漆</td>
            <td>柒</td>
            <td>沏</td>
            <td>其</td>
            <td>棋</td>
            <td>奇</td>
            <td>歧</td>
            <td>畦</td>
            <td>崎</td>
            <td>脐</td>
            <td>齐</td>
            <td>旗</td>
            <td>祈</td>
            <td>祁</td>
            <td>骑</td>
        </tr><tr><th>C6F0</th>
            <td>起</td>
            <td>岂</td>
            <td>乞</td>
            <td>企</td>
            <td>启</td>
            <td>契</td>
            <td>砌</td>
            <td>器</td>
            <td>气</td>
            <td>迄</td>
            <td>弃</td>
            <td>汽</td>
            <td>泣</td>
            <td>讫</td>
            <td>掐</td>
            <td> </td>
        </tr><tr><th>第39区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>C7A0</th>
            <td> </td>
            <td>恰</td>
            <td>洽</td>
            <td>牵</td>
            <td>扦</td>
            <td>钎</td>
            <td>铅</td>
            <td>千</td>
            <td>迁</td>
            <td>签</td>
            <td>仟</td>
            <td>谦</td>
            <td>乾</td>
            <td>黔</td>
            <td>钱</td>
            <td>钳</td>
        </tr><tr><th>C7B0</th>
            <td>前</td>
            <td>潜</td>
            <td>遣</td>
            <td>浅</td>
            <td>谴</td>
            <td>堑</td>
            <td>嵌</td>
            <td>欠</td>
            <td>歉</td>
            <td>枪</td>
            <td>呛</td>
            <td>腔</td>
            <td>羌</td>
            <td>墙</td>
            <td>蔷</td>
            <td>强</td>
        </tr><tr><th>C7C0</th>
            <td>抢</td>
            <td>橇</td>
            <td>锹</td>
            <td>敲</td>
            <td>悄</td>
            <td>桥</td>
            <td>瞧</td>
            <td>乔</td>
            <td>侨</td>
            <td>巧</td>
            <td>鞘</td>
            <td>撬</td>
            <td>翘</td>
            <td>峭</td>
            <td>俏</td>
            <td>窍</td>
        </tr><tr><th>C7D0</th>
            <td>切</td>
            <td>茄</td>
            <td>且</td>
            <td>怯</td>
            <td>窃</td>
            <td>钦</td>
            <td>侵</td>
            <td>亲</td>
            <td>秦</td>
            <td>琴</td>
            <td>勤</td>
            <td>芹</td>
            <td>擒</td>
            <td>禽</td>
            <td>寝</td>
            <td>沁</td>
        </tr><tr><th>C7E0</th>
            <td>青</td>
            <td>轻</td>
            <td>氢</td>
            <td>倾</td>
            <td>卿</td>
            <td>清</td>
            <td>擎</td>
            <td>晴</td>
            <td>氰</td>
            <td>情</td>
            <td>顷</td>
            <td>请</td>
            <td>庆</td>
            <td>琼</td>
            <td>穷</td>
            <td>秋</td>
        </tr><tr><th>C7F0</th>
            <td>丘</td>
            <td>邱</td>
            <td>球</td>
            <td>求</td>
            <td>囚</td>
            <td>酋</td>
            <td>泅</td>
            <td>趋</td>
            <td>区</td>
            <td>蛆</td>
            <td>曲</td>
            <td>躯</td>
            <td>屈</td>
            <td>驱</td>
            <td>渠</td>
            <td> </td>
        </tr><tr><th>第40区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>C8A0</th>
            <td> </td>
            <td>取</td>
            <td>娶</td>
            <td>龋</td>
            <td>趣</td>
            <td>去</td>
            <td>圈</td>
            <td>颧</td>
            <td>权</td>
            <td>醛</td>
            <td>泉</td>
            <td>全</td>
            <td>痊</td>
            <td>拳</td>
            <td>犬</td>
            <td>券</td>
        </tr><tr><th>C8B0</th>
            <td>劝</td>
            <td>缺</td>
            <td>炔</td>
            <td>瘸</td>
            <td>却</td>
            <td>鹊</td>
            <td>榷</td>
            <td>确</td>
            <td>雀</td>
            <td>裙</td>
            <td>群</td>
            <td>然</td>
            <td>燃</td>
            <td>冉</td>
            <td>染</td>
            <td>瓤</td>
        </tr><tr><th>C8C0</th>
            <td>壤</td>
            <td>攘</td>
            <td>嚷</td>
            <td>让</td>
            <td>饶</td>
            <td>扰</td>
            <td>绕</td>
            <td>惹</td>
            <td>热</td>
            <td>壬</td>
            <td>仁</td>
            <td>人</td>
            <td>忍</td>
            <td>韧</td>
            <td>任</td>
            <td>认</td>
        </tr><tr><th>C8D0</th>
            <td>刃</td>
            <td>妊</td>
            <td>纫</td>
            <td>扔</td>
            <td>仍</td>
            <td>日</td>
            <td>戎</td>
            <td>茸</td>
            <td>蓉</td>
            <td>荣</td>
            <td>融</td>
            <td>熔</td>
            <td>溶</td>
            <td>容</td>
            <td>绒</td>
            <td>冗</td>
        </tr><tr><th>C8E0</th>
            <td>揉</td>
            <td>柔</td>
            <td>肉</td>
            <td>茹</td>
            <td>蠕</td>
            <td>儒</td>
            <td>孺</td>
            <td>如</td>
            <td>辱</td>
            <td>乳</td>
            <td>汝</td>
            <td>入</td>
            <td>褥</td>
            <td>软</td>
            <td>阮</td>
            <td>蕊</td>
        </tr><tr><th>C8F0</th>
            <td>瑞</td>
            <td>锐</td>
            <td>闰</td>
            <td>润</td>
            <td>若</td>
            <td>弱</td>
            <td>撒</td>
            <td>洒</td>
            <td>萨</td>
            <td>腮</td>
            <td>鳃</td>
            <td>塞</td>
            <td>赛</td>
            <td>三</td>
            <td>叁</td>
            <td> </td>
        </tr><tr><th>第41区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>C9A0</th>
            <td> </td>
            <td>伞</td>
            <td>散</td>
            <td>桑</td>
            <td>嗓</td>
            <td>丧</td>
            <td>搔</td>
            <td>骚</td>
            <td>扫</td>
            <td>嫂</td>
            <td>瑟</td>
            <td>色</td>
            <td>涩</td>
            <td>森</td>
            <td>僧</td>
            <td>莎</td>
        </tr><tr><th>C9B0</th>
            <td>砂</td>
            <td>杀</td>
            <td>刹</td>
            <td>沙</td>
            <td>纱</td>
            <td>傻</td>
            <td>啥</td>
            <td>煞</td>
            <td>筛</td>
            <td>晒</td>
            <td>珊</td>
            <td>苫</td>
            <td>杉</td>
            <td>山</td>
            <td>删</td>
            <td>煽</td>
        </tr><tr><th>C9C0</th>
            <td>衫</td>
            <td>闪</td>
            <td>陕</td>
            <td>擅</td>
            <td>赡</td>
            <td>膳</td>
            <td>善</td>
            <td>汕</td>
            <td>扇</td>
            <td>缮</td>
            <td>墒</td>
            <td>伤</td>
            <td>商</td>
            <td>赏</td>
            <td>晌</td>
            <td>上</td>
        </tr><tr><th>C9D0</th>
            <td>尚</td>
            <td>裳</td>
            <td>梢</td>
            <td>捎</td>
            <td>稍</td>
            <td>烧</td>
            <td>芍</td>
            <td>勺</td>
            <td>韶</td>
            <td>少</td>
            <td>哨</td>
            <td>邵</td>
            <td>绍</td>
            <td>奢</td>
            <td>赊</td>
            <td>蛇</td>
        </tr><tr><th>C9E0</th>
            <td>舌</td>
            <td>舍</td>
            <td>赦</td>
            <td>摄</td>
            <td>射</td>
            <td>慑</td>
            <td>涉</td>
            <td>社</td>
            <td>设</td>
            <td>砷</td>
            <td>申</td>
            <td>呻</td>
            <td>伸</td>
            <td>身</td>
            <td>深</td>
            <td>娠</td>
        </tr><tr><th>C9F0</th>
            <td>绅</td>
            <td>神</td>
            <td>沈</td>
            <td>审</td>
            <td>婶</td>
            <td>甚</td>
            <td>肾</td>
            <td>慎</td>
            <td>渗</td>
            <td>声</td>
            <td>生</td>
            <td>甥</td>
            <td>牲</td>
            <td>升</td>
            <td>绳</td>
            <td> </td>
        </tr><tr><th>第42区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>CAA0</th>
            <td> </td>
            <td>省</td>
            <td>盛</td>
            <td>剩</td>
            <td>胜</td>
            <td>圣</td>
            <td>师</td>
            <td>失</td>
            <td>狮</td>
            <td>施</td>
            <td>湿</td>
            <td>诗</td>
            <td>尸</td>
            <td>虱</td>
            <td>十</td>
            <td>石</td>
        </tr><tr><th>CAB0</th>
            <td>拾</td>
            <td>时</td>
            <td>什</td>
            <td>食</td>
            <td>蚀</td>
            <td>实</td>
            <td>识</td>
            <td>史</td>
            <td>矢</td>
            <td>使</td>
            <td>屎</td>
            <td>驶</td>
            <td>始</td>
            <td>式</td>
            <td>示</td>
            <td>士</td>
        </tr><tr><th>CAC0</th>
            <td>世</td>
            <td>柿</td>
            <td>事</td>
            <td>拭</td>
            <td>誓</td>
            <td>逝</td>
            <td>势</td>
            <td>是</td>
            <td>嗜</td>
            <td>噬</td>
            <td>适</td>
            <td>仕</td>
            <td>侍</td>
            <td>释</td>
            <td>饰</td>
            <td>氏</td>
        </tr><tr><th>CAD0</th>
            <td>市</td>
            <td>恃</td>
            <td>室</td>
            <td>视</td>
            <td>试</td>
            <td>收</td>
            <td>手</td>
            <td>首</td>
            <td>守</td>
            <td>寿</td>
            <td>授</td>
            <td>售</td>
            <td>受</td>
            <td>瘦</td>
            <td>兽</td>
            <td>蔬</td>
        </tr><tr><th>CAE0</th>
            <td>枢</td>
            <td>梳</td>
            <td>殊</td>
            <td>抒</td>
            <td>输</td>
            <td>叔</td>
            <td>舒</td>
            <td>淑</td>
            <td>疏</td>
            <td>书</td>
            <td>赎</td>
            <td>孰</td>
            <td>熟</td>
            <td>薯</td>
            <td>暑</td>
            <td>曙</td>
        </tr><tr><th>CAF0</th>
            <td>署</td>
            <td>蜀</td>
            <td>黍</td>
            <td>鼠</td>
            <td>属</td>
            <td>术</td>
            <td>述</td>
            <td>树</td>
            <td>束</td>
            <td>戍</td>
            <td>竖</td>
            <td>墅</td>
            <td>庶</td>
            <td>数</td>
            <td>漱</td>
            <td> </td>
        </tr><tr><th>第43区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>CBA0</th>
            <td> </td>
            <td>恕</td>
            <td>刷</td>
            <td>耍</td>
            <td>摔</td>
            <td>衰</td>
            <td>甩</td>
            <td>帅</td>
            <td>栓</td>
            <td>拴</td>
            <td>霜</td>
            <td>双</td>
            <td>爽</td>
            <td>谁</td>
            <td>水</td>
            <td>睡</td>
        </tr><tr><th>CBB0</th>
            <td>税</td>
            <td>吮</td>
            <td>瞬</td>
            <td>顺</td>
            <td>舜</td>
            <td>说</td>
            <td>硕</td>
            <td>朔</td>
            <td>烁</td>
            <td>斯</td>
            <td>撕</td>
            <td>嘶</td>
            <td>思</td>
            <td>私</td>
            <td>司</td>
            <td>丝</td>
        </tr><tr><th>CBC0</th>
            <td>死</td>
            <td>肆</td>
            <td>寺</td>
            <td>嗣</td>
            <td>四</td>
            <td>伺</td>
            <td>似</td>
            <td>饲</td>
            <td>巳</td>
            <td>松</td>
            <td>耸</td>
            <td>怂</td>
            <td>颂</td>
            <td>送</td>
            <td>宋</td>
            <td>讼</td>
        </tr><tr><th>CBD0</th>
            <td>诵</td>
            <td>搜</td>
            <td>艘</td>
            <td>擞</td>
            <td>嗽</td>
            <td>苏</td>
            <td>酥</td>
            <td>俗</td>
            <td>素</td>
            <td>速</td>
            <td>粟</td>
            <td>僳</td>
            <td>塑</td>
            <td>溯</td>
            <td>宿</td>
            <td>诉</td>
        </tr><tr><th>CBE0</th>
            <td>肃</td>
            <td>酸</td>
            <td>蒜</td>
            <td>算</td>
            <td>虽</td>
            <td>隋</td>
            <td>随</td>
            <td>绥</td>
            <td>髓</td>
            <td>碎</td>
            <td>岁</td>
            <td>穗</td>
            <td>遂</td>
            <td>隧</td>
            <td>祟</td>
            <td>孙</td>
        </tr><tr><th>CBF0</th>
            <td>损</td>
            <td>笋</td>
            <td>蓑</td>
            <td>梭</td>
            <td>唆</td>
            <td>缩</td>
            <td>琐</td>
            <td>索</td>
            <td>锁</td>
            <td>所</td>
            <td>塌</td>
            <td>他</td>
            <td>它</td>
            <td>她</td>
            <td>塔</td>
            <td> </td>
        </tr><tr><th>第44区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>CCA0</th>
            <td> </td>
            <td>獭</td>
            <td>挞</td>
            <td>蹋</td>
            <td>踏</td>
            <td>胎</td>
            <td>苔</td>
            <td>抬</td>
            <td>台</td>
            <td>泰</td>
            <td>酞</td>
            <td>太</td>
            <td>态</td>
            <td>汰</td>
            <td>坍</td>
            <td>摊</td>
        </tr><tr><th>CCB0</th>
            <td>贪</td>
            <td>瘫</td>
            <td>滩</td>
            <td>坛</td>
            <td>檀</td>
            <td>痰</td>
            <td>潭</td>
            <td>谭</td>
            <td>谈</td>
            <td>坦</td>
            <td>毯</td>
            <td>袒</td>
            <td>碳</td>
            <td>探</td>
            <td>叹</td>
            <td>炭</td>
        </tr><tr><th>CCC0</th>
            <td>汤</td>
            <td>塘</td>
            <td>搪</td>
            <td>堂</td>
            <td>棠</td>
            <td>膛</td>
            <td>唐</td>
            <td>糖</td>
            <td>倘</td>
            <td>躺</td>
            <td>淌</td>
            <td>趟</td>
            <td>烫</td>
            <td>掏</td>
            <td>涛</td>
            <td>滔</td>
        </tr><tr><th>CCD0</th>
            <td>绦</td>
            <td>萄</td>
            <td>桃</td>
            <td>逃</td>
            <td>淘</td>
            <td>陶</td>
            <td>讨</td>
            <td>套</td>
            <td>特</td>
            <td>藤</td>
            <td>腾</td>
            <td>疼</td>
            <td>誊</td>
            <td>梯</td>
            <td>剔</td>
            <td>踢</td>
        </tr><tr><th>CCE0</th>
            <td>锑</td>
            <td>提</td>
            <td>题</td>
            <td>蹄</td>
            <td>啼</td>
            <td>体</td>
            <td>替</td>
            <td>嚏</td>
            <td>惕</td>
            <td>涕</td>
            <td>剃</td>
            <td>屉</td>
            <td>天</td>
            <td>添</td>
            <td>填</td>
            <td>田</td>
        </tr><tr><th>CCF0</th>
            <td>甜</td>
            <td>恬</td>
            <td>舔</td>
            <td>腆</td>
            <td>挑</td>
            <td>条</td>
            <td>迢</td>
            <td>眺</td>
            <td>跳</td>
            <td>贴</td>
            <td>铁</td>
            <td>帖</td>
            <td>厅</td>
            <td>听</td>
            <td>烃</td>
            <td> </td>
        </tr><tr><th>第45区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>CDA0</th>
            <td> </td>
            <td>汀</td>
            <td>廷</td>
            <td>停</td>
            <td>亭</td>
            <td>庭</td>
            <td>挺</td>
            <td>艇</td>
            <td>通</td>
            <td>桐</td>
            <td>酮</td>
            <td>瞳</td>
            <td>同</td>
            <td>铜</td>
            <td>彤</td>
            <td>童</td>
        </tr><tr><th>CDB0</th>
            <td>桶</td>
            <td>捅</td>
            <td>筒</td>
            <td>统</td>
            <td>痛</td>
            <td>偷</td>
            <td>投</td>
            <td>头</td>
            <td>透</td>
            <td>凸</td>
            <td>秃</td>
            <td>突</td>
            <td>图</td>
            <td>徒</td>
            <td>途</td>
            <td>涂</td>
        </tr><tr><th>CDC0</th>
            <td>屠</td>
            <td>土</td>
            <td>吐</td>
            <td>兔</td>
            <td>湍</td>
            <td>团</td>
            <td>推</td>
            <td>颓</td>
            <td>腿</td>
            <td>蜕</td>
            <td>褪</td>
            <td>退</td>
            <td>吞</td>
            <td>屯</td>
            <td>臀</td>
            <td>拖</td>
        </tr><tr><th>CDD0</th>
            <td>托</td>
            <td>脱</td>
            <td>鸵</td>
            <td>陀</td>
            <td>驮</td>
            <td>驼</td>
            <td>椭</td>
            <td>妥</td>
            <td>拓</td>
            <td>唾</td>
            <td>挖</td>
            <td>哇</td>
            <td>蛙</td>
            <td>洼</td>
            <td>娃</td>
            <td>瓦</td>
        </tr><tr><th>CDE0</th>
            <td>袜</td>
            <td>歪</td>
            <td>外</td>
            <td>豌</td>
            <td>弯</td>
            <td>湾</td>
            <td>玩</td>
            <td>顽</td>
            <td>丸</td>
            <td>烷</td>
            <td>完</td>
            <td>碗</td>
            <td>挽</td>
            <td>晚</td>
            <td>皖</td>
            <td>惋</td>
        </tr><tr><th>CDF0</th>
            <td>宛</td>
            <td>婉</td>
            <td>万</td>
            <td>腕</td>
            <td>汪</td>
            <td>王</td>
            <td>亡</td>
            <td>枉</td>
            <td>网</td>
            <td>往</td>
            <td>旺</td>
            <td>望</td>
            <td>忘</td>
            <td>妄</td>
            <td>威</td>
            <td> </td>
        </tr><tr><th>第46区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>CEA0</th>
            <td> </td>
            <td>巍</td>
            <td>微</td>
            <td>危</td>
            <td>韦</td>
            <td>违</td>
            <td>桅</td>
            <td>围</td>
            <td>唯</td>
            <td>惟</td>
            <td>为</td>
            <td>潍</td>
            <td>维</td>
            <td>苇</td>
            <td>萎</td>
            <td>委</td>
        </tr><tr><th>CEB0</th>
            <td>伟</td>
            <td>伪</td>
            <td>尾</td>
            <td>纬</td>
            <td>未</td>
            <td>蔚</td>
            <td>味</td>
            <td>畏</td>
            <td>胃</td>
            <td>喂</td>
            <td>魏</td>
            <td>位</td>
            <td>渭</td>
            <td>谓</td>
            <td>尉</td>
            <td>慰</td>
        </tr><tr><th>CEC0</th>
            <td>卫</td>
            <td>瘟</td>
            <td>温</td>
            <td>蚊</td>
            <td>文</td>
            <td>闻</td>
            <td>纹</td>
            <td>吻</td>
            <td>稳</td>
            <td>紊</td>
            <td>问</td>
            <td>嗡</td>
            <td>翁</td>
            <td>瓮</td>
            <td>挝</td>
            <td>蜗</td>
        </tr><tr><th>CED0</th>
            <td>涡</td>
            <td>窝</td>
            <td>我</td>
            <td>斡</td>
            <td>卧</td>
            <td>握</td>
            <td>沃</td>
            <td>巫</td>
            <td>呜</td>
            <td>钨</td>
            <td>乌</td>
            <td>污</td>
            <td>诬</td>
            <td>屋</td>
            <td>无</td>
            <td>芜</td>
        </tr><tr><th>CEE0</th>
            <td>梧</td>
            <td>吾</td>
            <td>吴</td>
            <td>毋</td>
            <td>武</td>
            <td>五</td>
            <td>捂</td>
            <td>午</td>
            <td>舞</td>
            <td>伍</td>
            <td>侮</td>
            <td>坞</td>
            <td>戊</td>
            <td>雾</td>
            <td>晤</td>
            <td>物</td>
        </tr><tr><th>CEF0</th>
            <td>勿</td>
            <td>务</td>
            <td>悟</td>
            <td>误</td>
            <td>昔</td>
            <td>熙</td>
            <td>析</td>
            <td>西</td>
            <td>硒</td>
            <td>矽</td>
            <td>晰</td>
            <td>嘻</td>
            <td>吸</td>
            <td>锡</td>
            <td>牺</td>
            <td> </td>
        </tr><tr><th>第47区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>CFA0</th>
            <td> </td>
            <td>稀</td>
            <td>息</td>
            <td>希</td>
            <td>悉</td>
            <td>膝</td>
            <td>夕</td>
            <td>惜</td>
            <td>熄</td>
            <td>烯</td>
            <td>溪</td>
            <td>汐</td>
            <td>犀</td>
            <td>檄</td>
            <td>袭</td>
            <td>席</td>
        </tr><tr><th>CFB0</th>
            <td>习</td>
            <td>媳</td>
            <td>喜</td>
            <td>铣</td>
            <td>洗</td>
            <td>系</td>
            <td>隙</td>
            <td>戏</td>
            <td>细</td>
            <td>瞎</td>
            <td>虾</td>
            <td>匣</td>
            <td>霞</td>
            <td>辖</td>
            <td>暇</td>
            <td>峡</td>
        </tr><tr><th>CFC0</th>
            <td>侠</td>
            <td>狭</td>
            <td>下</td>
            <td>厦</td>
            <td>夏</td>
            <td>吓</td>
            <td>掀</td>
            <td>锨</td>
            <td>先</td>
            <td>仙</td>
            <td>鲜</td>
            <td>纤</td>
            <td>咸</td>
            <td>贤</td>
            <td>衔</td>
            <td>舷</td>
        </tr><tr><th>CFD0</th>
            <td>闲</td>
            <td>涎</td>
            <td>弦</td>
            <td>嫌</td>
            <td>显</td>
            <td>险</td>
            <td>现</td>
            <td>献</td>
            <td>县</td>
            <td>腺</td>
            <td>馅</td>
            <td>羡</td>
            <td>宪</td>
            <td>陷</td>
            <td>限</td>
            <td>线</td>
        </tr><tr><th>CFE0</th>
            <td>相</td>
            <td>厢</td>
            <td>镶</td>
            <td>香</td>
            <td>箱</td>
            <td>襄</td>
            <td>湘</td>
            <td>乡</td>
            <td>翔</td>
            <td>祥</td>
            <td>详</td>
            <td>想</td>
            <td>响</td>
            <td>享</td>
            <td>项</td>
            <td>巷</td>
        </tr><tr><th>CFF0</th>
            <td>橡</td>
            <td>像</td>
            <td>向</td>
            <td>象</td>
            <td>萧</td>
            <td>硝</td>
            <td>霄</td>
            <td>削</td>
            <td>哮</td>
            <td>嚣</td>
            <td>销</td>
            <td>消</td>
            <td>宵</td>
            <td>淆</td>
            <td>晓</td>
            <td> </td>
        </tr><tr><th>第48区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>D0A0</th>
            <td> </td>
            <td>小</td>
            <td>孝</td>
            <td>校</td>
            <td>肖</td>
            <td>啸</td>
            <td>笑</td>
            <td>效</td>
            <td>楔</td>
            <td>些</td>
            <td>歇</td>
            <td>蝎</td>
            <td>鞋</td>
            <td>协</td>
            <td>挟</td>
            <td>携</td>
        </tr><tr><th>D0B0</th>
            <td>邪</td>
            <td>斜</td>
            <td>胁</td>
            <td>谐</td>
            <td>写</td>
            <td>械</td>
            <td>卸</td>
            <td>蟹</td>
            <td>懈</td>
            <td>泄</td>
            <td>泻</td>
            <td>谢</td>
            <td>屑</td>
            <td>薪</td>
            <td>芯</td>
            <td>锌</td>
        </tr><tr><th>D0C0</th>
            <td>欣</td>
            <td>辛</td>
            <td>新</td>
            <td>忻</td>
            <td>心</td>
            <td>信</td>
            <td>衅</td>
            <td>星</td>
            <td>腥</td>
            <td>猩</td>
            <td>惺</td>
            <td>兴</td>
            <td>刑</td>
            <td>型</td>
            <td>形</td>
            <td>邢</td>
        </tr><tr><th>D0D0</th>
            <td>行</td>
            <td>醒</td>
            <td>幸</td>
            <td>杏</td>
            <td>性</td>
            <td>姓</td>
            <td>兄</td>
            <td>凶</td>
            <td>胸</td>
            <td>匈</td>
            <td>汹</td>
            <td>雄</td>
            <td>熊</td>
            <td>休</td>
            <td>修</td>
            <td>羞</td>
        </tr><tr><th>D0E0</th>
            <td>朽</td>
            <td>嗅</td>
            <td>锈</td>
            <td>秀</td>
            <td>袖</td>
            <td>绣</td>
            <td>墟</td>
            <td>戌</td>
            <td>需</td>
            <td>虚</td>
            <td>嘘</td>
            <td>须</td>
            <td>徐</td>
            <td>许</td>
            <td>蓄</td>
            <td>酗</td>
        </tr><tr><th>D0F0</th>
            <td>叙</td>
            <td>旭</td>
            <td>序</td>
            <td>畜</td>
            <td>恤</td>
            <td>絮</td>
            <td>婿</td>
            <td>绪</td>
            <td>续</td>
            <td>轩</td>
            <td>喧</td>
            <td>宣</td>
            <td>悬</td>
            <td>旋</td>
            <td>玄</td>
            <td> </td>
        </tr><tr><th>第49区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>D1A0</th>
            <td> </td>
            <td>选</td>
            <td>癣</td>
            <td>眩</td>
            <td>绚</td>
            <td>靴</td>
            <td>薛</td>
            <td>学</td>
            <td>穴</td>
            <td>雪</td>
            <td>血</td>
            <td>勋</td>
            <td>熏</td>
            <td>循</td>
            <td>旬</td>
            <td>询</td>
        </tr><tr><th>D1B0</th>
            <td>寻</td>
            <td>驯</td>
            <td>巡</td>
            <td>殉</td>
            <td>汛</td>
            <td>训</td>
            <td>讯</td>
            <td>逊</td>
            <td>迅</td>
            <td>压</td>
            <td>押</td>
            <td>鸦</td>
            <td>鸭</td>
            <td>呀</td>
            <td>丫</td>
            <td>芽</td>
        </tr><tr><th>D1C0</th>
            <td>牙</td>
            <td>蚜</td>
            <td>崖</td>
            <td>衙</td>
            <td>涯</td>
            <td>雅</td>
            <td>哑</td>
            <td>亚</td>
            <td>讶</td>
            <td>焉</td>
            <td>咽</td>
            <td>阉</td>
            <td>烟</td>
            <td>淹</td>
            <td>盐</td>
            <td>严</td>
        </tr><tr><th>D1D0</th>
            <td>研</td>
            <td>蜒</td>
            <td>岩</td>
            <td>延</td>
            <td>言</td>
            <td>颜</td>
            <td>阎</td>
            <td>炎</td>
            <td>沿</td>
            <td>奄</td>
            <td>掩</td>
            <td>眼</td>
            <td>衍</td>
            <td>演</td>
            <td>艳</td>
            <td>堰</td>
        </tr><tr><th>D1E0</th>
            <td>燕</td>
            <td>厌</td>
            <td>砚</td>
            <td>雁</td>
            <td>唁</td>
            <td>彦</td>
            <td>焰</td>
            <td>宴</td>
            <td>谚</td>
            <td>验</td>
            <td>殃</td>
            <td>央</td>
            <td>鸯</td>
            <td>秧</td>
            <td>杨</td>
            <td>扬</td>
        </tr><tr><th>D1F0</th>
            <td>佯</td>
            <td>疡</td>
            <td>羊</td>
            <td>洋</td>
            <td>阳</td>
            <td>氧</td>
            <td>仰</td>
            <td>痒</td>
            <td>养</td>
            <td>样</td>
            <td>漾</td>
            <td>邀</td>
            <td>腰</td>
            <td>妖</td>
            <td>瑶</td>
            <td> </td>
        </tr><tr><th>第50区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>D2A0</th>
            <td> </td>
            <td>摇</td>
            <td>尧</td>
            <td>遥</td>
            <td>窑</td>
            <td>谣</td>
            <td>姚</td>
            <td>咬</td>
            <td>舀</td>
            <td>药</td>
            <td>要</td>
            <td>耀</td>
            <td>椰</td>
            <td>噎</td>
            <td>耶</td>
            <td>爷</td>
        </tr><tr><th>D2B0</th>
            <td>野</td>
            <td>冶</td>
            <td>也</td>
            <td>页</td>
            <td>掖</td>
            <td>业</td>
            <td>叶</td>
            <td>曳</td>
            <td>腋</td>
            <td>夜</td>
            <td>液</td>
            <td>一</td>
            <td>壹</td>
            <td>医</td>
            <td>揖</td>
            <td>铱</td>
        </tr><tr><th>D2C0</th>
            <td>依</td>
            <td>伊</td>
            <td>衣</td>
            <td>颐</td>
            <td>夷</td>
            <td>遗</td>
            <td>移</td>
            <td>仪</td>
            <td>胰</td>
            <td>疑</td>
            <td>沂</td>
            <td>宜</td>
            <td>姨</td>
            <td>彝</td>
            <td>椅</td>
            <td>蚁</td>
        </tr><tr><th>D2D0</th>
            <td>倚</td>
            <td>已</td>
            <td>乙</td>
            <td>矣</td>
            <td>以</td>
            <td>艺</td>
            <td>抑</td>
            <td>易</td>
            <td>邑</td>
            <td>屹</td>
            <td>亿</td>
            <td>役</td>
            <td>臆</td>
            <td>逸</td>
            <td>肄</td>
            <td>疫</td>
        </tr><tr><th>D2E0</th>
            <td>亦</td>
            <td>裔</td>
            <td>意</td>
            <td>毅</td>
            <td>忆</td>
            <td>义</td>
            <td>益</td>
            <td>溢</td>
            <td>诣</td>
            <td>议</td>
            <td>谊</td>
            <td>译</td>
            <td>异</td>
            <td>翼</td>
            <td>翌</td>
            <td>绎</td>
        </tr><tr><th>D2F0</th>
            <td>茵</td>
            <td>荫</td>
            <td>因</td>
            <td>殷</td>
            <td>音</td>
            <td>阴</td>
            <td>姻</td>
            <td>吟</td>
            <td>银</td>
            <td>淫</td>
            <td>寅</td>
            <td>饮</td>
            <td>尹</td>
            <td>引</td>
            <td>隐</td>
            <td> </td>
        </tr><tr><th>第51区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>D3A0</th>
            <td> </td>
            <td>印</td>
            <td>英</td>
            <td>樱</td>
            <td>婴</td>
            <td>鹰</td>
            <td>应</td>
            <td>缨</td>
            <td>莹</td>
            <td>萤</td>
            <td>营</td>
            <td>荧</td>
            <td>蝇</td>
            <td>迎</td>
            <td>赢</td>
            <td>盈</td>
        </tr><tr><th>D3B0</th>
            <td>影</td>
            <td>颖</td>
            <td>硬</td>
            <td>映</td>
            <td>哟</td>
            <td>拥</td>
            <td>佣</td>
            <td>臃</td>
            <td>痈</td>
            <td>庸</td>
            <td>雍</td>
            <td>踊</td>
            <td>蛹</td>
            <td>咏</td>
            <td>泳</td>
            <td>涌</td>
        </tr><tr><th>D3C0</th>
            <td>永</td>
            <td>恿</td>
            <td>勇</td>
            <td>用</td>
            <td>幽</td>
            <td>优</td>
            <td>悠</td>
            <td>忧</td>
            <td>尤</td>
            <td>由</td>
            <td>邮</td>
            <td>铀</td>
            <td>犹</td>
            <td>油</td>
            <td>游</td>
            <td>酉</td>
        </tr><tr><th>D3D0</th>
            <td>有</td>
            <td>友</td>
            <td>右</td>
            <td>佑</td>
            <td>釉</td>
            <td>诱</td>
            <td>又</td>
            <td>幼</td>
            <td>迂</td>
            <td>淤</td>
            <td>于</td>
            <td>盂</td>
            <td>榆</td>
            <td>虞</td>
            <td>愚</td>
            <td>舆</td>
        </tr><tr><th>D3E0</th>
            <td>余</td>
            <td>俞</td>
            <td>逾</td>
            <td>鱼</td>
            <td>愉</td>
            <td>渝</td>
            <td>渔</td>
            <td>隅</td>
            <td>予</td>
            <td>娱</td>
            <td>雨</td>
            <td>与</td>
            <td>屿</td>
            <td>禹</td>
            <td>宇</td>
            <td>语</td>
        </tr><tr><th>D3F0</th>
            <td>羽</td>
            <td>玉</td>
            <td>域</td>
            <td>芋</td>
            <td>郁</td>
            <td>吁</td>
            <td>遇</td>
            <td>喻</td>
            <td>峪</td>
            <td>御</td>
            <td>愈</td>
            <td>欲</td>
            <td>狱</td>
            <td>育</td>
            <td>誉</td>
            <td> </td>
        </tr><tr><th>第52区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>D4A0</th>
            <td> </td>
            <td>浴</td>
            <td>寓</td>
            <td>裕</td>
            <td>预</td>
            <td>豫</td>
            <td>驭</td>
            <td>鸳</td>
            <td>渊</td>
            <td>冤</td>
            <td>元</td>
            <td>垣</td>
            <td>袁</td>
            <td>原</td>
            <td>援</td>
            <td>辕</td>
        </tr><tr><th>D4B0</th>
            <td>园</td>
            <td>员</td>
            <td>圆</td>
            <td>猿</td>
            <td>源</td>
            <td>缘</td>
            <td>远</td>
            <td>苑</td>
            <td>愿</td>
            <td>怨</td>
            <td>院</td>
            <td>曰</td>
            <td>约</td>
            <td>越</td>
            <td>跃</td>
            <td>钥</td>
        </tr><tr><th>D4C0</th>
            <td>岳</td>
            <td>粤</td>
            <td>月</td>
            <td>悦</td>
            <td>阅</td>
            <td>耘</td>
            <td>云</td>
            <td>郧</td>
            <td>匀</td>
            <td>陨</td>
            <td>允</td>
            <td>运</td>
            <td>蕴</td>
            <td>酝</td>
            <td>晕</td>
            <td>韵</td>
        </tr><tr><th>D4D0</th>
            <td>孕</td>
            <td>匝</td>
            <td>砸</td>
            <td>杂</td>
            <td>栽</td>
            <td>哉</td>
            <td>灾</td>
            <td>宰</td>
            <td>载</td>
            <td>再</td>
            <td>在</td>
            <td>咱</td>
            <td>攒</td>
            <td>暂</td>
            <td>赞</td>
            <td>赃</td>
        </tr><tr><th>D4E0</th>
            <td>脏</td>
            <td>葬</td>
            <td>遭</td>
            <td>糟</td>
            <td>凿</td>
            <td>藻</td>
            <td>枣</td>
            <td>早</td>
            <td>澡</td>
            <td>蚤</td>
            <td>躁</td>
            <td>噪</td>
            <td>造</td>
            <td>皂</td>
            <td>灶</td>
            <td>燥</td>
        </tr><tr><th>D4F0</th>
            <td>责</td>
            <td>择</td>
            <td>则</td>
            <td>泽</td>
            <td>贼</td>
            <td>怎</td>
            <td>增</td>
            <td>憎</td>
            <td>曾</td>
            <td>赠</td>
            <td>扎</td>
            <td>喳</td>
            <td>渣</td>
            <td>札</td>
            <td>轧</td>
            <td> </td>
        </tr><tr><th>第53区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>D5A0</th>
            <td> </td>
            <td>铡</td>
            <td>闸</td>
            <td>眨</td>
            <td>栅</td>
            <td>榨</td>
            <td>咋</td>
            <td>乍</td>
            <td>炸</td>
            <td>诈</td>
            <td>摘</td>
            <td>斋</td>
            <td>宅</td>
            <td>窄</td>
            <td>债</td>
            <td>寨</td>
        </tr><tr><th>D5B0</th>
            <td>瞻</td>
            <td>毡</td>
            <td>詹</td>
            <td>粘</td>
            <td>沾</td>
            <td>盏</td>
            <td>斩</td>
            <td>辗</td>
            <td>崭</td>
            <td>展</td>
            <td>蘸</td>
            <td>栈</td>
            <td>占</td>
            <td>战</td>
            <td>站</td>
            <td>湛</td>
        </tr><tr><th>D5C0</th>
            <td>绽</td>
            <td>樟</td>
            <td>章</td>
            <td>彰</td>
            <td>漳</td>
            <td>张</td>
            <td>掌</td>
            <td>涨</td>
            <td>杖</td>
            <td>丈</td>
            <td>帐</td>
            <td>账</td>
            <td>仗</td>
            <td>胀</td>
            <td>瘴</td>
            <td>障</td>
        </tr><tr><th>D5D0</th>
            <td>招</td>
            <td>昭</td>
            <td>找</td>
            <td>沼</td>
            <td>赵</td>
            <td>照</td>
            <td>罩</td>
            <td>兆</td>
            <td>肇</td>
            <td>召</td>
            <td>遮</td>
            <td>折</td>
            <td>哲</td>
            <td>蛰</td>
            <td>辙</td>
            <td>者</td>
        </tr><tr><th>D5E0</th>
            <td>锗</td>
            <td>蔗</td>
            <td>这</td>
            <td>浙</td>
            <td>珍</td>
            <td>斟</td>
            <td>真</td>
            <td>甄</td>
            <td>砧</td>
            <td>臻</td>
            <td>贞</td>
            <td>针</td>
            <td>侦</td>
            <td>枕</td>
            <td>疹</td>
            <td>诊</td>
        </tr><tr><th>D5F0</th>
            <td>震</td>
            <td>振</td>
            <td>镇</td>
            <td>阵</td>
            <td>蒸</td>
            <td>挣</td>
            <td>睁</td>
            <td>征</td>
            <td>狰</td>
            <td>争</td>
            <td>怔</td>
            <td>整</td>
            <td>拯</td>
            <td>正</td>
            <td>政</td>
            <td> </td>
        </tr><tr><th>第54区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>D6A0</th>
            <td> </td>
            <td>帧</td>
            <td>症</td>
            <td>郑</td>
            <td>证</td>
            <td>芝</td>
            <td>枝</td>
            <td>支</td>
            <td>吱</td>
            <td>蜘</td>
            <td>知</td>
            <td>肢</td>
            <td>脂</td>
            <td>汁</td>
            <td>之</td>
            <td>织</td>
        </tr><tr><th>D6B0</th>
            <td>职</td>
            <td>直</td>
            <td>植</td>
            <td>殖</td>
            <td>执</td>
            <td>值</td>
            <td>侄</td>
            <td>址</td>
            <td>指</td>
            <td>止</td>
            <td>趾</td>
            <td>只</td>
            <td>旨</td>
            <td>纸</td>
            <td>志</td>
            <td>挚</td>
        </tr><tr><th>D6C0</th>
            <td>掷</td>
            <td>至</td>
            <td>致</td>
            <td>置</td>
            <td>帜</td>
            <td>峙</td>
            <td>制</td>
            <td>智</td>
            <td>秩</td>
            <td>稚</td>
            <td>质</td>
            <td>炙</td>
            <td>痔</td>
            <td>滞</td>
            <td>治</td>
            <td>窒</td>
        </tr><tr><th>D6D0</th>
            <td>中</td>
            <td>盅</td>
            <td>忠</td>
            <td>钟</td>
            <td>衷</td>
            <td>终</td>
            <td>种</td>
            <td>肿</td>
            <td>重</td>
            <td>仲</td>
            <td>众</td>
            <td>舟</td>
            <td>周</td>
            <td>州</td>
            <td>洲</td>
            <td>诌</td>
        </tr><tr><th>D6E0</th>
            <td>粥</td>
            <td>轴</td>
            <td>肘</td>
            <td>帚</td>
            <td>咒</td>
            <td>皱</td>
            <td>宙</td>
            <td>昼</td>
            <td>骤</td>
            <td>珠</td>
            <td>株</td>
            <td>蛛</td>
            <td>朱</td>
            <td>猪</td>
            <td>诸</td>
            <td>诛</td>
        </tr><tr><th>D6F0</th>
            <td>逐</td>
            <td>竹</td>
            <td>烛</td>
            <td>煮</td>
            <td>拄</td>
            <td>瞩</td>
            <td>嘱</td>
            <td>主</td>
            <td>著</td>
            <td>柱</td>
            <td>助</td>
            <td>蛀</td>
            <td>贮</td>
            <td>铸</td>
            <td>筑</td>
            <td> </td>
        </tr><tr><th>第55区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>D7A0</th>
            <td> </td>
            <td>住</td>
            <td>注</td>
            <td>祝</td>
            <td>驻</td>
            <td>抓</td>
            <td>爪</td>
            <td>拽</td>
            <td>专</td>
            <td>砖</td>
            <td>转</td>
            <td>撰</td>
            <td>赚</td>
            <td>篆</td>
            <td>桩</td>
            <td>庄</td>
        </tr><tr><th>D7B0</th>
            <td>装</td>
            <td>妆</td>
            <td>撞</td>
            <td>壮</td>
            <td>状</td>
            <td>椎</td>
            <td>锥</td>
            <td>追</td>
            <td>赘</td>
            <td>坠</td>
            <td>缀</td>
            <td>谆</td>
            <td>准</td>
            <td>捉</td>
            <td>拙</td>
            <td>卓</td>
        </tr><tr><th>D7C0</th>
            <td>桌</td>
            <td>琢</td>
            <td>茁</td>
            <td>酌</td>
            <td>啄</td>
            <td>着</td>
            <td>灼</td>
            <td>浊</td>
            <td>兹</td>
            <td>咨</td>
            <td>资</td>
            <td>姿</td>
            <td>滋</td>
            <td>淄</td>
            <td>孜</td>
            <td>紫</td>
        </tr><tr><th>D7D0</th>
            <td>仔</td>
            <td>籽</td>
            <td>滓</td>
            <td>子</td>
            <td>自</td>
            <td>渍</td>
            <td>字</td>
            <td>鬃</td>
            <td>棕</td>
            <td>踪</td>
            <td>宗</td>
            <td>综</td>
            <td>总</td>
            <td>纵</td>
            <td>邹</td>
            <td>走</td>
        </tr><tr><th>D7E0</th>
            <td>奏</td>
            <td>揍</td>
            <td>租</td>
            <td>足</td>
            <td>卒</td>
            <td>族</td>
            <td>祖</td>
            <td>诅</td>
            <td>阻</td>
            <td>组</td>
            <td>钻</td>
            <td>纂</td>
            <td>嘴</td>
            <td>醉</td>
            <td>最</td>
            <td>罪</td>
        </tr><tr><th>D7F0</th>
            <td>尊</td>
            <td>遵</td>
            <td>昨</td>
            <td>左</td>
            <td>佐</td>
            <td>柞</td>
            <td>做</td>
            <td>作</td>
            <td>坐</td>
            <td>座</td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
            <td> </td>
        </tr><tr><th>第56区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>D8A0</th>
            <td> </td>
            <td>亍</td>
            <td>丌</td>
            <td>兀</td>
            <td>丐</td>
            <td>廿</td>
            <td>卅</td>
            <td>丕</td>
            <td>亘</td>
            <td>丞</td>
            <td>鬲</td>
            <td>孬</td>
            <td>噩</td>
            <td>丨</td>
            <td>禺</td>
            <td>丿</td>
        </tr><tr><th>D8B0</th>
            <td>匕</td>
            <td>乇</td>
            <td>夭</td>
            <td>爻</td>
            <td>卮</td>
            <td>氐</td>
            <td>囟</td>
            <td>胤</td>
            <td>馗</td>
            <td>毓</td>
            <td>睾</td>
            <td>鼗</td>
            <td>丶</td>
            <td>亟</td>
            <td>鼐</td>
            <td>乜</td>
        </tr><tr><th>D8C0</th>
            <td>乩</td>
            <td>亓</td>
            <td>芈</td>
            <td>孛</td>
            <td>啬</td>
            <td>嘏</td>
            <td>仄</td>
            <td>厍</td>
            <td>厝</td>
            <td>厣</td>
            <td>厥</td>
            <td>厮</td>
            <td>靥</td>
            <td>赝</td>
            <td>匚</td>
            <td>叵</td>
        </tr><tr><th>D8D0</th>
            <td>匦</td>
            <td>匮</td>
            <td>匾</td>
            <td>赜</td>
            <td>卦</td>
            <td>卣</td>
            <td>刂</td>
            <td>刈</td>
            <td>刎</td>
            <td>刭</td>
            <td>刳</td>
            <td>刿</td>
            <td>剀</td>
            <td>剌</td>
            <td>剞</td>
            <td>剡</td>
        </tr><tr><th>D8E0</th>
            <td>剜</td>
            <td>蒯</td>
            <td>剽</td>
            <td>劂</td>
            <td>劁</td>
            <td>劐</td>
            <td>劓</td>
            <td>冂</td>
            <td>罔</td>
            <td>亻</td>
            <td>仃</td>
            <td>仉</td>
            <td>仂</td>
            <td>仨</td>
            <td>仡</td>
            <td>仫</td>
        </tr><tr><th>D8F0</th>
            <td>仞</td>
            <td>伛</td>
            <td>仳</td>
            <td>伢</td>
            <td>佤</td>
            <td>仵</td>
            <td>伥</td>
            <td>伧</td>
            <td>伉</td>
            <td>伫</td>
            <td>佞</td>
            <td>佧</td>
            <td>攸</td>
            <td>佚</td>
            <td>佝</td>
            <td> </td>
        </tr><tr><th>第57区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>D9A0</th>
            <td> </td>
            <td>佟</td>
            <td>佗</td>
            <td>伲</td>
            <td>伽</td>
            <td>佶</td>
            <td>佴</td>
            <td>侑</td>
            <td>侉</td>
            <td>侃</td>
            <td>侏</td>
            <td>佾</td>
            <td>佻</td>
            <td>侪</td>
            <td>佼</td>
            <td>侬</td>
        </tr><tr><th>D9B0</th>
            <td>侔</td>
            <td>俦</td>
            <td>俨</td>
            <td>俪</td>
            <td>俅</td>
            <td>俚</td>
            <td>俣</td>
            <td>俜</td>
            <td>俑</td>
            <td>俟</td>
            <td>俸</td>
            <td>倩</td>
            <td>偌</td>
            <td>俳</td>
            <td>倬</td>
            <td>倏</td>
        </tr><tr><th>D9C0</th>
            <td>倮</td>
            <td>倭</td>
            <td>俾</td>
            <td>倜</td>
            <td>倌</td>
            <td>倥</td>
            <td>倨</td>
            <td>偾</td>
            <td>偃</td>
            <td>偕</td>
            <td>偈</td>
            <td>偎</td>
            <td>偬</td>
            <td>偻</td>
            <td>傥</td>
            <td>傧</td>
        </tr><tr><th>D9D0</th>
            <td>傩</td>
            <td>傺</td>
            <td>僖</td>
            <td>儆</td>
            <td>僭</td>
            <td>僬</td>
            <td>僦</td>
            <td>僮</td>
            <td>儇</td>
            <td>儋</td>
            <td>仝</td>
            <td>氽</td>
            <td>佘</td>
            <td>佥</td>
            <td>俎</td>
            <td>龠</td>
        </tr><tr><th>D9E0</th>
            <td>汆</td>
            <td>籴</td>
            <td>兮</td>
            <td>巽</td>
            <td>黉</td>
            <td>馘</td>
            <td>冁</td>
            <td>夔</td>
            <td>勹</td>
            <td>匍</td>
            <td>訇</td>
            <td>匐</td>
            <td>凫</td>
            <td>夙</td>
            <td>兕</td>
            <td>亠</td>
        </tr><tr><th>D9F0</th>
            <td>兖</td>
            <td>亳</td>
            <td>衮</td>
            <td>袤</td>
            <td>亵</td>
            <td>脔</td>
            <td>裒</td>
            <td>禀</td>
            <td>嬴</td>
            <td>蠃</td>
            <td>羸</td>
            <td>冫</td>
            <td>冱</td>
            <td>冽</td>
            <td>冼</td>
            <td> </td>
        </tr><tr><th>第58区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>DAA0</th>
            <td> </td>
            <td>凇</td>
            <td>冖</td>
            <td>冢</td>
            <td>冥</td>
            <td>讠</td>
            <td>讦</td>
            <td>讧</td>
            <td>讪</td>
            <td>讴</td>
            <td>讵</td>
            <td>讷</td>
            <td>诂</td>
            <td>诃</td>
            <td>诋</td>
            <td>诏</td>
        </tr><tr><th>DAB0</th>
            <td>诎</td>
            <td>诒</td>
            <td>诓</td>
            <td>诔</td>
            <td>诖</td>
            <td>诘</td>
            <td>诙</td>
            <td>诜</td>
            <td>诟</td>
            <td>诠</td>
            <td>诤</td>
            <td>诨</td>
            <td>诩</td>
            <td>诮</td>
            <td>诰</td>
            <td>诳</td>
        </tr><tr><th>DAC0</th>
            <td>诶</td>
            <td>诹</td>
            <td>诼</td>
            <td>诿</td>
            <td>谀</td>
            <td>谂</td>
            <td>谄</td>
            <td>谇</td>
            <td>谌</td>
            <td>谏</td>
            <td>谑</td>
            <td>谒</td>
            <td>谔</td>
            <td>谕</td>
            <td>谖</td>
            <td>谙</td>
        </tr><tr><th>DAD0</th>
            <td>谛</td>
            <td>谘</td>
            <td>谝</td>
            <td>谟</td>
            <td>谠</td>
            <td>谡</td>
            <td>谥</td>
            <td>谧</td>
            <td>谪</td>
            <td>谫</td>
            <td>谮</td>
            <td>谯</td>
            <td>谲</td>
            <td>谳</td>
            <td>谵</td>
            <td>谶</td>
        </tr><tr><th>DAE0</th>
            <td>卩</td>
            <td>卺</td>
            <td>阝</td>
            <td>阢</td>
            <td>阡</td>
            <td>阱</td>
            <td>阪</td>
            <td>阽</td>
            <td>阼</td>
            <td>陂</td>
            <td>陉</td>
            <td>陔</td>
            <td>陟</td>
            <td>陧</td>
            <td>陬</td>
            <td>陲</td>
        </tr><tr><th>DAF0</th>
            <td>陴</td>
            <td>隈</td>
            <td>隍</td>
            <td>隗</td>
            <td>隰</td>
            <td>邗</td>
            <td>邛</td>
            <td>邝</td>
            <td>邙</td>
            <td>邬</td>
            <td>邡</td>
            <td>邴</td>
            <td>邳</td>
            <td>邶</td>
            <td>邺</td>
            <td> </td>
        </tr><tr><th>第59区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>DBA0</th>
            <td> </td>
            <td>邸</td>
            <td>邰</td>
            <td>郏</td>
            <td>郅</td>
            <td>邾</td>
            <td>郐</td>
            <td>郄</td>
            <td>郇</td>
            <td>郓</td>
            <td>郦</td>
            <td>郢</td>
            <td>郜</td>
            <td>郗</td>
            <td>郛</td>
            <td>郫</td>
        </tr><tr><th>DBB0</th>
            <td>郯</td>
            <td>郾</td>
            <td>鄄</td>
            <td>鄢</td>
            <td>鄞</td>
            <td>鄣</td>
            <td>鄱</td>
            <td>鄯</td>
            <td>鄹</td>
            <td>酃</td>
            <td>酆</td>
            <td>刍</td>
            <td>奂</td>
            <td>劢</td>
            <td>劬</td>
            <td>劭</td>
        </tr><tr><th>DBC0</th>
            <td>劾</td>
            <td>哿</td>
            <td>勐</td>
            <td>勖</td>
            <td>勰</td>
            <td>叟</td>
            <td>燮</td>
            <td>矍</td>
            <td>廴</td>
            <td>凵</td>
            <td>凼</td>
            <td>鬯</td>
            <td>厶</td>
            <td>弁</td>
            <td>畚</td>
            <td>巯</td>
        </tr><tr><th>DBD0</th>
            <td>坌</td>
            <td>垩</td>
            <td>垡</td>
            <td>塾</td>
            <td>墼</td>
            <td>壅</td>
            <td>壑</td>
            <td>圩</td>
            <td>圬</td>
            <td>圪</td>
            <td>圳</td>
            <td>圹</td>
            <td>圮</td>
            <td>圯</td>
            <td>坜</td>
            <td>圻</td>
        </tr><tr><th>DBE0</th>
            <td>坂</td>
            <td>坩</td>
            <td>垅</td>
            <td>坫</td>
            <td>垆</td>
            <td>坼</td>
            <td>坻</td>
            <td>坨</td>
            <td>坭</td>
            <td>坶</td>
            <td>坳</td>
            <td>垭</td>
            <td>垤</td>
            <td>垌</td>
            <td>垲</td>
            <td>埏</td>
        </tr><tr><th>DBF0</th>
            <td>垧</td>
            <td>垴</td>
            <td>垓</td>
            <td>垠</td>
            <td>埕</td>
            <td>埘</td>
            <td>埚</td>
            <td>埙</td>
            <td>埒</td>
            <td>垸</td>
            <td>埴</td>
            <td>埯</td>
            <td>埸</td>
            <td>埤</td>
            <td>埝</td>
            <td> </td>
        </tr><tr><th>第60区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>DCA0</th>
            <td> </td>
            <td>堋</td>
            <td>堍</td>
            <td>埽</td>
            <td>埭</td>
            <td>堀</td>
            <td>堞</td>
            <td>堙</td>
            <td>塄</td>
            <td>堠</td>
            <td>塥</td>
            <td>塬</td>
            <td>墁</td>
            <td>墉</td>
            <td>墚</td>
            <td>墀</td>
        </tr><tr><th>DCB0</th>
            <td>馨</td>
            <td>鼙</td>
            <td>懿</td>
            <td>艹</td>
            <td>艽</td>
            <td>艿</td>
            <td>芏</td>
            <td>芊</td>
            <td>芨</td>
            <td>芄</td>
            <td>芎</td>
            <td>芑</td>
            <td>芗</td>
            <td>芙</td>
            <td>芫</td>
            <td>芸</td>
        </tr><tr><th>DCC0</th>
            <td>芾</td>
            <td>芰</td>
            <td>苈</td>
            <td>苊</td>
            <td>苣</td>
            <td>芘</td>
            <td>芷</td>
            <td>芮</td>
            <td>苋</td>
            <td>苌</td>
            <td>苁</td>
            <td>芩</td>
            <td>芴</td>
            <td>芡</td>
            <td>芪</td>
            <td>芟</td>
        </tr><tr><th>DCD0</th>
            <td>苄</td>
            <td>苎</td>
            <td>芤</td>
            <td>苡</td>
            <td>茉</td>
            <td>苷</td>
            <td>苤</td>
            <td>茏</td>
            <td>茇</td>
            <td>苜</td>
            <td>苴</td>
            <td>苒</td>
            <td>苘</td>
            <td>茌</td>
            <td>苻</td>
            <td>苓</td>
        </tr><tr><th>DCE0</th>
            <td>茑</td>
            <td>茚</td>
            <td>茆</td>
            <td>茔</td>
            <td>茕</td>
            <td>苠</td>
            <td>苕</td>
            <td>茜</td>
            <td>荑</td>
            <td>荛</td>
            <td>荜</td>
            <td>茈</td>
            <td>莒</td>
            <td>茼</td>
            <td>茴</td>
            <td>茱</td>
        </tr><tr><th>DCF0</th>
            <td>莛</td>
            <td>荞</td>
            <td>茯</td>
            <td>荏</td>
            <td>荇</td>
            <td>荃</td>
            <td>荟</td>
            <td>荀</td>
            <td>茗</td>
            <td>荠</td>
            <td>茭</td>
            <td>茺</td>
            <td>茳</td>
            <td>荦</td>
            <td>荥</td>
            <td> </td>
        </tr><tr><th>第61区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>DDA0</th>
            <td> </td>
            <td>荨</td>
            <td>茛</td>
            <td>荩</td>
            <td>荬</td>
            <td>荪</td>
            <td>荭</td>
            <td>荮</td>
            <td>莰</td>
            <td>荸</td>
            <td>莳</td>
            <td>莴</td>
            <td>莠</td>
            <td>莪</td>
            <td>莓</td>
            <td>莜</td>
        </tr><tr><th>DDB0</th>
            <td>莅</td>
            <td>荼</td>
            <td>莶</td>
            <td>莩</td>
            <td>荽</td>
            <td>莸</td>
            <td>荻</td>
            <td>莘</td>
            <td>莞</td>
            <td>莨</td>
            <td>莺</td>
            <td>莼</td>
            <td>菁</td>
            <td>萁</td>
            <td>菥</td>
            <td>菘</td>
        </tr><tr><th>DDC0</th>
            <td>堇</td>
            <td>萘</td>
            <td>萋</td>
            <td>菝</td>
            <td>菽</td>
            <td>菖</td>
            <td>萜</td>
            <td>萸</td>
            <td>萑</td>
            <td>萆</td>
            <td>菔</td>
            <td>菟</td>
            <td>萏</td>
            <td>萃</td>
            <td>菸</td>
            <td>菹</td>
        </tr><tr><th>DDD0</th>
            <td>菪</td>
            <td>菅</td>
            <td>菀</td>
            <td>萦</td>
            <td>菰</td>
            <td>菡</td>
            <td>葜</td>
            <td>葑</td>
            <td>葚</td>
            <td>葙</td>
            <td>葳</td>
            <td>蒇</td>
            <td>蒈</td>
            <td>葺</td>
            <td>蒉</td>
            <td>葸</td>
        </tr><tr><th>DDE0</th>
            <td>萼</td>
            <td>葆</td>
            <td>葩</td>
            <td>葶</td>
            <td>蒌</td>
            <td>蒎</td>
            <td>萱</td>
            <td>葭</td>
            <td>蓁</td>
            <td>蓍</td>
            <td>蓐</td>
            <td>蓦</td>
            <td>蒽</td>
            <td>蓓</td>
            <td>蓊</td>
            <td>蒿</td>
        </tr><tr><th>DDF0</th>
            <td>蒺</td>
            <td>蓠</td>
            <td>蒡</td>
            <td>蒹</td>
            <td>蒴</td>
            <td>蒗</td>
            <td>蓥</td>
            <td>蓣</td>
            <td>蔌</td>
            <td>甍</td>
            <td>蔸</td>
            <td>蓰</td>
            <td>蔹</td>
            <td>蔟</td>
            <td>蔺</td>
            <td> </td>
        </tr><tr><th>第62区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>DEA0</th>
            <td> </td>
            <td>蕖</td>
            <td>蔻</td>
            <td>蓿</td>
            <td>蓼</td>
            <td>蕙</td>
            <td>蕈</td>
            <td>蕨</td>
            <td>蕤</td>
            <td>蕞</td>
            <td>蕺</td>
            <td>瞢</td>
            <td>蕃</td>
            <td>蕲</td>
            <td>蕻</td>
            <td>薤</td>
        </tr><tr><th>DEB0</th>
            <td>薨</td>
            <td>薇</td>
            <td>薏</td>
            <td>蕹</td>
            <td>薮</td>
            <td>薜</td>
            <td>薅</td>
            <td>薹</td>
            <td>薷</td>
            <td>薰</td>
            <td>藓</td>
            <td>藁</td>
            <td>藜</td>
            <td>藿</td>
            <td>蘧</td>
            <td>蘅</td>
        </tr><tr><th>DEC0</th>
            <td>蘩</td>
            <td>蘖</td>
            <td>蘼</td>
            <td>廾</td>
            <td>弈</td>
            <td>夼</td>
            <td>奁</td>
            <td>耷</td>
            <td>奕</td>
            <td>奚</td>
            <td>奘</td>
            <td>匏</td>
            <td>尢</td>
            <td>尥</td>
            <td>尬</td>
            <td>尴</td>
        </tr><tr><th>DED0</th>
            <td>扌</td>
            <td>扪</td>
            <td>抟</td>
            <td>抻</td>
            <td>拊</td>
            <td>拚</td>
            <td>拗</td>
            <td>拮</td>
            <td>挢</td>
            <td>拶</td>
            <td>挹</td>
            <td>捋</td>
            <td>捃</td>
            <td>掭</td>
            <td>揶</td>
            <td>捱</td>
        </tr><tr><th>DEE0</th>
            <td>捺</td>
            <td>掎</td>
            <td>掴</td>
            <td>捭</td>
            <td>掬</td>
            <td>掊</td>
            <td>捩</td>
            <td>掮</td>
            <td>掼</td>
            <td>揲</td>
            <td>揸</td>
            <td>揠</td>
            <td>揿</td>
            <td>揄</td>
            <td>揞</td>
            <td>揎</td>
        </tr><tr><th>DEF0</th>
            <td>摒</td>
            <td>揆</td>
            <td>掾</td>
            <td>摅</td>
            <td>摁</td>
            <td>搋</td>
            <td>搛</td>
            <td>搠</td>
            <td>搌</td>
            <td>搦</td>
            <td>搡</td>
            <td>摞</td>
            <td>撄</td>
            <td>摭</td>
            <td>撖</td>
            <td> </td>
        </tr><tr><th>第63区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>DFA0</th>
            <td> </td>
            <td>摺</td>
            <td>撷</td>
            <td>撸</td>
            <td>撙</td>
            <td>撺</td>
            <td>擀</td>
            <td>擐</td>
            <td>擗</td>
            <td>擤</td>
            <td>擢</td>
            <td>攉</td>
            <td>攥</td>
            <td>攮</td>
            <td>弋</td>
            <td>忒</td>
        </tr><tr><th>DFB0</th>
            <td>甙</td>
            <td>弑</td>
            <td>卟</td>
            <td>叱</td>
            <td>叽</td>
            <td>叩</td>
            <td>叨</td>
            <td>叻</td>
            <td>吒</td>
            <td>吖</td>
            <td>吆</td>
            <td>呋</td>
            <td>呒</td>
            <td>呓</td>
            <td>呔</td>
            <td>呖</td>
        </tr><tr><th>DFC0</th>
            <td>呃</td>
            <td>吡</td>
            <td>呗</td>
            <td>呙</td>
            <td>吣</td>
            <td>吲</td>
            <td>咂</td>
            <td>咔</td>
            <td>呷</td>
            <td>呱</td>
            <td>呤</td>
            <td>咚</td>
            <td>咛</td>
            <td>咄</td>
            <td>呶</td>
            <td>呦</td>
        </tr><tr><th>DFD0</th>
            <td>咝</td>
            <td>哐</td>
            <td>咭</td>
            <td>哂</td>
            <td>咴</td>
            <td>哒</td>
            <td>咧</td>
            <td>咦</td>
            <td>哓</td>
            <td>哔</td>
            <td>呲</td>
            <td>咣</td>
            <td>哕</td>
            <td>咻</td>
            <td>咿</td>
            <td>哌</td>
        </tr><tr><th>DFE0</th>
            <td>哙</td>
            <td>哚</td>
            <td>哜</td>
            <td>咩</td>
            <td>咪</td>
            <td>咤</td>
            <td>哝</td>
            <td>哏</td>
            <td>哞</td>
            <td>唛</td>
            <td>哧</td>
            <td>唠</td>
            <td>哽</td>
            <td>唔</td>
            <td>哳</td>
            <td>唢</td>
        </tr><tr><th>DFF0</th>
            <td>唣</td>
            <td>唏</td>
            <td>唑</td>
            <td>唧</td>
            <td>唪</td>
            <td>啧</td>
            <td>喏</td>
            <td>喵</td>
            <td>啉</td>
            <td>啭</td>
            <td>啁</td>
            <td>啕</td>
            <td>唿</td>
            <td>啐</td>
            <td>唼</td>
            <td> </td>
        </tr><tr><th>第64区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>E0A0</th>
            <td> </td>
            <td>唷</td>
            <td>啖</td>
            <td>啵</td>
            <td>啶</td>
            <td>啷</td>
            <td>唳</td>
            <td>唰</td>
            <td>啜</td>
            <td>喋</td>
            <td>嗒</td>
            <td>喃</td>
            <td>喱</td>
            <td>喹</td>
            <td>喈</td>
            <td>喁</td>
        </tr><tr><th>E0B0</th>
            <td>喟</td>
            <td>啾</td>
            <td>嗖</td>
            <td>喑</td>
            <td>啻</td>
            <td>嗟</td>
            <td>喽</td>
            <td>喾</td>
            <td>喔</td>
            <td>喙</td>
            <td>嗪</td>
            <td>嗷</td>
            <td>嗉</td>
            <td>嘟</td>
            <td>嗑</td>
            <td>嗫</td>
        </tr><tr><th>E0C0</th>
            <td>嗬</td>
            <td>嗔</td>
            <td>嗦</td>
            <td>嗝</td>
            <td>嗄</td>
            <td>嗯</td>
            <td>嗥</td>
            <td>嗲</td>
            <td>嗳</td>
            <td>嗌</td>
            <td>嗍</td>
            <td>嗨</td>
            <td>嗵</td>
            <td>嗤</td>
            <td>辔</td>
            <td>嘞</td>
        </tr><tr><th>E0D0</th>
            <td>嘈</td>
            <td>嘌</td>
            <td>嘁</td>
            <td>嘤</td>
            <td>嘣</td>
            <td>嗾</td>
            <td>嘀</td>
            <td>嘧</td>
            <td>嘭</td>
            <td>噘</td>
            <td>嘹</td>
            <td>噗</td>
            <td>嘬</td>
            <td>噍</td>
            <td>噢</td>
            <td>噙</td>
        </tr><tr><th>E0E0</th>
            <td>噜</td>
            <td>噌</td>
            <td>噔</td>
            <td>嚆</td>
            <td>噤</td>
            <td>噱</td>
            <td>噫</td>
            <td>噻</td>
            <td>噼</td>
            <td>嚅</td>
            <td>嚓</td>
            <td>嚯</td>
            <td>囔</td>
            <td>囗</td>
            <td>囝</td>
            <td>囡</td>
        </tr><tr><th>E0F0</th>
            <td>囵</td>
            <td>囫</td>
            <td>囹</td>
            <td>囿</td>
            <td>圄</td>
            <td>圊</td>
            <td>圉</td>
            <td>圜</td>
            <td>帏</td>
            <td>帙</td>
            <td>帔</td>
            <td>帑</td>
            <td>帱</td>
            <td>帻</td>
            <td>帼</td>
            <td> </td>
        </tr><tr><th>第65区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>E1A0</th>
            <td> </td>
            <td>帷</td>
            <td>幄</td>
            <td>幔</td>
            <td>幛</td>
            <td>幞</td>
            <td>幡</td>
            <td>岌</td>
            <td>屺</td>
            <td>岍</td>
            <td>岐</td>
            <td>岖</td>
            <td>岈</td>
            <td>岘</td>
            <td>岙</td>
            <td>岑</td>
        </tr><tr><th>E1B0</th>
            <td>岚</td>
            <td>岜</td>
            <td>岵</td>
            <td>岢</td>
            <td>岽</td>
            <td>岬</td>
            <td>岫</td>
            <td>岱</td>
            <td>岣</td>
            <td>峁</td>
            <td>岷</td>
            <td>峄</td>
            <td>峒</td>
            <td>峤</td>
            <td>峋</td>
            <td>峥</td>
        </tr><tr><th>E1C0</th>
            <td>崂</td>
            <td>崃</td>
            <td>崧</td>
            <td>崦</td>
            <td>崮</td>
            <td>崤</td>
            <td>崞</td>
            <td>崆</td>
            <td>崛</td>
            <td>嵘</td>
            <td>崾</td>
            <td>崴</td>
            <td>崽</td>
            <td>嵬</td>
            <td>嵛</td>
            <td>嵯</td>
        </tr><tr><th>E1D0</th>
            <td>嵝</td>
            <td>嵫</td>
            <td>嵋</td>
            <td>嵊</td>
            <td>嵩</td>
            <td>嵴</td>
            <td>嶂</td>
            <td>嶙</td>
            <td>嶝</td>
            <td>豳</td>
            <td>嶷</td>
            <td>巅</td>
            <td>彳</td>
            <td>彷</td>
            <td>徂</td>
            <td>徇</td>
        </tr><tr><th>E1E0</th>
            <td>徉</td>
            <td>後</td>
            <td>徕</td>
            <td>徙</td>
            <td>徜</td>
            <td>徨</td>
            <td>徭</td>
            <td>徵</td>
            <td>徼</td>
            <td>衢</td>
            <td>彡</td>
            <td>犭</td>
            <td>犰</td>
            <td>犴</td>
            <td>犷</td>
            <td>犸</td>
        </tr><tr><th>E1F0</th>
            <td>狃</td>
            <td>狁</td>
            <td>狎</td>
            <td>狍</td>
            <td>狒</td>
            <td>狨</td>
            <td>狯</td>
            <td>狩</td>
            <td>狲</td>
            <td>狴</td>
            <td>狷</td>
            <td>猁</td>
            <td>狳</td>
            <td>猃</td>
            <td>狺</td>
            <td> </td>
        </tr><tr><th>第66区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>E2A0</th>
            <td> </td>
            <td>狻</td>
            <td>猗</td>
            <td>猓</td>
            <td>猡</td>
            <td>猊</td>
            <td>猞</td>
            <td>猝</td>
            <td>猕</td>
            <td>猢</td>
            <td>猹</td>
            <td>猥</td>
            <td>猬</td>
            <td>猸</td>
            <td>猱</td>
            <td>獐</td>
        </tr><tr><th>E2B0</th>
            <td>獍</td>
            <td>獗</td>
            <td>獠</td>
            <td>獬</td>
            <td>獯</td>
            <td>獾</td>
            <td>舛</td>
            <td>夥</td>
            <td>飧</td>
            <td>夤</td>
            <td>夂</td>
            <td>饣</td>
            <td>饧</td>
            <td>饨</td>
            <td>饩</td>
            <td>饪</td>
        </tr><tr><th>E2C0</th>
            <td>饫</td>
            <td>饬</td>
            <td>饴</td>
            <td>饷</td>
            <td>饽</td>
            <td>馀</td>
            <td>馄</td>
            <td>馇</td>
            <td>馊</td>
            <td>馍</td>
            <td>馐</td>
            <td>馑</td>
            <td>馓</td>
            <td>馔</td>
            <td>馕</td>
            <td>庀</td>
        </tr><tr><th>E2D0</th>
            <td>庑</td>
            <td>庋</td>
            <td>庖</td>
            <td>庥</td>
            <td>庠</td>
            <td>庹</td>
            <td>庵</td>
            <td>庾</td>
            <td>庳</td>
            <td>赓</td>
            <td>廒</td>
            <td>廑</td>
            <td>廛</td>
            <td>廨</td>
            <td>廪</td>
            <td>膺</td>
        </tr><tr><th>E2E0</th>
            <td>忄</td>
            <td>忉</td>
            <td>忖</td>
            <td>忏</td>
            <td>怃</td>
            <td>忮</td>
            <td>怄</td>
            <td>忡</td>
            <td>忤</td>
            <td>忾</td>
            <td>怅</td>
            <td>怆</td>
            <td>忪</td>
            <td>忭</td>
            <td>忸</td>
            <td>怙</td>
        </tr><tr><th>E2F0</th>
            <td>怵</td>
            <td>怦</td>
            <td>怛</td>
            <td>怏</td>
            <td>怍</td>
            <td>怩</td>
            <td>怫</td>
            <td>怊</td>
            <td>怿</td>
            <td>怡</td>
            <td>恸</td>
            <td>恹</td>
            <td>恻</td>
            <td>恺</td>
            <td>恂</td>
            <td> </td>
        </tr><tr><th>第67区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>E3A0</th>
            <td> </td>
            <td>恪</td>
            <td>恽</td>
            <td>悖</td>
            <td>悚</td>
            <td>悭</td>
            <td>悝</td>
            <td>悃</td>
            <td>悒</td>
            <td>悌</td>
            <td>悛</td>
            <td>惬</td>
            <td>悻</td>
            <td>悱</td>
            <td>惝</td>
            <td>惘</td>
        </tr><tr><th>E3B0</th>
            <td>惆</td>
            <td>惚</td>
            <td>悴</td>
            <td>愠</td>
            <td>愦</td>
            <td>愕</td>
            <td>愣</td>
            <td>惴</td>
            <td>愀</td>
            <td>愎</td>
            <td>愫</td>
            <td>慊</td>
            <td>慵</td>
            <td>憬</td>
            <td>憔</td>
            <td>憧</td>
        </tr><tr><th>E3C0</th>
            <td>憷</td>
            <td>懔</td>
            <td>懵</td>
            <td>忝</td>
            <td>隳</td>
            <td>闩</td>
            <td>闫</td>
            <td>闱</td>
            <td>闳</td>
            <td>闵</td>
            <td>闶</td>
            <td>闼</td>
            <td>闾</td>
            <td>阃</td>
            <td>阄</td>
            <td>阆</td>
        </tr><tr><th>E3D0</th>
            <td>阈</td>
            <td>阊</td>
            <td>阋</td>
            <td>阌</td>
            <td>阍</td>
            <td>阏</td>
            <td>阒</td>
            <td>阕</td>
            <td>阖</td>
            <td>阗</td>
            <td>阙</td>
            <td>阚</td>
            <td>丬</td>
            <td>爿</td>
            <td>戕</td>
            <td>氵</td>
        </tr><tr><th>E3E0</th>
            <td>汔</td>
            <td>汜</td>
            <td>汊</td>
            <td>沣</td>
            <td>沅</td>
            <td>沐</td>
            <td>沔</td>
            <td>沌</td>
            <td>汨</td>
            <td>汩</td>
            <td>汴</td>
            <td>汶</td>
            <td>沆</td>
            <td>沩</td>
            <td>泐</td>
            <td>泔</td>
        </tr><tr><th>E3F0</th>
            <td>沭</td>
            <td>泷</td>
            <td>泸</td>
            <td>泱</td>
            <td>泗</td>
            <td>沲</td>
            <td>泠</td>
            <td>泖</td>
            <td>泺</td>
            <td>泫</td>
            <td>泮</td>
            <td>沱</td>
            <td>泓</td>
            <td>泯</td>
            <td>泾</td>
            <td> </td>
        </tr><tr><th>第68区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>E4A0</th>
            <td> </td>
            <td>洹</td>
            <td>洧</td>
            <td>洌</td>
            <td>浃</td>
            <td>浈</td>
            <td>洇</td>
            <td>洄</td>
            <td>洙</td>
            <td>洎</td>
            <td>洫</td>
            <td>浍</td>
            <td>洮</td>
            <td>洵</td>
            <td>洚</td>
            <td>浏</td>
        </tr><tr><th>E4B0</th>
            <td>浒</td>
            <td>浔</td>
            <td>洳</td>
            <td>涑</td>
            <td>浯</td>
            <td>涞</td>
            <td>涠</td>
            <td>浞</td>
            <td>涓</td>
            <td>涔</td>
            <td>浜</td>
            <td>浠</td>
            <td>浼</td>
            <td>浣</td>
            <td>渚</td>
            <td>淇</td>
        </tr><tr><th>E4C0</th>
            <td>淅</td>
            <td>淞</td>
            <td>渎</td>
            <td>涿</td>
            <td>淠</td>
            <td>渑</td>
            <td>淦</td>
            <td>淝</td>
            <td>淙</td>
            <td>渖</td>
            <td>涫</td>
            <td>渌</td>
            <td>涮</td>
            <td>渫</td>
            <td>湮</td>
            <td>湎</td>
        </tr><tr><th>E4D0</th>
            <td>湫</td>
            <td>溲</td>
            <td>湟</td>
            <td>溆</td>
            <td>湓</td>
            <td>湔</td>
            <td>渲</td>
            <td>渥</td>
            <td>湄</td>
            <td>滟</td>
            <td>溱</td>
            <td>溘</td>
            <td>滠</td>
            <td>漭</td>
            <td>滢</td>
            <td>溥</td>
        </tr><tr><th>E4E0</th>
            <td>溧</td>
            <td>溽</td>
            <td>溻</td>
            <td>溷</td>
            <td>滗</td>
            <td>溴</td>
            <td>滏</td>
            <td>溏</td>
            <td>滂</td>
            <td>溟</td>
            <td>潢</td>
            <td>潆</td>
            <td>潇</td>
            <td>漤</td>
            <td>漕</td>
            <td>滹</td>
        </tr><tr><th>E4F0</th>
            <td>漯</td>
            <td>漶</td>
            <td>潋</td>
            <td>潴</td>
            <td>漪</td>
            <td>漉</td>
            <td>漩</td>
            <td>澉</td>
            <td>澍</td>
            <td>澌</td>
            <td>潸</td>
            <td>潲</td>
            <td>潼</td>
            <td>潺</td>
            <td>濑</td>
            <td> </td>
        </tr><tr><th>第69区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>E5A0</th>
            <td> </td>
            <td>濉</td>
            <td>澧</td>
            <td>澹</td>
            <td>澶</td>
            <td>濂</td>
            <td>濡</td>
            <td>濮</td>
            <td>濞</td>
            <td>濠</td>
            <td>濯</td>
            <td>瀚</td>
            <td>瀣</td>
            <td>瀛</td>
            <td>瀹</td>
            <td>瀵</td>
        </tr><tr><th>E5B0</th>
            <td>灏</td>
            <td>灞</td>
            <td>宀</td>
            <td>宄</td>
            <td>宕</td>
            <td>宓</td>
            <td>宥</td>
            <td>宸</td>
            <td>甯</td>
            <td>骞</td>
            <td>搴</td>
            <td>寤</td>
            <td>寮</td>
            <td>褰</td>
            <td>寰</td>
            <td>蹇</td>
        </tr><tr><th>E5C0</th>
            <td>謇</td>
            <td>辶</td>
            <td>迓</td>
            <td>迕</td>
            <td>迥</td>
            <td>迮</td>
            <td>迤</td>
            <td>迩</td>
            <td>迦</td>
            <td>迳</td>
            <td>迨</td>
            <td>逅</td>
            <td>逄</td>
            <td>逋</td>
            <td>逦</td>
            <td>逑</td>
        </tr><tr><th>E5D0</th>
            <td>逍</td>
            <td>逖</td>
            <td>逡</td>
            <td>逵</td>
            <td>逶</td>
            <td>逭</td>
            <td>逯</td>
            <td>遄</td>
            <td>遑</td>
            <td>遒</td>
            <td>遐</td>
            <td>遨</td>
            <td>遘</td>
            <td>遢</td>
            <td>遛</td>
            <td>暹</td>
        </tr><tr><th>E5E0</th>
            <td>遴</td>
            <td>遽</td>
            <td>邂</td>
            <td>邈</td>
            <td>邃</td>
            <td>邋</td>
            <td>彐</td>
            <td>彗</td>
            <td>彖</td>
            <td>彘</td>
            <td>尻</td>
            <td>咫</td>
            <td>屐</td>
            <td>屙</td>
            <td>孱</td>
            <td>屣</td>
        </tr><tr><th>E5F0</th>
            <td>屦</td>
            <td>羼</td>
            <td>弪</td>
            <td>弩</td>
            <td>弭</td>
            <td>艴</td>
            <td>弼</td>
            <td>鬻</td>
            <td>屮</td>
            <td>妁</td>
            <td>妃</td>
            <td>妍</td>
            <td>妩</td>
            <td>妪</td>
            <td>妣</td>
            <td> </td>
        </tr><tr><th>第70区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>E6A0</th>
            <td> </td>
            <td>妗</td>
            <td>姊</td>
            <td>妫</td>
            <td>妞</td>
            <td>妤</td>
            <td>姒</td>
            <td>妲</td>
            <td>妯</td>
            <td>姗</td>
            <td>妾</td>
            <td>娅</td>
            <td>娆</td>
            <td>姝</td>
            <td>娈</td>
            <td>姣</td>
        </tr><tr><th>E6B0</th>
            <td>姘</td>
            <td>姹</td>
            <td>娌</td>
            <td>娉</td>
            <td>娲</td>
            <td>娴</td>
            <td>娑</td>
            <td>娣</td>
            <td>娓</td>
            <td>婀</td>
            <td>婧</td>
            <td>婊</td>
            <td>婕</td>
            <td>娼</td>
            <td>婢</td>
            <td>婵</td>
        </tr><tr><th>E6C0</th>
            <td>胬</td>
            <td>媪</td>
            <td>媛</td>
            <td>婷</td>
            <td>婺</td>
            <td>媾</td>
            <td>嫫</td>
            <td>媲</td>
            <td>嫒</td>
            <td>嫔</td>
            <td>媸</td>
            <td>嫠</td>
            <td>嫣</td>
            <td>嫱</td>
            <td>嫖</td>
            <td>嫦</td>
        </tr><tr><th>E6D0</th>
            <td>嫘</td>
            <td>嫜</td>
            <td>嬉</td>
            <td>嬗</td>
            <td>嬖</td>
            <td>嬲</td>
            <td>嬷</td>
            <td>孀</td>
            <td>尕</td>
            <td>尜</td>
            <td>孚</td>
            <td>孥</td>
            <td>孳</td>
            <td>孑</td>
            <td>孓</td>
            <td>孢</td>
        </tr><tr><th>E6E0</th>
            <td>驵</td>
            <td>驷</td>
            <td>驸</td>
            <td>驺</td>
            <td>驿</td>
            <td>驽</td>
            <td>骀</td>
            <td>骁</td>
            <td>骅</td>
            <td>骈</td>
            <td>骊</td>
            <td>骐</td>
            <td>骒</td>
            <td>骓</td>
            <td>骖</td>
            <td>骘</td>
        </tr><tr><th>E6F0</th>
            <td>骛</td>
            <td>骜</td>
            <td>骝</td>
            <td>骟</td>
            <td>骠</td>
            <td>骢</td>
            <td>骣</td>
            <td>骥</td>
            <td>骧</td>
            <td>纟</td>
            <td>纡</td>
            <td>纣</td>
            <td>纥</td>
            <td>纨</td>
            <td>纩</td>
            <td> </td>
        </tr><tr><th>第71区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>E7A0</th>
            <td> </td>
            <td>纭</td>
            <td>纰</td>
            <td>纾</td>
            <td>绀</td>
            <td>绁</td>
            <td>绂</td>
            <td>绉</td>
            <td>绋</td>
            <td>绌</td>
            <td>绐</td>
            <td>绔</td>
            <td>绗</td>
            <td>绛</td>
            <td>绠</td>
            <td>绡</td>
        </tr><tr><th>E7B0</th>
            <td>绨</td>
            <td>绫</td>
            <td>绮</td>
            <td>绯</td>
            <td>绱</td>
            <td>绲</td>
            <td>缍</td>
            <td>绶</td>
            <td>绺</td>
            <td>绻</td>
            <td>绾</td>
            <td>缁</td>
            <td>缂</td>
            <td>缃</td>
            <td>缇</td>
            <td>缈</td>
        </tr><tr><th>E7C0</th>
            <td>缋</td>
            <td>缌</td>
            <td>缏</td>
            <td>缑</td>
            <td>缒</td>
            <td>缗</td>
            <td>缙</td>
            <td>缜</td>
            <td>缛</td>
            <td>缟</td>
            <td>缡</td>
            <td>缢</td>
            <td>缣</td>
            <td>缤</td>
            <td>缥</td>
            <td>缦</td>
        </tr><tr><th>E7D0</th>
            <td>缧</td>
            <td>缪</td>
            <td>缫</td>
            <td>缬</td>
            <td>缭</td>
            <td>缯</td>
            <td>缰</td>
            <td>缱</td>
            <td>缲</td>
            <td>缳</td>
            <td>缵</td>
            <td>幺</td>
            <td>畿</td>
            <td>巛</td>
            <td>甾</td>
            <td>邕</td>
        </tr><tr><th>E7E0</th>
            <td>玎</td>
            <td>玑</td>
            <td>玮</td>
            <td>玢</td>
            <td>玟</td>
            <td>珏</td>
            <td>珂</td>
            <td>珑</td>
            <td>玷</td>
            <td>玳</td>
            <td>珀</td>
            <td>珉</td>
            <td>珈</td>
            <td>珥</td>
            <td>珙</td>
            <td>顼</td>
        </tr><tr><th>E7F0</th>
            <td>琊</td>
            <td>珩</td>
            <td>珧</td>
            <td>珞</td>
            <td>玺</td>
            <td>珲</td>
            <td>琏</td>
            <td>琪</td>
            <td>瑛</td>
            <td>琦</td>
            <td>琥</td>
            <td>琨</td>
            <td>琰</td>
            <td>琮</td>
            <td>琬</td>
            <td> </td>
        </tr><tr><th>第72区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>E8A0</th>
            <td> </td>
            <td>琛</td>
            <td>琚</td>
            <td>瑁</td>
            <td>瑜</td>
            <td>瑗</td>
            <td>瑕</td>
            <td>瑙</td>
            <td>瑷</td>
            <td>瑭</td>
            <td>瑾</td>
            <td>璜</td>
            <td>璎</td>
            <td>璀</td>
            <td>璁</td>
            <td>璇</td>
        </tr><tr><th>E8B0</th>
            <td>璋</td>
            <td>璞</td>
            <td>璨</td>
            <td>璩</td>
            <td>璐</td>
            <td>璧</td>
            <td>瓒</td>
            <td>璺</td>
            <td>韪</td>
            <td>韫</td>
            <td>韬</td>
            <td>杌</td>
            <td>杓</td>
            <td>杞</td>
            <td>杈</td>
            <td>杩</td>
        </tr><tr><th>E8C0</th>
            <td>枥</td>
            <td>枇</td>
            <td>杪</td>
            <td>杳</td>
            <td>枘</td>
            <td>枧</td>
            <td>杵</td>
            <td>枨</td>
            <td>枞</td>
            <td>枭</td>
            <td>枋</td>
            <td>杷</td>
            <td>杼</td>
            <td>柰</td>
            <td>栉</td>
            <td>柘</td>
        </tr><tr><th>E8D0</th>
            <td>栊</td>
            <td>柩</td>
            <td>枰</td>
            <td>栌</td>
            <td>柙</td>
            <td>枵</td>
            <td>柚</td>
            <td>枳</td>
            <td>柝</td>
            <td>栀</td>
            <td>柃</td>
            <td>枸</td>
            <td>柢</td>
            <td>栎</td>
            <td>柁</td>
            <td>柽</td>
        </tr><tr><th>E8E0</th>
            <td>栲</td>
            <td>栳</td>
            <td>桠</td>
            <td>桡</td>
            <td>桎</td>
            <td>桢</td>
            <td>桄</td>
            <td>桤</td>
            <td>梃</td>
            <td>栝</td>
            <td>桕</td>
            <td>桦</td>
            <td>桁</td>
            <td>桧</td>
            <td>桀</td>
            <td>栾</td>
        </tr><tr><th>E8F0</th>
            <td>桊</td>
            <td>桉</td>
            <td>栩</td>
            <td>梵</td>
            <td>梏</td>
            <td>桴</td>
            <td>桷</td>
            <td>梓</td>
            <td>桫</td>
            <td>棂</td>
            <td>楮</td>
            <td>棼</td>
            <td>椟</td>
            <td>椠</td>
            <td>棹</td>
            <td> </td>
        </tr><tr><th>第73区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>E9A0</th>
            <td> </td>
            <td>椤</td>
            <td>棰</td>
            <td>椋</td>
            <td>椁</td>
            <td>楗</td>
            <td>棣</td>
            <td>椐</td>
            <td>楱</td>
            <td>椹</td>
            <td>楠</td>
            <td>楂</td>
            <td>楝</td>
            <td>榄</td>
            <td>楫</td>
            <td>榀</td>
        </tr><tr><th>E9B0</th>
            <td>榘</td>
            <td>楸</td>
            <td>椴</td>
            <td>槌</td>
            <td>榇</td>
            <td>榈</td>
            <td>槎</td>
            <td>榉</td>
            <td>楦</td>
            <td>楣</td>
            <td>楹</td>
            <td>榛</td>
            <td>榧</td>
            <td>榻</td>
            <td>榫</td>
            <td>榭</td>
        </tr><tr><th>E9C0</th>
            <td>槔</td>
            <td>榱</td>
            <td>槁</td>
            <td>槊</td>
            <td>槟</td>
            <td>榕</td>
            <td>槠</td>
            <td>榍</td>
            <td>槿</td>
            <td>樯</td>
            <td>槭</td>
            <td>樗</td>
            <td>樘</td>
            <td>橥</td>
            <td>槲</td>
            <td>橄</td>
        </tr><tr><th>E9D0</th>
            <td>樾</td>
            <td>檠</td>
            <td>橐</td>
            <td>橛</td>
            <td>樵</td>
            <td>檎</td>
            <td>橹</td>
            <td>樽</td>
            <td>樨</td>
            <td>橘</td>
            <td>橼</td>
            <td>檑</td>
            <td>檐</td>
            <td>檩</td>
            <td>檗</td>
            <td>檫</td>
        </tr><tr><th>E9E0</th>
            <td>猷</td>
            <td>獒</td>
            <td>殁</td>
            <td>殂</td>
            <td>殇</td>
            <td>殄</td>
            <td>殒</td>
            <td>殓</td>
            <td>殍</td>
            <td>殚</td>
            <td>殛</td>
            <td>殡</td>
            <td>殪</td>
            <td>轫</td>
            <td>轭</td>
            <td>轱</td>
        </tr><tr><th>E9F0</th>
            <td>轲</td>
            <td>轳</td>
            <td>轵</td>
            <td>轶</td>
            <td>轸</td>
            <td>轷</td>
            <td>轹</td>
            <td>轺</td>
            <td>轼</td>
            <td>轾</td>
            <td>辁</td>
            <td>辂</td>
            <td>辄</td>
            <td>辇</td>
            <td>辋</td>
            <td> </td>
        </tr><tr><th>第74区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>EAA0</th>
            <td> </td>
            <td>辍</td>
            <td>辎</td>
            <td>辏</td>
            <td>辘</td>
            <td>辚</td>
            <td>軎</td>
            <td>戋</td>
            <td>戗</td>
            <td>戛</td>
            <td>戟</td>
            <td>戢</td>
            <td>戡</td>
            <td>戥</td>
            <td>戤</td>
            <td>戬</td>
        </tr><tr><th>EAB0</th>
            <td>臧</td>
            <td>瓯</td>
            <td>瓴</td>
            <td>瓿</td>
            <td>甏</td>
            <td>甑</td>
            <td>甓</td>
            <td>攴</td>
            <td>旮</td>
            <td>旯</td>
            <td>旰</td>
            <td>昊</td>
            <td>昙</td>
            <td>杲</td>
            <td>昃</td>
            <td>昕</td>
        </tr><tr><th>EAC0</th>
            <td>昀</td>
            <td>炅</td>
            <td>曷</td>
            <td>昝</td>
            <td>昴</td>
            <td>昱</td>
            <td>昶</td>
            <td>昵</td>
            <td>耆</td>
            <td>晟</td>
            <td>晔</td>
            <td>晁</td>
            <td>晏</td>
            <td>晖</td>
            <td>晡</td>
            <td>晗</td>
        </tr><tr><th>EAD0</th>
            <td>晷</td>
            <td>暄</td>
            <td>暌</td>
            <td>暧</td>
            <td>暝</td>
            <td>暾</td>
            <td>曛</td>
            <td>曜</td>
            <td>曦</td>
            <td>曩</td>
            <td>贲</td>
            <td>贳</td>
            <td>贶</td>
            <td>贻</td>
            <td>贽</td>
            <td>赀</td>
        </tr><tr><th>EAE0</th>
            <td>赅</td>
            <td>赆</td>
            <td>赈</td>
            <td>赉</td>
            <td>赇</td>
            <td>赍</td>
            <td>赕</td>
            <td>赙</td>
            <td>觇</td>
            <td>觊</td>
            <td>觋</td>
            <td>觌</td>
            <td>觎</td>
            <td>觏</td>
            <td>觐</td>
            <td>觑</td>
        </tr><tr><th>EAF0</th>
            <td>牮</td>
            <td>犟</td>
            <td>牝</td>
            <td>牦</td>
            <td>牯</td>
            <td>牾</td>
            <td>牿</td>
            <td>犄</td>
            <td>犋</td>
            <td>犍</td>
            <td>犏</td>
            <td>犒</td>
            <td>挈</td>
            <td>挲</td>
            <td>掰</td>
            <td> </td>
        </tr><tr><th>第75区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>EBA0</th>
            <td> </td>
            <td>搿</td>
            <td>擘</td>
            <td>耄</td>
            <td>毪</td>
            <td>毳</td>
            <td>毽</td>
            <td>毵</td>
            <td>毹</td>
            <td>氅</td>
            <td>氇</td>
            <td>氆</td>
            <td>氍</td>
            <td>氕</td>
            <td>氘</td>
            <td>氙</td>
        </tr><tr><th>EBB0</th>
            <td>氚</td>
            <td>氡</td>
            <td>氩</td>
            <td>氤</td>
            <td>氪</td>
            <td>氲</td>
            <td>攵</td>
            <td>敕</td>
            <td>敫</td>
            <td>牍</td>
            <td>牒</td>
            <td>牖</td>
            <td>爰</td>
            <td>虢</td>
            <td>刖</td>
            <td>肟</td>
        </tr><tr><th>EBC0</th>
            <td>肜</td>
            <td>肓</td>
            <td>肼</td>
            <td>朊</td>
            <td>肽</td>
            <td>肱</td>
            <td>肫</td>
            <td>肭</td>
            <td>肴</td>
            <td>肷</td>
            <td>胧</td>
            <td>胨</td>
            <td>胩</td>
            <td>胪</td>
            <td>胛</td>
            <td>胂</td>
        </tr><tr><th>EBD0</th>
            <td>胄</td>
            <td>胙</td>
            <td>胍</td>
            <td>胗</td>
            <td>朐</td>
            <td>胝</td>
            <td>胫</td>
            <td>胱</td>
            <td>胴</td>
            <td>胭</td>
            <td>脍</td>
            <td>脎</td>
            <td>胲</td>
            <td>胼</td>
            <td>朕</td>
            <td>脒</td>
        </tr><tr><th>EBE0</th>
            <td>豚</td>
            <td>脶</td>
            <td>脞</td>
            <td>脬</td>
            <td>脘</td>
            <td>脲</td>
            <td>腈</td>
            <td>腌</td>
            <td>腓</td>
            <td>腴</td>
            <td>腙</td>
            <td>腚</td>
            <td>腱</td>
            <td>腠</td>
            <td>腩</td>
            <td>腼</td>
        </tr><tr><th>EBF0</th>
            <td>腽</td>
            <td>腭</td>
            <td>腧</td>
            <td>塍</td>
            <td>媵</td>
            <td>膈</td>
            <td>膂</td>
            <td>膑</td>
            <td>滕</td>
            <td>膣</td>
            <td>膪</td>
            <td>臌</td>
            <td>朦</td>
            <td>臊</td>
            <td>膻</td>
            <td> </td>
        </tr><tr><th>第76区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>ECA0</th>
            <td> </td>
            <td>臁</td>
            <td>膦</td>
            <td>欤</td>
            <td>欷</td>
            <td>欹</td>
            <td>歃</td>
            <td>歆</td>
            <td>歙</td>
            <td>飑</td>
            <td>飒</td>
            <td>飓</td>
            <td>飕</td>
            <td>飙</td>
            <td>飚</td>
            <td>殳</td>
        </tr><tr><th>ECB0</th>
            <td>彀</td>
            <td>毂</td>
            <td>觳</td>
            <td>斐</td>
            <td>齑</td>
            <td>斓</td>
            <td>於</td>
            <td>旆</td>
            <td>旄</td>
            <td>旃</td>
            <td>旌</td>
            <td>旎</td>
            <td>旒</td>
            <td>旖</td>
            <td>炀</td>
            <td>炜</td>
        </tr><tr><th>ECC0</th>
            <td>炖</td>
            <td>炝</td>
            <td>炻</td>
            <td>烀</td>
            <td>炷</td>
            <td>炫</td>
            <td>炱</td>
            <td>烨</td>
            <td>烊</td>
            <td>焐</td>
            <td>焓</td>
            <td>焖</td>
            <td>焯</td>
            <td>焱</td>
            <td>煳</td>
            <td>煜</td>
        </tr><tr><th>ECD0</th>
            <td>煨</td>
            <td>煅</td>
            <td>煲</td>
            <td>煊</td>
            <td>煸</td>
            <td>煺</td>
            <td>熘</td>
            <td>熳</td>
            <td>熵</td>
            <td>熨</td>
            <td>熠</td>
            <td>燠</td>
            <td>燔</td>
            <td>燧</td>
            <td>燹</td>
            <td>爝</td>
        </tr><tr><th>ECE0</th>
            <td>爨</td>
            <td>灬</td>
            <td>焘</td>
            <td>煦</td>
            <td>熹</td>
            <td>戾</td>
            <td>戽</td>
            <td>扃</td>
            <td>扈</td>
            <td>扉</td>
            <td>礻</td>
            <td>祀</td>
            <td>祆</td>
            <td>祉</td>
            <td>祛</td>
            <td>祜</td>
        </tr><tr><th>ECF0</th>
            <td>祓</td>
            <td>祚</td>
            <td>祢</td>
            <td>祗</td>
            <td>祠</td>
            <td>祯</td>
            <td>祧</td>
            <td>祺</td>
            <td>禅</td>
            <td>禊</td>
            <td>禚</td>
            <td>禧</td>
            <td>禳</td>
            <td>忑</td>
            <td>忐</td>
            <td> </td>
        </tr><tr><th>第77区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>EDA0</th>
            <td> </td>
            <td>怼</td>
            <td>恝</td>
            <td>恚</td>
            <td>恧</td>
            <td>恁</td>
            <td>恙</td>
            <td>恣</td>
            <td>悫</td>
            <td>愆</td>
            <td>愍</td>
            <td>慝</td>
            <td>憩</td>
            <td>憝</td>
            <td>懋</td>
            <td>懑</td>
        </tr><tr><th>EDB0</th>
            <td>戆</td>
            <td>肀</td>
            <td>聿</td>
            <td>沓</td>
            <td>泶</td>
            <td>淼</td>
            <td>矶</td>
            <td>矸</td>
            <td>砀</td>
            <td>砉</td>
            <td>砗</td>
            <td>砘</td>
            <td>砑</td>
            <td>斫</td>
            <td>砭</td>
            <td>砜</td>
        </tr><tr><th>EDC0</th>
            <td>砝</td>
            <td>砹</td>
            <td>砺</td>
            <td>砻</td>
            <td>砟</td>
            <td>砼</td>
            <td>砥</td>
            <td>砬</td>
            <td>砣</td>
            <td>砩</td>
            <td>硎</td>
            <td>硭</td>
            <td>硖</td>
            <td>硗</td>
            <td>砦</td>
            <td>硐</td>
        </tr><tr><th>EDD0</th>
            <td>硇</td>
            <td>硌</td>
            <td>硪</td>
            <td>碛</td>
            <td>碓</td>
            <td>碚</td>
            <td>碇</td>
            <td>碜</td>
            <td>碡</td>
            <td>碣</td>
            <td>碲</td>
            <td>碹</td>
            <td>碥</td>
            <td>磔</td>
            <td>磙</td>
            <td>磉</td>
        </tr><tr><th>EDE0</th>
            <td>磬</td>
            <td>磲</td>
            <td>礅</td>
            <td>磴</td>
            <td>礓</td>
            <td>礤</td>
            <td>礞</td>
            <td>礴</td>
            <td>龛</td>
            <td>黹</td>
            <td>黻</td>
            <td>黼</td>
            <td>盱</td>
            <td>眄</td>
            <td>眍</td>
            <td>盹</td>
        </tr><tr><th>EDF0</th>
            <td>眇</td>
            <td>眈</td>
            <td>眚</td>
            <td>眢</td>
            <td>眙</td>
            <td>眭</td>
            <td>眦</td>
            <td>眵</td>
            <td>眸</td>
            <td>睐</td>
            <td>睑</td>
            <td>睇</td>
            <td>睃</td>
            <td>睚</td>
            <td>睨</td>
            <td> </td>
        </tr><tr><th>第78区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>EEA0</th>
            <td> </td>
            <td>睢</td>
            <td>睥</td>
            <td>睿</td>
            <td>瞍</td>
            <td>睽</td>
            <td>瞀</td>
            <td>瞌</td>
            <td>瞑</td>
            <td>瞟</td>
            <td>瞠</td>
            <td>瞰</td>
            <td>瞵</td>
            <td>瞽</td>
            <td>町</td>
            <td>畀</td>
        </tr><tr><th>EEB0</th>
            <td>畎</td>
            <td>畋</td>
            <td>畈</td>
            <td>畛</td>
            <td>畲</td>
            <td>畹</td>
            <td>疃</td>
            <td>罘</td>
            <td>罡</td>
            <td>罟</td>
            <td>詈</td>
            <td>罨</td>
            <td>罴</td>
            <td>罱</td>
            <td>罹</td>
            <td>羁</td>
        </tr><tr><th>EEC0</th>
            <td>罾</td>
            <td>盍</td>
            <td>盥</td>
            <td>蠲</td>
            <td>钅</td>
            <td>钆</td>
            <td>钇</td>
            <td>钋</td>
            <td>钊</td>
            <td>钌</td>
            <td>钍</td>
            <td>钏</td>
            <td>钐</td>
            <td>钔</td>
            <td>钗</td>
            <td>钕</td>
        </tr><tr><th>EED0</th>
            <td>钚</td>
            <td>钛</td>
            <td>钜</td>
            <td>钣</td>
            <td>钤</td>
            <td>钫</td>
            <td>钪</td>
            <td>钭</td>
            <td>钬</td>
            <td>钯</td>
            <td>钰</td>
            <td>钲</td>
            <td>钴</td>
            <td>钶</td>
            <td>钷</td>
            <td>钸</td>
        </tr><tr><th>EEE0</th>
            <td>钹</td>
            <td>钺</td>
            <td>钼</td>
            <td>钽</td>
            <td>钿</td>
            <td>铄</td>
            <td>铈</td>
            <td>铉</td>
            <td>铊</td>
            <td>铋</td>
            <td>铌</td>
            <td>铍</td>
            <td>铎</td>
            <td>铐</td>
            <td>铑</td>
            <td>铒</td>
        </tr><tr><th>EEF0</th>
            <td>铕</td>
            <td>铖</td>
            <td>铗</td>
            <td>铙</td>
            <td>铘</td>
            <td>铛</td>
            <td>铞</td>
            <td>铟</td>
            <td>铠</td>
            <td>铢</td>
            <td>铤</td>
            <td>铥</td>
            <td>铧</td>
            <td>铨</td>
            <td>铪</td>
            <td> </td>
        </tr><tr><th>第79区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>EFA0</th>
            <td> </td>
            <td>铩</td>
            <td>铫</td>
            <td>铮</td>
            <td>铯</td>
            <td>铳</td>
            <td>铴</td>
            <td>铵</td>
            <td>铷</td>
            <td>铹</td>
            <td>铼</td>
            <td>铽</td>
            <td>铿</td>
            <td>锃</td>
            <td>锂</td>
            <td>锆</td>
        </tr><tr><th>EFB0</th>
            <td>锇</td>
            <td>锉</td>
            <td>锊</td>
            <td>锍</td>
            <td>锎</td>
            <td>锏</td>
            <td>锒</td>
            <td>锓</td>
            <td>锔</td>
            <td>锕</td>
            <td>锖</td>
            <td>锘</td>
            <td>锛</td>
            <td>锝</td>
            <td>锞</td>
            <td>锟</td>
        </tr><tr><th>EFC0</th>
            <td>锢</td>
            <td>锪</td>
            <td>锫</td>
            <td>锩</td>
            <td>锬</td>
            <td>锱</td>
            <td>锲</td>
            <td>锴</td>
            <td>锶</td>
            <td>锷</td>
            <td>锸</td>
            <td>锼</td>
            <td>锾</td>
            <td>锿</td>
            <td>镂</td>
            <td>锵</td>
        </tr><tr><th>EFD0</th>
            <td>镄</td>
            <td>镅</td>
            <td>镆</td>
            <td>镉</td>
            <td>镌</td>
            <td>镎</td>
            <td>镏</td>
            <td>镒</td>
            <td>镓</td>
            <td>镔</td>
            <td>镖</td>
            <td>镗</td>
            <td>镘</td>
            <td>镙</td>
            <td>镛</td>
            <td>镞</td>
        </tr><tr><th>EFE0</th>
            <td>镟</td>
            <td>镝</td>
            <td>镡</td>
            <td>镢</td>
            <td>镤</td>
            <td>镥</td>
            <td>镦</td>
            <td>镧</td>
            <td>镨</td>
            <td>镩</td>
            <td>镪</td>
            <td>镫</td>
            <td>镬</td>
            <td>镯</td>
            <td>镱</td>
            <td>镲</td>
        </tr><tr><th>EFF0</th>
            <td>镳</td>
            <td>锺</td>
            <td>矧</td>
            <td>矬</td>
            <td>雉</td>
            <td>秕</td>
            <td>秭</td>
            <td>秣</td>
            <td>秫</td>
            <td>稆</td>
            <td>嵇</td>
            <td>稃</td>
            <td>稂</td>
            <td>稞</td>
            <td>稔</td>
            <td> </td>
        </tr><tr><th>第80区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>F0A0</th>
            <td> </td>
            <td>稹</td>
            <td>稷</td>
            <td>穑</td>
            <td>黏</td>
            <td>馥</td>
            <td>穰</td>
            <td>皈</td>
            <td>皎</td>
            <td>皓</td>
            <td>皙</td>
            <td>皤</td>
            <td>瓞</td>
            <td>瓠</td>
            <td>甬</td>
            <td>鸠</td>
        </tr><tr><th>F0B0</th>
            <td>鸢</td>
            <td>鸨</td>
            <td>鸩</td>
            <td>鸪</td>
            <td>鸫</td>
            <td>鸬</td>
            <td>鸲</td>
            <td>鸱</td>
            <td>鸶</td>
            <td>鸸</td>
            <td>鸷</td>
            <td>鸹</td>
            <td>鸺</td>
            <td>鸾</td>
            <td>鹁</td>
            <td>鹂</td>
        </tr><tr><th>F0C0</th>
            <td>鹄</td>
            <td>鹆</td>
            <td>鹇</td>
            <td>鹈</td>
            <td>鹉</td>
            <td>鹋</td>
            <td>鹌</td>
            <td>鹎</td>
            <td>鹑</td>
            <td>鹕</td>
            <td>鹗</td>
            <td>鹚</td>
            <td>鹛</td>
            <td>鹜</td>
            <td>鹞</td>
            <td>鹣</td>
        </tr><tr><th>F0D0</th>
            <td>鹦</td>
            <td>鹧</td>
            <td>鹨</td>
            <td>鹩</td>
            <td>鹪</td>
            <td>鹫</td>
            <td>鹬</td>
            <td>鹱</td>
            <td>鹭</td>
            <td>鹳</td>
            <td>疒</td>
            <td>疔</td>
            <td>疖</td>
            <td>疠</td>
            <td>疝</td>
            <td>疬</td>
        </tr><tr><th>F0E0</th>
            <td>疣</td>
            <td>疳</td>
            <td>疴</td>
            <td>疸</td>
            <td>痄</td>
            <td>疱</td>
            <td>疰</td>
            <td>痃</td>
            <td>痂</td>
            <td>痖</td>
            <td>痍</td>
            <td>痣</td>
            <td>痨</td>
            <td>痦</td>
            <td>痤</td>
            <td>痫</td>
        </tr><tr><th>F0F0</th>
            <td>痧</td>
            <td>瘃</td>
            <td>痱</td>
            <td>痼</td>
            <td>痿</td>
            <td>瘐</td>
            <td>瘀</td>
            <td>瘅</td>
            <td>瘌</td>
            <td>瘗</td>
            <td>瘊</td>
            <td>瘥</td>
            <td>瘘</td>
            <td>瘕</td>
            <td>瘙</td>
            <td> </td>
        </tr><tr><th>第81区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>F1A0</th>
            <td> </td>
            <td>瘛</td>
            <td>瘼</td>
            <td>瘢</td>
            <td>瘠</td>
            <td>癀</td>
            <td>瘭</td>
            <td>瘰</td>
            <td>瘿</td>
            <td>瘵</td>
            <td>癃</td>
            <td>瘾</td>
            <td>瘳</td>
            <td>癍</td>
            <td>癞</td>
            <td>癔</td>
        </tr><tr><th>F1B0</th>
            <td>癜</td>
            <td>癖</td>
            <td>癫</td>
            <td>癯</td>
            <td>翊</td>
            <td>竦</td>
            <td>穸</td>
            <td>穹</td>
            <td>窀</td>
            <td>窆</td>
            <td>窈</td>
            <td>窕</td>
            <td>窦</td>
            <td>窠</td>
            <td>窬</td>
            <td>窨</td>
        </tr><tr><th>F1C0</th>
            <td>窭</td>
            <td>窳</td>
            <td>衤</td>
            <td>衩</td>
            <td>衲</td>
            <td>衽</td>
            <td>衿</td>
            <td>袂</td>
            <td>袢</td>
            <td>裆</td>
            <td>袷</td>
            <td>袼</td>
            <td>裉</td>
            <td>裢</td>
            <td>裎</td>
            <td>裣</td>
        </tr><tr><th>F1D0</th>
            <td>裥</td>
            <td>裱</td>
            <td>褚</td>
            <td>裼</td>
            <td>裨</td>
            <td>裾</td>
            <td>裰</td>
            <td>褡</td>
            <td>褙</td>
            <td>褓</td>
            <td>褛</td>
            <td>褊</td>
            <td>褴</td>
            <td>褫</td>
            <td>褶</td>
            <td>襁</td>
        </tr><tr><th>F1E0</th>
            <td>襦</td>
            <td>襻</td>
            <td>疋</td>
            <td>胥</td>
            <td>皲</td>
            <td>皴</td>
            <td>矜</td>
            <td>耒</td>
            <td>耔</td>
            <td>耖</td>
            <td>耜</td>
            <td>耠</td>
            <td>耢</td>
            <td>耥</td>
            <td>耦</td>
            <td>耧</td>
        </tr><tr><th>F1F0</th>
            <td>耩</td>
            <td>耨</td>
            <td>耱</td>
            <td>耋</td>
            <td>耵</td>
            <td>聃</td>
            <td>聆</td>
            <td>聍</td>
            <td>聒</td>
            <td>聩</td>
            <td>聱</td>
            <td>覃</td>
            <td>顸</td>
            <td>颀</td>
            <td>颃</td>
            <td> </td>
        </tr><tr><th>第82区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>F2A0</th>
            <td> </td>
            <td>颉</td>
            <td>颌</td>
            <td>颍</td>
            <td>颏</td>
            <td>颔</td>
            <td>颚</td>
            <td>颛</td>
            <td>颞</td>
            <td>颟</td>
            <td>颡</td>
            <td>颢</td>
            <td>颥</td>
            <td>颦</td>
            <td>虍</td>
            <td>虔</td>
        </tr><tr><th>F2B0</th>
            <td>虬</td>
            <td>虮</td>
            <td>虿</td>
            <td>虺</td>
            <td>虼</td>
            <td>虻</td>
            <td>蚨</td>
            <td>蚍</td>
            <td>蚋</td>
            <td>蚬</td>
            <td>蚝</td>
            <td>蚧</td>
            <td>蚣</td>
            <td>蚪</td>
            <td>蚓</td>
            <td>蚩</td>
        </tr><tr><th>F2C0</th>
            <td>蚶</td>
            <td>蛄</td>
            <td>蚵</td>
            <td>蛎</td>
            <td>蚰</td>
            <td>蚺</td>
            <td>蚱</td>
            <td>蚯</td>
            <td>蛉</td>
            <td>蛏</td>
            <td>蚴</td>
            <td>蛩</td>
            <td>蛱</td>
            <td>蛲</td>
            <td>蛭</td>
            <td>蛳</td>
        </tr><tr><th>F2D0</th>
            <td>蛐</td>
            <td>蜓</td>
            <td>蛞</td>
            <td>蛴</td>
            <td>蛟</td>
            <td>蛘</td>
            <td>蛑</td>
            <td>蜃</td>
            <td>蜇</td>
            <td>蛸</td>
            <td>蜈</td>
            <td>蜊</td>
            <td>蜍</td>
            <td>蜉</td>
            <td>蜣</td>
            <td>蜻</td>
        </tr><tr><th>F2E0</th>
            <td>蜞</td>
            <td>蜥</td>
            <td>蜮</td>
            <td>蜚</td>
            <td>蜾</td>
            <td>蝈</td>
            <td>蜴</td>
            <td>蜱</td>
            <td>蜩</td>
            <td>蜷</td>
            <td>蜿</td>
            <td>螂</td>
            <td>蜢</td>
            <td>蝽</td>
            <td>蝾</td>
            <td>蝻</td>
        </tr><tr><th>F2F0</th>
            <td>蝠</td>
            <td>蝰</td>
            <td>蝌</td>
            <td>蝮</td>
            <td>螋</td>
            <td>蝓</td>
            <td>蝣</td>
            <td>蝼</td>
            <td>蝤</td>
            <td>蝙</td>
            <td>蝥</td>
            <td>螓</td>
            <td>螯</td>
            <td>螨</td>
            <td>蟒</td>
            <td> </td>
        </tr><tr><th>第83区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>F3A0</th>
            <td> </td>
            <td>蟆</td>
            <td>螈</td>
            <td>螅</td>
            <td>螭</td>
            <td>螗</td>
            <td>螃</td>
            <td>螫</td>
            <td>蟥</td>
            <td>螬</td>
            <td>螵</td>
            <td>螳</td>
            <td>蟋</td>
            <td>蟓</td>
            <td>螽</td>
            <td>蟑</td>
        </tr><tr><th>F3B0</th>
            <td>蟀</td>
            <td>蟊</td>
            <td>蟛</td>
            <td>蟪</td>
            <td>蟠</td>
            <td>蟮</td>
            <td>蠖</td>
            <td>蠓</td>
            <td>蟾</td>
            <td>蠊</td>
            <td>蠛</td>
            <td>蠡</td>
            <td>蠹</td>
            <td>蠼</td>
            <td>缶</td>
            <td>罂</td>
        </tr><tr><th>F3C0</th>
            <td>罄</td>
            <td>罅</td>
            <td>舐</td>
            <td>竺</td>
            <td>竽</td>
            <td>笈</td>
            <td>笃</td>
            <td>笄</td>
            <td>笕</td>
            <td>笊</td>
            <td>笫</td>
            <td>笏</td>
            <td>筇</td>
            <td>笸</td>
            <td>笪</td>
            <td>笙</td>
        </tr><tr><th>F3D0</th>
            <td>笮</td>
            <td>笱</td>
            <td>笠</td>
            <td>笥</td>
            <td>笤</td>
            <td>笳</td>
            <td>笾</td>
            <td>笞</td>
            <td>筘</td>
            <td>筚</td>
            <td>筅</td>
            <td>筵</td>
            <td>筌</td>
            <td>筝</td>
            <td>筠</td>
            <td>筮</td>
        </tr><tr><th>F3E0</th>
            <td>筻</td>
            <td>筢</td>
            <td>筲</td>
            <td>筱</td>
            <td>箐</td>
            <td>箦</td>
            <td>箧</td>
            <td>箸</td>
            <td>箬</td>
            <td>箝</td>
            <td>箨</td>
            <td>箅</td>
            <td>箪</td>
            <td>箜</td>
            <td>箢</td>
            <td>箫</td>
        </tr><tr><th>F3F0</th>
            <td>箴</td>
            <td>篑</td>
            <td>篁</td>
            <td>篌</td>
            <td>篝</td>
            <td>篚</td>
            <td>篥</td>
            <td>篦</td>
            <td>篪</td>
            <td>簌</td>
            <td>篾</td>
            <td>篼</td>
            <td>簏</td>
            <td>簖</td>
            <td>簋</td>
            <td> </td>
        </tr><tr><th>第84区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>F4A0</th>
            <td> </td>
            <td>簟</td>
            <td>簪</td>
            <td>簦</td>
            <td>簸</td>
            <td>籁</td>
            <td>籀</td>
            <td>臾</td>
            <td>舁</td>
            <td>舂</td>
            <td>舄</td>
            <td>臬</td>
            <td>衄</td>
            <td>舡</td>
            <td>舢</td>
            <td>舣</td>
        </tr><tr><th>F4B0</th>
            <td>舭</td>
            <td>舯</td>
            <td>舨</td>
            <td>舫</td>
            <td>舸</td>
            <td>舻</td>
            <td>舳</td>
            <td>舴</td>
            <td>舾</td>
            <td>艄</td>
            <td>艉</td>
            <td>艋</td>
            <td>艏</td>
            <td>艚</td>
            <td>艟</td>
            <td>艨</td>
        </tr><tr><th>F4C0</th>
            <td>衾</td>
            <td>袅</td>
            <td>袈</td>
            <td>裘</td>
            <td>裟</td>
            <td>襞</td>
            <td>羝</td>
            <td>羟</td>
            <td>羧</td>
            <td>羯</td>
            <td>羰</td>
            <td>羲</td>
            <td>籼</td>
            <td>敉</td>
            <td>粑</td>
            <td>粝</td>
        </tr><tr><th>F4D0</th>
            <td>粜</td>
            <td>粞</td>
            <td>粢</td>
            <td>粲</td>
            <td>粼</td>
            <td>粽</td>
            <td>糁</td>
            <td>糇</td>
            <td>糌</td>
            <td>糍</td>
            <td>糈</td>
            <td>糅</td>
            <td>糗</td>
            <td>糨</td>
            <td>艮</td>
            <td>暨</td>
        </tr><tr><th>F4E0</th>
            <td>羿</td>
            <td>翎</td>
            <td>翕</td>
            <td>翥</td>
            <td>翡</td>
            <td>翦</td>
            <td>翩</td>
            <td>翮</td>
            <td>翳</td>
            <td>糸</td>
            <td>絷</td>
            <td>綦</td>
            <td>綮</td>
            <td>繇</td>
            <td>纛</td>
            <td>麸</td>
        </tr><tr><th>F4F0</th>
            <td>麴</td>
            <td>赳</td>
            <td>趄</td>
            <td>趔</td>
            <td>趑</td>
            <td>趱</td>
            <td>赧</td>
            <td>赭</td>
            <td>豇</td>
            <td>豉</td>
            <td>酊</td>
            <td>酐</td>
            <td>酎</td>
            <td>酏</td>
            <td>酤</td>
            <td> </td>
        </tr><tr><th>第85区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>F5A0</th>
            <td> </td>
            <td>酢</td>
            <td>酡</td>
            <td>酰</td>
            <td>酩</td>
            <td>酯</td>
            <td>酽</td>
            <td>酾</td>
            <td>酲</td>
            <td>酴</td>
            <td>酹</td>
            <td>醌</td>
            <td>醅</td>
            <td>醐</td>
            <td>醍</td>
            <td>醑</td>
        </tr><tr><th>F5B0</th>
            <td>醢</td>
            <td>醣</td>
            <td>醪</td>
            <td>醭</td>
            <td>醮</td>
            <td>醯</td>
            <td>醵</td>
            <td>醴</td>
            <td>醺</td>
            <td>豕</td>
            <td>鹾</td>
            <td>趸</td>
            <td>跫</td>
            <td>踅</td>
            <td>蹙</td>
            <td>蹩</td>
        </tr><tr><th>F5C0</th>
            <td>趵</td>
            <td>趿</td>
            <td>趼</td>
            <td>趺</td>
            <td>跄</td>
            <td>跖</td>
            <td>跗</td>
            <td>跚</td>
            <td>跞</td>
            <td>跎</td>
            <td>跏</td>
            <td>跛</td>
            <td>跆</td>
            <td>跬</td>
            <td>跷</td>
            <td>跸</td>
        </tr><tr><th>F5D0</th>
            <td>跣</td>
            <td>跹</td>
            <td>跻</td>
            <td>跤</td>
            <td>踉</td>
            <td>跽</td>
            <td>踔</td>
            <td>踝</td>
            <td>踟</td>
            <td>踬</td>
            <td>踮</td>
            <td>踣</td>
            <td>踯</td>
            <td>踺</td>
            <td>蹀</td>
            <td>踹</td>
        </tr><tr><th>F5E0</th>
            <td>踵</td>
            <td>踽</td>
            <td>踱</td>
            <td>蹉</td>
            <td>蹁</td>
            <td>蹂</td>
            <td>蹑</td>
            <td>蹒</td>
            <td>蹊</td>
            <td>蹰</td>
            <td>蹶</td>
            <td>蹼</td>
            <td>蹯</td>
            <td>蹴</td>
            <td>躅</td>
            <td>躏</td>
        </tr><tr><th>F5F0</th>
            <td>躔</td>
            <td>躐</td>
            <td>躜</td>
            <td>躞</td>
            <td>豸</td>
            <td>貂</td>
            <td>貊</td>
            <td>貅</td>
            <td>貘</td>
            <td>貔</td>
            <td>斛</td>
            <td>觖</td>
            <td>觞</td>
            <td>觚</td>
            <td>觜</td>
            <td> </td>
        </tr><tr><th>第86区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>F6A0</th>
            <td> </td>
            <td>觥</td>
            <td>觫</td>
            <td>觯</td>
            <td>訾</td>
            <td>謦</td>
            <td>靓</td>
            <td>雩</td>
            <td>雳</td>
            <td>雯</td>
            <td>霆</td>
            <td>霁</td>
            <td>霈</td>
            <td>霏</td>
            <td>霎</td>
            <td>霪</td>
        </tr><tr><th>F6B0</th>
            <td>霭</td>
            <td>霰</td>
            <td>霾</td>
            <td>龀</td>
            <td>龃</td>
            <td>龅</td>
            <td>龆</td>
            <td>龇</td>
            <td>龈</td>
            <td>龉</td>
            <td>龊</td>
            <td>龌</td>
            <td>黾</td>
            <td>鼋</td>
            <td>鼍</td>
            <td>隹</td>
        </tr><tr><th>F6C0</th>
            <td>隼</td>
            <td>隽</td>
            <td>雎</td>
            <td>雒</td>
            <td>瞿</td>
            <td>雠</td>
            <td>銎</td>
            <td>銮</td>
            <td>鋈</td>
            <td>錾</td>
            <td>鍪</td>
            <td>鏊</td>
            <td>鎏</td>
            <td>鐾</td>
            <td>鑫</td>
            <td>鱿</td>
        </tr><tr><th>F6D0</th>
            <td>鲂</td>
            <td>鲅</td>
            <td>鲆</td>
            <td>鲇</td>
            <td>鲈</td>
            <td>稣</td>
            <td>鲋</td>
            <td>鲎</td>
            <td>鲐</td>
            <td>鲑</td>
            <td>鲒</td>
            <td>鲔</td>
            <td>鲕</td>
            <td>鲚</td>
            <td>鲛</td>
            <td>鲞</td>
        </tr><tr><th>F6E0</th>
            <td>鲟</td>
            <td>鲠</td>
            <td>鲡</td>
            <td>鲢</td>
            <td>鲣</td>
            <td>鲥</td>
            <td>鲦</td>
            <td>鲧</td>
            <td>鲨</td>
            <td>鲩</td>
            <td>鲫</td>
            <td>鲭</td>
            <td>鲮</td>
            <td>鲰</td>
            <td>鲱</td>
            <td>鲲</td>
        </tr><tr><th>F6F0</th>
            <td>鲳</td>
            <td>鲴</td>
            <td>鲵</td>
            <td>鲶</td>
            <td>鲷</td>
            <td>鲺</td>
            <td>鲻</td>
            <td>鲼</td>
            <td>鲽</td>
            <td>鳄</td>
            <td>鳅</td>
            <td>鳆</td>
            <td>鳇</td>
            <td>鳊</td>
            <td>鳋</td>
            <td> </td>
        </tr><tr><th>第87区</th>
            <th>+0</th>
            <th>+1</th>
            <th>+2</th>
            <th>+3</th>
            <th>+4</th>
            <th>+5</th>
            <th>+6</th>
            <th>+7</th>
            <th>+8</th>
            <th>+9</th>
            <th>+A</th>
            <th>+B</th>
            <th>+C</th>
            <th>+D</th>
            <th>+E</th>
            <th>+F</th>
        </tr><tr><th>F7A0</th>
            <td> </td>
            <td>鳌</td>
            <td>鳍</td>
            <td>鳎</td>
            <td>鳏</td>
            <td>鳐</td>
            <td>鳓</td>
            <td>鳔</td>
            <td>鳕</td>
            <td>鳗</td>
            <td>鳘</td>
            <td>鳙</td>
            <td>鳜</td>
            <td>鳝</td>
            <td>鳟</td>
            <td>鳢</td>
        </tr><tr><th>F7B0</th>
            <td>靼</td>
            <td>鞅</td>
            <td>鞑</td>
            <td>鞒</td>
            <td>鞔</td>
            <td>鞯</td>
            <td>鞫</td>
            <td>鞣</td>
            <td>鞲</td>
            <td>鞴</td>
            <td>骱</td>
            <td>骰</td>
            <td>骷</td>
            <td>鹘</td>
            <td>骶</td>
            <td>骺</td>
        </tr><tr><th>F7C0</th>
            <td>骼</td>
            <td>髁</td>
            <td>髀</td>
            <td>髅</td>
            <td>髂</td>
            <td>髋</td>
            <td>髌</td>
            <td>髑</td>
            <td>魅</td>
            <td>魃</td>
            <td>魇</td>
            <td>魉</td>
            <td>魈</td>
            <td>魍</td>
            <td>魑</td>
            <td>飨</td>
        </tr><tr><th>F7D0</th>
            <td>餍</td>
            <td>餮</td>
            <td>饕</td>
            <td>饔</td>
            <td>髟</td>
            <td>髡</td>
            <td>髦</td>
            <td>髯</td>
            <td>髫</td>
            <td>髻</td>
            <td>髭</td>
            <td>髹</td>
            <td>鬈</td>
            <td>鬏</td>
            <td>鬓</td>
            <td>鬟</td>
        </tr><tr><th>F7E0</th>
            <td>鬣</td>
            <td>麽</td>
            <td>麾</td>
            <td>縻</td>
            <td>麂</td>
            <td>麇</td>
            <td>麈</td>
            <td>麋</td>
            <td>麒</td>
            <td>鏖</td>
            <td>麝</td>
            <td>麟</td>
            <td>黛</td>
            <td>黜</td>
            <td>黝</td>
            <td>黠</td>
        </tr><tr><th>F7F0</th>
            <td>黟</td>
            <td>黢</td>
            <td>黩</td>
            <td>黧</td>
            <td>黥</td>
            <td>黪</td>
            <td>黯</td>
            <td>鼢</td>
            <td>鼬</td>
            <td>鼯</td>
            <td>鼹</td>
            <td>鼷</td>
            <td>鼽</td>
            <td>鼾</td>
            <td>齄</td>
            <td> </td>
        </tr><tr><th>第88区</th>
            <th>F8A0-F8FF</th>
            <td>没有编码</td>
        </tr><tr><th>第89区</th>
            <th>F9A0-F9FF</th>
            <td>没有编码</td>
        </tr><tr><th>第90区</th>
            <th>FAA0-FAFF</th>
            <td>没有编码</td>
        </tr><tr><th>第91区</th>
            <th>FBA0-FBFF</th>
            <td>没有编码</td>
        </tr><tr><th>第92区</th>
            <th>FCA0-FCFF</th>
            <td>没有编码</td>
        </tr><tr><th>第93区</th>
            <th>FDA0-FDFF</th>
            <td>没有编码</td>
        </tr><tr><th>第94区</th>
            <th>FEA0-FEFF</th>
            <td>没有编码</td>
        </tr></tbody></table> 

<h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>GB2312在兼容GB2312和ASCII的前提下，用每个字占据2bytes的方式又编码了许多汉字。可以表示的汉字达到了20902个，另有984个汉语标点符号、部首等。值得注意的是这20902个汉字还包含了繁体字。</p>
<h2 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h2><p>GB18030使用4bytes编码。为了兼容GBK，这个四字节的前两位显然不能与GBK冲突。我国在2000年和2005年分别颁布的两次GB18030编码，其中2005年的是在2000年基础上进一步补充。至此，GB18030编码的中文文件已经有七万多个汉字了，甚至包含了少数民族文字。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>Unicode TransformationFormat-8bit，允许含BOM，但通常不含BOM。是用以解决国际上字符的一种多字节编码，它对英文使用8位（即一个字节），中文使用3个字节来编码。UTF-8包含全世界所有国家需要用到的字符，是国际编码，通用性强。UTF-8编码的文字可以在各国支持UTF8字符集的浏览器上显示。如，如果是UTF8编码，则在外国人的英文IE上也能显示中文，他们无需下载IE的中文语言支持包。</p>
]]></content>
  </entry>
  <entry>
    <title>daemon process</title>
    <url>/2022/08/13/c/daemon/</url>
    <content><![CDATA[<p>每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。</p>
<p>守护进程(daemon)是一种在系统引导装入时起动，在系统关闭时终止，不会受到用户、终端或者其他的变化而影响，在后台运行没有控制终端的进程。</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>进程组是一个或多个进程的集合。进程组由进程组 ID 来惟一标识。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;                 <span class="comment">/* POSIX.1 version */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">pid_t</span> pid)</span>;            <span class="comment">/* BSD version */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;                   <span class="comment">/* System V version */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;  <span class="comment">/* BSD version */</span></span><br></pre></td></tr></table></figure>

<p>setpgid()将pid进程的进程组ID设置为pgid。如果pid和pgid相等，则由pid指定的进程变成进程组组长，如果pid是0，则使用调用者的进程ID，如果pgid是0，则由pid指定的进程ID被用作为进程组ID。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话是一个或多个进程组的集合，一个会话开始于用户登录，终止于用户退出，在此期间该用户运行的所有进程都属于这个会话。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>setsid()函数能够使进程完全独立出来，从而脱离其他进程的控制：</p>
<ul>
<li>让进程摆脱原会话的控制。</li>
<li>让进程摆脱原进程组的控制。</li>
<li>让进程摆脱原控制终端的控制。</li>
</ul>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><ol>
<li><p>首先fork一个子进程，然后让父进程exit。这样做实现了下面几点：(a)如果精灵进程是由一条shell命令起动的，那么父进程终止使得shell认为这条命令已经执行完成。(b)进程继承了父进程的进程组ID，其进程ID则是新分配的，这就保证了子进程不是一个进程组的首进程，这是setsid()调用的前提条件。</p>
</li>
<li><p>调用setsid()以创建一个新对话期，使调用进程：(a)成为新对话期的首进程，(b)成为一个新进程组的首进程，(c)没有控制终端。</p>
</li>
<li><p>将当前工作目录更改为/目录，保证工作目录所在的文件系统不能被卸载。</p>
</li>
<li><p>将文件权限掩码设置为0，方便进程操作文件。</p>
</li>
<li><p>关闭不再需要的文件描述符，从父进程那里继承打开了的文件，可能永远不会被守护进程读或写，但一样消耗系统资源，而且可能导致所在的文件系统无法被卸载。</p>
</li>
</ol>
<p>守护进程没有控制终端，所以不能将错误信息输出到控制终端，可以使用syslog服务将程序中的出错信息输入到系统日志文件/var/log/syslog。</p>
<h2 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h2><p>syslog是linux中的系统日志管理服务，通过守护进程syslogd来维护，该守护进程在启动时会读配置文件/etc/syslog.conf，该文件决定了不同种类的消息会发送向何处。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> option, <span class="type">int</span> facility)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>openlog用于打开系统日志服务的一个连接。ident参数定义消息的标签字符串，option参数：</p>
<ul>
<li>LOG_CONS  如果消息无法送到系统日志服务，则直接输出到系统控制终端</li>
<li>LOG_NDELAY  立即打开系统日志服务的连接。在正常情况下，直接发送到第一条消息时才打开连接</li>
<li>LOG_PERROR  将日志消息发送给 s y s l o g和stderr。</li>
<li>LOG_PID  消息中包含进程的PID</li>
</ul>
<p>facility参数指定程序发送的消息类型：</p>
<ul>
<li>LOG_AUTHPRIV  安全/授权信息</li>
<li>LOG_CRON  时间守护进程(cron 及 at)函数传入值</li>
<li>LOG_DAEMON  其他系统守护进程</li>
<li>LOG_KERN  内核信息</li>
<li>LOG_LOCAL[0~7]  保留</li>
<li>LOG_LPR  行打印机子系统</li>
<li>LOG_MAIL  邮件子系统</li>
<li>LOG_NEWS  新闻子系统</li>
<li>LOG_SYSLOG  syslogd 内部所产生的信息</li>
<li>LOG_USER  一般使用者等级信息</li>
<li>LOG_UUCP  UUCP 子系统</li>
</ul>
<p>syslog是用于向日志文件中写入消息，format参数规定消息输出格式等。priority参数指定消息等级：</p>
<ul>
<li>LOG_EMERG  紧急(系统不可使用)</li>
<li>LOG_ALERT  需要立即采取措施</li>
<li>LOG_CRIT  重要情况</li>
<li>LOG_ERR  错误消息</li>
<li>LOG_WARNING  警告消息</li>
<li>LOG_NOTICE  正常情况,但也是重要情况</li>
<li>LOG_INFO  信息消息</li>
<li>LOG_DEBUG  调试信息</li>
</ul>
<p>closelog是用于关闭系统日志服务的连接。</p>
<h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开系统日志服务 */</span></span><br><span class="line">openlog(<span class="string">&quot;daemon_syslog&quot;</span>, LOG_PID, LOG_DAEMON);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建新的会话组*/</span></span><br><span class="line"><span class="type">int</span> ret = setsid();</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    syslog(LOG_ERR, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    syslog(LOG_ERR, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*关闭父进程的文件描述符*/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; getdtablesize(); ++i) &#123;</span><br><span class="line">    close(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syslog(LOG_INFO, <span class="string">&quot;daemon init\n&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux 文件管理函数</title>
    <url>/2022/06/07/c/filedir/</url>
    <content><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p><img src="/images/linux/filedir/file_fs.png" alt="文件系统"><br><img src="/images/linux/filedir/inode.png" alt="i节点"></p>
<p>Linux 下的文件是通过索引节点(inode)来识别文件，硬链接是一个指向文件索引节点的指针。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;         <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">mode_t</span>    st_mode;        <span class="comment">/* protection */</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;       <span class="comment">/* number of hard links */</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;         <span class="comment">/* user ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>     st_gid;         <span class="comment">/* group ID of owner */</span></span><br><span class="line">    <span class="type">dev_t</span>     st_rdev;        <span class="comment">/* device ID (if special file) */</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;        <span class="comment">/* total size, in bytes */</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize;     <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">/* number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* time of last status change */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>stat函数返回一个与此命名文件有关的信息结构， fstat函数获得已在描述符filedes上打开的文件的有关信息。lstat函数类似于stat，但是当命名的文件是一个符号连接时，lstat返回该符号连接的有关信息，而不是由该符号连接引用的文件的信息。</p>
<p>软连接的长度是其所指向的文件名的长度。</p>
<p>修改时间(st_mtime)是文件内容最后一次被修改的时间。更改状态时间(st_ctime)是该文件的i节点最后一次被修改的时间。很多操作影响到 i节点，但并没有更改文件的实际内容:文件的存取许可权、用户ID、连接数等等。因为i节点中的所有信息都是与文件的实际内容分开存放的，所以，除了文件数据修改时间以外，还需要更改状态时间。</p>
<p><img src="/images/linux/filedir/file_time.png" alt="文件的时间"></p>
<p>ls命令按这三个时间值中的一个排序进行显示。按系统默认 (用-l或-t选择项调用时 )，它按文件的修改时间的先后排序显示。 -u选择项使其用存取时间排序， -c选择项则使其用更改状态时间排序。</p>
<p>表4-9中包含两列的原因，其中一列是与该文件(或目录)相关的三个时间，另一列是与所引用的文件(或目录)的父目录相关的三个时间。例如创建一个新文件影响到包含此新文件的目录，也影响该新文件的i节点。但读或写一个文件只影响该文件的i节点，而对父目录则无影响。</p>
<p><img src="/images/linux/filedir/time_effect_by_function.png" alt="函数对文件时间的作用"></p>
<h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>按实际用户ID和实际组ID进行存取许可权测试。成功返回0，失败返回-1。mode取值：</p>
<ul>
<li>R_OK 测试读许可权</li>
<li>W_OK 测试写许可权</li>
<li>X_OK 测试执行许可权</li>
<li>F_OK 测试文件是否存在</li>
</ul>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>;</span><br></pre></td></tr></table></figure>

<p>相对于系统umaks为0000来的，要把系统umask也算上。</p>
<p><img src="/images/linux/filedir/mode_t.png" alt="mode_t"></p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchmod</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>将指定的文件的长度截短为length。如果该文件以前的长度大于length，则超过length以外的数据就不能存取。如果以前的长度短于length，则超过部分的数据将读作’\0’。</p>
<h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<p>创建硬连接，只有root用户才可以创建到目录的硬连接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>解除硬连接，并将引用的文件的连接计数减1。可以用作删除文件，只有当文件的连接计数为0，没有被进程打开，文件才能删除。</p>
<p>unlink的这种特性经常被程序用来确保即使是在程序崩溃时,它所创建的临时文件也不会遗留下来。进程用open或creat创建一个文件,然后立即调用unlink。因为该文件已经被打开了，所以不会将其内容删除。只有当进程关闭该文件或终止时，该文件的内容才被删除。</p>
<h3 id="symlink-readlink"><a href="#symlink-readlink" class="headerlink" title="symlink readlink"></a>symlink readlink</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>;</span><br></pre></td></tr></table></figure>

<p>创建软连接，不要求target已经存在，且target和linkpath不需要位于同一文件系统中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *buf, <span class="type">size_t</span> bufsiz)</span>;</span><br></pre></td></tr></table></figure>

<p>打开该连接本身，并读该连接中的名字，此函数组合了open,read和close的所有操作，如果此函数成功，则它返回读入buf的字节数，不包含终止符\0。</p>
<p><img src="/images/linux/filedir/link.png" alt="link"></p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="utime"><a href="#utime" class="headerlink" title="utime"></a>utime</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> actime;       <span class="comment">/* access time */</span></span><br><span class="line">    <span class="type">time_t</span> modtime;      <span class="comment">/* modification time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此函数的操作以及执行它所要求的优先权取决于times参数是否是NULL。</p>
<ul>
<li>如果times是一个空指针，则存取时间和修改时间两者都设置为当前时间。为了执行此操作必须满足下列两条件之一: (a)进程的有效用户ID必须等于该文件的所有者ID，(b)进程对该文件必须具有写许可权。</li>
<li>如果times是非空指针，则存取时间和修改时间被设置为times所指向的结构中的值。此时进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是一个超级用户进程。</li>
</ul>
<p>我们不能对更改状态时间st_ctime指定一个值，当调用utime函数时，此字段被自动更新。</p>
<h3 id="mkdir-rmdir"><a href="#mkdir-rmdir" class="headerlink" title="mkdir rmdir"></a>mkdir rmdir</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>创建一个新的空目录。 . 和.. 目录项是自动创建的。指定的文件存取许可权mode由进程的文件方式创建屏蔽字修改。至少要设置1个执行许可权位，以允许存取该目录中的文件名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>目录必须是空才能被删除。</p>
<h3 id="opendir"><a href="#opendir" class="headerlink" title="opendir"></a>opendir</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*resets the position of the directory stream dirp to the beginning of the directory.*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewinddir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span>          d_ino;       <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">off_t</span>          d_off;       <span class="comment">/* not an offset; see NOTES */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* length of this record */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* type of file; not supported</span></span><br><span class="line"><span class="comment">                                  by all filesystem types */</span></span><br><span class="line">    <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchdir</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">syncfs</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>将缓存的数据同步到磁盘文件。</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>linux file io</title>
    <url>/2022/08/13/c/fileio/</url>
    <content><![CDATA[<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><table>
<thead>
<tr>
<th align="center">文件描述符</th>
<th align="center">用途</th>
<th>POSIX 名称</th>
<th>stdio 流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">标准输入</td>
<td>STDIN_FILENO</td>
<td>stdin</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">标准输出</td>
<td>STDOUT_FILENO</td>
<td>stdout</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">标准错误</td>
<td>STDERR_FILENO</td>
<td>stderr</td>
</tr>
</tbody></table>
<p>stdout和stderr两者默认向屏幕输出，stdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。而stderr是无缓冲的，会直接输出。如果重定向向标准输出到文件，stdout输出到文件，stderr在屏幕。</p>
<h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>flags参数：</p>
<ul>
<li><code>O_RDONLY</code>  只读打开；</li>
<li><code>O_WRONLY</code>  只写打开；</li>
<li><code>O_RDWR</code>  读写打开；</li>
<li><code>O_CLOEXEC</code>  设置close-on-exec标志</li>
<li><code>O_CREAT</code>  若文件不存在则创建之</li>
<li><code>O_DIRECT</code>  无缓冲的输入/输出</li>
<li><code>O_DIRECTORY</code>  如果pathname不是目录，则失败</li>
<li><code>O_EXCL</code>  结合O_CREAT参数使用，如果要创建的文件已存在，则返回-1，并且修改errno的值</li>
<li><code>O_LARGEFILE</code>  在32位系统中使用此标志打开大文件</li>
<li><code>O_NOATIME</code> 调用read，不修改文件最近访问时间</li>
<li><code>O_NOCTTY</code>  不要让pathname所指向的终端设备成为控制终端</li>
<li><code>O_NOFOLLOW</code>  对符号链接不予解引用  </li>
<li><code>O_TRUNC</code>  截断已有文件，使其长度为零</li>
<li><code>O_APPEND</code>  总在文件尾部追加数据  </li>
<li><code>O_ASYNC</code>  异步I/O，产生信号通知进程</li>
<li><code>O_DSYNC</code>  提供同步的 I/O 数据完整性</li>
<li><code>O_NONBLOCK</code>  以非阻塞方式打开</li>
<li><code>O_NDELAY</code>  同O_NONBLOCK</li>
<li><code>O_SYNC</code>  以同步方式写入文件</li>
<li><code>O_TEXT</code>  打开文本文件翻译CR-LF控制字符；</li>
<li><code>O_BINARY</code>  打开二进制字符，不作CR-LF翻译</li>
</ul>
<p>mode 参数:</p>
<ul>
<li><code>S_IRWXU</code>  00700 user (file owner) has read, write, and execute permission</li>
<li><code>S_IRUSR</code>  00400 user has read permission</li>
<li><code>S_IWUSR</code>  00200 user has write permission</li>
<li><code>S_IXUSR</code>  00100 user has execute permission</li>
<li><code>S_IRWXG</code>  00070 group has read, write, and execute permission</li>
<li><code>S_IRGRP</code>  00040 group has read permission</li>
<li><code>S_IWGRP</code>  00020 group has write permission</li>
<li><code>S_IXGRP</code>  00010 group has execute permission</li>
<li><code>S_IRWXO</code>  00007 others have read, write, and execute permission</li>
<li><code>S_IROTH</code>  00004 others have read permission</li>
<li><code>S_IWOTH</code>  00002 others have write permission</li>
<li><code>S_IXOTH</code>  00001 others have execute permission</li>
<li><code>S_ISUID</code>  0004000 set-user-ID bit</li>
<li><code>S_ISGID</code>  0002000 set-group-ID bit (see stat(2))</li>
<li><code>S_ISVTX</code>  0001000 sticky bit (see stat(2))</li>
</ul>
<p>openat() 函数使进程内的各线程拥有不同的当前目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek()"></a>lseek()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>lseek()函数会重新定位被打开文件的位移量，根据参数offset以及whence的组合来决定。</p>
<ul>
<li>SEEK_SET： 从文件头部开始偏移offset个字节。</li>
<li>SEEK_CUR：从文件当前读写的指针位置开始，增加offset个字节的偏移量。</li>
<li>SEEK_END：文件偏移量设置为文件的大小加上偏移量字节。</li>
</ul>
<p>因为管道、套接字等文件是不可定位的，所以无法在这些文件使用lseek()。</p>
<p><strong>空洞文件</strong></p>
<p>通过 lseek() 设置文件大小，可以形成一个空洞文件，有很多用途：</p>
<ul>
<li>迅雷未下载完，就占据文件全部大小的空间，可以实现多线程从多个地址写入。</li>
<li>提前占用空间，防止所需空间不足。</li>
<li>使磁盘尽可能的连续，减少磁盘寻道开销。</li>
<li>追加数据不会改变大小，故不涉及元数据的修改。</li>
</ul>
<h3 id="read-write"><a href="#read-write" class="headerlink" title="read() write()"></a>read() write()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>  filedes, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes)</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="type">void</span> * buff, <span class="type">size_t</span> nbytes)</span></span><br></pre></td></tr></table></figure>

<p>read()从打开文件中读数据，返回读到的字节数，若已到文件尾为 0，若出错为- 1。</p>
<p>write()向打开文件写数据，若成功返回已写的字节数，若出错为- 1。不带缓存。</p>
<p><strong>pwrite() pread()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>pwrite函数在单线程的情况下，相当于 lseek 和 write 函数的组合：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lseek</span>(fd, offset, SEEK_SET);</span><br><span class="line"><span class="built_in">write</span>(fd, buf, len);</span><br></pre></td></tr></table></figure>

<p>在 fd文件描述符没有O_APPEND属性的情况下，write函数会修改文件偏移指针，下次不seek写入位置直接调用write函数时，write函数会接着上次的位置继续写入（offset+len），而pwrite函数则不会改变文件偏移指针。另外，pwrite函数的seek和写入是原子操作，不会因为进程调度或者其他因素中断。</p>
<h2 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl()"></a>fcntl()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">   <span class="type">short</span> l_type;    <span class="comment">/* Type of lock: F_RDLCK,F_WRLCK, F_UNLCK */</span></span><br><span class="line">   <span class="type">short</span> l_whence;  <span class="comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">   <span class="type">off_t</span> l_start;   <span class="comment">/* Starting offset for lock */</span></span><br><span class="line">   <span class="type">off_t</span> l_len;     <span class="comment">/* Number of bytes to lock */</span></span><br><span class="line">   <span class="type">pid_t</span> l_pid;     <span class="comment">/* PID of process blocking our lock(set by F_GETLK and F_OFD_GETLK) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>F_DUPFD  复制文件描述符</li>
<li>F_GETFD  获得fd的close-on-exec标志，若标志未设置，则文件经过exec函数之后仍保持打开状态</li>
<li>F_SETFD  设置close-on-exec标志，该标志由参数arg的FD_CLOEXEC位决定</li>
<li>F_GETFL  得到文件描述符标志</li>
<li>F_SETFL  改变文件描述符标志，新标志值按第三个参数设置。</li>
<li>F_GETLK  根据lock参数值，决定是否上文件锁</li>
<li>F_SETLK  设置lock参数值的文件锁</li>
<li>F_SETLKW  这是F_SETLK的阻塞版本</li>
</ul>
<p>读取锁又称为共享锁，它能够使多个进程都能在文件的同一部分建立读取锁。而写入锁又称为排斥锁，在任何时刻只能有一个进程在文件的某个部分上建立写入锁。当然，在文件的同一部分不能同时建立读取锁和写入锁。</p>
<h2 id="dup"><a href="#dup" class="headerlink" title="dup()"></a>dup()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure>

<p>dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。dup2()则可以用newfd参数指定新描述符的数值，如果newfd已经打开，则先将其关闭，若oldfd等于newfd，则dup2返回newfd，不关闭它。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><ul>
<li><p>阻塞式IO：使用系统调用，并一直被阻塞，直到数据准备好且从内核复制到用户程序才返回。</p>
</li>
<li><p>非阻塞式IO：如果数据没有准备好，不会阻塞，而是返回一个错误码。</p>
</li>
<li><p>IO多路复用：类似与非阻塞，只不过轮询不是由用户线程去执行，而是由内核去轮询，直到监听到数据准备好。</p>
</li>
<li><p>信号驱动IO：内核在数据准备就绪时通过信号来进行通知，首先开启信号驱动io套接字，并使用sigaction系统调用来安装信号处理程序，内核直接返回，不会阻塞用户态，数据准备好时，内核会发送SIGIO信号，用户进程收到信号后才开始进行io操作。</p>
</li>
<li><p>异步IO：依赖信号处理程序来进行通知，等IO操作完成时通过回调函数对数据进行处理，unix中异步io函数以aio_或lio_打头。</p>
</li>
</ul>
<h3 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">            fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pselect</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">            fd_set *exceptfds, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout, <span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span>;</span><br></pre></td></tr></table></figure>

<p>nfds参数值为需要监视的文件描述符的最大值+1。</p>
<p>在使用 select()函数之前，首先使用 FD_ZERO()和 FD_SET()来初始化文件描述符集，在使用了select()函数时，可循环使用 FD_ISSET()来测试描述符集，在执行完对相关文件描述符的操作之后，使用FD_CLR()来清除描述符集。</p>
<p>select 机制的缺陷:</p>
<ul>
<li>内核必须检查多余的文件描述符</li>
<li>每次调用后必须重置被监听的文件描述符集</li>
<li>可监听的文件个数受限制，最大FD_SETSIZE</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>numfds:需要监听的文件个数，fds参数所指向的数组中的元素数目。<br>timeout:表示 poll 阻塞的超时时间(毫秒)。如果该值小于0，则表示无限等待。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll()"></a>epoll()</h3><p>用于代替poll和select，没有大小限制。使用一个文件描述符管理多个文件描述符，使用红黑树存储。同时用事件驱动代替了轮询。epoll_ctl中注册的文件描述符在事件触发的时候会通过回调机制激活该文件描述符。epoll_wait便会收到通知。epoll还采用了mmap虚拟内存映射技术减少用户态和内核态数据传输的开销。</p>
<hr>
<p><a href="https://zhuanlan.zhihu.com/p/159457916">https://zhuanlan.zhihu.com/p/159457916</a></p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>getopt() 函数使用</title>
    <url>/2022/06/07/c/getopt/</url>
    <content><![CDATA[<h2 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h2><p>getopt()函数用于解析命令行参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">const</span> <span class="type">char</span> *optstring)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *optarg;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> optind, opterr, optopt;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p>argc是main()函数传递过来的参数的个数，argv通常是main()函数传递过来的参数的字符串指针数组，optstring是作为选项的字符串的列表，格式为：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>单个字符</td>
<td>表示选项，没有参数</td>
</tr>
<tr>
<td>单字符加冒号:</td>
<td>表示选项有，且必须加参数，参数紧跟其后或者以空格隔开</td>
</tr>
<tr>
<td>单字符加2冒号::</td>
<td>表示选项可以有，也可以没有，选项与参数之间无空格</td>
</tr>
</tbody></table>
<p><strong>返回值</strong></p>
<ul>
<li>如果选项成功找到，返回选项字母。</li>
<li>如果所有命令行选项都解析完毕，返回 -1。</li>
<li>如果发现无效选项字符，返回字符 ‘?’。</li>
<li>如果遇到丢失参数，那么返回值依赖于 optstring 中第一个字符，如果第一个字符是 ‘:’，则返回’:’，否则返回’?’，并提示出错误信息。</li>
</ul>
<p>它还会用到4个外部变量：</p>
<ul>
<li>optarg：如果有参数，则指向当前选项参数的指针，否则为null。</li>
<li>optind：指示下一个要解析的argv索引值，初始时为1，注意如果一个进程里用了多次getopt，则需要手动复位该值。</li>
<li>opterr：设为0时将不打印错误信息。非零时，表示无效选项或缺少参数选项，并输出错误信息。</li>
<li>optopt：包含所发现的无效选项字符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> opt;</span><br><span class="line">	<span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;a::b:c:d&quot;</span>))!= <span class="number">-1</span>)</span><br><span class="line">	&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;opt = %c\n&quot;</span>, opt);</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;opterr = %d\n&quot;</span>, opterr);</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;optarg = %s\n&quot;</span>, optarg);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;optind = %d\n&quot;</span>, optind);</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;optopt = %c\n&quot;</span>, optopt);</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long"></a>getopt_long</h2><p>getopt函数只能处理一个字符的参数，但类似于–help，–version这样的参数，这种参数称为长参数，对于这样的参数，只能用getopt_long函数解析。</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>可重入与线程安全</title>
    <url>/2022/06/07/c/func_r/</url>
    <content><![CDATA[<h2 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h2><p>异步信号安全函数又被称为可重入函数，其定义源自单线程环境： 如果一个函数可以在执行期间的任意时刻被中断，并且可以在中断服务程序中再次被安全调用，以及在中断退出后还可以继续正确执行完函数的剩下部分内容，就称该函数为可重入函数。而不可重入的函数由于使用了全局资源、中断向量表等，在多线程的环境下，它如果被中断，或没有处理数据保护和互斥访问，就会发生错误。</p>
<p>重入即表示重复进入，意味着函数可以被中断，它除了使用自己栈上的变量以外不依赖于任何环境，由于它们使用的是分离的栈，允许多个副本运行，所以互不干扰。</p>
<p>不可重入函数通常会符合以下这些特征之一：</p>
<ul>
<li>使用了静态的数据结构，存在共享资源，可能会损坏；</li>
<li>使用了malloc()或者free()函数；</li>
<li>使用了标准I/O函数，不能在中断处理函数里调用printf(文件偏移是全局的)，printf()有重入和性能上的问题。</li>
<li>函数中调用longjmp或siglongjmp：信号发生时程序正在修改一个数据结构，处理程序返回到另外一处，导致数据被部分更新。</li>
</ul>
<p>常用的可重入函数主要可以分为以下几类：</p>
<ul>
<li><p>所有套接字API，包括socket、connect、bind、accept、listen、select、pselect、poll、recv、recvfrom、recvmsg、send、sendto、sendmsg、setsockopt、getsockopt、socketpair</p>
</li>
<li><p>绝大部分非标准库文件I/O函数，包括read、write、open、openat、creat、close、lseek、dup、dup2、fsync、fdatasync(缺sync)、stat、fstat、fstatat、lstat、access、faccessat、umask、chmod、fchmod、fchmodat、chown、fchown、fchownat、link、linkat、unlink、unlinkat(缺remove)、futimens、utimensat、utimes、mkdir、mkdirat(缺rmdir)、chdir(缺fchdir)</p>
</li>
<li><p>所有进程信号API，包括signal、kill、raise、alarm、pause、sigprocmask、sigpending、sigaction、sigsuspend、abort、sleep(缺nanosleep和clock_nanosleep)、sigqueue</p>
</li>
<li><p>绝大部分进程控制API，包括fork(缺vfork)、_exit、_Exit(缺exit)、wait、waitpid、execl、execle、execv、execve、setuid、setgid、setsid、setpgid、getuid、geteuid、getgid、getegid、getpid、getppid</p>
</li>
<li><p>POSIX标准库函数</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>accept</th>
<th>fchmod</th>
<th>lseek</th>
<th>sendto</th>
<th>stat</th>
</tr>
</thead>
<tbody><tr>
<td>access</td>
<td>fchown</td>
<td>lstat</td>
<td>setgid</td>
<td>symlink</td>
</tr>
<tr>
<td>aio_error</td>
<td>fcntl</td>
<td>mkdir</td>
<td>setpgid</td>
<td>sysconf</td>
</tr>
<tr>
<td>aio_return</td>
<td>fdatasync</td>
<td>mkfifo</td>
<td>setsid</td>
<td>tcdrain</td>
</tr>
<tr>
<td>aio_suspend</td>
<td>fork</td>
<td>open</td>
<td>setsockopt</td>
<td>tcflow</td>
</tr>
<tr>
<td>alarm</td>
<td>fpathconf</td>
<td>pathconf</td>
<td>setuid</td>
<td>tcflush</td>
</tr>
<tr>
<td>bind</td>
<td>fstat</td>
<td>pause</td>
<td>shutdown</td>
<td>tcgetattr</td>
</tr>
<tr>
<td>cfgetispeed</td>
<td>fsync</td>
<td>pipe</td>
<td>sigaction</td>
<td>tcgetpgrp</td>
</tr>
<tr>
<td>cfgetospeed</td>
<td>ftruncate</td>
<td>poll</td>
<td>sigaddset</td>
<td>tcsendbreak</td>
</tr>
<tr>
<td>cfsetispeed</td>
<td>getegid</td>
<td>posix_trace_event</td>
<td>sigdelset</td>
<td>tcsetattr</td>
</tr>
<tr>
<td>cfsetospeed</td>
<td>geteuid</td>
<td>pselect</td>
<td>sigemptyset</td>
<td>tcsetpgrp</td>
</tr>
<tr>
<td>chdir</td>
<td>getgid</td>
<td>raise</td>
<td>sigfillset</td>
<td>time</td>
</tr>
<tr>
<td>chmod</td>
<td>getgroups</td>
<td>read</td>
<td>sigismenber</td>
<td>timer_getoverrun</td>
</tr>
<tr>
<td>chown</td>
<td>getpeername</td>
<td>readlink</td>
<td>signal</td>
<td>timer_gettime</td>
</tr>
<tr>
<td>clock_gettime</td>
<td>getpgrp</td>
<td>recv</td>
<td>sigpause</td>
<td>timer_settime</td>
</tr>
<tr>
<td>close</td>
<td>getpid</td>
<td>recvfrom</td>
<td>sigpending</td>
<td>times</td>
</tr>
<tr>
<td>connect</td>
<td>getppid</td>
<td>recvmsg</td>
<td>sigprocmask</td>
<td>umask</td>
</tr>
<tr>
<td>creat</td>
<td>getsockname</td>
<td>rename</td>
<td>sigqueue</td>
<td>uname</td>
</tr>
<tr>
<td>dup</td>
<td>getsockopt</td>
<td>rmdir</td>
<td>sigset</td>
<td>unlink</td>
</tr>
<tr>
<td>dup2</td>
<td>getuid</td>
<td>select</td>
<td>sigsuspend</td>
<td>utime</td>
</tr>
<tr>
<td>execle</td>
<td>kill</td>
<td>sem_post</td>
<td>sleep</td>
<td>wait</td>
</tr>
<tr>
<td>execve</td>
<td>link</td>
<td>send</td>
<td>socket</td>
<td>waitpid</td>
</tr>
<tr>
<td>_Exit/_exit</td>
<td>listen</td>
<td>sendmsg</td>
<td>socketpair</td>
<td>write</td>
</tr>
</tbody></table>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全函数的定义来自多线程环境：如果一个函数在相同的时间点可以被多个线程安全的调用，就称该函数为线程安全函数。</p>
<p>POSIX中大多数函数都是线程安全的，常用的非线程安全函数主要有以下这些：</p>
<table>
<thead>
<tr>
<th>asctime</th>
<th>ecvt</th>
<th>gethostent</th>
<th>getutxline</th>
<th>putc_unlocked</th>
</tr>
</thead>
<tbody><tr>
<td>basename</td>
<td>encrypt</td>
<td>getlogin</td>
<td>gmtime</td>
<td>putchar_unlocked</td>
</tr>
<tr>
<td>catgets</td>
<td>endgrent</td>
<td>getnetbyaddr</td>
<td>hcreate</td>
<td>putenv</td>
</tr>
<tr>
<td>crypt</td>
<td>endpwent</td>
<td>getnetbyname</td>
<td>hdestroy</td>
<td>pututxline</td>
</tr>
<tr>
<td>ctime</td>
<td>endutxent</td>
<td>getnetent</td>
<td>hsearch</td>
<td>rand</td>
</tr>
<tr>
<td>dbm_clearerr</td>
<td>fcvt</td>
<td>getopt</td>
<td>inet_ntoa</td>
<td>readdir</td>
</tr>
<tr>
<td>dbm_close</td>
<td>ftw</td>
<td>getprotobyname</td>
<td>l64a</td>
<td>setenv</td>
</tr>
<tr>
<td>dbm_delete</td>
<td>gcvt</td>
<td>getprotobynumber</td>
<td>lgamma</td>
<td>setgrent</td>
</tr>
<tr>
<td>dbm_error</td>
<td>getc_unlocked</td>
<td>getprotoent</td>
<td>lgammaf</td>
<td>setkey</td>
</tr>
<tr>
<td>dbm_fetch</td>
<td>getchar_unlocked</td>
<td>getpwent</td>
<td>lgammal</td>
<td>setpwent</td>
</tr>
<tr>
<td>dbm_firstkey</td>
<td>getdate</td>
<td>getpwnam</td>
<td>localeconv</td>
<td>setutxent</td>
</tr>
<tr>
<td>dbm_nextkey</td>
<td>getenv</td>
<td>getpwuid</td>
<td>localtime</td>
<td>strerror</td>
</tr>
<tr>
<td>dbm_open</td>
<td>getgrent</td>
<td>getservbyname</td>
<td>lrand48</td>
<td>strsignal</td>
</tr>
<tr>
<td>dbm_store</td>
<td>getgrgid</td>
<td>getservbyport</td>
<td>mrand48</td>
<td>strtok</td>
</tr>
<tr>
<td>dirname</td>
<td>getgrnam</td>
<td>getservent</td>
<td>nftw</td>
<td>system</td>
</tr>
<tr>
<td>dlerror</td>
<td>gethostbyaddr</td>
<td>getutxent</td>
<td>nl_langinfo</td>
<td>tmpnam</td>
</tr>
<tr>
<td>drand48</td>
<td>gethostbyname</td>
<td>getutxid</td>
<td>ptsname</td>
<td>ttyname</td>
</tr>
<tr>
<td>unsetenv</td>
<td>wcstombs</td>
<td>wctomb</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在写函数时候尽量使用局部变量，对全局变量要用互斥手段加以保护，变得线程安全，对于返回值是存放在静态共享的函数可以通过自己传入地址的方式变得线程可重入。</p>
<p>可重入和线程安全是不同的概念，其观察角度不同，可重入函数和线程安全函数之间也没有必然联系。线程可重入，也就是说是线程安全的，但并不是说对于信号处理函数也是可重入的，同样的也不是异步信号安全的。</p>
<p>对于printf这类IO函数，它们使用了全局数据结构（iobuffer），所以不是线程安全的（多个线程同时访问共享资源），需要对输出缓冲区加锁，所以是不可重入的（有共享资源）。</p>
<p>一个线程中只有一个errno 变量，信号处理函数中使用的可重入函数也有可能会修改errno。正确的做法是在信号处理函数开始时保存errno，在信号处 理函数退出的时候恢复errno。</p>
]]></content>
  </entry>
  <entry>
    <title>GNU extend c syntax</title>
    <url>/2022/08/13/c/gnu_c/</url>
    <content><![CDATA[<p>GCC 对c语言语法进行了扩展，这些扩展对优化、目标代码布局、更安全的检查等提供了很强的支持，其实这并不完全符合 ANSI C 标准。</p>
<p>gcc如果使用“-ansi –pedantic”编译选项，则不使用 GNU 扩展语法。</p>
<h2 id="语句表达式"><a href="#语句表达式" class="headerlink" title="语句表达式"></a>语句表达式</h2><p>GCC把包含在括号中的复合语句看作是一个表达式，称为语句表达式，它允许在一个表达式内使用循环、跳转、局部变量，并可以出现在任何允许表达式出现的地方。位于括号中的复合语句的最后一句必需是一个以分号结尾的表达式，它的值将成为这个语句表达式的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(x,y) (&#123; \</span></span><br><span class="line"><span class="meta">    const typeof(x) _x = (x); \</span></span><br><span class="line"><span class="meta">    const typeof(y) _y = (y); \</span></span><br><span class="line"><span class="meta">    (void) (&amp;_x == &amp;_y); \</span></span><br><span class="line"><span class="meta">    _x &lt; _y ? _x : _y; &#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="零长数组"><a href="#零长数组" class="headerlink" title="零长数组"></a>零长数组</h2><p>零长数组是长度为0的数组，也可以称之为可变长数组，它并不占用结构的空间，一般用作结构体最后一个成员，用于访问该结构体对象之后的一段内存，来看<a href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html">GNU C官网</a>的一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="type">char</span> contents[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> *<span class="title">thisline</span> =</span> (<span class="keyword">struct</span> line *)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> line) + this_length);</span><br><span class="line">thisline-&gt;length = this_length;</span><br></pre></td></tr></table></figure>

<p>contents只是结构体之后一段内存的标记，使用时往后申请this_length大的内存，即可使用thisline-&gt;contents进行访问。</p>
<h2 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> debug(format, ...) fprintf(stderr, format, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<p>其中的“…”表示可变参数，实际调用时，它们会替代宏体里的<code>__VA_ARGS__</code>。甚至还可以给可变参数取个名字。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pr_info(fmt,arg...) printk(KERN_INFO fmt,##arg)</span></span><br></pre></td></tr></table></figure>

<p>其中“##”主要针对参数为空的情况，既然称为可变参数，那传递空参数也是可以的。宏展开后，其中的字符串后面会多个多余的逗号，而“##”则会使预处理器去掉这个多余的逗号。</p>
<h2 id="标号元素"><a href="#标号元素" class="headerlink" title="标号元素"></a>标号元素</h2><p>在标准 C 里，数组或结构变量的初始化值必须以固定的顺序出现，而在 GCC 中，通过指定索引或结构域名，则允许初始化值以任意顺序出现。</p>
<p>指定数组索引的方法是在初始化值前写<code>[INDEX] =</code>，还可以使用<code>[FIRST ... LAST] =</code>的形式指定一个范围，比如:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num[SIZE] = &#123;</span><br><span class="line">    [<span class="number">0</span>] = <span class="number">0</span>,</span><br><span class="line">    [<span class="number">1</span> ... SIZE] = <span class="number">-1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于结构初始化，使用这种形式，当结构体的定义变化导致元素的偏移位置改变时，仍然可以确保已知元素的正确性。对于未出现在初始化中的元素，其初值为 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">misc_ops</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = gpio_drv_open,</span><br><span class="line">    .release = gpio_drv_release,</span><br><span class="line">    .unlocked_ioctl = gpio_drv_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="attribute-属性"><a href="#attribute-属性" class="headerlink" title="__attribute__属性"></a>__attribute__属性</h2><ul>
<li><strong>format</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((format(<span class="built_in">printf</span>,m,n)))</span><br><span class="line">__attribute__((format(<span class="built_in">scanf</span>,m,n)))</span><br></pre></td></tr></table></figure>

<p>编译器会检查格式化字符串与“…”的匹配情况，其中参数m与n的含义为：<br>    m 格式化字符串（format string）的位置（顺序从1开始）；<br>    n 参数“…”的位置（顺序从1开始）；</p>
<ul>
<li><strong>availability</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((availability(macosx,introduced=m,deprecated=n)))</span><br></pre></td></tr></table></figure>

<p>指明API版本的变更。m 引入的版本；n 过时的版本</p>
<ul>
<li><strong>deprecated</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((deprecated))</span><br><span class="line">__attribute__((deprecated(s)))</span><br></pre></td></tr></table></figure>

<p>使编译会给出过时的警告。</p>
<ul>
<li><strong>unavailable</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((unavailable))</span><br></pre></td></tr></table></figure>

<p>告诉编译器该方法不可用，如果强行调用编译器会提示错误。比如某个类在构造的时候不想直接通过init来初始化，只能通过特定的初始化方法，就可以将init方法标记为unavailable。</p>
<ul>
<li><strong>const</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((<span class="type">const</span>))</span><br></pre></td></tr></table></figure>

<p>用于带有数值类型参数的函数上。当重复调用带有数值参数的函数时，由于返回值是相同的，所以此时编译器可以进行优化处理，除第一次需要运算外， 其它只需要返回第一次的结果就可以了，进而可以提高效率。该属性主要适用于没有静态状态和副作用的一些函数，并且返回值仅仅依赖输入的参数。（const参数不能用在带有指针类型参数的函数中，因为该属性不但影响函数的参数值，同样也影响到了参数指向的数据，它可能会对代码本身产生严重甚至是不可恢复的严重后果）。</p>
<ul>
<li><strong>cleanup</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((cleanup(...)))</span><br></pre></td></tr></table></figure>

<p>离开作用域之后执行指定的方法。实际应用中可以在作用域结束之后做一些特定的工作，比如清理。</p>
<ul>
<li><strong>constructor / destructor</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">__attribute__((destructor))</span><br><span class="line">__attribute__((constructor(PRIORITY)))</span><br><span class="line">__attribute__((destructor(PRIORITY)))</span><br></pre></td></tr></table></figure>

<p>constructor标志的函数和全局变量对象（或静态变量）的构造函数在main函数之前调用。destructor标志的函数和全局变量对象（或静态变量）的析构函数在main函数之后调用。PRIORITY 为优先级。main函数之前的，数值越小,越先调用；main函数之后的数值越大，越先调用。（可用于动态库注入的Hook）</p>
<ul>
<li><strong>noreturn</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((<span class="keyword">noreturn</span>))</span><br></pre></td></tr></table></figure>

<p>定义有返回值的函数时，而实际情况有可能没有返回值，避免编译器产生警告信息。</p>
<ul>
<li><strong>unused</strong></li>
</ul>
<p>表示该函数或变量可能并不使用,这个属性能够避免编译器产生警告信息。</p>
<ul>
<li><strong>nonnull</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((nonnull(...)))</span><br></pre></td></tr></table></figure>

<p>编译器对函数参数进行NULL的检查</p>
<ul>
<li><strong>aligned</strong></li>
<li><strong>packed</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((aligned (m)))</span><br><span class="line">__attribute__((aligned))</span><br><span class="line">__attribute__((packed))</span><br></pre></td></tr></table></figure>

<p>aligned(m) 将强制编译器尽其所能地确保变量在分配空间时采用m字节对齐方式。packed该属性对struct 或者union 类型进行定义，设定其类型的每个变量按1字节对齐,这个常用于与协议有关的网络传输中，当用在enum 类型定义时，暗示了应该使用最小完整的类型。aligned 属性使被设置的对象占用更多的空间，使用packed 可以减小对象占用的空间。</p>
<ul>
<li><strong>overloadable</strong></li>
</ul>
<p>用于c语言函数,可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型。</p>
<h2 id="builtin函数"><a href="#builtin函数" class="headerlink" title="__builtin函数"></a>__builtin函数</h2><p>GNU C 提供了大量的内建函数，其中大部分是标准 C 库函数的内建版本，不属于库函数的其他内建函数通常以__builtin 开始命名。</p>
<blockquote>
<p>__builtin_return_address(LEVEL)</p>
</blockquote>
<p>返回当前函数或其调用者的返回地址，参数LEVEL 指定调用栈的级数，如 0表 示当前函数的返回地址，1 表示当前函数的调用者的返回地址。</p>
<blockquote>
<p>__builtin_constant_p(EXP)</p>
</blockquote>
<p>用于判断一个值是否为编译时常数，如果参数 EXP的值是常数，函数返回 1，否则返回 0。</p>
<blockquote>
<p>__builtin_expect(long exp, long c)</p>
</blockquote>
<p>这个内建函数的意思就是exp的预期值为c，用于为编译器提供分支预测信息，其返回值是整数表达式exp的值，c的值必须是编译时常数。内核的likely函数就是利用这个实现的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x)    __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x)  __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>

<p>likely和unlikely主要用于if语句中，当条件被认为是非常有可能满足时，则使用likely()宏，而条件很难满足时，则使用unlikely()宏。好让编译器对这个条件判断进行优化，生成了高效的汇编码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __builtin_types_compatible_p(type_a, type_b);</span><br></pre></td></tr></table></figure>

<p>此函数为GNU扩展，用来判断两个类型是否相同，如果type_a与 type_b相同的话，就会返回1，否则的话，返回0。</p>
<ol>
<li>限定符会被忽略，例如const long和long的类型是相同的。</li>
<li>用typedef定义的类型，当且它们定义的类型是相同的时候，它们才是相同的。</li>
<li>两个enum类型是不相同的。</li>
</ol>
<h2 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h2><p>在include\linux\compiler-gcc.h中__weak是这样定义的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __weak              __attribute__((weak))</span></span><br></pre></td></tr></table></figure>

<p>GCC通过<code>__attribute__((weak))</code>指令定义的函数或变量称为弱符号，实际上这个指令大部分时候都是用来定义函数，很少用于定义变量。编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。规则如下：</p>
<ol>
<li>当两者都为强符号时，报错：redefinition of ‘xxx’</li>
<li>当两者为一强一弱时，选取强符号的值</li>
<li>当两者同时为弱时，选择其中占用空间较大的符号，保证至少不会造成诸如溢出、越界等严重后果。</li>
</ol>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>GNU C支持 case x…y 这样的语法，区间[x,y]的数都会满足这个case的条件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> ... <span class="number">4</span> :</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 - 4\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> ... <span class="number">8</span> :</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;5 - 8\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch类型必须是一个整型或枚举类型，因为可以隐式转换，所以char short也是可以的。</p>
<h2 id="typeof-x"><a href="#typeof-x" class="headerlink" title="typeof(x)"></a>typeof(x)</h2><p>typeof(x)语句可以获得x的类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> min(x,y) (&#123; \</span></span><br><span class="line"><span class="meta">    const typeof(x) _x = (x); \</span></span><br><span class="line"><span class="meta">    const typeof(y) _y = (y); \</span></span><br><span class="line"><span class="meta">    (void) (&amp;_x == &amp;_y); \</span></span><br><span class="line"><span class="meta">    _x &lt; _y ? _x : _y; &#125;)</span></span><br></pre></td></tr></table></figure>

<p><code>(void) (&amp;_x == &amp;_y);</code>检查_x 和_y 的类型是否一致。</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>iniparser 开源库</title>
    <url>/2022/06/07/c/iniparser/</url>
    <content><![CDATA[<p>iniparser是针对INI文件的解析器。</p>
<h2 id="ini文件"><a href="#ini文件" class="headerlink" title="ini文件"></a>ini文件</h2><p>ini文件的最基本组成单元就是key，每个key都有一个name和对应的value：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">;注释以分号开头</span></span><br><span class="line"><span class="attr">name</span>=value <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>多个Key可以被归类为一组，即section。组名定义要独立一行，并用中括号括起来：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[section]</span></span><br><span class="line"><span class="attr">name</span>=value12</span><br></pre></td></tr></table></figure>

<p>在section声明下的keys都会和该section关联起来。一个section的作用域会在下一个section声明的地方结束，如果没有下一个section的声明，那么该section的结束地方就是该文件末尾，section是不可以嵌套的。定位一个key是用section:key来表示的，所以不同section下的key的名称是可以相同的。</p>
<p>iniparser库处理名称的时候，会统一换成小写，所以section和key的命名是大小写无关的。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iniparser.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">iniparser_getnsec</span><span class="params">(dictionary * d)</span>;  </span><br><span class="line"><span class="comment">//获取dictionary对象的section个数</span></span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> * <span class="title function_">iniparser_getsecname</span><span class="params">(dictionary * d, <span class="type">int</span> n)</span>; </span><br><span class="line"><span class="comment">//获取dictionary对象的第n个section的名字</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">iniparser_dump_ini</span><span class="params">(dictionary * d, FILE * f)</span>;  </span><br><span class="line"><span class="comment">//保存dictionary对象到file</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">iniparser_dumpsection_ini</span><span class="params">(dictionary * d, <span class="type">char</span> * s, FILE * f)</span>; </span><br><span class="line"><span class="comment">//保存dictionary对象一个section到file</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">iniparser_dump</span><span class="params">(dictionary * d, FILE * f)</span>;  </span><br><span class="line"><span class="comment">//保存dictionary对象到file</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">iniparser_getsecnkeys</span><span class="params">(dictionary * d, <span class="type">char</span> * s)</span>;    </span><br><span class="line"><span class="comment">//获取dictionary对象某个section下的key个数</span></span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> ** <span class="title function_">iniparser_getseckeys</span><span class="params">(dictionary * d, <span class="type">char</span> * s)</span>; </span><br><span class="line"><span class="comment">//获取dictionary对象某个section下所有的key</span></span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> * <span class="title function_">iniparser_getstring</span><span class="params">(dictionary * d, <span class="type">const</span> <span class="type">char</span> * key, <span class="type">char</span> * def)</span>;   </span><br><span class="line"><span class="comment">//返回dictionary对象的section:key对应的字串值</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">iniparser_getint</span><span class="params">(dictionary * d, <span class="type">const</span> <span class="type">char</span> * key, <span class="type">int</span> notfound)</span>;   </span><br><span class="line"><span class="comment">//返回idictionary对象的section:key对应的整形值</span></span><br><span class="line"> </span><br><span class="line"><span class="type">double</span> <span class="title function_">iniparser_getdouble</span><span class="params">(dictionary * d, <span class="type">const</span> <span class="type">char</span> * key, <span class="type">double</span> notfound)</span>;  </span><br><span class="line"><span class="comment">//返回dictionary对象的section:key对应的双浮点值</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">iniparser_getboolean</span><span class="params">(dictionary * d, <span class="type">const</span> <span class="type">char</span> * key, <span class="type">int</span> notfound)</span>;   </span><br><span class="line"><span class="comment">//返回dictionary对象的section:key对应的布尔值</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">iniparser_set</span><span class="params">(dictionary * ini, <span class="type">const</span> <span class="type">char</span> * entry, <span class="type">const</span> <span class="type">char</span> * val)</span>;  </span><br><span class="line"><span class="comment">//设置dictionary对象的某个section:key的值</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">iniparser_unset</span><span class="params">(dictionary * ini, <span class="type">const</span> <span class="type">char</span> * entry)</span>; </span><br><span class="line"><span class="comment">//删除dictionary对象中某个section:key</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">iniparser_find_entry</span><span class="params">(dictionary * ini, <span class="type">const</span> <span class="type">char</span> * entry)</span> ;    </span><br><span class="line"><span class="comment">//判断dictionary对象中是否存在某个section:key</span></span><br><span class="line"> </span><br><span class="line">dictionary * <span class="title function_">iniparser_load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * ininame)</span>;  </span><br><span class="line"><span class="comment">//解析dictionary对象并返回(分配内存)dictionary对象</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">iniparser_freedict</span><span class="params">(dictionary * d)</span>;    </span><br><span class="line"><span class="comment">//释放dictionary对象(内存)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">dictionary_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * key)</span>; </span><br><span class="line"><span class="comment">//计算关键词的hash值</span></span><br><span class="line"> </span><br><span class="line">dictionary * <span class="title function_">dictionary_new</span><span class="params">(<span class="type">int</span> size)</span>;  </span><br><span class="line"><span class="comment">//创建dictionary对象</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">dictionary_del</span><span class="params">(dictionary * vd)</span>;   </span><br><span class="line"><span class="comment">//删除dictionary对象</span></span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> * <span class="title function_">dictionary_get</span><span class="params">(dictionary * d, <span class="type">const</span> <span class="type">char</span> * key, <span class="type">char</span> * def)</span>;    </span><br><span class="line"><span class="comment">//获取dictionary对象的key值</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">dictionary_set</span><span class="params">(dictionary * vd, <span class="type">const</span> <span class="type">char</span> * key, <span class="type">const</span> <span class="type">char</span> * val)</span>;    </span><br><span class="line"><span class="comment">//设置dictionary对象的key值</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">dictionary_unset</span><span class="params">(dictionary * d, <span class="type">const</span> <span class="type">char</span> * key)</span>;    </span><br><span class="line"><span class="comment">//删除dictionary对象的key值</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">dictionary_dump</span><span class="params">(dictionary * d, FILE * out)</span>;   </span><br><span class="line"><span class="comment">//保存dictionary对象</span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[tcp]</span></span><br><span class="line"><span class="comment">;for tcp communication</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">port</span> = <span class="number">8000</span><span class="comment">;</span></span><br><span class="line"><span class="attr">ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">family</span> = AF_INET<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"><span class="section">[serial port]</span></span><br><span class="line"><span class="comment">;for serial port communication</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">speed</span> = <span class="number">9600</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iniparser.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    dictionary *ini;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">    ini = iniparser_load(<span class="string">&quot;example.ini&quot;</span>);<span class="comment">//parser the file</span></span><br><span class="line">    <span class="keyword">if</span>(ini == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;can not open %s&quot;</span>,<span class="string">&quot;example.ini&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dictionary obj:\n&quot;</span>);</span><br><span class="line">    iniparser_dump(ini,<span class="built_in">stderr</span>);<span class="comment">//save ini to stderr</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s:\n&quot;</span>,iniparser_getsecname(ini,<span class="number">0</span>));<span class="comment">//get section name</span></span><br><span class="line"></span><br><span class="line">    n = iniparser_getint(ini,<span class="string">&quot;tcp:port&quot;</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port : %d\n&quot;</span>,n);</span><br><span class="line"></span><br><span class="line">    str = iniparser_getstring(ini,<span class="string">&quot;tcp:ip&quot;</span>,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip : %s\n&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">    str = iniparser_getstring(ini,<span class="string">&quot;tcp:family&quot;</span>,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;family : %s\n&quot;</span>,str);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s:\n&quot;</span>,iniparser_getsecname(ini,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    n = iniparser_getint(ini,<span class="string">&quot;serial port:speed&quot;</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;speed : %d\n&quot;</span>,n);</span><br><span class="line"></span><br><span class="line">    iniparser_freedict(ini);<span class="comment">//free dirctionary obj</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>linux ipc</title>
    <url>/2022/08/13/c/ipc/</url>
    <content><![CDATA[<h2 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h2><p>无名管道通常用于具有亲缘关系的父子进程或者兄弟进程间通信，是半双工的，数据只能往一个方向流动，先入先出，要想双向通信，需要建立两个管道。</p>
<p><img src="/images/linux/ipc/pipe.png" alt="pipe"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>pipe创建的管道两端处于一个进程中，用于父子进程间的通信。管道建立时会创建两个文件描述符，pipefd[0]固定用于读管道，而pipefd[1]固定用于写管道。</p>
<ol>
<li><p>如果读一个写端已被关闭的管道，在所有数据都被读取后，read返回0指示达到了文件结束处。</p>
</li>
<li><p>只有在管道的读端存在时，向管道写入数据才有意义。否则写一个读端已被关闭的管道，将产生信号SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回，则write出错返回，errno设置为EPIPE。</p>
</li>
<li><p>管道写入数据不保证原子性，管道存在缓冲区，如果读进程不读取管道缓冲区中的数据，那么写操作将会一直阻塞。</p>
</li>
</ol>
<h2 id="标准流管道"><a href="#标准流管道" class="headerlink" title="标准流管道"></a>标准流管道</h2><p><img src="/images/linux/ipc/popen.png" alt="popen"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>popen提供连接到另一个进程的标准输入或标准输出的一个单行管道，创建的管道必须使用标准I/O函数进行操作。popen先执行fork，然后调用exec以执行command，并且返回一个标准I/O文件指针。如果type是”r”，则文件指针连接到command的标准输出。如果type是”w”，则文件指针连接到command的标准输入。</p>
<p>pclose用来关闭创建的管道流，返回由popen所执行的进程的终止状态。</p>
<h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>命名管道在非父子、兄弟进程之间也可相互通信。FIFO遵循先进先出规则，对FIFO的读总是从开始处返回数据，写则把数据添加到末尾，不支持如 lseek()等文件定位操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>对于读进程：</p>
<ul>
<li>若该管道是阻塞打开，且当前 FIFO 内没有数据，则对读进程而言将一直阻塞到有数据写入。</li>
<li>若该管道是非阻塞打开，则不论 FIFO 内是否有数据，读进程都会立即执行读操作。即如果 FIFO<br>内没有数据，则读函数将立刻返回 0。</li>
</ul>
<p>对于写进程：</p>
<ul>
<li><p>若该管道是阻塞打开，则写操作将一直阻塞到数据可以被写入。</p>
</li>
<li><p>若该管道是非阻塞打开而不能写入全部数据，则读操作进行部分写入或者调用失败。</p>
</li>
<li><p>O_RDONLY  读管道</p>
</li>
<li><p>O_WRONLY  写管道</p>
</li>
<li><p>O_RDWR      读写管道</p>
</li>
<li><p>O_NONBLOCK  非阻塞</p>
</li>
<li><p>O_CREAT  如果该文件不存在，那么就创建一个新的文件，并用第三个参数为其设置权限。</p>
</li>
<li><p>O_EXCL   如果使用O_CREAT时文件存在，那么可返回错误消息。可测试文件是否存在。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>返回错误类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>EACCESS</td>
<td>所指定的目录路径无可执行的权限</td>
</tr>
<tr>
<td>EEXIST</td>
<td>所指定的文件已存在</td>
</tr>
<tr>
<td>ENAMETOOLONG</td>
<td>的路径名称太长</td>
</tr>
<tr>
<td>ENOENT</td>
<td>包含的目录不存在</td>
</tr>
<tr>
<td>ENOSPC</td>
<td>文件系统的剩余空间不足</td>
</tr>
<tr>
<td>ENOTDIR</td>
<td>路径中的目录存在但却非真正的目录</td>
</tr>
<tr>
<td>EROFS</td>
<td>指定的文件存在于只读文件系统内</td>
</tr>
</tbody></table>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是软件中断，用于在多个进程之间传递异步信号，可以直接进行用户空间进程和内核进程之间的交互。<code>kill -l</code>命令可以查看系统支持的信号列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<ul>
<li>SIGABRT 调用abort函数时产生此信号。进程异常终止。</li>
<li>SIGALRM 超过用alarm函数设置的时间时产生此信号。由setitimer函数设置的间隔时间已经过时。</li>
<li>SIGBUS 指示一个实现定义的硬件故障。</li>
<li>SIGCHLD 在一个进程终止或停止时被送给其父进程。</li>
<li>SIGCONT 此作业控制信号送给需要继续运行的处于停止状态的进程。如果接收到此信号的进程处于停止状态,则系统默认动作是使该进程继续运行，否则默认动作是忽略此信号。</li>
<li>SIGEMT 指示一个实现定义的硬件故障。</li>
<li>SIGFPE 此信号表示一个算术运算异常，例如除以0，浮点溢出等。</li>
<li>SIGHUP 如果终端界面检测到一个连接断开，则将此信号送给与该终端相关的控制进程。</li>
<li>SIGILL 此信号指示进程已执行一条非法硬件指令。</li>
<li>SIGINT 当用户按中断键(Ctrl+C)时，此信号送至前台进程组中的每一个进程。</li>
<li>SIGIO 此信号指示一个异步I/O事件。</li>
<li>SIGIOT 这指示一个实现定义的硬件故障。</li>
<li>SIGKILL  杀死任一进程。不能被捕捉或忽略。</li>
<li>SIGPIPE 如果在读进程已终止时写管道，则产生此信号。当套接口的一端已经终止时，若进程写该套接口也产生此信号。</li>
<li>SIGPOLL 在一个可轮询设备上发生一特定事件时产生此信号。</li>
<li>SIGPROF 当setitimer函数设置的梗概统计间隔时间已经超过时产生此信号。</li>
<li>SIGPWR 它主要用于具有不间断电源(UPS)的系统上。蓄电池电压过低时将信号发送给init进程，然后由init处理停机操作。</li>
<li>SIGQUIT 当用户在终端上按退出键(Ctrl+)时，产生此信号，并送至前台进程组中的所有进程。终止前台进程组并产生core文件。</li>
<li>SIGSEGV 指示进程进行了一次无效的存储访问。</li>
<li>SIGSTOP 这是一个作业控制信号，它停止一个进程。不能被捕捉或忽略。</li>
<li>SIGSYS 指示一个无效的系统调用。</li>
<li>SIGTERM kill命令发送的系统默认终止信号。</li>
<li>SIGTRAP 指示一个实现定义的硬件故障。</li>
<li>SIGTSTP 交互停止信号，当用户在终端上按挂起键(Ctrl+Z)时，终端驱动程序产生此信号。</li>
<li>SIGTTIN 当一个后台进程组进程试图读其控制终端时，终端驱动程序产生此信号。当读进程忽略或阻塞此信号，或读进程所属的进程组是孤儿进程组时不产生此信号，读操作出错并设置errno。</li>
<li>SIGTTOU 当一个后台进程组进程试图写其控制终端时产生此信号。当写进程忽略或阻塞此信号，或写进程所属的进程组是孤儿进程组时不产生此信号，写操作出错并设置errno。</li>
<li>SIGURG 此信号通知进程已经发生一个紧急情况。在网络连接上，接到非规定波特率的数据时，此信号可选择地产生。</li>
<li>SIGUSR1 这是一个用户定义的信号，可用于应用程序。</li>
<li>SIGUSR2 这是一个用户定义的信号，可用于应用程序。</li>
<li>SIGVTALRM 当一个由setitimer函数设置的虚拟间隔时间已经超过时产生此信号。</li>
<li>SIGWINCH 如果一个进程用ioctl设置窗口大小命令更改了窗口大小，则内核将信号送至前台进程组。</li>
<li>SIGXCPU 如果进程超过了其软CPU时间限制，则产生此信号。</li>
<li>SIGXFSZ 如果进程超过了其软文件长度限制产生此信号。</li>
</ul>
<p>一个完整的信号生命周期可以分为几个阶段：信号产生、信号在进程中注册、信号在进程中注销、执行信号处理函数。</p>
<p><strong>signal()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_ERR  ((__sighandler_t) -1) <span class="comment">/* Error return.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_DFL  ((__sighandler_t)  0) <span class="comment">/* Default action.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_IGN  ((__sighandler_t)  1) <span class="comment">/* Ignore signal.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>

<p>对于handler参数：</p>
<ul>
<li>SIG_IGN  表示忽略此信号(SIGKILL和SIGSTOP不能忽略)</li>
<li>SIG_DFL  表示执行系统默认动作。</li>
<li>自定义的信号处理函数指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="type">int</span>        sa_flags;</span><br><span class="line">    <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/ipc/sighandle_r.png" alt="sighandle_r"></p>
<p><strong>raise()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p>raise()给进程本身发送信号。</p>
<p><strong>kill()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p>kill()给一个进程发送信号，pid参数:</p>
<ul>
<li><code>pid &gt; 0</code>   将信号发送给pid相等的进程。</li>
<li><code>pid == 0</code>  将信号发送给与其进程组ID相等的进程。</li>
<li><code>pid &lt; 0</code>   将信号发送给进程组ID等于pid绝对值的进程。</li>
</ul>
<p>进程将信号发送给其他进程需要许可权，对于非root用户，其规则是发送者的实际或有效用户ID必须等于接收者的实际或有效用户ID。</p>
<p><strong>alarm()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<p>alarm()函数可以设置一个闹钟时间，超时后产生SIGALRM信号，如果不忽略或不捕捉此信号，则其默认动作是终止进程。</p>
<p>每个进程只能有一个闹钟时间。如果在调用alarm()时，以前已设置过闹钟时间，而且还没有超时，则该闹钟时间的余留值作为本次函数调用的值返回，以前登记的闹钟时间则被新值代换。</p>
<p><strong>pause()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>pause()函数是用于将调用进程挂起直至捕捉到信号为止。</p>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量用于进程同步，只有获得了信号量的进程才可以运行，没有获得信号量的进程则只能等待。</p>
<p>信号量包括一个称为信号量的变量和在该信号量下等待资源的进程等待队列，以及对信号量进行的两个原子操作(PV操作)。其中信号量对应于某一种资源，取一个非负的整型值，信号量值指的是当前可用的该资源的数量，若它等于 0 则意味着目前没有可用的资源。PV原子操作的具体定义如下:</p>
<ul>
<li><p>P操作：获得信号量，将值-1。如果值非负，表明有可用的资源，则占用一个资源直接返回，否则被阻塞，直到别的任务释放该信号量才能运行。它会导致调用的进程睡眠，因此不能在中断上下文使用。</p>
</li>
<li><p>V操作：释放信号量，把值+1，如果值为非正数，表明有任务等待该信号量，因此唤醒这些任务。</p>
</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>因为进程可以直接读写内存，不需要任何数据的复制。为了在多个进程间交换信息，内核专门留出了一块内存区。这段内存区可以由需要访问的进<br>程将其映射到自己的私有地址空间。因此，进程就可以直接读写这一内存区而不需要进行数据的复制，从而大大提高了效率。当然，由于多个进程共享一段内存，因此也需要有相应的同步机制。</p>
<p><code>ipcs -m</code>命令可以查看系统的共享内存，共享存储段紧靠在栈之下。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链表，存放在内核中并由消息队列标识符标识，用户可以从消息队列中添加消息和读取消息等，消息队列具有一定的FIFO特性，但是也可以按消息的类型字段随机查取消息。</p>
<p>消息队列的实现包括创建或打开消息队列、添加消息、读取消息和控制消息队列这 4 种操作：</p>
<ul>
<li>创建或打开消息队列使用的函数是 msgget()，这里创建的消息队列的数量会受到系统消息队列数量的限制。</li>
<li>添加消息使用的函数是 msgsnd()函数，它把消息添加到已打开的消息队列末尾。</li>
<li>读取消息使用的函数是msgrcv()，它把消息从消息队列中取走，与 FIFO 不同的是，这里可以指定取走某一条消息。</li>
<li>控制消息队列使用的函数是 msgctl()。</li>
</ul>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2>]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>c语言内存管理</title>
    <url>/2022/08/27/c/mem-manage/</url>
    <content><![CDATA[<h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><p>大端和小端表示多字节值的哪一端存储在该值的起始地址处，指的是字节在内存中存储时的排列规则，而不是数据中的位的排列规则，不管是大端还是小端，计算机在内存中存放数据的顺序都是从低地址到高地址，不同的是在低字节还是高字节处先取数据。</p>
<p><strong>大端(Big-Endian)</strong></p>
<p>就是把数值0x123456的高位字节放在内存的低位地址上，把数值的低位字节放在内存的高位地址上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低地址 -----&gt; 高地址</span><br><span class="line">0x12 | 0x34 | 0x56</span><br></pre></td></tr></table></figure>

<p><strong>小端(Little-Endian)</strong></p>
<p>就是把数值0x123456的高位字节放在高位的地址上，低位字节放在低位地址上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低地址 -----&gt; 高地址</span><br><span class="line">0x56 | 0x34 | 0x12</span><br></pre></td></tr></table></figure>

<p>由于不同架构的CPU处理多个字节数据的顺序不一样，产生了大小端之分。主机字节序是多样的，ARM既可以工作在大端，也可以工作在小端。网络统一为大端模式，还专门有网络字节序和主机字节序之间的转换接口(ntohs、htons、ntohl、htonl)。</p>
<p>小端模式强制转换类型时不需要调整字节内容，直接截取低字节即可。大端模式由于符号位为第一个字节，很方便判断正负。</p>
<p><strong>判断大小端</strong></p>
<ol>
<li>通过强制类型转换截断</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">IsBigEndian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">short</span> a = <span class="number">0x1234</span>;</span><br><span class="line">   <span class="type">char</span> b = *(<span class="type">char</span>*)&amp;a;</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">0x12</span> == b)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> TRUE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> FALSE;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用联合体共享内存的特性，截取低地址部分</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">IsBigEndian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">NUM</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">      <span class="type">short</span>  a;</span><br><span class="line">      <span class="type">char</span> b;</span><br><span class="line">  &#125;num;</span><br><span class="line"></span><br><span class="line">  num.a = <span class="number">0x1234</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0x12</span> == num.b)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><p>字节对齐的作用在于提高CPU访问内存的效率，同时字节的合理分布可以节省存储空间。如果一个变量的内存地址正好位于它长度的整数倍，则称做自然对齐。访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
<p>对齐访问也可能是硬件的特殊要求。不同平台和架构的CPU对存储空间的处理不同，有些平台从偶地址开始读数据，如果一个int型变量存放在偶地址开始的地址，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。同时并不是所有的平台都能够访问任意地址上的任意数据，有些硬件平台只能够访问对齐的地址，否则就会出现硬件异常错误。</p>
<p>数组按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。联合体按其包含的长度最大的数据类型对齐。结构体中每个数据类型都要对齐，规则为：</p>
<ol>
<li>结构体变量的起始地址能够被其最宽的成员大小整除。</li>
<li>结构体第一个成员在偏移0的位置，之后的每个成员相对于起始位置必须是当前成员大小的整数倍。</li>
<li>结构体内所有数据成员各自对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍。</li>
</ol>
<p><strong>#pragma pack()</strong></p>
<p>可以使用<code>#pragma pack(n)</code>预编译指令来设定变量以n字节对齐方式。n字节对齐就是说变量存放的起始地址的偏移量有两种情况：</p>
<ul>
<li>如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式；</li>
<li>如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式。</li>
</ul>
<p>结构的总大小也有约束条件，分两种情况：如果n大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为n的倍数。</p>
<p><code>#pragma pack()</code> 取消自定义对齐方式，恢复默认方式。</p>
<h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。位域是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 位域结构名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    类型说明符 位域名:位域长度</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a:<span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> b:<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c:<span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span>  :<span class="number">2</span>; <span class="comment">/*空域*/</span></span><br><span class="line">&#125;data;</span><br><span class="line"><span class="comment">/* data共占2个字节，其中位域a占8位，位域b占2位，位域c占4位 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>位域的长度不能大于一个字节，一个位域必须存储在同一个字节中，不能跨两个字节。</li>
<li>位域可以没有位域名，叫空域，这时它只用来作填充或调整位置，空域是不能使用的。</li>
<li>给位域赋值不能超过该位域的允许范围。</li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>c语言运算符</title>
    <url>/2022/06/07/c/operator/</url>
    <content><![CDATA[<h2 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h2><table>
<thead>
<tr>
<th>等级</th>
<th>名称</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>作用域解析</td>
<td><code>::</code></td>
</tr>
<tr>
<td>2</td>
<td>成员选择、下标、后缀加减</td>
<td><code>.</code> <code>-&gt;</code> <code>[]</code> <code>()</code> <code>++</code> <code>--</code></td>
</tr>
<tr>
<td>3</td>
<td>sizeof、前缀加减、负号、取地址、解引用、new/delete、类型转换、按位取反、逻辑非</td>
<td><code>++</code> <code>--</code> <code>-</code> <code>&amp;</code> <code>*</code> <code>~</code> <code>!</code></td>
</tr>
<tr>
<td>4</td>
<td>乘、除、取模</td>
<td><code>*</code> <code>/</code> <code>%</code></td>
</tr>
<tr>
<td>5</td>
<td>加、减</td>
<td><code>+</code> <code>-</code></td>
</tr>
<tr>
<td>6</td>
<td>移位</td>
<td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
</tr>
<tr>
<td>7</td>
<td>大于、小于、大于等于、小于等于</td>
<td><code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code></td>
</tr>
<tr>
<td>8</td>
<td>等于、不等于</td>
<td><code>==</code> <code>!=</code></td>
</tr>
<tr>
<td>9</td>
<td>按位与</td>
<td><code>&amp;</code></td>
</tr>
<tr>
<td>10</td>
<td>按位异或</td>
<td><code>^</code></td>
</tr>
<tr>
<td>11</td>
<td>按位或</td>
<td>`</td>
</tr>
<tr>
<td>12</td>
<td>逻辑与</td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>13</td>
<td>逻辑或</td>
<td>`</td>
</tr>
<tr>
<td>14</td>
<td>条件运算符</td>
<td><code>? :</code></td>
</tr>
<tr>
<td>15</td>
<td>赋值运算符</td>
<td><code>=</code> <code>/=</code> <code>+=</code> <code>&amp;=</code> `</td>
</tr>
<tr>
<td>16</td>
<td>逗号运算符</td>
<td><code>,</code></td>
</tr>
</tbody></table>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>C在以下四种情况下会进行隐式转换:</p>
<ol>
<li>算术运算。</li>
<li>赋值表达式中，右边表达式的值自动隐式转换为左边变量的类型，并赋值给他。</li>
<li>函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。</li>
<li>函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。</li>
</ol>
<p>类型转换规则：</p>
<ol>
<li>字符必须先转换为整数。</li>
<li>低类型转换为高类型，比如short型转换为int型。</li>
<li>有符号先转换为无符号</li>
<li>float型数据在运算时一律先转换为双精度double型，以提高运算精度，即使是同为float类型的运算，也一样先转换为double型。</li>
</ol>
<blockquote>
<p>char -&gt; short -&gt; int -&gt; unsigned -&gt; long -&gt; double &lt;- float</p>
</blockquote>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>linux process in user</title>
    <url>/2022/08/21/c/process/</url>
    <content><![CDATA[<p>进程是系统进行资源分配和调度的单位。从系统的角度看是通过进程控制块来描述的，进程控制块包含了进程的描述信息、控制信息以及资源信息。进程控制块中的每一项都是一个 task_struct 结构，在 include/linux/sched.h中定义的。</p>
<ul>
<li>0号进程是idle，系统创建的一个进程，运行在内核态，完成加载系统后，演变为进程调度scheduler。</li>
<li>1号进程是init，所有用户进程的父进程。</li>
<li>2号进程是kthreadd，所有kernel thread的父进程，由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理。</li>
</ul>
<p>进程根据它的生命周期可以划分成 3 种状态：</p>
<ul>
<li>执行态:该进程正在运行，即进程正在占用 CPU。</li>
<li>就绪态:进程已经具备执行的一切条件，正在等待分配 CPU 的处理时间片。</li>
<li>等待态:进程不能使用 CPU，若等待事件发生(等待的资源分配到)则可将其唤醒。</li>
</ul>
<p><img src="/images/linux/process/status.jpeg" alt="进程状态转换"></p>
<h2 id="进程空间"><a href="#进程空间" class="headerlink" title="进程空间"></a>进程空间</h2><p><img src="/images/linux/process/mem.jpeg" alt="进程空间"></p>
<ul>
<li><p>未初始化数据段(.bss)：Block Storage Start，存放未初始化或初始化为0的全局变量，未初始化的静态变量。bss段的变量只占用运行时的内存空间，而不占用文件空间。在程序开始执行之前，内核将此段初始化为0。.bss段占据的大小存放在ELF文件格式中的段表(Section Table)中，段表存放了各个段的各种信息，比如段的名字、段的类型、段在elf文件中的偏移、段的大小等信息。同时符号存放在符号表.symtab中。</p>
</li>
<li><p>初始化数据段(.data)：存放初始化非0的全局变量，初始化的静态变量。既占用运行时的内存空间，又占用文件空间。</p>
</li>
<li><p>代码段：只读，包含程序代码（.init和.text）和只读数据（.rodata），存储机器码序列、全局常量、代码、字符串常量。</p>
</li>
<li><p>栈：从高地址往低地址向下增长，存放局部变量、局部常量、函数参数、返回值、函数调用时返回地址、调用者的环境信息。</p>
</li>
<li><p>堆：从低地址往高低至增长，动态分配的内存。</p>
</li>
</ul>
<p>可以用<code>cat /proc/self/maps</code>查看程序运行时空间的分配情况，每个区间都有4个属性：</p>
<ul>
<li>r  表示可以读取;</li>
<li>w  表示可以修改;</li>
<li>x  表示可以执行;</li>
<li>p/s 表示是否为共享内存;</li>
</ul>
<p><code>size</code>命令可以查看可执行文件的正文段、数据段和 b s s段的长度(单位:字节)。</p>
<p>数据段和代码段分离，数据和指令被映射到两个虚拟内存区域，数据段对进程来说可读写，代码段是只读，这样可以防止程序的指令被改写。现代CPU缓存一般被设计成数据缓存和指令缓存分离，分开对CPU缓存命中率有好处。代码段是可以共享的，数据段是私有的，当运行多个程序的副本时，只需要保存一份代码段。</p>
<p>栈容易溢出是因为栈内存有限，递归次数多了，局部数据占用的内存直到整个递归结束才会被释放，很容易就导致栈溢出。</p>
<h2 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>getpid返回调用进程的进程号，Linux 内核限制进程号&lt;= 32767。任何进程都可使用符号链接/proc/self 来访问其自己的/proc/pid/ 目录。</p>
<p>getppid返回目前进程的父进程的进程号。可通过查看/proc/pid/status 的PPid字段，可以获知每个进程的父进程。</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">vfork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>fork创建的新进程被称为子进程。该函数被调用一次，但返回两次，可通过返回值来区分父、子进程，在父进程中返回新创建子进程的进程pid，而在子进程中则返回 0，子进程可调用getpid()以获取自身的进程 ID，调用getppid()以获取父进程ID。</p>
<p>子进程从父进程处继承了整个进程的地址空间,包括进程上下文、代码段、进程堆栈、内存信息、打开的文件描述符、信号控制设定、进程优先级、进程组号、当前工作目录、根目录、资源限制、环境变量、标准IO的缓存数据和控制终端等，而子进程所独有的只有它的进程号、资源使用和计时器等。这两个进程将执行相同的程序文本段，但却各自拥有不同的栈段、数据段以及堆段拷贝。子进程的栈、数据以及栈段开始时是对父进程内存相应各部分的完全复制，每个进程均可修改各自的栈数据、以及堆段中的变量，而并不影响另一进程。子进程的tms_utime、tms_stime、tms_cutime以及tms_ustime设置为0，子进程不继承父进程设置的锁。</p>
<p>vfork用于创建一个新进程，但并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec或exit，不会存访该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行(如果调用这两个函数之前子进程依赖于父进程，会导致死锁)。</p>
<p>当子进程退出时，其父进程没有调用 wait() 系统调用回收他的进程描述符信息，该进程就会继续停留在系统的进程表中，占用内核资源，称为<strong>僵尸进程</strong>。预防僵尸进程的方法:</p>
<ul>
<li>父进程注册<code>signal(SIGCHLD, SIG_IGN)</code>通知内核父进程忽略SIGCHLD信号，由内核回收。</li>
<li>父进程调用 wait()/waitpid() 函数等待子进程结束</li>
<li>父进程用signal注册信号处理函数，在信号处理函数中调用 wait()/waitpid() 函数等待子进程退出。</li>
<li>连续调用两次fork，使紧跟的子进程退出，其孙子进程成为一个孤儿进程，交给init进程托管。</li>
</ul>
<h2 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br></pre></td></tr></table></figure>

<p>终止进程的，清除包括 PCB 在内的各种数据结构。区别在于 exit()函数会清理 I/O 缓冲，检查文件的打开情况，把文件缓冲区中的内容写回文件。</p>
<h2 id="atexit"><a href="#atexit" class="headerlink" title="atexit()"></a>atexit()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>在进程终止后，以登记的相反顺序调用注册的终止处理函数。</p>
<h2 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>abort()可以产生SIGABRT信号，当进程发生越界访问或除0时。</p>
<h2 id="wait-waitpid"><a href="#wait-waitpid" class="headerlink" title="wait() waitpid()"></a>wait() waitpid()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>wait()使其调用者阻塞，直到一个子进程终止，并返回其进程号,如果该父进程没有子进程或者他的子进程已经结束，则立即返回。</p>
<p>waitpid的pid参数：</p>
<ul>
<li><code>&gt;0</code>  只等待进程ID等于pid 的子进程，只要子进程还没结束，就会一直等下去；</li>
<li><code>-1</code>  等待任何一个子进程退出，和wait()一样；</li>
<li><code>=0</code>  等待其组ID相同的任一子进程；</li>
<li><code>&lt;-1</code> 等待其组ID等于pid的绝对值的任一子进程；</li>
</ul>
<p>waitpid的options参数：</p>
<ul>
<li>WNOHANG   若由pid指定的子进程不立即可用，则不阻塞并返回0；</li>
<li>WUNTRACED 若实现某支持作业控制，则由pid指定的任一子进程状态已暂停，且其状态自暂停以来还未报告过，则返回其状态；</li>
<li>0 同wait阻塞父进程，等待子进程退出；</li>
</ul>
<p>如果不关心终止状态，可将该status参数指定为NULL，可用宏检查status的状态。</p>
<p><img src="/images/linux/process/wait_status.png" alt="wait_status"></p>
<p>如果一个进程希望等待一个子进程终止，则它必须调用wait函数。如果一个进程要等待其父进程终止，则可使用下列形式的循环:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="execl"><a href="#execl" class="headerlink" title="execl()"></a>execl()</h2><p>exec函数并不创建新进程，只是用另一个新程序替换了当前进程的正文、数据、堆和栈段，且两个进程的PID相同。例如：在shell命令行执行ps命令，实际上是shell进程调用fork复制一个新的子进程，在利用exec系统调用将新产生的子进程完全替换成ps进程。exec系列函数底层其实都是通过调用execve函数实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... (<span class="type">char</span> *)<span class="literal">NULL</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... (<span class="type">char</span> *)<span class="literal">NULL</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... (<span class="type">char</span> *)<span class="literal">NULL</span>, <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>带 l 的exec函数表示命令的参数以可变参数的形式给出，且以一个NULL结束。</li>
<li>带 p 的exec函数表示第一个参数只要是进程名即可，它会在环境变量当中查找命令。</li>
<li>带 v 的exec函数表示命令的参数以字符串数组形式给出，且最后一个元素也必须是NULL。</li>
<li>带 e 的exec函数表示将envp数组的内容作为环境变量传递给替换的进程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *<span class="type">const</span> envp[] = &#123;<span class="string">&quot;AA=11&quot;</span>, <span class="string">&quot;BB=22&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>&#125;;</span><br><span class="line">    execle(<span class="string">&quot;./hello&quot;</span>, <span class="string">&quot;hello&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>, envp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(*envp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(*(envp++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; environ[i] != <span class="literal">NULL</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> &#123;</span></span><br><span class="line">   <span class="type">clock_t</span> tms_utime;  <span class="comment">/* user time */</span></span><br><span class="line">   <span class="type">clock_t</span> tms_stime;  <span class="comment">/* system time */</span></span><br><span class="line">   <span class="type">clock_t</span> tms_cutime; <span class="comment">/* user time of children */</span></span><br><span class="line">   <span class="type">clock_t</span> tms_cstime; <span class="comment">/* system time of children */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">times</span><span class="params">(<span class="keyword">struct</span> tms *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>获取进程的系统CPU时间和用户CPU时间，返回当时的系统时钟计数。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>printf() 函数格式化与颜色显示</title>
    <url>/2022/06/07/c/printf/</url>
    <content><![CDATA[<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><table>
<thead>
<tr>
<th align="center">格式字符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">d i</td>
<td>有符号十进制整数(正数不输出符号)</td>
</tr>
<tr>
<td align="center">o</td>
<td>无符号八进制(不输出前缀0)</td>
</tr>
<tr>
<td align="center">x X</td>
<td>无符号十六进制整数(不输出前缀Ox)</td>
</tr>
<tr>
<td align="center">u</td>
<td>无符号十进制整数</td>
</tr>
<tr>
<td align="center">f</td>
<td>十进制浮点数</td>
</tr>
<tr>
<td align="center">e E</td>
<td>指数形式输出</td>
</tr>
<tr>
<td align="center">g G</td>
<td>以%f或%e中较短的宽度输出</td>
</tr>
<tr>
<td align="center">a A</td>
<td>十六进制浮点数</td>
</tr>
<tr>
<td align="center">c</td>
<td>输出单个字符</td>
</tr>
<tr>
<td align="center">s</td>
<td>输出字符串</td>
</tr>
<tr>
<td align="center">p</td>
<td>指针地址</td>
</tr>
<tr>
<td align="center">n</td>
<td></td>
</tr>
<tr>
<td align="center">%</td>
<td>打印%</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">标 志</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td>左对齐，右边填空格</td>
</tr>
<tr>
<td align="center">+</td>
<td>输出正负号</td>
</tr>
<tr>
<td align="center">空格</td>
<td>输出值为正时冠以空格，为负时冠以负号</td>
</tr>
<tr>
<td align="center">#</td>
<td>对c、s、d、u类无影响； 对o类，在输出时加前缀o； 对x类，在输出时加前缀0x； 对e、g、f 类当结果有小数时才给出小数点。</td>
</tr>
<tr>
<td align="center">0</td>
<td>指定填充时，用0而不是空格左填充数字</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>修饰符</th>
<th><code>d i</code></th>
<th><code>u o x X</code></th>
<th><code>f F e E g G a A</code></th>
<th><code>c</code></th>
<th><code>s</code></th>
<th><code>p</code></th>
<th><code>n</code></th>
</tr>
</thead>
<tbody><tr>
<td><em>(none)</em></td>
<td><code>int</code></td>
<td><code>unsigned int</code></td>
<td><code>double</code></td>
<td><code>int</code></td>
<td><code>char*</code></td>
<td><code>void*</code></td>
<td><code>int*</code></td>
</tr>
<tr>
<td><code>hh</code></td>
<td><code>signed char</code></td>
<td><code>unsigned char</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>signed char*</code></td>
</tr>
<tr>
<td><code>h</code></td>
<td><code>short int</code></td>
<td><code>unsigned short int</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>short int*</code></td>
</tr>
<tr>
<td><code>l</code></td>
<td><code>long int</code></td>
<td><code>unsigned long int</code></td>
<td></td>
<td><code>wint_t</code></td>
<td><code>wchar_t*</code></td>
<td></td>
<td><code>long int*</code></td>
</tr>
<tr>
<td><code>ll</code></td>
<td><code>long long int</code></td>
<td><code>unsigned long long int</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>long long int*</code></td>
</tr>
<tr>
<td><code>j</code></td>
<td><code>intmax_t</code></td>
<td><code>uintmax_t</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>intmax_t*</code></td>
</tr>
<tr>
<td><code>z</code></td>
<td><code>size_t</code></td>
<td><code>size_t</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>size_t*</code></td>
</tr>
<tr>
<td><code>t</code></td>
<td><code>ptrdiff_t</code></td>
<td><code>ptrdiff_t</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>ptrdiff_t*</code></td>
</tr>
<tr>
<td><code>L</code></td>
<td></td>
<td></td>
<td><code>long double</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><em>宽度</em>：用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。 </li>
<li><em>精度</em>：格式符以“.”开头，后跟十进制整数。如果输出数字，则表示小数的位数；如果输出的是字符，则表示输出字符的个数；若实际位数大于所定义的精度数，则截断超过的部分。</li>
<li><em>长度修饰符</em>：h表示按短整型量输出，l表示按长整型量输出。</li>
</ul>
<h2 id="颜色显示"><a href="#颜色显示" class="headerlink" title="颜色显示"></a>颜色显示</h2><blockquote>
<p>\033[显示方式;&lt;前景色&gt;;&lt;背景色&gt;m</p>
</blockquote>
<table>
<thead>
<tr>
<th>显示方式</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>终端默认设置</td>
</tr>
<tr>
<td>1</td>
<td>粗体/高亮显示</td>
</tr>
<tr>
<td>2</td>
<td>模糊</td>
</tr>
<tr>
<td>3</td>
<td>斜体</td>
</tr>
<tr>
<td>4</td>
<td>下划线</td>
</tr>
<tr>
<td>5</td>
<td>闪烁（慢）</td>
</tr>
<tr>
<td>6</td>
<td>闪烁（快）</td>
</tr>
<tr>
<td>7</td>
<td>反白显示，交换背景色与前景色</td>
</tr>
<tr>
<td>8</td>
<td>不可见</td>
</tr>
<tr>
<td>22</td>
<td>关闭模糊</td>
</tr>
<tr>
<td>24</td>
<td>关闭下划线</td>
</tr>
<tr>
<td>25</td>
<td>关闭闪烁</td>
</tr>
<tr>
<td>27</td>
<td>关闭反白显示</td>
</tr>
</tbody></table>
<p><img src="/images/cpp/printf_color.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\33[1;36;47m %s \33[m\n&quot;</span>, <span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>RGB颜色</strong></li>
</ul>
<blockquote>
<p>\033[显示方式;38;2;&lt;r&gt;;&lt;g&gt;;&lt;b&gt;m<br>\033[显示方式;48;2;&lt;r&gt;;&lt;g&gt;;&lt;b&gt;m</p>
</blockquote>
<p>38代表前景色，48代表后景色；2代表RGB模式，后面三位为RGB数值。</p>
<p><img src="/images/cpp/printf_rgb.png" alt="rgb颜色"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\33[1;38;2;255;0;255;48;2;255;255;0m %s \33[m\n&quot;</span>, <span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>linux standard io</title>
    <url>/2022/08/13/c/stdio/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>标准I/O提供了三种类型的缓存:</p>
<ul>
<li>全缓存，当填满缓存后才进行实际I/O操作，对于驻在磁盘上的文件通常是由标准I/O库实施全缓存的。</li>
<li>行缓存，当在输入和输出中遇到新行符时才执行I/O操作，标准输入和标准输出就是使用行缓冲。</li>
<li>不带缓存。标准出错流stderr通常是不带缓存的，使得出错信息可以尽快显示出来。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>setbuf函数打开或关闭缓存机制。为了带缓存进行I/O，参数buf必须指向一个长度为BUFSIZ的缓存，设置后通常该流是全缓存的，但如果该流与一个终端设备相关，某些系统可能将其设置为行缓存。将buf设置为NUL可可以关闭缓存。</p>
<p>setvbuf可以精确地设置缓存类型。这是依靠mode参数实现的:</p>
<ul>
<li>_IOFBF 全缓存</li>
<li>_IOLBF 行缓存</li>
<li>_IONBF 不带缓存</li>
</ul>
<p><img src="/images/linux/stdio/setbuf.png" alt="setbuf"></p>
<h2 id="fflush"><a href="#fflush" class="headerlink" title="fflush()"></a>fflush()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>刷新流的输出缓冲区，若fp是NULL，则此函数刷新所有输出流。</p>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>fopen打开一个标准I/O流，返回:若成功则为文件指针，若出错则为NULL，并设置errno。mode参数指定对该I/O流的读、写方式:</p>
<table>
<thead>
<tr>
<th>字符串</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读方式打开文件，该文件必须存在</td>
</tr>
<tr>
<td>r+</td>
<td>以读/写方式打开文件，该文件必须存在</td>
</tr>
<tr>
<td>rb+</td>
<td>以读/写方式打开一个二进制文件，只允许读/写数据</td>
</tr>
<tr>
<td>rt+</td>
<td>以读/写方式打开一个文本文件，允许读和写</td>
</tr>
<tr>
<td>w</td>
<td>打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件</td>
</tr>
<tr>
<td>w+</td>
<td>打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件</td>
</tr>
<tr>
<td>a</td>
<td>以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）</td>
</tr>
<tr>
<td>a+</td>
<td>以附加方式打开可读/写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）</td>
</tr>
<tr>
<td>wb</td>
<td>以只写方式打开或新建一个二进制文件，只允许写数据</td>
</tr>
<tr>
<td>wb+</td>
<td>以读/写方式打开或新建一个二进制文件，允许读和写</td>
</tr>
<tr>
<td>wt+</td>
<td>以读/写方式打开或新建一个文本文件，允许读和写</td>
</tr>
<tr>
<td>at+</td>
<td>以读/写方式打开一个文本文件，允许读或在文本末追加数据</td>
</tr>
<tr>
<td>ab+</td>
<td>以读/写方式打开一个二进制文件，允许读或在文件末追加数据</td>
</tr>
</tbody></table>
<p><img src="/images/linux/stdio/io_mode.png" alt="io_mode"></p>
<ol>
<li>以 x 结尾的模式为独占模式，文件已存在或者无法创建（一般是路径不正确）都会导致 fopen 失败。文件以操作系统支持的独占模式打开。</li>
<li>上述的形态字符串都可以加入 b 字符用来告诉函数库以二进制模式打开文件。如果不加 b，表示默认加了 t，表示以文本模式打开文件。</li>
<li>由 fopen() 所建立的新文件会具有_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666) 权限，此文件权限也会参考umask值。</li>
<li>有些 C编译系统可能不完全提供所有这些功能，有的C版本不”r+”、”w+”、”a+”，而用”rw”、”wr”、”ar”等。</li>
<li>在Windows系统中，文本模式下，文件以”\r\n”代表换行，若以文本模式打开文件，并用 fputs 等函数写入换行符”\n”时，函数会自动在”\n”前面加上”\r”，即实际写入文件的是”\r\n”。</li>
<li>在类 Unix/Linux 系统中文本模式下，文件以”\n”代表换行。所以 Linux 系统中在文本模式和二进制模式下并无区别。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">FILE *<span class="title function_">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>fdopen可以将文件描述符转为文件指针，写打开时并不截短该文件，因为描述符已被打开。</p>
<h2 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc()"></a>fgetc()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>一次读一个字符，fgetc不能实现为宏。返回:若成功则为下一个字符，若已处文件尾端或出错则为EOF(-1)，<code>Ctrl+d</code>可产生1个EOF。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>FILE对象中有出错标志和文件结束标志，feof和ferror可以用来判断这些标志，若条件为真返回非0，否则为0。clearerr则清除这两个标志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>从一个流读之后，ungetc将字符再送回流中，返回:若成功则为c,若出错则为EOF。回送的字符，不一定要是上一次读到的字符。EOF不能回送。已经到达文件尾端时，仍可以回送一字符。</p>
<h2 id="fputc"><a href="#fputc" class="headerlink" title="fputc()"></a>fputc()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="fgets-fputs"><a href="#fgets-fputs" class="headerlink" title="fgets() fputs()"></a>fgets() fputs()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p>fgets必须指定缓存的长度n，一直读到下一个新行符为止，但是不超过n-1个字符，读入的字符被送入缓存，缓存以’\0’字符结尾。如若该行包括最后一个新行符的字符数超过n-1，则只返回一个不完整的行，而且缓存总是以’\0’字符结尾，对fgets的下一次调用会继续读该行。</p>
<p>gets并不将新行符存入缓存中，已经被停用，因为不能指定缓存的长度，会造成缓存越界。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p>fputs将一个以’\0’终止的字符串写到指定的流，终止符’\0’不写出。</p>
<h2 id="fread-fwrite"><a href="#fread-fwrite" class="headerlink" title="fread() fwrite()"></a>fread() fwrite()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb,FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>fread和fwrite返回读或写的对象数。对于读，如果出错或到达文件尾端，则此返回値小于nmemb，应调用ferror或feof判断是那一种情况。对于写，如果返回值小于nmemb，则出错。</p>
<p>当用来读写结构体时，应当考虑不同系统之间的结构体对齐方式，整数和浮点数的存储格式的不同。</p>
<h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>fseek定位一个二进制文件，必须指定一个字节offset，whence是位移量的方式:</p>
<ul>
<li>SEEK_SET  表示从文件的起始位置开始</li>
<li>SEEK_CUR  表示从当前文件位置</li>
<li>SEEK_END  表示从文件的尾端</li>
</ul>
<p>对于文本文件，whence一定要是SEEK_SET，而且offset只能有两种值:0 表示文件起始位置；或ftell所返回的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>ftell返回当前文件的位置指示，若出错则为-1。<br>rewind函数也可将一个流设置到文件的起始位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE *stream, <span class="type">fpos_t</span> *pos)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span>;</span><br></pre></td></tr></table></figure>

<p>fgetpos将文件位置指示器的当前值存入由pos指向的对象中。以后调用fsetpos时，可以使用此值将流重新定位至该位置。</p>
<h2 id="fprintf-sprintf"><a href="#fprintf-sprintf" class="headerlink" title="fprintf() sprintf()"></a>fprintf() sprintf()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>格式化数据到流，成功返回输出字符数。</p>
<h2 id="fscanf-sscanf"><a href="#fscanf-sscanf" class="headerlink" title="fscanf() sscanf()"></a>fscanf() sscanf()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="fileno"><a href="#fileno" class="headerlink" title="fileno()"></a>fileno()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>获得流的描述符。</p>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">tmpnam</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">tempnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dir, <span class="type">const</span> <span class="type">char</span> *pfx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> P_tmpdir</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> P_tmpdir <span class="string">&quot;/tmp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TMP_MAX</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TMP_MAX 238328</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>tmpnam()在tmp目录下产生一个有效路径名字符串，最多调用次数是TMP_MAX。该使用不安全，建议用mkstemp代替。</p>
<ul>
<li>若ptr是NULL，则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。下一次再调用tmpnam时，会重写该静态区。</li>
<li>若ptr不是NULL，则它指向长度至少是L_tmpnam个字符的数组。产生的路径名存放在该数组中，ptr也作为函数值返回。</li>
</ul>
<p>tmpfile创建一个临时二进制文件(类型wb+)，在关闭该文件或程序结束时会自动删除。</p>
<p>tempnam可以指定临时文件的目录和前缀。对于目录有四种不同的优先选择：</p>
<ol>
<li>如果定义了环境变量TMPDIR，则用作为目录。</li>
<li>如果参数directory非NULL，则用作为目录。</li>
<li>将&lt;stdio.h&gt;中的字符串P_tmpdir作为目录。</li>
<li>将/tmp作为目录。如果prefix非NULL，则它至少5个字节。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkostemp</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemps</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> suffixlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkostemps</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> suffixlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>创建一个惟一的临时文件，并返回文件的描述符，各文件路径，所以template必须是数组，且后6个字符为”XXXXXX”。</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>linux pthread</title>
    <url>/2022/08/13/c/pthread/</url>
    <content><![CDATA[<p>进程是系统中程序执行和资源分配的基本单位，每个进程都拥有自己的数据段、代码段和堆栈段，这就造成进程在进行切换时需要消耗更多的处理器空转时间，为了减少上下文切换开销，进程在演化中出现了线程。</p>
<p>线程处理器调度的最小单元。线程可以访问进程的内存空间和资源，并与同一进程中的其他线程共享，因此线程的上下文切换的开销比创建进程小很多。同进程一样，线程也将相关的执行状态和存储变量放在线程控制表内，一个进程可以有多个线程，也就是有多个线程控制表及堆栈寄存器，但却共享一个用户地址空间。由于线程共享了进程的资源和地址空间，因此任何线程对系统资源的操作都会给其他线程带来影响，必须考虑线程间资源访问的同步与互斥问题。</p>
<p>线程按照其调度者可以分为用户级线程和核心级线程两种：</p>
<ul>
<li><p>用户级线程主要解决的是上下文切换的问题，它的调度算法和调度过程全部由用户自行选择决定，在运行时不需要内核支持。系统往往会提供一个用户空间的线程库，该线程库提供了线程的创建、调度和撤销等功能，而内核仍然仅对进程进行管理。如果一个进程中的某一个线程调用了一个阻塞的系统调用函数，那么该进程包括该进程中的其他所有线程也同时被阻塞。这种用户级线程的主要缺点是在一个进程中的多个线程的调度中无法发挥多处理器的优势。</p>
</li>
<li><p>内核级线程允许不同进程中的线程按照同一相对优先调度方法进行调度，这样就可以发挥多处理器的并发优势。</p>
</li>
</ul>
<p>现在大多数系统都采用用户级线程与核心级线程并存的方法，一个用户级线程可以对应一个或几个核心级线程，这样既可满足多处理机系统的需要，也可以最大限度地减少调度开销。</p>
<p>gcc在编译时要链接libpthread库<code>gcc -lpthread</code>。</p>
<h2 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁是用一种简单的加锁方法来控制对共享资源按顺序进行原子操作。这个互斥锁只有两种状态，也就是上锁和解锁，在同一时刻只能有一个线程掌握某个互斥锁，拥有上锁状态的线程能够对共享资源进行操作，若其他线程希望上锁一个已经被上锁的互斥锁，则该线程就会挂起，直到上锁的线程释放掉互斥锁为止。</p>
<p>互斥锁可以分为快速互斥锁、递归互斥锁和检错互斥锁，区别在于其他未占有互斥锁的线程在希望得到互斥锁时是否需要阻塞等待，默认为快速互斥锁。</p>
<ul>
<li>快速锁是指调用线程会阻塞，直至拥有互斥锁的线程解锁为止。</li>
<li>递归互斥锁能够成功地返回，并且在调用线程互斥上多次加锁。</li>
<li>检错互斥锁则为快速互斥锁的非阻塞版本，它会立即返回并返回一个错误信息。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span> <span class="params">(<span class="keyword">struct</span> __pthread_mutex *__restrict __mutex,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *__restrict __attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span> <span class="params">(<span class="keyword">struct</span> __pthread_mutex *__mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread_mutex_init()创建互斥锁，attr参数：</p>
<ul>
<li>PTHREAD_MUTEX_INITIALIZER  创建快速互斥锁</li>
<li>PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP   创建递归互斥锁</li>
<li>PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP  创建检错互斥锁</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>pthread_create()函数的第二个参数attr表示线程的属性，默认为非绑定、非分离、缺省1M的堆栈以及与父进程同样级别的优先级。</p>
<ul>
<li><p>绑定属性：一个用户线程固定地分配给一个内核线程，可以保证在需要的时候总有一个内核线程与之对应。</p>
</li>
<li><p>非绑定属性：用户线程和内核线程的关系不是始终固定的，由系统来控制分配。</p>
</li>
<li><p>分离属性：线程结束时会立即释放它所占有的系统资源，如果这个线程运行非常快，可能在pthread_create()函数返回之前就终止了，系统就可能将线程号和系统资源移交给其他的线程使用，从而导致出错。</p>
</li>
<li><p>非分离属性：线程结束时要等 pthread_join()函数返回，才释放自己占用的系统资源。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scheduling algorithms.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_OTHER 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_FIFO  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_RR    2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> &#123;</span></span><br><span class="line">   <span class="type">int</span> sched_priority;     <span class="comment">/* Scheduling priority */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setscope</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> scope)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getscope</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *scope)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setschedpolicy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getschedpolicy</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *policy)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setschedparam</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getschedparam</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="keyword">struct</span> sched_param *param)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread_attr_init() 初始化线程属性。pthread_attr_destroy() 对分配的属性结构指针进行清理和回收。</p>
<p>pthread_attr_setscope() 设置绑定属性：</p>
<ul>
<li>PTHREAD_SCOPE_SYSTEM  绑定</li>
<li>PTHREAD_SCOPE_PROCESS  非绑定</li>
</ul>
<p>pthread_attr_setdetachstate() 设置线程分离属性：</p>
<ul>
<li>PTHREAD_CREATE_DETACHED  分离</li>
<li>PTHREAD _CREATE_JOINABLE  非分离</li>
</ul>
<p>pthread_attr_getschedparam() 获取线程优先级。pthread_attr_setschedparam() 设置线程优先级，设置之前可用sched_get_priority_max() 确定优先级的取値范围。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_max</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_min</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>c standard library</title>
    <url>/2022/06/07/c/stdlib/</url>
    <content><![CDATA[<p>c语言标准函数库分为以下几类：</p>
<ul>
<li>输入/输出 I/O</li>
<li>字符串和字符处理</li>
<li>数学</li>
<li>时间、日期和本地化</li>
<li>动态分配</li>
<li>其他</li>
<li>宽字符函数</li>
</ul>
<h2 id="assert-h"><a href="#assert-h" class="headerlink" title="assert.h"></a>assert.h</h2><p>assert.h头文件提供了一个 assert 的宏，用于在函数开始处检验传入参数的合法性。assert会先判断表达式的真假，如果表达式值为假，那么它先向stderr打印错误信息，然后通过调用 abort 来终止程序运行。如果表达式值为真，继续运行后面的程序。</p>
<p><code>assert</code>只在 DEBUG 下生效，在release版本中，可以通过在<code>#include &lt;assert.h&gt;</code>语句之前插入<code>#define NDEBUG</code>来禁用assert调用。</p>
<h2 id="ctype-h"><a href="#ctype-h" class="headerlink" title="ctype.h"></a>ctype.h</h2><p>ctype.h 头文件提供了一些用于测试和映射字符，大小写转换函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*检查所传的字符是否是字母和数字*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isalnum</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*检查所传的字符是否是字母*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isalpha</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*检查所传的字符是否是控制字符*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">iscntrl</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*检查所传的字符是否是十进制数字*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isdigit</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*检查所传的字符是否有图形表示法*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isgraph</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*检查所传的字符是否是小写字母*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">islower</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*检查所传的字符是否是可打印的*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isprint</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*检查所传的字符是否是标点符号字符*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ispunct</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*检查所传的字符是否是空白字符*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isspace</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*检查所传的字符是否是大写字母*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isupper</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*检查所传的字符是否是十六进制数字*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isxdigit</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*把大写字母转换为小写字母*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tolower</span><span class="params">(<span class="type">int</span> c)</span> </span><br><span class="line"><span class="comment">/*把小写字母转换为大写字母*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">toupper</span><span class="params">(<span class="type">int</span> c)</span> </span><br></pre></td></tr></table></figure>

<h2 id="errno-h"><a href="#errno-h" class="headerlink" title="errno.h"></a>errno.h</h2><p>errno.h 头文件定义了整数变量 errno，就近发生的系统调用错误都会存储到 errno中，下一次的错误码会覆盖掉上一次的错误。可使用<code>errno</code>命令查阅错误码定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印系统错误信息 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 错误码转字符串 */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="float-h"><a href="#float-h" class="headerlink" title="float.h"></a>float.h</h2><p>float.h 头文件包含了一组与浮点值相关的依赖于平台的常量。</p>
<h2 id="limits-h"><a href="#limits-h" class="headerlink" title="limits.h"></a>limits.h</h2><p>limits.h 定义了各种变量类型的最大值宏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHAR_BIT    8     <span class="comment">//定义一个字节的比特数。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHAR_MIN   -128  <span class="comment">//定义一个有符号字符的最小值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHAR_MAX   127   <span class="comment">//定义一个有符号字符的最大值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCHAR_MAX   255   <span class="comment">//定义一个无符号字符的最大值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHAR_MIN    0     <span class="comment">//定义类型 char 的最小值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHAR_MAX    127   <span class="comment">//定义类型 char 的最大值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MB_LEN_MAX  1     <span class="comment">//定义多字节字符中的最大字节数。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHRT_MIN    -32768     <span class="comment">//定义一个短整型的最小值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHRT_MAX    +32767     <span class="comment">//定义一个短整型的最大值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USHRT_MAX   65535      <span class="comment">//定义一个无符号短整型的最大值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MIN     -32768     <span class="comment">//定义一个整型的最小值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MAX     +32767     <span class="comment">//定义一个整型的最大值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINT_MAX    65535      <span class="comment">//定义一个无符号整型的最大值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LONG_MIN    -2147483648   <span class="comment">//定义一个长整型的最小值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LONG_MAX    +2147483647   <span class="comment">//定义一个长整型的最大值。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULONG_MAX   4294967295    <span class="comment">//定义一个无符号长整型的最大值。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="time-h"><a href="#time-h" class="headerlink" title="time.h"></a>time.h</h2><p>time.h 头文件定义了各种操作日期和时间的函数。</p>
<h2 id="stdlib-h"><a href="#stdlib-h" class="headerlink" title="stdlib.h"></a>stdlib.h</h2><p>stdlib .h 头文件定义了各种通用工具函数。</p>
<p><code>EXIT_FAILURE</code>这是 exit 函数失败时要返回的值。<br><code>EXIT_SUCCESS</code>这是 exit 函数成功时要返回的值。<br><code>RAND_MAX</code>这个宏是 rand 函数返回的最大值。<br><code>MB_CUR_MAX</code> 这个宏表示在多字节字符集中的最大字符数，不能大于 MB_LEN_MAX。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把参数 str 所指向的字符串转换为一个整数（类型为 int 型）*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）*/</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">atol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">strtod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **endptr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）*/</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把参数 str 所指向的字符串转换为一个无符号长整数（类型为 unsigned long int 型）*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">strtoul</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*分配所需的内存空间，并返回一个指向它的指针*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nitems, <span class="type">size_t</span> size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*释放之前调用 calloc、malloc 或 realloc 所分配的内存空间*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*分配所需的内存空间，并返回一个指向它的指针*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使一个异常程序终止并coredump*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*当程序正常终止时，调用指定的函数 func*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使程序正常终止*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*搜索 name 所指向的环境字符串，并返回相关的值给字符串*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*由 string 指定的命令传给要被命令处理器执行的主机环境*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行二分查找*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">bsearch</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="type">void</span> *base, <span class="type">size_t</span> nitems, <span class="type">size_t</span> size, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, constoid *))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*数组排序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nitems, <span class="type">size_t</span> size, </span></span><br><span class="line"><span class="params">    <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span>*))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 x 的绝对值*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*分子除以分母*/</span></span><br><span class="line"><span class="type">div_t</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> numer, <span class="type">int</span> denom)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 x 的绝对值*/</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">labs</span><span class="params">(<span class="type">long</span> <span class="type">int</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*分子除以分母*/</span></span><br><span class="line"><span class="type">ldiv_t</span> <span class="title function_">ldiv</span><span class="params">(<span class="type">long</span> <span class="type">int</span> numer, <span class="type">long</span> <span class="type">int</span> denom)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回一个范围在 0 到 RAND_MAX 之间的伪随机数*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*该函数播种由函数 rand 使用的随机数发生器*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回参数 str 所指向的多字节字符的长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mblen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把参数 str 所指向的多字节字符的字符串转换为参数 pwcs 所指向的数组*/</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">mbstowcs</span><span class="params">(<span class="type">schar_t</span> *pwcs, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*检查参数 str 所指向的多字节字符*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mbtowc</span><span class="params">(<span class="type">whcar_t</span> *pwc, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把数组 pwcs 中存储的编码转换为多字节字符，并把它们存储在字符串 str 中*/</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">wcstombs</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">wchar_t</span> *pwcs, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*检查对应于参数 wchar 所给出的多字节字符的编码*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">wctomb</span><span class="params">(<span class="type">char</span> *str, <span class="type">wchar_t</span> wchar)</span></span><br></pre></td></tr></table></figure>

<h2 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h2><p>string .h 头文件定义了各种操作字符数组的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把 str1 和 str2 的前 n 个字节进行比较*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从 src 复制 n 个字符到 dest*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*另一个用于从 src 复制 n 个字符到 dest 的函数*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把 src 所指向的字符串追加到 dest 所指向的字符串的结尾*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把 str1 所指向的字符串和 str2 所指向的字符串进行比较*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把 str1 和 str2 进行比较，最多比较前 n 个字节*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcoll</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把 src 所指向的字符串复制到 dest*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把 src 所指向的字符串复制到 dest，最多复制 n 个字符*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符*/</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strcspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算字符串 str 的长度，直到空结束字符，但不包括空结束字符*/</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strpbrk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br><span class="line"><span class="comment">/*也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，</span></span><br><span class="line"><span class="comment">检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符*/</span></span><br><span class="line">则停止检验，并返回该字符位置*/</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标*/</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*分解字符串 str 为一组字符串，delim 为分隔符*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中*/</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strxfrm</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>

<h2 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h2><p>math.h 头文件定义了各种数学函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*返回以弧度表示的 x 的反余弦*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">acos</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回以弧度表示的 x 的反正弦*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">asin</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回以弧度表示的 x 的反正切*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">atan</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回以弧度表示的 y/x 的反正切，y 和 x 的值的符号决定了正确的象限*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">atan2</span><span class="params">(<span class="type">double</span> y, <span class="type">double</span> x)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*返回弧度角 x 的余弦*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">cos</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 x 的双曲余弦*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">cosh</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回弧度角 x 的正弦*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 x 的双曲正弦*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">sinh</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 x 的双曲正切*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">tanh</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 e 的 x 次幂的值*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">exp</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中，所得的值是 x = mantissa * 2 ^ exponent*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">frexp</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> *exponent)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*返回 x 乘以 2 的 exponent 次幂*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">ldexp</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> exponent)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 x 的自然对数（基数为 e 的对数）*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">log</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 x 的常用对数（基数为 10 的对数）*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">log10</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回值为小数部分（小数点后的部分），并设置 integer 为整数部分*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">modf</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> *integer)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 x 的 y 次幂*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 x 的平方根*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回大于或等于 x 的最小的整数值*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 x 的绝对值*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">fabs</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回小于或等于 x 的最大的整数值*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">floor</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回 x 除以 y 的余数*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">fmod</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="stdarg-h"><a href="#stdarg-h" class="headerlink" title="stdarg.h"></a>stdarg.h</h2><p>stdarg.h 头文件定义了一个变量类型 va_list 和获取可变参数中的参数的方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这个宏初始化 ap 变量，它与 va_arg 和 va_end 宏是一起使用的，last_arg 是最后一个传递给函数的已知的固定参数，即省略号之前的参数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">va_start</span><span class="params">(va_list ap, last_arg)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这个宏检索函数参数列表中类型为 type 的下一个参数*/</span></span><br><span class="line">type <span class="title function_">va_arg</span><span class="params">(va_list ap, type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这个宏允许使用了 va_start 宏的带有可变参数的函数返回，如果在从函数返回之前没有调用 va_end，则结果为未定义*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">va_end</span><span class="params">(va_list ap)</span></span><br></pre></td></tr></table></figure>

<h2 id="stddef-h"><a href="#stddef-h" class="headerlink" title="stddef.h"></a>stddef.h</h2><p>stddef .h 头文件定义了各种变量类型和宏。</p>
<p><code>ptrdiff_t</code> 这是有符号整数类型，它是两个指针相减的结果。<br><code>size_t</code> 这是无符号整数类型，它是 sizeof 关键字的结果。<br><code>wchar_t</code> 这是一个宽字符常量大小的整数类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator 给定的，结构的名称是在 type 中给定的*/</span></span><br><span class="line">offsetof(type, member-designator)</span><br></pre></td></tr></table></figure>

<h2 id="signal-h"><a href="#signal-h" class="headerlink" title="signal.h"></a>signal.h</h2><p>signal.h 头文件定义了一些跟信号相关的函数和宏。</p>
<h2 id="stdio-h"><a href="#stdio-h" class="headerlink" title="stdio.h"></a>stdio.h</h2><p>stdio .h 头文件定义了各种函数来执行输入和输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*关闭流 stream。刷新所有的缓冲区*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除给定流 stream 的文件结束和错误标识符*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试给定流 stream 的文件结束标识符*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试给定流 stream 的错误标识符*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*刷新流 stream 的输出缓冲区*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取流 stream 的当前文件位置，并把它写入到 pos*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE *stream, <span class="type">fpos_t</span> *pos)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用给定的模式 mode 打开 filename 所指向的文件*/</span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从给定流 stream 读取数据到 ptr 所指向的数组中*/</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把一个新的文件名 filename 与给定的打开的流 stream 关联，同时关闭流中的旧文件*/</span></span><br><span class="line">FILE *<span class="title function_">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置流 stream 的文件位置为给定的偏移 offset，参数offset意味着从给定的whence位置查找的字节数*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置给定流 stream 的文件位置为给定的位置，参数pos是由函数 fgetpos 给定的位置*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回给定流 stream 的当前文件位置*/</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把 ptr 所指向的数组中的数据写入到给定流 stream 中*/</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除给定的文件名 filename，以便它不再被访问*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把 old_filename 所指向的文件名改为 new_filename*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *old_filename, <span class="type">const</span> <span class="type">char</span> *new_filename)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置文件位置为给定流 stream 的文件的开头*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义流 stream 应如何缓冲*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buffer)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*另一个定义流 stream 应如何缓冲的函数*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buffer, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*以二进制更新模式(wb+)创建临时文件*/</span></span><br><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*生成并返回一个有效的临时文件名，该文件名之前是不存在的*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">tmpnam</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送格式化输出到流 stream 中*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送格式化输出到标准输出 stdout*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送格式化输出到字符串*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用参数列表发送格式化输出到流 stream 中*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list arg)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用参数列表发送格式化输出到标准输出 stdout*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list arg)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用参数列表发送格式化输出到字符串*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list arg)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从流 stream 读取格式化输入*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从标准输入 stdin 读取格式化输入*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从字符串读取格式化输入*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span></span><br><span class="line"><span class="comment">/*从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内，</span></span><br><span class="line"><span class="comment">当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把字符串写入到指定的流 stream 中，但不包括空字符*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从标准输入 stdin 获取一个字符（一个无符号字符）*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line"><span class="comment">/*从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中，</span></span><br><span class="line"><span class="comment">/*当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> <span class="type">char</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line"><span class="comment">/*把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符，/*换行符会被追加到输出中*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把字符 char（一个无符号字符）推入到指定的流 stream 中，以便它是下一个被读取到的字符*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line"><span class="comment">/*把一个描述性错误消息输出到标准错误 stderr，首先输出字符串 str，后跟一个冒号，然后是一个空格*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*格式字符串到 str 中*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>linux time function</title>
    <url>/2022/06/07/c/time/</url>
    <content><![CDATA[<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p><strong>GMT</strong>格林威治时间(Greenwich Mean Time)。根据地球的自转和公转来计算时间，就是太阳横穿格林威治子午线（本初子午线）时的时间，也是0时区的标准时间，是老的时间计量标准。格林威治子午线是穿过英国伦敦格林威治天文台子午仪中心的一条经线，作为零度参考线。</p>
<p>UT根据原子钟计算出来的时间。</p>
<p><strong>UTC</strong>协调世界时(Coordinated Universal Time)。因为地球自转越来越慢，每年都会比前一年多出零点几秒，为了让基于原子钟的世界时和基于天文学的格林威治时间相差不至于太大，每隔几年协调世界时组织都会给世界时+1秒，并将所得到的时间称为UTC，这就是现在使用的世界标准时间。协调世界时不与任何地区位置相关，<strong>本地时间</strong>是 UTC+TimeZone，GMT = UTC+0。</p>
<p>北京时间(CST)所属时区: UTC/GMT +8。</p>
<p>Unix<strong>时间戳</strong>是从1970-01-01 00:00:00 +0000至今的秒数，不考虑闰秒。</p>
<p>世界时区的划分以本初子午线（穿过英国伦敦格林威治天文台子午仪中心的一条经线）为标准，向东12个时区，向西12个时区，子午线所在区为0时区，经度每向东或者向西间隔15°，就划分一个时区，共有24个时区，相邻时区的时间相差一个小时。</p>
<p>夏令时DST(Daylight Saving Time)，它是为节约能源而人为规定地方时间的制度。一般在天亮早的夏季人为将时间提前一小时。在施行夏令时的国家，一年里面有一天只有23小时（夏令时开始那一天），有一天有25小时（夏令时结束那一天），其他时间每天都是24小时。</p>
<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><h3 id="time"><a href="#time" class="headerlink" title="time()"></a>time()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">time_t</span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *tloc)</span>;</span><br></pre></td></tr></table></figure>

<p>返回从UTC至今所经过的秒数，如果tloc非空，会将返回值也存到该指针。</p>
<h3 id="ftime"><a href="#ftime" class="headerlink" title="ftime()"></a>ftime()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timeb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeb</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>         time;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> millitm;   <span class="comment">// ms</span></span><br><span class="line">    <span class="type">short</span>          timezonel; <span class="comment">// 为目前时区和Greenwich相差的时间，单位为分钟，东区为负</span></span><br><span class="line">    <span class="type">short</span>          dstflag;   <span class="comment">// 非0代表启用夏时制</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ftime</span><span class="params">(<span class="keyword">struct</span> timeb *tp)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="gettimeofday"><a href="#gettimeofday" class="headerlink" title="gettimeofday()"></a>gettimeofday()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>      tv_sec;     <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;    <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tz_minuteswest;     <span class="comment">/* minutes west of Greenwich */</span></span><br><span class="line">    <span class="type">int</span> tz_dsttime;         <span class="comment">/* type of DST correction */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*tz_dsttime 所代表的状态如下:*/</span> </span><br><span class="line">   DST_NONE     <span class="comment">/* not on DST */</span></span><br><span class="line">   DST_USA      <span class="comment">/* USA style DST */</span></span><br><span class="line">   DST_AUST     <span class="comment">/* Australian style DST */</span></span><br><span class="line">   DST_WET      <span class="comment">/* Western European DST */</span></span><br><span class="line">   DST_MET      <span class="comment">/* Middle European DST */</span></span><br><span class="line">   DST_EET      <span class="comment">/* Eastern European DST */</span></span><br><span class="line">   DST_CAN      <span class="comment">/* Canada */</span></span><br><span class="line">   DST_GB       <span class="comment">/* Great Britain and Eire */</span></span><br><span class="line">   DST_RUM      <span class="comment">/* Romania */</span></span><br><span class="line">   DST_TUR      <span class="comment">/* Turkey */</span></span><br><span class="line">   DST_AUSTALT  <span class="comment">/* Australian style with shift in 1986 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="clock-gettime"><a href="#clock-gettime" class="headerlink" title="clock_gettime()"></a>clock_gettime()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>   tv_sec;        <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span>     tv_nsec;       <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">(<span class="type">clockid_t</span> clk_id, <span class="keyword">struct</span> timespec *tp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_getres</span><span class="params">(<span class="type">clockid_t</span> clk_id, <span class="keyword">struct</span> timespec *res)</span>;</span><br></pre></td></tr></table></figure>

<p>clk_id 用于指定计时时钟的类型:</p>
<ul>
<li><p><code>CLOCK_REALTIME</code>/<code>CLOCK_REALTIME_COARSE</code> 系统实时时间，即从UTC开始计时的秒数，随系统实时时间改变而改变，包括通过系统函数手动调整系统时间，例如 settime()、settimeofday()，或者通过 adjtime()、adjtimex() 或者 NTP 调整时间。</p>
</li>
<li><p><code>CLOCK_MONOTONIC</code>/<code>CLOCK_MONOTONIC_COARSE</code> 从系统启动开始计时，不受系统时间被用户改变的影响，但会受像 adjtime() 或者 NTP 之类渐进调整的影响。</p>
</li>
<li><p><code>CLOCK_MONOTONIC_RAW</code> 与上述的 CLOCK_MONOTONIC 相同，只是不会受 adjtime() 以及 NTP 的影响。</p>
</li>
<li><p><code>CLOCK_PROCESS_CPUTIME_ID</code> 本进程到当前代码系统 CPU 花费的时间。</p>
</li>
<li><p><code>CLOCK_THREAD_CPUTIME_ID</code> 本线程到当前代码系统 CPU 花费的时间。</p>
</li>
</ul>
<h3 id="clock"><a href="#clock" class="headerlink" title="clock()"></a>clock()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回程序执行使用的时钟时间*/</span></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">clock</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h2><h3 id="ctime-asctime"><a href="#ctime-asctime" class="headerlink" title="ctime asctime"></a>ctime asctime</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转换为本地时间，使用标准格式 */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将时间格式转为字符串，不修改时区，使用标准格式 */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime_r</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm, <span class="type">char</span> *buf)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="mktime"><a href="#mktime" class="headerlink" title="mktime()"></a>mktime()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;         <span class="comment">/* seconds [0, 59] */</span></span><br><span class="line">    <span class="type">int</span> tm_min;         <span class="comment">/* minutes [0, 59] */</span></span><br><span class="line">    <span class="type">int</span> tm_hour;        <span class="comment">/* hours [0, 23] */</span></span><br><span class="line">    <span class="type">int</span> tm_mday;        <span class="comment">/* day of the month [1, 31] */</span></span><br><span class="line">    <span class="type">int</span> tm_mon;         <span class="comment">/* month [0, 11] */</span></span><br><span class="line">    <span class="type">int</span> tm_year;        <span class="comment">/* year now.year - 1900 */</span></span><br><span class="line">    <span class="type">int</span> tm_wday;        <span class="comment">/* day of the week, [0, 6] 0-&gt;sunday */</span></span><br><span class="line">    <span class="type">int</span> tm_yday;        <span class="comment">/* day in the year [0, 365] */</span></span><br><span class="line">    <span class="type">int</span> tm_isdst;       <span class="comment">/* daylight saving time */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure>

<p>tm_isdst是夏令时：</p>
<ul>
<li>0 完全不考虑夏令时的问题，直接将日历时间转换为秒数；</li>
<li>1 考虑夏令时。</li>
<li>-1 自动根据时区信息进行判断。</li>
</ul>
<p>注意在使用前，需要将 struct tm 结构体清空，否则不需要设置的字段 (如 tm_isdst ) 会有脏数据。</p>
<p>实际上程序比较怕时间回退，那么关于夏令时比较坑的是，夏令时的停止，此时时钟会向后回拨一次，也就是说，同一个小时的时间点出现了两次。</p>
<p>例如 CET (欧洲中部时间) 在 2016-10-30 02:59:59 下一秒会跳转到 2016-10-30 02:00:00 ，也就是说 02:00:00 到 02:59:59 这一个小时的时间窗出现了两次。</p>
<p>那么，此时，如果要获取到中间的时间窗，在使用 mktime() 时就需要手动配置其中的 tm_isdst 字段。</p>
<p>mktime() 会忽略 tm_wday 以及 tm_yday 字段，会使用 tm_isdst 判断是否采用夏令时，同时会根据其它字段来修改 tm_wday tm_yday 字段，同时其它字段如果超过了范围则会修正。</p>
<h3 id="gmtime-localtime"><a href="#gmtime-localtime" class="headerlink" title="gmtime() localtime()"></a>gmtime() localtime()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将时间戳转换为GMT时区的标准时间 */</span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将时间戳转换为本地时区的时间格式 */</span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="strftime-strptime"><a href="#strftime-strptime" class="headerlink" title="strftime() strptime()"></a>strftime() strptime()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将时间按格式化字符串转换为字符串 */</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> max, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strptime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *format, <span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%a 星期几的简写</span><br><span class="line">%A 星期几的全称</span><br><span class="line">%b 月份的简写</span><br><span class="line">%B 月份的全称</span><br><span class="line">%c 标准的日期的时间串</span><br><span class="line">%C 年份的前两位数字</span><br><span class="line">%d 十进制表示的每月的第几天</span><br><span class="line">%D 月/天/年</span><br><span class="line">%e 在两字符域中，十进制表示的每月的第几天</span><br><span class="line">%F 年-月-日</span><br><span class="line">%g 年份的后两位数字，使用基于周的年</span><br><span class="line">%G 年份，使用基于周的年</span><br><span class="line">%h 简写的月份名</span><br><span class="line">%H 24小时制的小时</span><br><span class="line">%I 12小时制的小时</span><br><span class="line">%j 十进制表示的每年的第几天</span><br><span class="line">%m 十进制表示的月份</span><br><span class="line">%M 十时制表示的分钟数</span><br><span class="line">%n 新行符</span><br><span class="line">%p 本地的AM或PM的等价显示</span><br><span class="line">%r 12小时的时间</span><br><span class="line">%R 显示小时和分钟：hh:mm</span><br><span class="line">%S 十进制的秒数</span><br><span class="line">%t 水平制表符</span><br><span class="line">%T 显示时分秒：hh:mm:ss</span><br><span class="line">%u 每周的第几天，星期一为第一天 （值从1到7，星期一为1）</span><br><span class="line">%U 第年的第几周，把星期日作为第一天（值从0到53）</span><br><span class="line">%V 每年的第几周，使用基于周的年</span><br><span class="line">%w 十进制表示的星期几（值从0到6，星期天为0）</span><br><span class="line">%W 每年的第几周，把星期一做为第一天（值从0到53）</span><br><span class="line">%x 标准的日期串</span><br><span class="line">%X 标准的时间串</span><br><span class="line">%y 不带世纪的十进制年份（值从0到99）</span><br><span class="line">%Y 带世纪部分的十制年份</span><br><span class="line">%z，%Z 时区名称，如果不能得到时区名称则返回空字符。</span><br><span class="line">%% 百分号</span><br></pre></td></tr></table></figure>

<p><img src="/images/cpp/time_function.bmp" alt="时间转换函数"></p>
<h2 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*返回 time1 和 time2 之间相差的秒数 (time1-time2)*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">difftime</span><span class="params">(<span class="type">time_t</span> time1, <span class="type">time_t</span> time2)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_settime</span><span class="params">(<span class="type">clockid_t</span> clk_id, <span class="type">const</span> <span class="keyword">struct</span> timespec *tp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">settimeofday</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timeval *tv, <span class="type">const</span> <span class="keyword">struct</span> timezone *tz)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置系统的时间，不过需要超级用户的权限*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stime</span><span class="params">(<span class="type">time_t</span> *t)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>string functions</title>
    <url>/2022/06/07/c/string/</url>
    <content><![CDATA[<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* des, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert((des!=<span class="literal">NULL</span>) &amp;&amp; (src!=<span class="literal">NULL</span>)); </span><br><span class="line">    <span class="type">char</span> *address = des;  </span><br><span class="line">    <span class="keyword">while</span>((*des++ = *src++) != <span class="string">&#x27;\0&#x27;</span>)  </span><br><span class="line">        ;  </span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>源指针所指的字符串内容是不能修改的，因此应该声明为 const 类型。</li>
<li>要判断源指针和目的指针为空的情况，这里使用<code>assert</code>。</li>
<li>要用一个临时变量保存目的串的首地址，最后返回这个首地址。</li>
<li>函数返回 char* 的目的是为了支持链式表达式，即strcpy可以作为其他函数的实参。</li>
</ul>
<h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* des, <span class="type">const</span> <span class="type">char</span>* src)</span>   <span class="comment">// const表明为输入参数 </span></span><br><span class="line">&#123;  </span><br><span class="line">    assert((des!=<span class="literal">NULL</span>) &amp;&amp; (src!=<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">char</span>* address = des;</span><br><span class="line">    <span class="keyword">while</span>(*des != <span class="string">&#x27;\0&#x27;</span>)  <span class="comment">// 移动到字符串末尾</span></span><br><span class="line">        ++des;</span><br><span class="line">    <span class="keyword">while</span>(*des++ = *src++)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert((s1!=<span class="literal">NULL</span>) &amp;&amp; (s2!=<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(*s1 == *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s1 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s1 - *s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>若s1==s2，返回零；</li>
<li>若s1&gt;s2，返回正数；</li>
<li>若s1&lt;s2，返回负数。</li>
</ul>
<p>两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇\0为止。</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>uboot启动分析</title>
    <url>/2022/09/04/boot/uboot/</url>
    <content><![CDATA[<p>BootLoader (引导加载程序)就是在操作系统内核运行之前运行的一段小程序，通过这段代码实现硬件的初始化，建立内存空间的映射，将内核镜像从flash上读到RAM中，为操作系统内核准备好硬件环境，然后跳转到内核的入口点去运行引导内核启动。</p>
<p>BootLoader必须要具备的能力：</p>
<ol>
<li>能自身开机直接启动，必须进行和硬件相对应的代码级别的更改和移植，才能够保证可以从相应的启动介质启动。</li>
<li>能引导操作系统内核启动并给内核传参，uboot 的终极目标就是启动内核，参数通过环境变量设置。</li>
<li>能进行 SoC 级和板级硬件管理，控制部分硬件外设。</li>
<li>能提供系统部署功能，实现flash上的烧录下载。</li>
</ol>
<p>u-boot下载地址：<a href="https://ftp.denx.de/pub/u-boot/">https://ftp.denx.de/pub/u-boot/</a></p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="/images/uboot/uboot_arch.png" alt="img"></p>
<p>u-boot-2010.06及以后版本目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── api                存放uboot提供的接口函数</span><br><span class="line">├── arch               CPU体系结构相关的代码，每种架构对应一个子目录</span><br><span class="line">├── board              开发板相关的文件，每种开发板对应一个子目录</span><br><span class="line">├── common             通用的代码，主要实现 uboot命令行下支持的命令，每一条命令对应一个文件。</span><br><span class="line">├── disk               磁盘分区相关代码</span><br><span class="line">├── doc                文档</span><br><span class="line">├── drivers            支持的设备驱动</span><br><span class="line">├── examples           示例程序</span><br><span class="line">├── fs                 文件系统，目前支持 cramfs、fat、fdos、jffs2 和 registerfs</span><br><span class="line">├── include            头文件，已通用的头文件为主</span><br><span class="line">├── lib                通用库文件</span><br><span class="line">├── nand_spl           NAND存储器相关代码</span><br><span class="line">├── net                网络相关代码，小型的协议栈</span><br><span class="line">├── onenand_ipl</span><br><span class="line">├── post               加电自检程序</span><br><span class="line">└── tools              辅助程序，用于编译和检查uboot目标文件</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="启动流程分析"><a href="#启动流程分析" class="headerlink" title="启动流程分析"></a>启动流程分析</h2><p>第一阶段依赖于 CPU 体系结构的代码，在 SRAM 中，一般用汇编语言来实现。主要进行以下方面的设置：</p>
<p>设置 ARM 进入 SVC 模式<br>禁止 IRQ 和 FIQ、关闭看门狗、屏蔽所有中断<br>设置CPU的速度和时钟(FCLK,HCLK,PCLK)<br>RAM初始化，清空 I/D cache<br>清空 TLB、禁止 MMU 和 cache、配置内存控制器、为搬运代码做准备<br>搬移 uboot 镜像到 RAM 中（使用 copy_loop 实现）、分配堆栈、清空 bss 段（使用 clbss_l 实现）<br>最后跳转到第二阶段。</p>
<p>主要功能为：</p>
<ul>
<li>硬件设备初始化（关闭看门狗和中断，MMU，Cache，配置系统工作时钟）。</li>
<li>为加载第二阶段代码准备RAM空间。</li>
<li>拷贝第二阶段代码到 RAM 空间中。</li>
<li>设置堆栈指针sp。</li>
<li>跳转到第二阶段代码的入口点。</li>
</ul>
<p>初始化异常向量表<br>设置 SVC 模式<br>关中断<br>配置cp15协处理器<br>初始化 mmu、cache、tlb（cpu_init_cp15）<br>板级初始化（cpu_init_crit）</p>
<p>第二阶段在 DRAM 中，用c语言来实现，这样可以实现更复杂的功能，而且代码会具有更好的可读性和可移植性。初始化SoC 外部硬件(如 iNand、网卡芯片等)、 uboot 本身的一些东西(uboot 的命令、环境变量等)。</p>
<p>主要功能为：</p>
<ul>
<li>初始化本阶段要使用到的硬件设备（led uart等）。</li>
<li>检测系统内存映射(memory map)。</li>
<li>将内核镜像和根文件系统镜像从Flash上读到RAM空间中。</li>
<li>设置内核启动参数。</li>
<li>引导内核。</li>
</ul>
<h3 id="start-S"><a href="#start-S" class="headerlink" title="start.S"></a>start.S</h3><h4 id="设置异常向量表"><a href="#设置异常向量表" class="headerlink" title="设置异常向量表"></a>设置异常向量表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl _start                        /* u-boot 启动入口 */</span><br><span class="line">_start: b reset                    /* 复位 */</span><br><span class="line">    ldr pc, _undefined_instruction   /* 未定义指令向量 */</span><br><span class="line">    ldr pc, _software_interrupt      /* 软件中断向量 */</span><br><span class="line">    ldr pc, _prefetch_abort          /* 预取指令异常向量 */</span><br><span class="line">    ldr pc, _data_abort              /* 数据操作异常向量 */</span><br><span class="line">    ldr pc, _not_used                /* 未使用 */</span><br><span class="line">    ldr pc, _irq                     /* irq 中断向量 */            </span><br><span class="line">    ldr pc, _fiq                     /* fiq 中断向量 */</span><br><span class="line"></span><br><span class="line">/* 中断向量表入口地址 */</span><br><span class="line">_undefined_instruction: .word undefined_instruction</span><br><span class="line">_software_interrupt:    .word software_interrupt</span><br><span class="line">_prefetch_abort:    .word prefetch_abort</span><br><span class="line">_data_abort:        .word data_abort</span><br><span class="line">_not_used:      .word not_used</span><br><span class="line">_irq:           .word irq</span><br><span class="line">_fiq:           .word fiq</span><br><span class="line"></span><br><span class="line">    .balignl 16,0xdeadbeef</span><br></pre></td></tr></table></figure>
<p>异常向量表是硬件决定的，软件只是参照硬件的设计来实现它。复位异常处的代码是<code>b reset</code>，因此在 CPU 复位后真正去执行的是<a href="#reset%E5%A4%8D%E4%BD%8D"> reset </a>符号处代码。</p>
<p><code>.balignl 16,0xdeadbeef</code>指令是让当前地址对齐排布，如果当前地址不对齐则后面的内存用 0xdeadbeef 来填充。</p>
<p>uboot编译好之后，在 uboot 目录下会生成个 System.map 文件，这里面有各个变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c3e00010 T _start</span><br><span class="line">c3e00030 t _undefined_instruction</span><br><span class="line">c3e00034 t _software_interrupt</span><br><span class="line">c3e00038 t _prefetch_abort</span><br><span class="line">c3e0003c t _data_abort</span><br><span class="line">c3e00040 t _not_used</span><br><span class="line">c3e00044 t _irq</span><br><span class="line">c3e00048 t _fiq</span><br><span class="line">c3e0004c t _pad</span><br></pre></td></tr></table></figure>

<h4 id="指定代码段的编译地址"><a href="#指定代码段的编译地址" class="headerlink" title="指定代码段的编译地址"></a>指定代码段的编译地址</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl _TEXT_BASE</span><br><span class="line">_TEXT_BASE:</span><br><span class="line">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_TEXT_BASE)</span><br><span class="line">    .word   CONFIG_SPL_TEXT_BASE</span><br><span class="line">#else</span><br><span class="line">    .word   CONFIG_SYS_TEXT_BASE</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>编译器会对每一条指令分配一个编译地址，是编译器在编译过程中分配的。运行地址是指程序指令真正运行的地址，是由用户指定的。编译地址与运行地址是一一对应的。</p>
<h4 id="reset复位"><a href="#reset复位" class="headerlink" title="reset复位"></a>reset复位</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl	reset</span><br><span class="line">reset:</span><br><span class="line">    bl	save_boot_params</span><br><span class="line">    /*</span><br><span class="line">     * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,</span><br><span class="line">     * except if in HYP mode already</span><br><span class="line">     */</span><br><span class="line">    mrs	r0, cpsr</span><br><span class="line">    and	r1, r0, #0x1f		@ mask mode bits</span><br><span class="line">    teq	r1, #0x1a		@ test for HYP mode</span><br><span class="line">    bicne	r0, r0, #0x1f		@ clear all mode bits</span><br><span class="line">    orrne	r0, r0, #0x13		@ set SVC mode</span><br><span class="line">    orr	r0, r0, #0xc0		@ disable FIQ and IRQ</span><br><span class="line">    msr	cpsr,r0</span><br><span class="line"></span><br><span class="line">#ifndef CONFIG_SKIP_LOWLEVEL_INIT</span><br><span class="line">    bl	cpu_init_cp15</span><br><span class="line">    bl	cpu_init_crit</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    bl	_main</span><br><span class="line">    </span><br><span class="line">ENTRY(save_boot_params)</span><br><span class="line">    bx	lr			@ back to my caller</span><br><span class="line">ENDPROC(save_boot_params)</span><br><span class="line">    .weak	save_boot_params</span><br></pre></td></tr></table></figure>
<p>cpu设置为 SVC 模式，屏蔽 IRQ 和 FIQ 中断。跳转到[cpu_init_cp15](#cp15 协处理器初始化)处初始化协处理器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(cpu_init_crit)</span><br><span class="line">    b	lowlevel_init		@ go setup pll,mux,memory</span><br><span class="line">ENDPROC(cpu_init_crit)</span><br></pre></td></tr></table></figure>
<p>cpu_init_crit 实现cpu核心初始化，主要由 lowlevel_init 完成，代码位于 board 目录下相应 <a href="#lowlevel_init.S">lowlevel_init.S </a>文件中。</p>
<p>复位成功后程序跳转到_main符号处执行，代码位于arch/arm/lib/目录下的 <a href="#crt0.S">crt0.S</a> 文件中。</p>
<h4 id="cp15-协处理器初始化"><a href="#cp15-协处理器初始化" class="headerlink" title="cp15 协处理器初始化"></a>cp15 协处理器初始化</h4><p>关闭MMU和cache。catch 是 cpu 内部的一个 2 级缓存，,她的作用是将常用的数据和指令放在 cpu 内部，关闭catch可使volatile无效，避免编译器对代码进行优化。uboot设置的寄存器都是物理地址，不需要虚拟地址，所以MMU可以关闭。</p>
<p>设置 TTB。TTB 就是 translation table base，转换表基地址。建立虚拟地址映射的主要工作就是建立这张转换表。转换表分为表索引和表项，表索引对应虚拟地址，表项对应物理地址。一对表索引和表项构成一个转换表单元，能够对一个内存块进行虚拟地址转换。转换表由若干个转换表单元构成的，每个单元负责 1 个内存块，总体的转换表负责整个内存空间的映射。</p>
<p>转换表放置在内存中，放置时要求起始地址在内存中要 x 位对齐。转换表不需要软件干涉，将基地址 TTB 设置到 cp15 的 c2 寄存器中，然后 MMU 工作时会自动去查转换表。</p>
<h4 id="复制-stage2-到-RAM"><a href="#复制-stage2-到-RAM" class="headerlink" title="复制 stage2 到 RAM"></a>复制 stage2 到 RAM</h4><p>拷贝 stage2 到 RAM时要确定两点：<br>-　stage2 的可执行镜像在固态存储设备的存放起始地址和终止地址；<br>-　RAM 空间的起始地址；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ldr	r0, =_start</span><br><span class="line">    ldr	r1, =0x0</span><br><span class="line">    mov	r2, #16</span><br><span class="line">copyex:</span><br><span class="line">    subs	r2, r2, #1</span><br><span class="line">    ldr	r3, [r0], #4</span><br><span class="line">    str	r3, [r1], #4</span><br><span class="line">    bne	copyex</span><br></pre></td></tr></table></figure>

<h4 id="设置堆栈"><a href="#设置堆栈" class="headerlink" title="设置堆栈"></a>设置堆栈</h4><p>将 sp 指针指向一段没有被使用的内存就完成栈的设置。<br><img src="/images/uboot/uboot_mem.png" alt="1590311696418"></p>
<h4 id="清除-BSS-段"><a href="#清除-BSS-段" class="headerlink" title="清除 BSS 段"></a>清除 BSS 段</h4><p>BSS 段存放初始值为 0，未初始化的全局变量和静态变量，应该将这些变量的初始值赋为 0。</p>
<h4 id="跳转到-stage2-入口"><a href="#跳转到-stage2-入口" class="headerlink" title="跳转到 stage2 入口"></a>跳转到 stage2 入口</h4><h3 id="lowlevel-init-S"><a href="#lowlevel-init-S" class="headerlink" title="lowlevel_init.S"></a>lowlevel_init.S</h3><p>lowlevel_init 做一些开发板的初始化：检查复位状态、IO恢复、关看门狗、开发板供电锁存、时钟初始化、DDR初始化、串口初始化并打印’O’、tzpc初始化打印’K’。</p>
<h3 id="crt0-S"><a href="#crt0-S" class="headerlink" title="crt0.S"></a>crt0.S</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(_main)</span><br><span class="line">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)</span><br><span class="line">    ldr	sp, =(CONFIG_SPL_STACK)</span><br><span class="line">#else</span><br><span class="line">    ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)</span><br><span class="line">#endif</span><br><span class="line">    bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */</span><br><span class="line">    sub	sp, #GD_SIZE	/* allocate one GD above SP */</span><br><span class="line">    bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */</span><br><span class="line">    mov	r9, sp		/* GD is above SP */</span><br><span class="line">    mov	r0, #0</span><br><span class="line">    bl	board_init_f</span><br></pre></td></tr></table></figure>

<p>设置sp栈指针，将栈地址8位对齐。sp减去全局变量的长度，就是给全局数据分配空间，再把sp的值传给r9，就是把gd全局变量放在r9寄存器中。栈空间紧靠在dg全局变量之上，然后调用 <a href="#board_init_f">board_init_f</a>函数。这个环境只有代码段，所以不包含变量，只包含只读常量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if !defined(CONFIG_SPL_BUILD)</span><br><span class="line">    ldr	sp, [r9, #GD_START_ADDR_SP]	/* sp = gd-&gt;start_addr_sp */</span><br><span class="line">    bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */</span><br><span class="line">    ldr	r9, [r9, #GD_BD]		/* r9 = gd-&gt;bd */</span><br><span class="line">    sub	r9, r9, #GD_SIZE		/* new GD is below bd */</span><br><span class="line"></span><br><span class="line">    adr	lr, here</span><br><span class="line">    ldr	r0, [r9, #GD_RELOC_OFF]		/* r0 = gd-&gt;reloc_off */</span><br><span class="line">    add	lr, lr, r0</span><br><span class="line">    ldr	r0, [r9, #GD_RELOCADDR]		/* r0 = gd-&gt;relocaddr */</span><br><span class="line">    b	relocate_code</span><br><span class="line">here:</span><br></pre></td></tr></table></figure>
<p>调用<a href="#relocate_code">relocate_code</a>重新定位uboot，对于SPL，不用重新定位。relocate_code 函数在 arch/arm/lib/<br>relocate.S 文件中定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    bl	c_runtime_cpu_setup	/* we still call old routine here */</span><br><span class="line"></span><br><span class="line">    ldr	r0, =__bss_start	/* this is auto-relocated! */</span><br><span class="line">    ldr	r1, =__bss_end		/* this is auto-relocated! */</span><br><span class="line"></span><br><span class="line">    mov	r2, #0x00000000		/* prepare zero to clear BSS */</span><br><span class="line"></span><br><span class="line">clbss_l:cmp	r0, r1			/* while not at end of BSS */</span><br><span class="line">    strlo	r2, [r0]		/* clear 32-bit BSS word */</span><br><span class="line">    addlo	r0, r0, #4		/* move to next */</span><br><span class="line">    blo	clbss_l</span><br><span class="line"></span><br><span class="line">    bl coloured_LED_init</span><br><span class="line">    bl red_led_on</span><br><span class="line"></span><br><span class="line">    /* call board_init_r(gd_t *id, ulong dest_addr) */</span><br><span class="line">    mov     r0, r9                  /* gd_t */</span><br><span class="line">    ldr	r1, [r9, #GD_RELOCADDR]	/* dest_addr */</span><br><span class="line">    /* call board_init_r */</span><br><span class="line">    ldr	pc, =board_init_r	/* this is auto-relocated! */</span><br><span class="line"></span><br><span class="line">ENDPROC(_main)</span><br></pre></td></tr></table></figure>

<p>调用<a href="#board_init_r">board_init_r</a>函数，这个环境包含BSS段和.data段。</p>
<h3 id="gd全局变量"><a href="#gd全局变量" class="headerlink" title="gd全局变量"></a>gd全局变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/global_data.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm (<span class="string">&quot;r9&quot;</span>)  <span class="comment">//放到寄存器r9中</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> &#123;</span></span><br><span class="line">    <span class="type">bd_t</span> *bd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> baudrate;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpu_clk;	<span class="comment">/* CPU clock in Hz!		*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bus_clk;</span><br><span class="line">    <span class="comment">/* We cannot bracket this with CONFIG_PCI due to mpc5xxx */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pci_clk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mem_clk;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_LCD) || defined(CONFIG_VIDEO)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fb_base;	<span class="comment">/* Base address of framebuffer mem */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_POST) || defined(CONFIG_LOGBUFFER)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> post_log_word;  <span class="comment">/* Record POST activities */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> post_log_res; <span class="comment">/* success of POST test */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> post_init_f_time;  <span class="comment">/* When post_init_f started */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOARD_TYPES</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> board_type;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> have_console;	<span class="comment">/* serial_init() was called */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PRE_CONSOLE_BUFFER</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> precon_buf_idx;	<span class="comment">/* Pre-Console buffer index */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MODEM_SUPPORT</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> do_mdm_init;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> be_quiet;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> env_addr;	<span class="comment">/* Address  of Environment struct */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> env_valid;	<span class="comment">/* Checksum of Environment valid? */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ram_top;	<span class="comment">/* Top address of RAM used by U-Boot */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> relocaddr;	<span class="comment">/* Start address of U-Boot in RAM */</span></span><br><span class="line">    <span class="type">phys_size_t</span> ram_size;	<span class="comment">/* RAM size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mon_len;	<span class="comment">/* monitor len */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> irq_sp;		<span class="comment">/* irq stack pointer */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_addr_sp;	<span class="comment">/* start_addr_stackpointer */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> reloc_off;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> *<span class="title">new_gd</span>;</span>	<span class="comment">/* relocated global data */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *fdt_blob;	<span class="comment">/* Our device tree, NULL if none */</span></span><br><span class="line">    <span class="type">void</span> *new_fdt;		<span class="comment">/* Relocated FDT */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fdt_size;	<span class="comment">/* Space reserved for relocated FDT */</span></span><br><span class="line">    <span class="type">void</span> **jt;		<span class="comment">/* jump table */</span></span><br><span class="line">    <span class="type">char</span> env_buf[<span class="number">32</span>];	<span class="comment">/* buffer for getenv() before reloc. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">    <span class="type">void</span>		*trace_buff;	<span class="comment">/* The trace buffer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_I2C)</span></span><br><span class="line">    <span class="type">int</span>		cur_i2c_bus;	<span class="comment">/* current used i2c bus */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arch_global_data</span> <span class="title">arch</span>;</span>	<span class="comment">/* architecture-specific data */</span></span><br><span class="line">&#125; <span class="type">gd_t</span>;</span><br></pre></td></tr></table></figure>

<p>gd 是一个指向gd_t类型的全局变量指针，地址是r9寄存器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bd_info</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>	bi_baudrate;	<span class="comment">/* serial console baudrate */</span></span><br><span class="line">    ulong	        bi_arch_number;	<span class="comment">/* unique id for this board */</span></span><br><span class="line">    ulong	        bi_boot_params;	<span class="comment">/* 向kernel传参的内存地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>	bi_arm_freq; <span class="comment">/* arm frequency */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>	bi_dsp_freq; <span class="comment">/* dsp core frequency */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>	bi_ddr_freq; <span class="comment">/* ddr frequency */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>				/* <span class="title">RAM</span> <span class="title">configuration</span> */</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    ulong start;</span><br><span class="line">    ulong size;</span><br><span class="line">    &#125;			bi_dram[CONFIG_NR_DRAM_BANKS];</span><br><span class="line">&#125; <span class="type">bd_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>bd_t 是开发板的板级信息的结构体， 包含硬件相关的参数，如波特率、IP 地址、机器码、DDR 内存分布。</p>
<ul>
<li><p>bi_arch_number 是开发板的机器码。就是 uboot 给这个开发板定义的一个唯一编号，主要作用是在 uboot 和 linux 内核之间进行比对和适配。</p>
</li>
<li><p>bi_boot_params  表示uboot给linux内核传参的内存地址，bootargs参数就是放在这里。</p>
</li>
</ul>
<h3 id="board-init-f"><a href="#board-init-f" class="headerlink" title="board_init_f"></a>board_init_f</h3><p>uboot 第二阶段代码的入口是 board_init_f 函数，是第一个在内存中运行的代码，在 arch/arm/lib/board.c 中定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_f</span><span class="params">(ulong bootflag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bd_t</span> *bd;</span><br><span class="line">    <span class="type">init_fnc_t</span> **init_fnc_ptr;</span><br><span class="line">    <span class="type">gd_t</span> *id;</span><br><span class="line">    ulong addr, addr_sp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PRAM</span></span><br><span class="line">    ulong reg;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">void</span> *new_fdt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> fdt_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span> *)gd, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">gd_t</span>));</span><br><span class="line"></span><br><span class="line">    gd-&gt;mon_len = _bss_end_ofs;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF_EMBED</span></span><br><span class="line">    <span class="comment">/* Get a pointer to the FDT */</span></span><br><span class="line">    gd-&gt;fdt_blob = _binary_dt_dtb_start;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined CONFIG_OF_SEPARATE</span></span><br><span class="line">    <span class="comment">/* FDT is at end of image */</span></span><br><span class="line">    gd-&gt;fdt_blob = (<span class="type">void</span> *)(_end_ofs + _TEXT_BASE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Allow the early environment to override the fdt address */</span></span><br><span class="line">    gd-&gt;fdt_blob = (<span class="type">void</span> *)getenv_ulong(<span class="string">&quot;fdtcontroladdr&quot;</span>, <span class="number">16</span>,</span><br><span class="line">                        (<span class="type">uintptr_t</span>)gd-&gt;fdt_blob);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*init_fnc_ptr)() != <span class="number">0</span>) &#123;</span><br><span class="line">            hang ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF_CONTROL</span></span><br><span class="line">    <span class="comment">/* For now, put this check after the console is ready */</span></span><br><span class="line">    <span class="keyword">if</span> (fdtdec_prepare_fdt()) &#123;</span><br><span class="line">        panic(<span class="string">&quot;** CONFIG_OF_CONTROL defined but no FDT - please see &quot;</span></span><br><span class="line">            <span class="string">&quot;doc/README.fdt-control&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_MEM_TOP_HIDE)</span></span><br><span class="line">    gd-&gt;ram_size -= CONFIG_SYS_MEM_TOP_HIDE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    addr = CONFIG_SYS_SDRAM_BASE + gd-&gt;ram_size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOGBUFFER</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_ALT_LB_ADDR</span></span><br><span class="line">    <span class="comment">/* reserve kernel log buffer */</span></span><br><span class="line">    addr -= (LOGBUFF_RESERVE);</span><br><span class="line">    debug(<span class="string">&quot;Reserving %dk for kernel logbuffer at %08lx\n&quot;</span>, LOGBUFF_LEN,</span><br><span class="line">        addr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PRAM</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * reserve protected RAM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    reg = getenv_ulong(<span class="string">&quot;pram&quot;</span>, <span class="number">10</span>, CONFIG_PRAM);</span><br><span class="line">    addr -= (reg &lt;&lt; <span class="number">10</span>);		<span class="comment">/* size is in kB */</span></span><br><span class="line">    debug(<span class="string">&quot;Reserving %ldk for protected RAM at %08lx\n&quot;</span>, reg, addr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_PRAM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(defined(CONFIG_SYS_ICACHE_OFF) &amp;&amp; defined(CONFIG_SYS_DCACHE_OFF))</span></span><br><span class="line">    <span class="comment">/* reserve TLB table */</span></span><br><span class="line">    gd-&gt;arch.tlb_size = <span class="number">4096</span> * <span class="number">4</span>;</span><br><span class="line">    addr -= gd-&gt;arch.tlb_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* round down to next 64 kB limit */</span></span><br><span class="line">    addr &amp;= ~(<span class="number">0x10000</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    gd-&gt;arch.tlb_addr = addr;</span><br><span class="line">    debug(<span class="string">&quot;TLB table from %08lx to %08lx\n&quot;</span>, addr, addr + gd-&gt;arch.tlb_size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* round down to next 4 kB limit */</span></span><br><span class="line">    addr &amp;= ~(<span class="number">4096</span> - <span class="number">1</span>);</span><br><span class="line">    debug(<span class="string">&quot;Top of RAM usable for U-Boot at: %08lx\n&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LCD</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FB_ADDR</span></span><br><span class="line">    gd-&gt;fb_base = CONFIG_FB_ADDR;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/* reserve memory for LCD display (always full pages) */</span></span><br><span class="line">    addr = lcd_setmem(addr);</span><br><span class="line">    gd-&gt;fb_base = addr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_FB_ADDR */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_LCD */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * reserve memory for U-Boot code, data &amp; bss</span></span><br><span class="line"><span class="comment">     * round down to next 4 kB limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addr -= gd-&gt;mon_len;</span><br><span class="line">    addr &amp;= ~(<span class="number">4096</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    debug(<span class="string">&quot;Reserving %ldk for U-Boot at: %08lx\n&quot;</span>, gd-&gt;mon_len &gt;&gt; <span class="number">10</span>, addr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPL_BUILD</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * reserve memory for malloc() arena</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addr_sp = addr - TOTAL_MALLOC_LEN;</span><br><span class="line">    debug(<span class="string">&quot;Reserving %dk for malloc() at: %08lx\n&quot;</span>,</span><br><span class="line">            TOTAL_MALLOC_LEN &gt;&gt; <span class="number">10</span>, addr_sp);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * (permanently) allocate a Board Info struct</span></span><br><span class="line"><span class="comment">     * and a permanent copy of the &quot;global&quot; data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addr_sp -= <span class="keyword">sizeof</span> (<span class="type">bd_t</span>);</span><br><span class="line">    bd = (<span class="type">bd_t</span> *) addr_sp;</span><br><span class="line">    gd-&gt;bd = bd;</span><br><span class="line">    debug(<span class="string">&quot;Reserving %zu Bytes for Board Info at: %08lx\n&quot;</span>,</span><br><span class="line">            <span class="keyword">sizeof</span> (<span class="type">bd_t</span>), addr_sp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MACH_TYPE</span></span><br><span class="line">    gd-&gt;bd-&gt;bi_arch_number = CONFIG_MACH_TYPE; <span class="comment">/* board id for Linux */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    addr_sp -= <span class="keyword">sizeof</span> (<span class="type">gd_t</span>);</span><br><span class="line">    id = (<span class="type">gd_t</span> *) addr_sp;</span><br><span class="line">    debug(<span class="string">&quot;Reserving %zu Bytes for Global Data at: %08lx\n&quot;</span>,</span><br><span class="line">            <span class="keyword">sizeof</span> (<span class="type">gd_t</span>), addr_sp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_SEPARATE) &amp;&amp; defined(CONFIG_OF_CONTROL)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If the device tree is sitting immediate above our image then we</span></span><br><span class="line"><span class="comment">     * must relocate it. If it is embedded in the data section, then it</span></span><br><span class="line"><span class="comment">     * will be relocated with other data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (gd-&gt;fdt_blob) &#123;</span><br><span class="line">        fdt_size = ALIGN(fdt_totalsize(gd-&gt;fdt_blob) + <span class="number">0x1000</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        addr_sp -= fdt_size;</span><br><span class="line">        new_fdt = (<span class="type">void</span> *)addr_sp;</span><br><span class="line">        debug(<span class="string">&quot;Reserving %zu Bytes for FDT at: %08lx\n&quot;</span>,</span><br><span class="line">              fdt_size, addr_sp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup stackpointer for exeptions */</span></span><br><span class="line">    gd-&gt;irq_sp = addr_sp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USE_IRQ</span></span><br><span class="line">    addr_sp -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);</span><br><span class="line">    debug(<span class="string">&quot;Reserving %zu Bytes for IRQ stack at: %08lx\n&quot;</span>,</span><br><span class="line">        CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ, addr_sp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* leave 3 words for abort-stack    */</span></span><br><span class="line">    addr_sp -= <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 8-byte alignment for ABI compliance */</span></span><br><span class="line">    addr_sp &amp;= ~<span class="number">0x07</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    addr_sp += <span class="number">128</span>;	<span class="comment">/* leave 32 words for abort-stack   */</span></span><br><span class="line">    gd-&gt;irq_sp = addr_sp;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    interrupt_init();</span><br><span class="line"></span><br><span class="line">    debug(<span class="string">&quot;New Stack Pointer is: %08lx\n&quot;</span>, addr_sp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_POST</span></span><br><span class="line">    post_bootmode_init();</span><br><span class="line">    post_run(<span class="literal">NULL</span>, POST_ROM | post_bootmode_get(<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    gd-&gt;bd-&gt;bi_baudrate = gd-&gt;baudrate;</span><br><span class="line">    <span class="comment">/* Ram ist board specific, so move it to board code ... */</span></span><br><span class="line">    dram_init_banksize();</span><br><span class="line">    display_dram_config();	<span class="comment">/* and display it */</span></span><br><span class="line"></span><br><span class="line">    gd-&gt;relocaddr = addr;</span><br><span class="line">    gd-&gt;start_addr_sp = addr_sp;</span><br><span class="line">    gd-&gt;reloc_off = addr - _TEXT_BASE;</span><br><span class="line">    debug(<span class="string">&quot;relocation Offset is: %08lx\n&quot;</span>, gd-&gt;reloc_off);</span><br><span class="line">    <span class="keyword">if</span> (new_fdt) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(new_fdt, gd-&gt;fdt_blob, fdt_size);</span><br><span class="line">        gd-&gt;fdt_blob = new_fdt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(id, (<span class="type">void</span> *)gd, <span class="keyword">sizeof</span>(<span class="type">gd_t</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是填充 gd、bd数据，设置堆、栈。</p>
<h3 id="relocate"><a href="#relocate" class="headerlink" title="relocate"></a>relocate</h3><h3 id="board-init-r"><a href="#board-init-r" class="headerlink" title="board_init_r"></a>board_init_r</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_r</span><span class="params">(<span class="type">gd_t</span> *id, ulong dest_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    ulong malloc_start;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_SYS_NO_FLASH)</span></span><br><span class="line">    ulong flash_size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    gd-&gt;flags |= GD_FLG_RELOC;	<span class="comment">/* tell others: relocation done */</span></span><br><span class="line">    bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, <span class="string">&quot;board_init_r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    monitor_flash_len = _end_ofs;</span><br><span class="line"></span><br><span class="line">    enable_caches();</span><br><span class="line"></span><br><span class="line">    board_init();	<span class="comment">/* Setup chipselects */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CLOCKS</span></span><br><span class="line">    set_cpu_clk_info(); <span class="comment">/* Setup clock information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    serial_initialize();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOGBUFFER</span></span><br><span class="line">    logbuff_init_ptrs();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_POST</span></span><br><span class="line">    post_output_backlog();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The Malloc area is immediately below the monitor copy in DRAM */</span></span><br><span class="line">    malloc_start = dest_addr - TOTAL_MALLOC_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化uboot的堆管理器*/</span></span><br><span class="line">    mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_EARLY_INIT_R</span></span><br><span class="line">    arch_early_init_r();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    power_init_board();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_SYS_NO_FLASH)</span></span><br><span class="line"></span><br><span class="line">    flash_size = flash_init();</span><br><span class="line">    <span class="keyword">if</span> (flash_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_SYS_FLASH_CHECKSUM</span></span><br><span class="line">        print_size(flash_size, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getenv_yesno(<span class="string">&quot;flashchecksum&quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  CRC: %08X&quot;</span>, crc32(<span class="number">0</span>,</span><br><span class="line">                (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) CONFIG_SYS_FLASH_BASE,</span><br><span class="line">                flash_size));</span><br><span class="line">        &#125;</span><br><span class="line">        putc(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span>	<span class="comment">/* !CONFIG_SYS_FLASH_CHECKSUM */</span></span></span><br><span class="line">        print_size(flash_size, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> <span class="comment">/* CONFIG_SYS_FLASH_CHECKSUM */</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(failed);</span><br><span class="line">        hang();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CMD_NAND)</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NAND:  &quot;</span>);</span><br><span class="line">    nand_init();		<span class="comment">/* go init the NAND */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CMD_ONENAND)</span></span><br><span class="line">    onenand_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_MMC</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;MMC:   &quot;</span>);</span><br><span class="line">    mmc_initialize(gd-&gt;bd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAS_DATAFLASH</span></span><br><span class="line">    AT91F_DataflashInit();</span><br><span class="line">    dataflash_print_info();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize environment */</span></span><br><span class="line">    <span class="keyword">if</span> (should_load_env())</span><br><span class="line">        env_relocate();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        set_default_env(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)</span></span><br><span class="line">    arm_pci_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    stdio_init();	<span class="comment">/* get the devices list going. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*建立一个函数跳转表*/</span></span><br><span class="line">    jumptable_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_API)</span></span><br><span class="line">    <span class="comment">/* Initialize API */</span></span><br><span class="line">    api_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    console_init_r();	<span class="comment">/* fully init console as a device */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DISPLAY_BOARDINFO_LATE</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_OF_CONTROL</span></span><br><span class="line">    <span class="comment">/* Put this here so it appears on the LCD, now it is ready */</span></span><br><span class="line">    display_fdt_model(gd-&gt;fdt_blob);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    checkboard();</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_MISC_INIT)</span></span><br><span class="line">    <span class="comment">/* miscellaneous arch dependent initialisations */</span></span><br><span class="line">    arch_misc_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MISC_INIT_R)</span></span><br><span class="line">    <span class="comment">/* miscellaneous platform dependent initialisations */</span></span><br><span class="line">    misc_init_r();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable exceptions */</span></span><br><span class="line">    enable_interrupts();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize from environment */</span></span><br><span class="line">    load_addr = getenv_ulong(<span class="string">&quot;loadaddr&quot;</span>, <span class="number">16</span>, load_addr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOARD_LATE_INIT</span></span><br><span class="line">    board_late_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BITBANGMII</span></span><br><span class="line">    bb_miiphy_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CMD_NET)</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Net:   &quot;</span>);</span><br><span class="line">    eth_initialize(gd-&gt;bd);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_RESET_PHY_R)</span></span><br><span class="line">    reset_phy();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_POST</span></span><br><span class="line">    post_run(<span class="literal">NULL</span>, POST_RAM | post_bootmode_get(<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Export available size of memory for Linux,</span></span><br><span class="line"><span class="comment">     * taking into account the protected RAM at top of memory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">        ulong pram = <span class="number">0</span>;</span><br><span class="line">        uchar memsz[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PRAM</span></span><br><span class="line">        pram = getenv_ulong(<span class="string">&quot;pram&quot;</span>, <span class="number">10</span>, CONFIG_PRAM);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOGBUFFER</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_ALT_LB_ADDR</span></span><br><span class="line">        <span class="comment">/* Also take the logbuffer into account (pram is in kB) */</span></span><br><span class="line">        pram += (LOGBUFF_LEN + LOGBUFF_OVERHEAD) / <span class="number">1024</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">sprintf</span>((<span class="type">char</span> *)memsz, <span class="string">&quot;%ldk&quot;</span>, (gd-&gt;ram_size / <span class="number">1024</span>) - pram);</span><br><span class="line">        setenv(<span class="string">&quot;mem&quot;</span>, (<span class="type">char</span> *)memsz);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        main_loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行串口、flash、网卡、控制台等初始化，最后进入 main_loop()函数中。board_init()是开发板相关的初始化，在/board/samsung/xxx/xxx.c中定义。</p>
<h3 id="main-loop"><a href="#main-loop" class="headerlink" title="main_loop"></a>main_loop</h3><p>main_loop()函数在common/main.c文件定义，等待终端输入命令以及对命令进行处理。</p>
<h2 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h2><h3 id="mkimage"><a href="#mkimage" class="headerlink" title="mkimage"></a>mkimage</h3><p>内核编译成功会生成 vmlinux、Image、zImage，再通过 uboot 提供的工具 mkimage，执行``make uImage` 命令生成 uImage。</p>
<ul>
<li><strong>vmlinux</strong>  原始的未经任何处理加工的原版内核 elf 文件，一般PC机上直接加载就可运行。</li>
<li><strong>Image</strong>  由vmlinux 经 objcopy 去掉一些不需要的东西之后得到。</li>
<li><strong>zImage</strong>  由Image用gzip压缩得到，文件开头嵌有解压缩代码。</li>
<li><strong>uImage</strong>   uboot专用的镜像文件，它是在zImage之前加上64字节的头部信息合成，说明这个内核的版本、加载位置、生成时间、大小等信息；其0x40之后与zImage没区别。</li>
</ul>
<p><img src="/images/uboot/vmlinux.bmp" alt="img"></p>
<p>uboot都支持uImage启动，支持zImage启动需要定义LINUX_ZIMAGE_MAGIC宏。</p>
<p>mkimage工具在uboot源代码的tools/目录下，用来给zImage镜像添加64字节的头部信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">-A：指定 CPU 的体系结构，alpha、arm 、x86、ia64、mips、mips64、 ppc 、s390、sh、sparc 、sparc64、m68k 等；</span><br><span class="line">-O：指定操作系统类型，可用值有：openbsd、netbsd、freebsd、4_4bsd、linux、 svr4、esix、solaris、irix、sco、dell、ncr、lynxos、vxworks、psos、qnx、u-boot、rtems、artos；</span><br><span class="line">-T：指定镜像类型，可用值有：standalone、kernel、ramdisk、multi、firmware、script、filesystem；</span><br><span class="line">-C：指定镜像压缩方式，可用值有：</span><br><span class="line">    ：none 不压缩(一般使用这个，因为 zImage 是已经被 bzip2 压缩过的自解压内核)；</span><br><span class="line">    ：zip 用 gzip 的压缩方式；</span><br><span class="line">    ：bzip2 用 bzip2 的压缩方式；</span><br><span class="line">-a：指定镜像在内存中的加载地址，镜像下载到内存中时，要按照这个地址来下载；</span><br><span class="line">-e：指定镜像运行的入口点地址，这个地址就是-a 参数指定的值加上0x40（前面mkimage添加了64个字节头）；</span><br><span class="line">-n：指定镜像名；</span><br><span class="line">-d：指定制作镜像的源文件；</span><br></pre></td></tr></table></figure>

<p>uboot启动内核的打印：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Booting kernel from Legacy Image at 82208000 ...</span><br><span class="line">Image Name:   Linux-3.4.35</span><br><span class="line">Image Type:   ARM Linux Kernel Image (uncompressed)</span><br><span class="line">Data Size:    1417696 Bytes = 1.4 MiB</span><br><span class="line">Load Address: 82208000</span><br><span class="line">Entry Point:  82208040</span><br><span class="line">Verifying Checksum ... OK</span><br><span class="line">XIP Kernel Image ... OK</span><br></pre></td></tr></table></figure>

<h3 id="加载内核到DDR"><a href="#加载内核到DDR" class="headerlink" title="加载内核到DDR"></a>加载内核到DDR</h3><p>uboot将内核镜像从启动介质中加载到DDR中，还要给内核传递启动参数，内核就从链接地址处开始运行。</p>
<h3 id="校验内核格式"><a href="#校验内核格式" class="headerlink" title="校验内核格式"></a>校验内核格式</h3><p>uboot用bootm命令引导内核，bootm会读取一个64字节的文件头，来获取这个内核镜像所针对的CPU体系结构、OS、加载到内存中的位置、在内存中入口点的位置以及镜像名等等信息。这样bootm才能为OS设置好启动环境，并跳入内核镜像的入口点。</p>
<p>当bootm命令执行时，uboot实际执行do_bootm()函数，在cmd_bootm.c中定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_bootm</span><span class="params">(<span class="type">cmd_tbl_t</span> *cmdtp, <span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> relocated = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!relocated) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* relocate boot function table */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(boot_os); i++)</span><br><span class="line">            <span class="keyword">if</span> (boot_os[i] != <span class="literal">NULL</span>)</span><br><span class="line">                boot_os[i] += gd-&gt;reloc_off;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* relocate names of sub-command table */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(cmd_bootm_sub); i++)</span><br><span class="line">            cmd_bootm_sub[i].name += gd-&gt;reloc_off;</span><br><span class="line"></span><br><span class="line">        relocated = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* determine if we have a sub command */</span></span><br><span class="line">    argc--; argv++;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *endp;</span><br><span class="line"></span><br><span class="line">        simple_strtoul(argv[<span class="number">0</span>], &amp;endp, <span class="number">16</span>);</span><br><span class="line">        <span class="comment">/* endp pointing to NULL means that argv[0] was just a</span></span><br><span class="line"><span class="comment">         * valid number, pass it along to the normal bootm processing</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If endp is &#x27;:&#x27; or &#x27;#&#x27; assume a FIT identifier so pass</span></span><br><span class="line"><span class="comment">         * along for normal processing.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Right now we assume the first arg should never be &#x27;-&#x27;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((*endp != <span class="number">0</span>) &amp;&amp; (*endp != <span class="string">&#x27;:&#x27;</span>) &amp;&amp; (*endp != <span class="string">&#x27;#&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> do_bootm_subcommand(cmdtp, flag, argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |</span><br><span class="line">        BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |</span><br><span class="line">        BOOTM_STATE_LOADOS |</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_PPC) || defined(CONFIG_MIPS)</span></span><br><span class="line">        BOOTM_STATE_OS_CMDLINE |</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |</span><br><span class="line">        BOOTM_STATE_OS_GO, &amp;images, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://blog.csdn.net/qq_45544223/category_9907716.html">https://blog.csdn.net/qq_45544223/category_9907716.html</a></p>
<p><a href="https://www.cnblogs.com/Cqlismy/category/1603479.html">https://www.cnblogs.com/Cqlismy/category/1603479.html</a></p>
]]></content>
      <categories>
        <category>uboot</category>
      </categories>
  </entry>
  <entry>
    <title>cp</title>
    <url>/2022/06/26/cmd/cp/</url>
    <content><![CDATA[<p>cp - copy files and directories</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp [OPTION]... SOURCE... DIRECTORY</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a：此参数的效果和同时指定&quot;-dpR&quot;参数相同；</span><br><span class="line">-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；</span><br><span class="line">-f：强行复制文件或目录，不论目标文件或目录是否已存在；</span><br><span class="line">-i：覆盖既有文件之前先询问用户；</span><br><span class="line">-l：对源文件建立硬连接，而非复制文件；</span><br><span class="line">-p：保留源文件或目录的属性；</span><br><span class="line">-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；</span><br><span class="line">-s：对源文件建立符号连接，而非复制文件；</span><br><span class="line">-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；</span><br><span class="line">-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；</span><br><span class="line">-b：覆盖已存在的文件目标前将目标文件备份；</span><br><span class="line">-v：详细显示命令执行的操作。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>cat</title>
    <url>/2022/06/26/cmd/cat/</url>
    <content><![CDATA[<p>cat - concatenate files and print on the standard output，连接多个文件并打印到标准输出。</p>
<p>主要用途:</p>
<ul>
<li>显示文件内容，如果没有文件或文件为<code>-</code>则读取标准输入。</li>
<li>将多个文件的内容进行连接并打印到标准输出。</li>
<li>显示文件内容中的不可见字符（控制字符、换行符、制表符等）。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>FILE（可选）：要处理的文件，可以为一或多个。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">长选项与短选项等价</span><br><span class="line"></span><br><span class="line">-A, --show-all           等价于&quot;-vET&quot;组合选项。</span><br><span class="line">-b, --number-nonblank    只对非空行编号，从1开始编号，覆盖&quot;-n&quot;选项。</span><br><span class="line">-e                       等价于&quot;-vE&quot;组合选项。</span><br><span class="line">-E, --show-ends          在每行的结尾显示&#x27;$&#x27;字符。</span><br><span class="line">-n, --number             对所有行编号，从1开始编号。</span><br><span class="line">-s, --squeeze-blank      压缩连续的空行到一行。</span><br><span class="line">-t                       等价于&quot;-vT&quot;组合选项。</span><br><span class="line">-T, --show-tabs          使用&quot;^I&quot;表示TAB（制表符）。</span><br><span class="line">-u                       POSIX兼容性选项，无意义。</span><br><span class="line">-v, --show-nonprinting   使用&quot;^&quot;和&quot;M-&quot;符号显示控制字符，除了LFD（line feed，即换行符&#x27;\n&#x27;）和TAB（制表符）。</span><br><span class="line">--help                   显示帮助信息并退出。</span><br><span class="line">--version                显示版本信息并退出。</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回状态为成功除非给出了非法选项或非法参数。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将标准输入保存到文件</span></span><br><span class="line">cat &gt; test.log</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>该命令是<code>GNU coreutils</code>包中的命令，相关的帮助信息请查看<code>man -s 1 cat</code>或<code>info coreutils &#39;cat invocation&#39;</code>。</li>
<li>当使用<code>cat</code>命令查看<strong>体积较大的文件</strong>时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容，为了控制滚屏，可以按<code>Ctrl+s</code>键停止滚屏；按<code>Ctrl+q</code>键恢复滚屏；按<code>Ctrl+c</code>（中断）键可以终止该命令的执行，返回Shell提示符状态。</li>
<li>建议您查看<strong>体积较大的文件</strong>时使用<code>less</code>、<code>more</code>命令或<code>emacs</code>、<code>vi</code>等文本编辑器。</li>
</ol>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>diff3</title>
    <url>/2022/06/26/cmd/diff3/</url>
    <content><![CDATA[<p>diff3 - compare three files line by line，比较3个文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">diff3 [OPTION]... MYFILE OLDFILE YOURFILE</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a：把所有的文件都当做文本文件按照行为单位进行比较，即给定的文件不是文本文件；</span><br><span class="line">-A：合并第2个文件和第3个文件之间的不同到第1个文件中，有冲突内容用括号括起来；</span><br><span class="line">-B：与选项“-A”功能相同，但是不显示冲突的内容；</span><br><span class="line">-e/--ed：生成一个“-ed”脚本，用于将第2个文件和第3个文件之间的不同合并到第1个文件中；</span><br><span class="line">--easy-only：除了不显示互相重叠的变化，与选项“-e”的功能相同；</span><br><span class="line">-i：为了和system V系统兼容，在“ed”脚本的最后生成“w”和“q”命令。此选项必须和选项“-AeExX3”连用，但是不能和“-m”连用；</span><br><span class="line">--initial-tab：在正常格式的行的文本前，输出一个TAB字符而非两个空白字符。此选项将导致在行中TAB字符的对齐方式看上去规范。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>cpio</title>
    <url>/2022/06/26/cmd/cpio/</url>
    <content><![CDATA[<p>cpio - copy files to and from archives，用来建立或者还原备份的工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpio (选项)</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-0或--null：接受新增列控制字符，通常配合find指令的“-print0”参数使用；</span><br><span class="line">-a或--rest-access-time：重新设置文件的存取时间；</span><br><span class="line">-A或--append：附加到已存在的备份文档中，且这个备份文档必须存放在磁盘上，而不能放置于磁带机里；</span><br><span class="line">-b或--awap：此参数的效果和同时指定“-ss”参数相同；</span><br><span class="line">-B：将输入/输出的区块大小改成5210Bytes；</span><br><span class="line">-c：使用旧ASCII备份格式；</span><br><span class="line">-C&lt;区块大小&gt;或--io-size=&lt;区块大小&gt;：设置输入/输出的区块大小，单位是Byte；</span><br><span class="line">-d或--make-directories：如有需要cpio会自行建立目录；</span><br><span class="line">-E&lt;范本文件&gt;或--pattern-file=&lt;范本文件&gt;：指定范本文件，其内含有一个或多个范本样式，让cpio解开符合范本条件的文件，格式为每列一个范本样式；</span><br><span class="line">-f或--nonmatching：让cpio解开所有不符合范本条件的文件；</span><br><span class="line">-F&lt;备份档&gt;或--file=&lt;备份档&gt;：指定备份档的名称，用来取代标准输入或输出，也能借此通过网络使用另一台主机的保存设备存取备份档；</span><br><span class="line">-H&lt;备份格式&gt;：指定备份时欲使用的文件格式；</span><br><span class="line">-i或--extract：执行copy-in模式，还原备份档；</span><br><span class="line">-l&lt;备份档&gt;：指定备份档的名称，用来取代标准输入，也能借此通过网络使用另一台主机的保存设备读取备份档；</span><br><span class="line">-k：此参数将忽略不予处理，仅负责解决cpio不同版本间的兼容性问题；</span><br><span class="line">-l或--link：以硬连接的方式取代复制文件，可在copy-pass模式下运用；</span><br><span class="line">-L或--dereference：不建立符号连接，直接复制该连接所指向的原始文件；</span><br><span class="line">-m或preserve-modification-time：不去更改文件的更改时间；</span><br><span class="line">-M&lt;回传信息&gt;或--message=&lt;回传信息&gt;：设置更换保存媒体的信息；</span><br><span class="line">-n或--numeric-uid-gid：使用“-tv”参数列出备份档的内容时，若再加上参数“-n”，则会以用户识别和群组识别码替代拥有者和群组名称列出文件清单；</span><br><span class="line">-o或--create：执行copy-out模式，建立备份档；</span><br><span class="line">-O&lt;备份档&gt;：指定备份档的名称，用来取代标准输出，也能借此通过网络使用另一台主机的保存设备存放备份档；</span><br><span class="line">-p或--pass-through：执行copy-pass模式，略过备份步骤，直接将文件复制到目的目录；</span><br><span class="line">-r或--rename：当有文件名称需要更改时，采用互动模式；</span><br><span class="line">-R&lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt;或----owner&lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt;   在copy-in模式还原备份档，或copy-pass模式复制文件时，可指定这些备份，复制的文件的拥有者与所属群组；</span><br><span class="line">-s或--swap-bytes：交换每队字节的内容；</span><br><span class="line">-S或--swap-halfwords：交换每半个字节的内容；</span><br><span class="line">-t或--list：将输入的内容呈现出来；</span><br><span class="line">-u或--unconditional：置换所有文件，不论日期时间的新旧与否，皆不予询问而直接覆盖；</span><br><span class="line">-v或--verbose：详细显示指令的执行过程；</span><br><span class="line">-V或--dot：执行指令时。在每个文件的执行程序前面加上“.”号；</span><br><span class="line">--block-size=&lt;区块大小&gt;：设置输入/输出的区块大小，假如设置数值为5，则区块大小为2500，若设置成10，则区块大小为5120，以此类推；</span><br><span class="line">--force-local：强制将备份档存放在本地主机；</span><br><span class="line">--help：在线帮助；</span><br><span class="line">--no-absolute-filenames：使用相对路径建立文件名称；</span><br><span class="line">--no-preserve-owner：不保留文件的拥有者，谁解开了备份档，那些文件就归谁所有；</span><br><span class="line">-only-verify-crc：当备份档采用CRC备份格式时，可使用这项参数检查备份档内的每个文件是否正确无误；</span><br><span class="line">--quiet：不显示复制了多少区块；</span><br><span class="line">--sparse：倘若一个文件内含有大量的连续0字节，则将此文件存在稀疏文件；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包</span></span><br><span class="line">find ./ | cpio –ocB &gt; filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解包</span></span><br><span class="line">cpio –idc &lt; filename</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>diff</title>
    <url>/2022/06/26/cmd/diff/</url>
    <content><![CDATA[<p>diff - compare files line by line，比较两个文件的不同</p>
<p>如果使用“-”代替“文件”参数，则要比较的内容将来自标准输入。diff命令是以逐行的方式，比较文本文件的异同处。如果该命令指定进行目录的比较，则将会比较该目录中具有相同文件名的文件，而不会对其子目录文件进行任何比较操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">diff [OPTION]... FILES</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-&lt;行数&gt;：指定要显示多少行的文本。此参数必须与-c或-u参数一并使用；</span><br><span class="line">-a或——text：diff预设只会逐行比较文本文件；</span><br><span class="line">-b或--ignore-space-change：不检查空格字符的不同；</span><br><span class="line">-B或--ignore-blank-lines：不检查空白行；</span><br><span class="line">-c：显示全部内容，并标出不同之处；</span><br><span class="line">-C&lt;行数&gt;或--context&lt;行数&gt;：与执行“-c-&lt;行数&gt;”指令相同；</span><br><span class="line">-d或——minimal：使用不同的演算法，以小的单位来做比较；</span><br><span class="line">-D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt;：此参数的输出格式可用于前置处理器巨集；</span><br><span class="line">-e或——ed：此参数的输出格式可用于ed的script文件；</span><br><span class="line">-f或-forward-ed：输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处；</span><br><span class="line">-H或--speed-large-files：比较大文件时，可加快速度；</span><br><span class="line">-l&lt;字符或字符串&gt;或--ignore-matching-lines&lt;字符或字符串&gt;：若两个文件在某几行有所不同，而之际航同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异；</span><br><span class="line">-i或--ignore-case：不检查大小写的不同；</span><br><span class="line">-l或——paginate：将结果交由pr程序来分页；</span><br><span class="line">-n或——rcs：将比较结果以RCS的格式来显示；</span><br><span class="line">-N或--new-file：在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录，文件A 若使用-N参数，则diff会将文件A 与一个空白的文件比较；</span><br><span class="line">-p：若比较的文件为C语言的程序码文件时，显示差异所在的函数名称；</span><br><span class="line">-P或--unidirectional-new-file：与-N类似，但只有当第二个目录包含了第一个目录所没有的文件时，才会将这个文件与空白的文件做比较；</span><br><span class="line">-q或--brief：仅显示有无差异，不显示详细的信息；</span><br><span class="line">-r或——recursive：比较子目录中的文件；</span><br><span class="line">-s或--report-identical-files：若没有发现任何差异，仍然显示信息；</span><br><span class="line">-S&lt;文件&gt;或--starting-file&lt;文件&gt;：在比较目录时，从指定的文件开始比较；</span><br><span class="line">-t或--expand-tabs：在输出时，将tab字符展开；</span><br><span class="line">-T或--initial-tab：在每行前面加上tab字符以便对齐；</span><br><span class="line">-u，-U&lt;列数&gt;或--unified=&lt;列数&gt;：以合并的方式来显示文件内容的不同；</span><br><span class="line">-v或——version：显示版本信息；</span><br><span class="line">-w或--ignore-all-space：忽略全部的空格字符；</span><br><span class="line">-W&lt;宽度&gt;或--width&lt;宽度&gt;：在使用-y参数时，指定栏宽；</span><br><span class="line">-x&lt;文件名或目录&gt;或--exclude&lt;文件名或目录&gt;：不比较选项中所指定的文件或目录；</span><br><span class="line">-X&lt;文件&gt;或--exclude-from&lt;文件&gt;；您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件；</span><br><span class="line">-y或--side-by-side：以并列的方式显示文件的异同之处；</span><br><span class="line">--help：显示帮助；</span><br><span class="line">--left-column：在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容；</span><br><span class="line">--suppress-common-lines：在使用-y参数时，仅显示不同之处。</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打补丁</span></span><br><span class="line">diff file1 file2 &gt; xxx.patch</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>lsof</title>
    <url>/2022/06/26/cmd/lsof/</url>
    <content><![CDATA[<p>lsof - list open files，显示Linux系统当前已打开的所有文件列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof [ -?abChKlnNOPRtUvVX ] [ -A A ] [ -c c ] [ +c c ] [ +|-d d ] [ +|-D D ] [ +|-e s ] [ +|-E ] [ +|-f [cfgGn] ] </span><br><span class="line">    [ -F [f] ] [ -g [s] ]</span><br><span class="line">    [ -i [i] ] [ -k k ] [ +|-L [l] ] [ +|-m m ] [ +|-M ] [ -o [o] ] [ -p s ] [ +|-r [t[m&lt;fmt&gt;]] ] [ -s [p:s] ] </span><br><span class="line">    [ -S [t] ] [ -T [t] ] </span><br><span class="line">    [ -u s ] [ +|-w ] [ -x [fl] ] [ -z [z] ] [ -Z [Z] ] [ -- ] [names]</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a：列出打开文件存在的进程；</span><br><span class="line">-c&lt;进程名&gt;：列出指定进程所打开的文件；</span><br><span class="line">-g：列出GID号进程详情；</span><br><span class="line">-d&lt;文件号&gt;：列出占用该文件号的进程；</span><br><span class="line">+d&lt;目录&gt;：列出目录下被打开的文件；</span><br><span class="line">+D&lt;目录&gt;：递归列出目录下被打开的文件；</span><br><span class="line">-n&lt;目录&gt;：列出使用NFS的文件；</span><br><span class="line">-i&lt;条件&gt;：列出符合条件的进程。（4、6、协议、:端口、 @ip ）</span><br><span class="line">-p&lt;进程号&gt;：列出指定进程号所打开的文件；</span><br><span class="line">-u：列出UID号进程详情；</span><br><span class="line">-h：显示帮助信息；</span><br><span class="line">-v：显示版本信息。</span><br></pre></td></tr></table></figure>

<p>lsof输出各列信息的意义如下：</p>
<ul>
<li>COMMAND：程序的名称</li>
<li>PID：进程标识符</li>
<li>PPID：父进程标识符（需要指定-R参数）</li>
<li>USER：进程所有者</li>
<li>PGID：进程所属组</li>
<li>FD：文件描述符</li>
<li>TYPE：文件类型，如 DIR、REG 等</li>
<li>DEVICE：以逗号分隔设备编号</li>
<li>SIZE：文件的大小(bytes)</li>
<li>NODE：索引节点(文件在磁盘上的标识)</li>
<li>NAME：打开文件的确切名称</li>
</ul>
<p>文件描述符列表：</p>
<ul>
<li>cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改</li>
<li>txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序</li>
<li>lnn：library references (AIX);</li>
<li>er：FD information error (see NAME column);</li>
<li>jld：jail directory (FreeBSD);</li>
<li>ltx：shared library text (code and data);</li>
<li>mxx ：hex memory-mapped type number xx.</li>
<li>m86：DOS Merge mapped file;</li>
<li>mem：memory-mapped file;</li>
<li>mmap：memory-mapped device;</li>
<li>pd：parent directory;</li>
<li>rtd：root directory;</li>
<li>tr：kernel trace file (OpenBSD);</li>
<li>v86  VP/ix mapped file;</li>
<li>0：表示标准输出</li>
<li>1：表示标准输入</li>
<li>2：表示标准错误</li>
</ul>
<p>一般在标准输出、标准错误、标准输入后还跟着文件状态模式：</p>
<ul>
<li>u：表示该文件被打开并处于读取/写入模式。</li>
<li>r：表示该文件被打开并处于只读模式。</li>
<li>w：表示该文件被打开并处于。</li>
<li>空格：表示该文件的状态模式为unknow，且没有锁定。</li>
<li>-：表示该文件的状态模式为unknow，且被锁定。</li>
</ul>
<p>同时在文件状态模式后面，还跟着相关的锁：</p>
<ul>
<li>N：for a Solaris NFS lock of unknown type;</li>
<li>r：for read lock on part of the file;</li>
<li>R：for a read lock on the entire file;</li>
<li>w：for a write lock on part of the file;（文件的部分写锁）</li>
<li>W：for a write lock on the entire file;（整个文件的写锁）</li>
<li>u：for a read and write lock of any length;</li>
<li>U：for a lock of unknown type;</li>
<li>x：for an SCO OpenServer Xenix lock on part      of the file;</li>
<li>X：for an SCO OpenServer Xenix lock on the      entire file;</li>
<li>空格：if there is no lock.</li>
</ul>
<p>文件类型：</p>
<ul>
<li>DIR：表示目录。</li>
<li>CHR：表示字符类型。</li>
<li>BLK：块设备类型。</li>
<li>UNIX： UNIX 域套接字。</li>
<li>FIFO：先进先出 (FIFO) 队列。</li>
<li>IPv4：网际协议 (IP) 套接字。</li>
<li>DEVICE：指定磁盘的名称</li>
<li>SIZE：文件的大小</li>
<li>NODE：索引节点（文件在磁盘上的标识）</li>
<li>NAME：打开文件的确切名称</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>列出指定进程打开的文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof /bin/bash</span><br></pre></td></tr></table></figure>

<p>列出指定进程号所打开的文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -p $pid</span><br></pre></td></tr></table></figure>

<p>获取端口对应的进程ID=&gt;pid</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -i:9981 -P -t -sTCP:LISTEN</span><br></pre></td></tr></table></figure>

<p>列出打开文件的进程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof $filename</span><br></pre></td></tr></table></figure>

<p>查看某个用户打开的所有文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -u syslog</span><br></pre></td></tr></table></figure>

<p>查看哪些进程打开了某个目录:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof +d /var/log</span><br><span class="line">lsof +D /var/log  #对目录递归查找</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>make</title>
    <url>/2022/06/26/cmd/make/</url>
    <content><![CDATA[<p>make - GNU make utility to maintain groups of programs，GNU的工程化编译工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make [OPTION]... [TARGET]...</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-f：指定“makefile”文件；</span><br><span class="line">-i：忽略命令执行返回的出错信息；</span><br><span class="line">-s：沉默模式，在执行之前不输出相应的命令行信息；</span><br><span class="line">-r：禁止使用build-in规则；</span><br><span class="line">-n：非执行模式，输出所有执行命令，但并不执行；</span><br><span class="line">-t：更新目标文件；</span><br><span class="line">-q：make操作将根据目标文件是否已经更新返回&quot;0&quot;或非&quot;0&quot;的状态信息；</span><br><span class="line">-p：输出所有宏定义和目标文件描述；</span><br><span class="line">-d：Debug模式，输出有关文件和检测时间的详细信息。</span><br></pre></td></tr></table></figure>

<p>Linux下常用选项与Unix系统中稍有不同，下面是不同的部分：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c dir：在读取 makefile 之前改变到指定的目录dir；</span><br><span class="line">-I dir：当包含其他 makefile文件时，利用该选项指定搜索目录；</span><br><span class="line">-h：help文挡，显示所有的make选项；</span><br><span class="line">-w：在处理 makefile 之前和之后，都显示工作目录。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>nm</title>
    <url>/2022/06/26/cmd/nm/</url>
    <content><![CDATA[<p>nm显示二进制目标文件的符号表</p>
<p>使用nm前，最好先用<code>file</code>命令查看对象文件所属处理器架构，再用相应版本的nm工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nm [option] [file]</span><br><span class="line"></span><br><span class="line">-C 输出demangle过了的符号名称；</span><br><span class="line">-l 使用对象文件中的调试信息打印出所在源文件及行号；必须保证你的对象文件中带有符号调式信息，编译时指定`-g`选项。</span><br><span class="line">-n 按照地址/符号值来排序；</span><br><span class="line">-u 打印出那些未定义的符号；</span><br><span class="line">-A：每个符号前显示文件名；</span><br><span class="line">-D：显示动态符号；</span><br><span class="line">-g：仅显示外部符号；</span><br><span class="line">-r：反序显示符号表。</span><br><span class="line"></span><br><span class="line">常见的符号类型:</span><br><span class="line">A 该符号的值在今后的链接中将不再改变；</span><br><span class="line">B 该符号放在BSS段中，通常是那些未初始化的全局变量；</span><br><span class="line">D 该符号放在普通的数据段中，通常是那些已经初始化的全局变量；</span><br><span class="line">T 该符号放在代码段中，通常是那些全局非静态函数；</span><br><span class="line">U 该符号未定义过，需要自其他对象文件中链接进来；</span><br><span class="line">W 未明确指定的弱链接符号；同链接的其他对象文件中有它的定义就用上，否则就用一个系统特别指定的默认值。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>man</title>
    <url>/2022/06/26/cmd/man/</url>
    <content><![CDATA[<p>查看Linux中的指令帮助、配置文件帮助和编程帮助等信息。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a：在所有的man帮助手册中搜索；</span><br><span class="line">-f：等价于whatis指令，显示给定关键字的简短描述信息；</span><br><span class="line">-P：指定内容时使用分页程序；</span><br><span class="line">-M：指定man手册搜索的路径。</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>  数字：指定从哪本man手册中搜索帮助；</li>
<li>  关键字：指定要搜索帮助的关键字。</li>
</ul>
<h2 id="数字代表内容"><a href="#数字代表内容" class="headerlink" title="数字代表内容"></a>数字代表内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1：用户在shell环境可操作的命令或执行文件；</span><br><span class="line">2：系统内核可调用的函数与工具等</span><br><span class="line">3：一些常用的函数(function)与函数库(library)，大部分为C的函数库(libc)</span><br><span class="line">4：设备文件说明，通常在/dev下的文件</span><br><span class="line">5：配置文件或某些文件格式</span><br><span class="line">6：游戏(games)</span><br><span class="line">7：惯例与协议等，如Linux文件系统，网络协议，ASCII code等说明</span><br><span class="line">8：系统管理员可用的管理命令</span><br><span class="line">9：跟kernel有关的文件</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>我们输入<code>man ls</code>，它会在最左上角显示“LS（1）”，在这里，“LS”表示手册名称，而“（1）”表示该手册位于第一节章，同样，我们输<code>man ifconfig</code>它会在最左上角显示“IFCONFIG（8）”。也可以这样输入命令：“man [章节号] 手册名称”。</p>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>patch</title>
    <url>/2022/06/26/cmd/patch/</url>
    <content><![CDATA[<p>patch - apply a diff file to an original，安装补丁程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patch [options] [originalfile [patchfile]]</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-b或--backup：备份每一个原始文件；</span><br><span class="line">-B&lt;备份字首字符串&gt;或--prefix=&lt;备份字首字符串&gt;：设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称；</span><br><span class="line">-c或--context：把修补数据解译成关联性的差异；</span><br><span class="line">-d&lt;工作目录&gt;或--directory=&lt;工作目录&gt;：设置工作目录；</span><br><span class="line">-D&lt;标示符号&gt;或--ifdef=&lt;标示符号&gt;：用指定的符号把改变的地方标示出来；</span><br><span class="line">-e或--ed：把修补数据解译成ed指令可用的叙述文件；</span><br><span class="line">-E或--remove-empty-files：若修补过后输出的文件其内容是一片空白，则移除该文件；</span><br><span class="line">-f或--force：此参数的效果和指定&quot;-t&quot;参数类似，但会假设修补数据的版本为新版本；</span><br><span class="line">-F&lt;监别列数&gt;或--fuzz&lt;监别列数&gt;：设置监别列数的最大值；</span><br><span class="line">-g&lt;控制数值&gt;或--get=&lt;控制数值&gt;：设置以RSC或SCCS控制修补作业；</span><br><span class="line">-i&lt;修补文件&gt;或--input=&lt;修补文件&gt;：读取指定的补丁；</span><br><span class="line">-l或--ignore-whitespace：忽略修补数据与输入数据的跳格，空格字符；</span><br><span class="line">-n或--normal：把修补数据解译成一般性的差异；</span><br><span class="line">-N或--forward：忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使 用过；</span><br><span class="line">-o&lt;输出文件&gt;或--output=&lt;输出文件&gt;：设置输出文件的名称，修补过的文件会以该名称存放；</span><br><span class="line">-p&lt;剥离层级&gt;或--strip=&lt;剥离层级&gt;：设置欲剥离几层路径名称；</span><br><span class="line">-f&lt;拒绝文件&gt;或--reject-file=&lt;拒绝文件&gt;：设置保存拒绝修补相关信息的文件名称，预设的文件名称为.rej；</span><br><span class="line">-R或--reverse：假设修补数据是由新旧文件交换位置而产生；</span><br><span class="line">-s或--quiet或--silent：不显示指令执行过程，除非发生错误；</span><br><span class="line">-t或--batch：自动略过错误，不询问任何问题；</span><br><span class="line">-T或--set-time：此参数的效果和指定&quot;-Z&quot;参数类似，但以本地时间为主；</span><br><span class="line">-u或--unified：把修补数据解译成一致化的差异；</span><br><span class="line">-v或--version：显示版本信息；</span><br><span class="line">-V&lt;备份方式&gt;或--version-control=&lt;备份方式&gt;：用&quot;-b&quot;参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用&quot;-z&quot;参数变更，当使用&quot;-V&quot;参数指定不同备份方式时，也会产生不同字尾的备份字符串；</span><br><span class="line">-Y&lt;备份字首字符串&gt;或--basename-prefix=--&lt;备份字首字符串&gt;：设置文件备份时，附加在文件基本名称开头的字首字符串；</span><br><span class="line">-z&lt;备份字尾字符串&gt;或--suffix=&lt;备份字尾字符串&gt;：此参数的效果和指定&quot;-B&quot;参数类似，差别在于修补作业使用的路径与文件名若为src/linux/fs/super.c，加上&quot;backup/&quot;字符串后，文件super.c会备份于/src/linux/fs/backup目录里；</span><br><span class="line">-Z或--set-utc：把修补过的文件更改，存取时间设为UTC；</span><br><span class="line">--backup-if-mismatch：在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件；</span><br><span class="line">--binary：以二进制模式读写数据，而不通过标准输出设备；</span><br><span class="line">--help：在线帮助；</span><br><span class="line">--nobackup-if-mismatch：在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件；</span><br><span class="line">--verbose：详细显示指令的执行过程。</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>原文件：指定需要打补丁的原始文件；</li>
<li>补丁文件：指定补丁文件。</li>
</ul>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>objdump</title>
    <url>/2022/06/26/cmd/objdump/</url>
    <content><![CDATA[<p>objdump 命令是Linux下的反汇编目标文件或者可执行文件的命令，显示二进制文件信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a --archive-headers </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示档案库的成员信息,类似<span class="built_in">ls</span> -l将lib*.a的信息列出。</span> </span><br><span class="line"></span><br><span class="line">-b bfdname --target=bfdname </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定目标码格式。这不是必须的，objdump能自动识别许多格式，比如：</span> </span><br><span class="line"></span><br><span class="line">objdump -b oasys -m vax -h fu.o </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示fu.o的头部摘要信息，明确指出该文件是Vax系统下用Oasys编译器生成的目标文件。objdump -i将给出这里可以指定的目标码格式列表。</span> </span><br><span class="line"></span><br><span class="line">-C --demangle </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得C++函数名以可理解的方式显示出来。</span> </span><br><span class="line">--debugging </span><br><span class="line">-g </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示调试信息。企图解析保存在文件中的调试信息并以C语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持。</span> </span><br><span class="line"></span><br><span class="line">-e --debugging-tags </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">类似-g选项，但是生成的信息是和ctags工具相兼容的格式。</span> </span><br><span class="line">--disassemble </span><br><span class="line">-d </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从objfile中反汇编那些特定指令机器码的section。</span> </span><br><span class="line"></span><br><span class="line">-D --disassemble-all </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">与 -d 类似，但反汇编所有section.</span> </span><br><span class="line"></span><br><span class="line">--prefix-addresses </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反汇编的时候，显示每一行的完整地址。这是一种比较老的反汇编格式。</span> </span><br><span class="line"></span><br><span class="line">-EB </span><br><span class="line">-EL </span><br><span class="line">--endian=&#123;big|little&#125; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定目标文件的小端。这个项将影响反汇编出来的指令。在反汇编的文件没描述小端信息的时候用。例如S-records.</span> </span><br><span class="line"></span><br><span class="line">-f </span><br><span class="line">--file-headers </span><br><span class="line">显示objfile中每个文件的整体头部摘要信息。 </span><br><span class="line"></span><br><span class="line">-h </span><br><span class="line">--section-headers </span><br><span class="line">--headers </span><br><span class="line">显示目标文件各个section的头部摘要信息。 </span><br><span class="line"></span><br><span class="line">-H </span><br><span class="line">--help </span><br><span class="line">简短的帮助信息。 </span><br><span class="line"></span><br><span class="line">-i </span><br><span class="line">--info </span><br><span class="line">显示对于 -b 或者 -m 选项可用的架构和目标格式列表。 </span><br><span class="line"></span><br><span class="line">-j name</span><br><span class="line">--section=name </span><br><span class="line">仅仅显示指定名称为name的section的信息 </span><br><span class="line"></span><br><span class="line">-l</span><br><span class="line">--line-numbers </span><br><span class="line">用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用使用-ld和使用-d的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g之类的调试编译选项。 </span><br><span class="line"></span><br><span class="line">-m machine </span><br><span class="line">--architecture=machine </span><br><span class="line">指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候(比如S-records)，这个选项很有用。可以用-i选项列出这里能够指定的架构. </span><br><span class="line"></span><br><span class="line">--reloc </span><br><span class="line">-r </span><br><span class="line">显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。 </span><br><span class="line"></span><br><span class="line">--dynamic-reloc </span><br><span class="line">-R </span><br><span class="line">显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库。 </span><br><span class="line"></span><br><span class="line">-s </span><br><span class="line">--full-contents </span><br><span class="line">显示指定section的完整内容。默认所有的非空section都会被显示。 </span><br><span class="line"></span><br><span class="line">-S </span><br><span class="line">--source </span><br><span class="line">尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。 </span><br><span class="line"></span><br><span class="line">--show-raw-insn </span><br><span class="line">反汇编的时候，显示每条汇编指令对应的机器码，如不指定--prefix-addresses，这将是缺省选项。 </span><br><span class="line"></span><br><span class="line">--no-show-raw-insn </span><br><span class="line">反汇编时，不显示汇编指令的机器码，如不指定--prefix-addresses，这将是缺省选项。 </span><br><span class="line"></span><br><span class="line">--start-address=address </span><br><span class="line">从指定地址开始显示数据，该选项影响-d、-r和-s选项的输出。 </span><br><span class="line"></span><br><span class="line">--stop-address=address </span><br><span class="line">显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出。 </span><br><span class="line"></span><br><span class="line">-t </span><br><span class="line">--syms </span><br><span class="line">显示文件的符号表入口。类似于nm -s提供的信息 </span><br><span class="line"></span><br><span class="line">-T </span><br><span class="line">--dynamic-syms </span><br><span class="line">显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D|--dynamic 显示的信息。 </span><br><span class="line"></span><br><span class="line">-V </span><br><span class="line">--version </span><br><span class="line">版本信息 </span><br><span class="line"></span><br><span class="line">--all-headers </span><br><span class="line">-x </span><br><span class="line">显示所可用的头信息，包括符号表、重定位入口。-x 等价于-a -f -h -r -t 同时指定。 </span><br><span class="line"></span><br><span class="line">-z </span><br><span class="line">--disassemble-zeroes </span><br><span class="line">一般反汇编输出将省略大块的零，该选项使得这些零块也被反汇编。 </span><br><span class="line"></span><br><span class="line">@file 可以将选项集中到一个文件中，然后使用这个@file选项载入。</span><br></pre></td></tr></table></figure>

<p>常见符号表字段：</p>
<ul>
<li><p>.text：已编译程序的机器代码。</p>
</li>
<li><p>.rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。</p>
</li>
<li><p>.data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。</p>
</li>
<li><p>.bss：未初始化的全局C变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。</p>
</li>
<li><p>.symtab：一个符号表（symbol table），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。</p>
</li>
<li><p>.rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。</p>
</li>
<li><p>.rel.data：被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。</p>
</li>
<li><p>.debug：一个调试符号表，其有些表目是程序中定义的局部变量和类型定义，有些表目是程序中定义和引用的全局变量，有些是原始的C源文件。只有以-g选项调用编译驱动程序时，才会得到这张表。</p>
</li>
<li><p>.line：原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译驱动程序时，才会得到这张表。</p>
</li>
<li><p>.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>route</title>
    <url>/2022/06/26/cmd/route/</url>
    <content><![CDATA[<p>route - show / manipulate the IP routing table，显示并设置静态路由表</p>
<p>可以在<code>/etc/rc.local</code>中添加route命令来保证该路由设置永久有效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route [-CFvnee]</span><br><span class="line"></span><br><span class="line">route  [-v] [-A family] add [-net|-host] target [netmask Nm] [gw Gw] [metric N] [mss M] [window W] [irtt I] [reject] [mod] [dyn] [rein‐state] [[dev] If]</span><br><span class="line"></span><br><span class="line">route  [-v] [-A family] del [-net|-host] target [gw Gw] [netmask Nm] [metric N] [[dev] If]</span><br><span class="line"></span><br><span class="line">route  [-V] [--version] [-h] [--help]</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-A：设置地址类型；</span><br><span class="line">-C：打印将Linux核心的路由缓存；</span><br><span class="line">-v：详细信息模式；</span><br><span class="line">-n：不执行DNS反向查找，直接显示数字形式的IP地址；</span><br><span class="line">-e：netstat格式显示路由表；</span><br><span class="line">-net：到一个网络的路由表；</span><br><span class="line">-host：到一个主机的路由表。</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">add：增加指定的路由记录；</span><br><span class="line">del：删除指定的路由记录；</span><br><span class="line">target：目的网络或目的主机；</span><br><span class="line">gw：设置默认网关；</span><br><span class="line">mss：设置TCP的最大区块长度（MSS），单位MB；</span><br><span class="line">window：指定通过路由表的TCP连接的TCP窗口大小；</span><br><span class="line">dev：路由记录所表示的网络接口。</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> <strong>显示当前路由</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure>

<p>其中Flags为路由标志，标记当前网络节点的状态，Flags标志说明：</p>
<ul>
<li>U Up表示此路由当前为启动状态。</li>
<li>H Host，表示此网关为一主机。</li>
<li>G Gateway，表示此网关为一路由器。</li>
<li>R Reinstate Route，使用动态路由重新初始化的路由。</li>
<li>D Dynamically,此路由是动态性地写入。</li>
<li>M Modified，此路由是由路由守护程序或导向器动态修改。</li>
<li>! 表示此路由当前为关闭状态。</li>
</ul>
<p><strong>添加/设置网关</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route add -net 192.168.1.0 netmask 255.255.255.0 dev eth0</span><br><span class="line">route del -net 192.168.1.0 netmask 255.255.255.0 dev eth0</span><br></pre></td></tr></table></figure>

<p><strong>屏蔽一条路由</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 reject  #增加一条屏蔽的路由，目的地址为224.x.x.x将被拒绝。</span><br></pre></td></tr></table></figure>

<p><strong>删除路由记录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0</span><br><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0 reject</span><br></pre></td></tr></table></figure>

<p><strong>删除/添加默认网关</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route add default gw 192.168.1.2 eth0</span><br><span class="line">route del default gw 192.168.1.2 eth0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>sh</title>
    <url>/2022/06/26/cmd/sh/</url>
    <content><![CDATA[<p><strong>sh</strong> 是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取。通过用户输入命令，和内核进行沟通。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash [options] [file]</span><br><span class="line"></span><br><span class="line">-c string  命令从-c后的字符串读取。</span><br><span class="line">-i  实现脚本交互。</span><br><span class="line">-n  进行shell脚本的语法检查。</span><br><span class="line">-x  跟踪脚本调试shell脚本，能打印出所执行的每一行命令以及当前状态。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2022/06/26/cmd/test/</url>
    <content><![CDATA[<p><strong>test命令</strong> 是shell环境中测试条件表达式的实用工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-b &lt;文件&gt;：如果文件为一个块特殊文件，则为true；</span><br><span class="line">-c &lt;文件&gt;：如果文件为一个字符特殊文件，则为true；</span><br><span class="line">-d &lt;文件&gt;：如果文件为一个目录，则为true；</span><br><span class="line">-e &lt;文件&gt;：如果文件存在，则为true；</span><br><span class="line">-f &lt;文件&gt;：如果文件为一个普通文件，则为true；</span><br><span class="line">-g &lt;文件&gt;：如果设置了文件的SGID位，则为true；</span><br><span class="line">-G &lt;文件&gt;：如果文件存在且归该组所有，则为true；</span><br><span class="line">-k &lt;文件&gt;：如果设置了文件的粘着位，则为true；</span><br><span class="line">-O &lt;文件&gt;：如果文件存在并且归该用户所有，则为true；</span><br><span class="line">-p &lt;文件&gt;：如果文件为一个命名管道，则为true；</span><br><span class="line">-r &lt;文件&gt;：如果文件可读，则为true；</span><br><span class="line">-s &lt;文件&gt;：如果文件的长度不为零，则为true；</span><br><span class="line">-S &lt;文件&gt;：如果文件为一个套接字特殊文件，则为true；</span><br><span class="line">-u &lt;文件&gt;：如果设置了文件的SUID位，则为true；</span><br><span class="line">-w &lt;文件&gt;：如果文件可写，则为true；</span><br><span class="line">-x &lt;文件&gt;：如果文件可执行，则为true。</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>linux中shell编程中的test常见用法：</p>
<p> <strong>判断表达式</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if test     #表达式为真</span><br><span class="line">if test !   #表达式为假</span><br><span class="line">test 表达式1 –a 表达式2     #两个表达式都为真</span><br><span class="line">test 表达式1 –o 表达式2     #两个表达式有一个为真</span><br><span class="line">test 表达式1 ! 表达式2       #条件求反</span><br></pre></td></tr></table></figure>

<p> <strong>判断字符串</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test –n 字符串    #字符串的长度非零</span><br><span class="line">test –z 字符串    #字符串的长度是否为零</span><br><span class="line">test 字符串1＝字符串2       #字符串是否相等，若相等返回true</span><br><span class="line">test 字符串1!＝字符串2      #字符串是否不等，若不等反悔false</span><br></pre></td></tr></table></figure>

<p> <strong>判断整数</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test 整数1 -eq 整数2    #整数相等</span><br><span class="line">test 整数1 -ge 整数2    #整数1大于等于整数2</span><br><span class="line">test 整数1 -gt 整数2    #整数1大于整数2</span><br><span class="line">test 整数1 -le 整数2    #整数1小于等于整数2</span><br><span class="line">test 整数1 -lt 整数2    #整数1小于整数2</span><br><span class="line">test 整数1 -ne 整数2    #整数1不等于整数2</span><br></pre></td></tr></table></figure>

<p> <strong>判断文件</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test File1 –ef File2    两个文件是否为同一个文件，可用于硬连接。主要判断两个文件是否指向同一个inode。</span><br><span class="line">test File1 –nt File2    判断文件1是否比文件2新</span><br><span class="line">test File1 –ot File2    判断文件1比是否文件2旧</span><br><span class="line">test –b file   #文件是否块设备文件</span><br><span class="line">test –c File   #文件并且是字符设备文件</span><br><span class="line">test –d File   #文件并且是目录</span><br><span class="line">test –e File   #文件是否存在 （常用）</span><br><span class="line">test –f File   #文件是否为正规文件 （常用）</span><br><span class="line">test –g File   #文件是否是设置了组id</span><br><span class="line">test –G File   #文件属于的有效组ID</span><br><span class="line">test –h File   #文件是否是一个符号链接（同-L）</span><br><span class="line">test –k File   #文件是否设置了Sticky bit位</span><br><span class="line">test –b File   #文件存在并且是块设备文件</span><br><span class="line">test –L File   #文件是否是一个符号链接（同-h）</span><br><span class="line">test –o File   #文件的属于有效用户ID</span><br><span class="line">test –p File   #文件是一个命名管道</span><br><span class="line">test –r File   #文件是否可读</span><br><span class="line">test –s File   #文件是否是非空白文件</span><br><span class="line">test –t FD     #文件描述符是在一个终端打开的</span><br><span class="line">test –u File   #文件存在并且设置了它的set-user-id位</span><br><span class="line">test –w File   #文件是否存在并可写</span><br><span class="line">test –x File   #文件属否存在并可执行</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>watch</title>
    <url>/2022/06/26/cmd/watch/</url>
    <content><![CDATA[<p>watch - execute a program periodically, showing output fullscreen，以周期性的方式执行给定的指令，指令输出以全屏方式显示。</p>
<p>watch可以帮你监测一个命令的运行结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch [options] command</span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-n # 或--interval  watch缺省每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。</span><br><span class="line">-d # 或--differences  用-d或--differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。</span><br><span class="line">-t # 或-no-title  会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。</span><br><span class="line">-h, --help # 查看帮助文档</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch -n 1 -d netstat -ant       # 命令：每隔一秒高亮显示网络链接数的变化情况</span><br><span class="line">watch -n 1 -d &#x27;pstree|grep http&#x27; # 每隔一秒高亮显示http链接数的变化情况。 后面接的命令若带有管道符，需要加&#x27;&#x27;将命令区域归整。</span><br><span class="line">watch &#x27;netstat -an | grep:21 | \ grep&lt;模拟攻击客户机的IP&gt;| wc -l&#x27; # 实时查看模拟攻击客户机建立起来的连接数</span><br><span class="line">watch -d &#x27;ls -l|grep scf&#x27;       # 监测当前目录中 scf&#x27; 的文件的变化</span><br><span class="line">watch -n 10 &#x27;cat /proc/loadavg&#x27; # 10秒一次输出系统的平均负载</span><br><span class="line">watch uptime</span><br><span class="line">watch -t uptime</span><br><span class="line">watch -d -n 1 netstat -ntlp</span><br><span class="line">watch -d &#x27;ls -l | fgrep goface&#x27;     # 监测goface的文件</span><br><span class="line">watch -t -differences=cumulative uptime</span><br><span class="line">watch -n 60 from            # 监控mail</span><br><span class="line">watch -n 1 &quot;df -i;df&quot;       # 监测磁盘inode和block数目变化情况</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>time</title>
    <url>/2022/06/26/cmd/time/</url>
    <content><![CDATA[<p>time - run programs and summarize system resource usage</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">time   [ -apqvV ] [ -f FORMAT ] [ -o FILE ]</span><br><span class="line">        [ --append ] [ --verbose ] [ --quiet ] [ --portability ]</span><br><span class="line">        [ --format=FORMAT ] [ --output=FILE ] [ --version ]</span><br><span class="line">        [ --help ] COMMAND [ ARGS ]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>real时间</code>是指挂钟时间，也就是命令开始执行到结束的时间。这个短时间包括其他进程所占用的时间片，和进程被阻塞时所花费的时间。</li>
<li><code>user时间</code>是指进程花费在用户模式中的CPU时间，这是唯一真正用于执行进程所花费的时间，其他进程和花费阻塞状态中的时间没有计算在内。</li>
<li><code>sys时间</code>是指花费在内核模式中的CPU时间，代表在内核中执系统调用所花费的时间，这也是真正由进程使用的CPU时间。</li>
</ul>
<p>shell内置也有一个time命令，当运行time时候是调用的shell内建命令，其功能有限，所以需要其他功能要执行<code>/usr/bin/time</code>。</p>
<p>使用<code>-o选项</code>将执行时间写入到文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/time -o outfile.txt ls</span><br></pre></td></tr></table></figure>

<p>使用<code>-a选项</code>追加信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/time -a -o outfile.txt ls</span><br></pre></td></tr></table></figure>

<p>使用<code>-f选项</code>格式化时间输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/time -f &quot;time: %U&quot; ls</span><br></pre></td></tr></table></figure>

<p>-f选项后的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%E</td>
<td>real时间，显示格式为[小时:]分钟:秒</td>
</tr>
<tr>
<td>%U</td>
<td>user时间。</td>
</tr>
<tr>
<td>%S</td>
<td>sys时间。</td>
</tr>
<tr>
<td>%C</td>
<td>进行计时的命令名称和命令行参数。</td>
</tr>
<tr>
<td>%D</td>
<td>进程非共享数据区域，以KB为单位。</td>
</tr>
<tr>
<td>%x</td>
<td>命令退出状态。</td>
</tr>
<tr>
<td>%k</td>
<td>进程接收到的信号数量。</td>
</tr>
<tr>
<td>%W</td>
<td>进程被交换出主存的次数。</td>
</tr>
<tr>
<td>%Z</td>
<td>系统的页面大小，不用系统值不同</td>
</tr>
<tr>
<td>%P</td>
<td>进程所获取的CPU时间百分百，这个值等于user+system时间除以总共的运行时间</td>
</tr>
<tr>
<td>%K</td>
<td>进程的平均总内存使用量（data+stack+text），单位是KB</td>
</tr>
<tr>
<td>%w</td>
<td>进程主动进行上下文切换的次数，例如等待I/O操作完成</td>
</tr>
<tr>
<td>%c</td>
<td>进程被迫进行上下文切换的次数（由于时间片到期）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>代码检视思维导图</title>
    <url>/2022/06/07/code/code-review/</url>
    <content><![CDATA[<p><img src="/images/code/%E4%BB%A3%E7%A0%81%E6%A3%80%E8%A7%86.png" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>wc</title>
    <url>/2022/06/26/cmd/wc/</url>
    <content><![CDATA[<p>wc命令统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。wc同时也给出所指定文件的总统计数。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc(选项)(参数)</span><br><span class="line">wc [选项]... [文件]...</span><br><span class="line">wc [选项]... --files0-from=F</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c # 统计字节数，或--bytes或——chars：只显示Bytes数；。</span><br><span class="line">-l # 统计行数，或——lines：只显示列数；。</span><br><span class="line">-m # 统计字符数。这个标志不能与 -c 标志一起使用。</span><br><span class="line">-w # 统计字数，或——words：只显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。</span><br><span class="line">-L # 打印最长行的长度。</span><br><span class="line">-help     # 显示帮助信息</span><br><span class="line">--version # 显示版本信息</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title>开源库编译</title>
    <url>/2022/06/07/code/opensource/</url>
    <content><![CDATA[<h2 id="lrzsz"><a href="#lrzsz" class="headerlink" title="lrzsz"></a>lrzsz</h2><p>Lrzsz是一款在linux里可代替ftp上传和下载的程序，提供 XMODEM，YMODEM ZMODEM文件传输协议的unix通信包 。只要输入一行简单的命令，就可以上传下载文件，无需打开 ftp 或者其他服务器文件管理软件。下载地址：<a href="https://ohse.de/uwe/software/lrzsz.html">https://ohse.de/uwe/software/lrzsz.html</a></p>
<ol>
<li>修改<code>arm-linux.cache</code>，（可省略）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ac_cv_prog_CC=$&#123;ac_cv_prog_CC=&#x27;arm-linux-gcc&#x27;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>若没有cache file，则直接编译，CC参数放在configure前面。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CC=/opt/arm-anykav200-crosstool/usr/bin/arm-anykav200-linux-uclibcgnueabi-gcc ./configure --prefix=/home/luoyou/home/arm/`</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>打开SecureCRT软件 -&gt; Options -&gt; session options -&gt; X/Y/Zmodem 下可以设置上传和下载的目录</p>
<h2 id="libnl"><a href="#libnl" class="headerlink" title="libnl"></a>libnl</h2><p>下载地址：<a href="http://www.infradead.org/~tgr/libnl/">http://www.infradead.org/~tgr/libnl/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/home/luo_u/usr/hisi/libnl-3.4.0/ --host=arm-himix100-linux</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><p>下载地址：<a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./config no-asm shared no-async --prefix=/home/luo_u/usr/hisi/openssl-1.1.1 --cross-compile-prefix=arm-himix100-linux-</span><br></pre></td></tr></table></figure>

<p>将生成的Makefile中将-m64选项全部删除掉，因为平台是在32位的系统上使用，如果是64位跳过这一步骤。</p>
<blockquote>
<p>sed -i “s/-m64//g” Makefile</p>
</blockquote>
<h2 id="expat"><a href="#expat" class="headerlink" title="expat"></a>expat</h2><p>下载地址：<a href="https://libexpat.github.io/">https://libexpat.github.io/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/home/luo_u/usr/hisi/expat-2.2.9 --host=arm-himix100-linux\</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="dbus"><a href="#dbus" class="headerlink" title="dbus"></a>dbus</h2><p>下载地址：<a href="https://dbus.freedesktop.org/releases/dbus/">https://dbus.freedesktop.org/releases/dbus/</a></p>
<p>依赖expat库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/home/luo_u/usr/anyka/dbus-1.12.10/ --host=arm-anykav200-linux CFLAGS=-I/home/luo_u/usr/anyka/expat-2.2.9/include LDFLAGS=-L/home/luo_u/usr/anyka/expat-2.2.9/lib CC=arm-anykav200-linux-uclibcgnueabi-gcc</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="UPX"><a href="#UPX" class="headerlink" title="UPX"></a>UPX</h2><p>下载地址：<a href="https://github.com/upx/upx.git">https://github.com/upx/upx.git</a></p>
<h2 id="liblzo"><a href="#liblzo" class="headerlink" title="liblzo"></a>liblzo</h2><p>下载地址：<a href="http://www.linuxfromscratch.org/blfs/view/svn/general/lzo.html">http://www.linuxfromscratch.org/blfs/view/svn/general/lzo.html</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure -prefix=/home/luoyou/home/usr/x86_64/lzo-2.10 --enable-shared --disable-static</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h2><p><a href="https://libevent.org/">https://libevent.org/</a></p>
<h2 id="libncurses"><a href="#libncurses" class="headerlink" title="libncurses"></a>libncurses</h2><p><a href="http://ftp.gnu.org/pub/gnu/ncurses/">http://ftp.gnu.org/pub/gnu/ncurses/</a></p>
<p>libncurses库用来在显示器上显示文本界面。典型例子就是Linux内核的make menuconfig配置界面。libform库用于 在ncurses中使用表格。libmenu库用于在ncurses中使用菜单。libpanel库用于在ncurses中使用面板。</p>
<h2 id="libmodbus"><a href="#libmodbus" class="headerlink" title="libmodbus"></a>libmodbus</h2><p><a href="https://www.libmodbus.org/">https://www.libmodbus.org/</a></p>
]]></content>
  </entry>
  <entry>
    <title>开源协议</title>
    <url>/2022/06/08/code/opensource-license/</url>
    <content><![CDATA[<h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><p><img src="/images/code/opensource.png" alt="img"></p>
<p><strong>BSD</strong></p>
<p>BSD（original BSD license、FreeBSD license、Original BSD license）是”Berkeley Software Distribution”的缩写，意思是”伯克利软件发行版”。BSD协议给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p>
<ol>
<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li>
<li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li>
<li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li>
</ol>
<p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。公司企业在选用开源产品时都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>
<p><strong>Apache License</strong></p>
<p>Apache License（Apache License, Version 2.0、Apache License, Version 1.1、Apache License, Version 1.0），是Apache软件基金会发布的一个自由软件许可证。</p>
<p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件：</p>
<ol>
<li>需要给代码的用户一份Apache Licence。</li>
<li>如果修改了代码，需要再被修改的文件中说明。</li>
<li>在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li>
<li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。</li>
</ol>
<p>Apache Licence也是对商业应用友好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。使用这个协议的好处是:</p>
<ul>
<li>永久权利 一旦被授权，永久拥有。</li>
<li>全球范围的权利 在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li>
<li>授权免费 无版税， 前期、后期均无任何费用。</li>
<li>授权无排他性 任何人都可以获得授权</li>
<li>授权不可撤消 一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码</li>
</ul>
<p><strong>GPL</strong></p>
<p>GPL（GNU General Public License）：GNU通用公共许可协议。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售，这就是所谓的传染性。</p>
<p><strong>LGPL</strong></p>
<p>LGPL（GNU Lesser General Public License）是GPL的一个为主要为类库使用设计的开源协议。和GPL协议不同，LGPL允许商业软件通过类库链接方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p>
<p><strong>MIT</strong></p>
<p>MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p>
<p><strong>MPL</strong></p>
<p>MPL(Mozilla Public License 1.1)协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。</p>
<p><strong>EPL</strong></p>
<p>EPL(Eclipse Public License 1.0)允许Recipients任意使用、复制、分发、传播、展示、修改以及改后闭源的二次商业发布。使用EPL协议，需要遵守以下规则：</p>
<ol>
<li>当一个Contributors将源码的整体或部分再次开源发布的时候,必须继续遵循EPL开源协议来发布,而不能改用其他协议发布.除非你得到了原”源码”Owner 的授权；</li>
<li>EPL协议下,你可以将源码不做任何修改来商业发布.但如果你要发布修改后的源码,或者当你再发布的是Object Code的时候,你必须声明它的Source Code是可以获取的,而且要告知获取方法；</li>
<li>当你需要将EPL下的源码作为一部分跟其他私有的源码混和着成为一个Project发布的时候,你可以将整个Project/Product以私人的协议发布,但要声明哪一部分代码是EPL下的,而且声明那部分代码继续遵循EPL；</li>
<li>独立的模块(Separate Module),不需要开源。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>C++ atomic</title>
    <url>/2022/06/11/cpp/atomic/</url>
    <content><![CDATA[<h2 id="atomic-flag"><a href="#atomic-flag" class="headerlink" title="atomic_flag"></a>atomic_flag</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">atomic_flag</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">atomic_flag</span> (<span class="type">const</span> atomic_flag&amp;T) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p><code>std::atomic_flag</code> 只有默认构造函数，拷贝构造函数已被禁用。如果创建时没有初始化，那么对象的状态是未指定的，初始化时应该赋值为<code>ATOMIC_FLAG_INIT</code>，保证该对象在创建时处于 clear 状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::atomic_flag flag = ATOMIC_FLAG_INIT;</span><br></pre></td></tr></table></figure>

<p><code>test_and_set()</code> 函数检查 <code>atomic_flag</code> 标志，如果之前没有被设置过，则设置 <code>atomic_flag</code> 的标志，并返回先前该对象是否被设置过，如果之前对象已被设置，则返回 true，否则返回 false。</p>
<h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p> <code>std::atomic</code> 提供了针对整形和指针类型的特化实现，分别定义如下：</p>
<p><code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short</code>, <code>unsigned short</code>, <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code>, <code>unsigned long long</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11特性</title>
    <url>/2022/06/07/cpp/c++11/</url>
    <content><![CDATA[<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>当大范围的变量来初始化小范围变量时，可能会有缩窄转换的风险，列表初始化将初始化的变<br>量或值放在大括号{}内，可以禁止缩窄转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> largeNum = <span class="number">5000000</span>;</span><br><span class="line"><span class="type">short</span> num1&#123; largeNum &#125;; <span class="comment">// warning: narrowing conversion of ‘largeNum’ from ‘int’ to ‘short int’ inside &#123; &#125; [-Wnarrowing]</span></span><br><span class="line"><span class="type">int</span> num2&#123; largeNum &#125;;   <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>c++11引入<code>auto</code>类型说明符，能让编译器自动表达式所属的类型。当引用被当作初始値时，以引用对象的类型作为auto的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, sizeof(a) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> b = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> c = b;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;, sizeof(c) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(c) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>a = 1, sizeof(a) = 1<br>c = 100, sizeof(c) = 8</p>
</blockquote>
<p>C++14可以用auto作为函数的返回类型。</p>
<h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p>常量表达式是指不会改变并且在编译过程就能得到结果的表达式。constexpr变量必须在编译时初始化，而const变量的初始化可以延迟到运行时，只保证运行时不被修改。</p>
<p>constexpr函数限制：</p>
<ol>
<li>函数必须有返回値，参数是常量表达式。</li>
<li>函数体只能有一条语句，且该语句必须是return语句，但允许包含static_assert、using、typedef等不产生实际代码语句，还可以使用递归（利用三元运算符实现）。</li>
<li>只能调用constexpr函数。</li>
<li>只能使用全局constexpr变量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">GetPi</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">22.0</span> / <span class="number">7</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数要求：</p>
<ol>
<li>只能通过初始化列表来初始化成员变量，函数体必须为空。</li>
<li>初始化列表只能由常量表达式来赋值。</li>
</ol>
<p>常量成员函数要求：</p>
<ol>
<li>不能修改成员变量，因为其被隐式定义为const成员函数。</li>
<li>不能是virtual函数。</li>
</ol>
<h2 id="范围for循环"><a href="#范围for循环" class="headerlink" title="范围for循环"></a>范围for循环</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : array) &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>可使用限定符 override 来核实被覆盖的函数在基类中是否被声明为virtual。让程序员能够明确地表达对基类的虚函数进行覆盖的<br>意图，进而让编译器做如下检查:<br>• 基类函数是否是虚函数。<br>• 基类中相应虚函数的特征标是否与派生类中被声明为 override 的函数完全相同。</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>声明为 final 的类不能用作基类，从而禁止继承。被声明为 final 的虚函数，不能在派生类中进行覆盖。</p>
<h2 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert"></a>static_assert</h2><p>static_assert是编译期间断言，不生成目标代码，因此不会造成任何运行期性能损失。</p>
<blockquote>
<p>static_assert(常量表达式，”提示字符串”)</p>
</blockquote>
<p>因为是编译期的检查，这里的表达式必须是常量表达式，也就是能够在编译时计算出来的值。错误字符串也必须是字面量，不能是字符串变量。表达式计算结果为false时，编译器就会报出错误，并显示错误字符串的信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">void</span>*) == <span class="number">8</span>, <span class="string">&quot;only 64bit is supported.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>static_assert的实现原理是利用switch的各个case表达式不能相等的机制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> static_assert(a, b) \</span></span><br><span class="line"><span class="meta">    do &#123; switch (0) case 0: case (a): ;&#125; while(0)</span></span><br></pre></td></tr></table></figure>

<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>tuple(元组)是泛化的std::pair，将多个值组合成一个值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">tuple&lt;<span class="type">int</span>, string&gt; <span class="title">t1</span><span class="params">(<span class="number">3</span>, <span class="string">&quot;aaa&quot;</span>)</span></span>;</span><br><span class="line">    tuple&lt;<span class="type">int</span>, string&gt; t2 = <span class="built_in">make_pair</span>(<span class="number">6</span>, <span class="string">&quot;nnn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="built_in">tie</span>(num, name) = t1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t2) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  &#123;dividend / divisor, dividend % divisor&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> [quotient, remainder] = <span class="built_in">divide</span>(<span class="number">12</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>用<code>mutable</code>修饰的类成员称为可变数据成员，意思是这个成员不算对象内部状态，在任何函数(包括const函数)都能修改它的値。mutable不能修饰静态数据成员，因为它不属于类对象，不用修饰也可以任意修改。</p>
<h2 id="右値引用"><a href="#右値引用" class="headerlink" title="右値引用"></a>右値引用</h2><p>在赋值号左边的表达式称为<strong>左値</strong>，所有非const变量和对象，会在内存分配空间的都是左値，是可以取地址的。不能出现赋值号左边的表达式称为<strong>右値</strong>，非引用返回的或运算表达式产生的临时变量、常量、原始字面量和lambda表达式等都是右値，。</p>
<p>右值引用就是必须绑定到右值的引用，可实现转移语义，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。可以通过右値引用来延长临时变量的生命周期。定义右値引用的格式如下：</p>
<blockquote>
<p>类型 &amp;&amp;引用名 = 右值表达式;</p>
</blockquote>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a>std::move()</h2><p>move函数将一个左値强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义，等同于一个类型转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span>&gt; remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数参数T&amp;&amp;是一个指向模板类型参数的右值引用，通过引用折叠，此参数左值引用和右值引用都可以绑定，称为万能引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">vector&lt;string&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(str);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">move</span>(str));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;move...&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; endl;  <span class="comment">// str = &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="forward"><a href="#forward" class="headerlink" title="forward()"></a>forward()</h2><p>forward函数用于完美转发，能按参数原来的类型转发到另一个函数中，如果输入参数是左値，那么传递给下一个函数的参数也是左值，反之是右値。</p>
<h2 id="enable-shared-from-this"><a href="#enable-shared-from-this" class="headerlink" title="enable_shared_from_this"></a>enable_shared_from_this</h2><p>通过继承enable_shared_from_this类，然后调用继承过来的shared_from_this()方法，就能返回一个当前类的share_ptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;Test&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Test&gt; <span class="title">getSharedFromThis</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++14特性</title>
    <url>/2022/06/07/cpp/c++14/</url>
    <content><![CDATA[<h2 id="组块分隔符"><a href="#组块分隔符" class="headerlink" title="组块分隔符"></a>组块分隔符</h2><p>组块分隔符(chunking separator)用单引号表示，提高代码的可读性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.141&#x27;592&#x27;653&#x27;59</span>;</span><br></pre></td></tr></table></figure>

<h2 id="二进制字面量"><a href="#二进制字面量" class="headerlink" title="二进制字面量"></a>二进制字面量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0b1010</span>; <span class="comment">// binary 1010 = decimal 10</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++98</title>
    <url>/2022/07/14/cpp/c++98/</url>
    <content><![CDATA[<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>名称空间是给代码限定使用空间，有助于降低命名冲突的风险。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">using <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">using <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><p>由于c语言和C++的符号修饰方式不同，函数用extern “C”声明，告诉编译器对此函数使用c语言的方式来处理，则此函数的符号就是按c语言方式生成的，可以避免 C++ 因符号修饰导致代码不能和c语言库中的符号进行链接的问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>在定义函数时给参数一个缺省値，在使用函数时，如果函数调用时没有传递参数，就使用默认参数。</p>
<ol>
<li>如果某个参数是默认参数，那么它后面的参数必须都是默认参数。</li>
<li>默认参数只能放到函数声明或定义两者之一，如果放在函数定义中，那就只能在当前文件中调用该函数。</li>
<li>在多态中，重载的函数不要使用默认参数，因为默认参数是静态绑定，虚函数是动态绑定。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNum</span><span class="params">(<span class="type">int</span> n = <span class="number">4</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用只能绑定对象，不能是字面值。引用的类型要和初始化的类型一致。</p>
<p>引用与指针的区别：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<p>引用作为函数返回值时，不能返回局部数据的引用，因为当函数调用完成后局部数据就会被销毁，C++ 编译器检测到该行为时也会给出警告。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">//分配1个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">//释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">//分配10个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// placement new</span></span><br><span class="line">p2 = <span class="built_in">new</span>(p) <span class="built_in">int</span>();  <span class="comment">// 在p所指向的内存分配一个int对象</span></span><br></pre></td></tr></table></figure>

<p>new和delete不是库函数，而是 c++的运算符。new 是在堆区分配内存，必须手动释放。为了避免内存泄露，new 和 delete、new[] 和 delete[] 操作符应该配对使用。new和delete会自动调用构造函数和析构函数。</p>
<p>使用 new 在堆上生成对象，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 运算符重载为私有，那么第一阶段就无法完成，也就不能够在堆上构造对象了。</p>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p><strong>typeid</strong></p>
<p>typeid 运算符返回一个表达式的类型信息。对于基本数据类型，类型信息指数据的类型。对于类类型的数据，类型信息是指对象所属的类、所包含的成员、所在的继承关系等。经常被用来判断两个类型是否相等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">typeid</span>(ClassA) == <span class="built_in">typeid</span>(object)</span><br></pre></td></tr></table></figure>

<p>typeid 会把获取到的类型信息保存到一个 type_info 类型的对象里面，并返回该对象的常引用，当需要具体的类型信息时，可以通过成员函数来提取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">type_info</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">type_info</span>();</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>==(<span class="type">const</span> type_info&amp; rhs) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>!=(<span class="type">const</span> type_info&amp; rhs) <span class="type">const</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">before</span><span class="params">(<span class="type">const</span> type_info&amp; rhs)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">raw_name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> *_m_data;</span><br><span class="line">    <span class="type">char</span> _m_d_name[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">type_info</span>(<span class="type">const</span> type_info&amp; rhs);</span><br><span class="line">    type_info&amp; <span class="keyword">operator</span>=(<span class="type">const</span> type_info&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了减小编译后文件的体积，编译器不会为所有的类型创建 type_info 对象，一个类型不管使用了多少次，编译器都只为它创建一个type_info 对象，所有 typeid 都返回这个对象的引用。不过有一种特殊情况，就是带虚函数的类（包括继承来的），不管有没有使用 typeid 运算符，编译器都会为带虚函数的类创建 type_info 对象。</p>
<p><strong>decltype</strong></p>
<p>decltype()返回操作数的数据类型。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li><code>const_cast</code>  去掉表达式的const或volatile属性</li>
<li><code>static_cast</code>  基本类型静态显式转换</li>
<li><code>dynamic_cast</code>  多态类之间转换，运行时检查类型安全，转换失败返回NULL，使用时需要检查返回値。</li>
<li><code>reinterpret_cast</code>  将任何指针转换为任何其他指针类型，对二进制重新解释类型，比如指针转整型，取地址値。</li>
</ul>
<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>RAII(Resource Acquisition Is Initialization)是 C++ 所特有的资源管理方式。RAII 依托栈和析构函数，来对所有的资源，包括堆内存在内进行管理。有了RAII使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。</p>
<p>内存管理器的操作：</p>
<ol>
<li>让内存管理器分配一个某个大小的内存块</li>
<li>让内存管理器释放一个之前分配的内存块让内存管理器进行垃圾收集操作，</li>
<li>寻找不再使用的内存块并予以释放</li>
</ol>
<p>C++ 通常会做上面的操作 1 和 2。Java 会做上面的操作 1 和 3。而 Python 会做上面的操作 1、2、3。这是语言的特性和实现方式决定的。</p>
<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p>bitset是用于处理位标志的类，它提供了一些位操作的函数和运算符。</p>
<table>
<thead>
<tr>
<th align="center">运算符/函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;&lt;</td>
<td>将位序列的文本表示插入到输出流中</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td>将一个字符串插入到 bitset 对象中</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td align="center">|</td>
<td>按位或</td>
</tr>
<tr>
<td align="center">^</td>
<td>按位异或</td>
</tr>
<tr>
<td align="center">~</td>
<td>按位取反</td>
</tr>
<tr>
<td align="center">&gt;&gt;=</td>
<td>按位右移</td>
</tr>
<tr>
<td align="center">&lt;&lt;=</td>
<td>按位左移</td>
</tr>
<tr>
<td align="center">[N]</td>
<td>返回指向位序列中第N位的引用</td>
</tr>
<tr>
<td align="center">set()</td>
<td>所有位都设置为 1</td>
</tr>
<tr>
<td align="center">set (N, val=1)</td>
<td>将第 N 位设置为 val 指定的值(默认为 1)</td>
</tr>
<tr>
<td align="center">reset()</td>
<td>所有位都重置为 0</td>
</tr>
<tr>
<td align="center">reset (N)</td>
<td>将N位清除</td>
</tr>
<tr>
<td align="center">filp()</td>
<td>将位序列中的所有位取反</td>
</tr>
<tr>
<td align="center">size()</td>
<td>返回序列中的位数</td>
</tr>
<tr>
<td align="center">count()</td>
<td>返回序列中值为 1 的位数</td>
</tr>
</tbody></table>
<h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><p>restrict是c99标准引入的，它用于限定和约束指针，表明指针是访问一个数据对象的唯一且初始的方式，而不能通过其它指针来修改，这样可以帮助编译器会优化代码。restrict修饰的指针主要用于函数形参，说明指针参数不指向同一数据，或指向由malloc()分配的内存空间。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>用register声明的变量是寄存器变量存放在CPU的寄存器里的。运算速度快，因为不是存放在内存，所以不能取地址。只能用于局部变量和函数形参。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改，告诉编译器不应对这样的对象进行优化。volatile 关键字声明的变量，每次访问时都必须从内存中取出值。没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值<br>const 可以是 volatile（只读的状态寄存器）；指针可以是 volatile（指向一段内存地址）。</p>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>在c++中结构体中的成员默认都是 public 属性，默认是 public 继承，且不能使用模块。</p>
<h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值，当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是static的</li>
</ul>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>内联函数在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</p>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p><code>explicit</code>关键字用于修饰类的单参数构造函数，限定此构造函数只能显示初始化当前类，防止其它类对象通过隐式转换作为参数传入。无参构造函数和多参构造函数本身就是显示调用，加了没意义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">//  People(int num) &#123;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">People</span><span class="params">(<span class="type">int</span> name)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    People a1 = <span class="built_in">People</span>(<span class="number">1</span>);</span><br><span class="line">    People a2 = <span class="number">2</span>; <span class="comment">// 没有报错，正常应该 error: conversion from ‘int’ to non-scalar type ‘People</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>pair将一对值(T1和T2)组合成一个值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">3</span>, <span class="string">&quot;aaa&quot;</span>)</span></span>;</span><br><span class="line">    pair&lt;<span class="type">int</span>, string&gt; p2 = <span class="built_in">make_pair</span>(<span class="number">6</span>, <span class="string">&quot;nnn&quot;</span>);</span><br><span class="line">    pair&lt;<span class="type">int</span>, string&gt; p3;</span><br><span class="line"></span><br><span class="line">    p3.first = <span class="number">8</span>;</span><br><span class="line">    p3.second = <span class="string">&quot;rrr&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="built_in">tie</span>(num, name) = p1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h2><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>函数模板里调用另一个函数模板时，最外层的函数模板参数通常是万能引用，传递一个右值到外层，再转给内层时参数变成了左值，原参数属性丢失了。</p>
<p><strong>引用折叠</strong></p>
<ul>
<li>引用的引用折叠成左值引用(<code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 折叠成 <code>X&amp;</code>)</li>
<li>右值引用的右值引用，折叠成右值引用(<code>X&amp;&amp; &amp;&amp;</code> 折叠成 <code>X&amp;&amp;</code>)</li>
</ul>
<p><strong>万能引用</strong></p>
<p>即可以绑定到左值引用，也可以绑定到右值引用，并且不能保持左右值的const属性的函数模板参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(T&amp;&amp; v)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="std-ref"><a href="#std-ref" class="headerlink" title="std::ref"></a>std::ref</h2><p>可以在模板传参时传入引用，对于std::bind 或 std::thread，可以显式通过std::ref来绑定引用进行传参。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ class and object</title>
    <url>/2022/06/07/cpp/class/</url>
    <content><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>公有（public）成员在程序中类的外部是可访问的。</p>
<p>私有（private）成员变量或函数在类的外部是不可访问的。只有类和友元函数可以访问私有成员。<strong>默认属性</strong>。</p>
<p>保护（protected）成员变量或函数与私有成员相似，但在派生类中是可访问的。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">classname</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 new 分配内存时会调用构造函数，构造函数可用于为某些成员变量设置初始值。</p>
<p>构造函数是允许重载的，一个类可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪一个构造函数。如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的函数体是空的，也没有形参，也不执行任何操作。</p>
<p>构造函数不能是虚函数，因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针。</p>
<p><strong>初始化列表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassName</span>(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> score): <span class="built_in">m_age</span>(age), <span class="built_in">m_name</span>(name), <span class="built_in">m_score</span>(score) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">等价于：</span><br><span class="line"><span class="built_in">ClassName</span>(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> score) &#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">    m_age = age;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化列表只能在构造函数中使用，成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。类里面的 const 成员变量只能使用初始化列表来初始化。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在类名前面加一个<code>~</code>符号，它不会返回任何值，也不能带有任何参数。析构函数有助于在退出程序前释放资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">classname</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 delete 释放内存时会调用析构函数。编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。将析构函数声明为私有，则可以禁止在栈中实例化的类。</p>
<p>基类通过多态调用时，派生类的析构函数并不会被调用，这会导致资源未释放、内存泄露等问题，可将基类的析构函数声明为虚函数。</p>
<h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>赋值运算符是将一个对象来初始化已经存在的对象，而拷贝构造函数是将一个对象的値来初始化新创建的对象，会发生在以下场合：</p>
<ul>
<li>用另一个同类型的对象来初始化新对象。</li>
<li>对象作为函数参数，以値方式传入。</li>
<li>对象作为函数返回値，以値方式返回。</li>
</ul>
<p>拷贝构造必须以引的的方式传递参数，是因为値传递会调用拷贝构造函数生成函数实参，如果仍然以値方式传入，就会无限循环调用下去，直到函数栈溢出。当类里有指针或引用数据成员时，应注意浅拷贝影响。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        name_ = p.name;</span><br><span class="line">        ptr_ = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">        <span class="built_in">memcpy</span>(ptr_, p.ptr, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        name_ = p.name;</span><br><span class="line">        ptr_ = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">        <span class="built_in">memcpy</span>(ptr_, p.ptr, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name_;</span><br><span class="line">    <span class="type">int</span> *ptr_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类如果没有定义构造函数，编译器会自动生成一个拷贝构造函数和赋值运算符，如果类带有指针变量，就对其动态内存分配。可以使用<code>delete</code>来指定不生成，使对象不能通过值传递和进行赋值运算。</p>
<p>编译器返回値优化将会把临时对象优化掉，设置编译选项<code>-fno-elide-constructors</code>可以关闭返回値优化效果。</p>
<p><strong>浅拷贝与深拷贝</strong></p>
<p>当把一个对象赋值给一个变量时，赋的是该对象在栈中的地址，而不是堆中的数据，结果是这两个对象指向同一个存储空间。</p>
<p><strong>浅拷贝</strong>：重新在堆上创建内存，拷贝前后对象的基本数据类型互不影响，但对指针和引用类型，其拷贝的是内存地址，当其中的一个对象析构了那个地址，另外一个也会销毁，这里再使用就会发现错误。</p>
<p><strong>深拷贝</strong>：开辟一个新区域存放对象，对对象中的全部成员进行递归拷贝，拷贝前后的两个对象互不影响。</p>
<h3 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h3><p>移动构造函数和移动赋值运算符可以将一个对象的成员转移到另一个对象，它只是将资源从源头移到目的地，而没有进行复制，对于指针成员被转移后，原对象中的指针成员要置NULL，防止其再被使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;&amp;p) &#123;</span><br><span class="line">        name_ = p.name;</span><br><span class="line">        ptr_ = p.ptr;</span><br><span class="line">        p.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Person &amp;&amp;p) &#123;</span><br><span class="line">        name_ = p.name;</span><br><span class="line">        ptr_ = p.ptr;</span><br><span class="line">        p.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name_;</span><br><span class="line">    <span class="type">int</span> *ptr_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p><strong>友元类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Other</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>友元类Other的所有方法都能访问Base类的私有数据成员和方法。</p>
<p><strong>友元函数</strong></p>
<p>友元函数是定义在类外部，但有权访问类的所有私有成员和保护成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数，在友元函数中不能直接访问类的成员，必须借助参数传入对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">getNum</span><span class="params">(Base obj)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNum</span><span class="params">(Base obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> obj.num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p><strong>静态成员变量</strong></p>
<p>使用 <code>static</code>关键字来把类成员定义为静态的。static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，静态成员都只有一个副本。在创建第一个对象时，默认所有的静态数据都会被初始化为零。</p>
<p>static 成员变量只能在类定义中声明，不能进行初始化，其内存既不是在声明类时分配，也不是在创建对象时分配，而是在类的外部初始化时分配。因此没有在类外初始化的 static 成员变量不能使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::num = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>static 成员变量不占用对象的内存，而是在对象之外开辟内存，即使不创建对象也可以访问。</p>
<p><strong>静态成员函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getNum</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base::<span class="built_in">getNum</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员函数可以通过类加范围解析运算符<code>::</code>来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。因为没有 this 指针，只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</p>
<h3 id="const-成员"><a href="#const-成员" class="headerlink" title="const 成员"></a>const 成员</h3><p><strong>const 成员函数</strong></p>
<p>const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，成员函数的声明和定义处都要加上<code>const</code>关键字。只能通过构造函数的初始化列表初始化 const 成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">getname</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *m_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">Student::getname</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常对象</strong></p>
<p>用<code>const</code>修饰的对象称为常对象。常对象只能调用类的  const 成员变量和 const 成员函数。</p>
<h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p>this 指针是所有成员函数内部的隐含参数，用来指向调用对象，因此每一个对象都能通过 this 指针来访问自己的地址。友元函数没有 this 指针，因为友元不是类的成员，静态成员函数也是一样。</p>
<p>this只有在通过对象调用成员函数时，才将对象的地址作为实参赋值给 this。this 作为隐式形参，本质上是成员函数的局部变量，所以只能在成员函数的内部使用。它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>从外部类的角度来看，内部类只是多了一层作用域的限制而已，跟一个namespace中看一个类一样，外部类方法只能访问内部类中的public成员（前提是要有内部类的对象或者访问内部类中的static成员）。</p>
<p>从内部类看外部类，因为内部类属于外部类的一个成员，所以对外部类的成员访问没有限制。因为内部类得不到外部类的对象，所以就无法访问外部类中非static成员，可以给内部类的方法传递一个外部类成员的对象。</p>
<h3 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h3><ul>
<li>因为空类同样可以实例化，不同对象实例地址不能相同，所以编译器会给空类添加一个隐藏字节，所以空类会占1个字节。</li>
<li>虚函数会有一个指向虚函数表的指针，需要加上指针大小，多个虚函数等同于1个虚函数计算。</li>
<li>静态数据成员不影响类的大小。</li>
<li>类的大小只与数据成员有关，与构造函数、析构函数和其他成员函数无关，。</li>
<li>子类就是基类的大小加上派生类自身成员的大小。虚拟继承时，派生类中会有一个指向虚基类表的指针，故要额外加上一个的指针大小。</li>
<li>子类继承空类，如果自己有数据成员，则空类的大小不会加到子类去。</li>
<li>在多继承中，如果多个父类有虚函数，则会有多个虚函数表。子类自己定义的虚函数不会生成虚函数表（在单继承时并入父类的虚表，多继承时并入第一个父类）。</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>C++ 允许在同一作用域中（同一个类中）声明的函数或方法具有相同名称，但是它们的参数列表和实现不相同，分别称为函数重载和运算符重载。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载的函数的参数列表不同，包括参数的个数不同、类型不同或顺序不同，与返回值无关。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>  f)</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++代码在编译时会根据参数列表对函数进行重命名，例如<code>void Swap(int a, int b)</code>会被重命名为<code>_Swap_int_int</code>。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错。</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    Box box;</span><br><span class="line">    box.mLength = <span class="keyword">this</span>-&gt;mLength + b.mLength;</span><br><span class="line">    <span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span> size )</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">( <span class="type">void</span> *ptr)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>下面是可重载的运算符列表：</p>
<ul>
<li>双目算术运算符  <code>+</code>   <code>-</code>   <code>*</code> <code>/</code>   <code>%</code></li>
<li>关系运算符      <code>==</code>  <code>!=</code>  <code>&lt;</code>  <code>&gt;</code>  <code>&lt;=</code>   <code>&gt;=</code></li>
<li>逻辑运算符      <code>||</code>(逻辑或)   <code>&amp;&amp;</code>(逻辑与)   <code>!</code>(逻辑非)</li>
<li>单目运算符      <code>+</code> (正)   <code>-</code>(负)   <code>*</code>(指针)   <code>&amp;</code>(取地址)</li>
<li>自增自减运算符   <code>++</code>  <code>--</code></li>
<li>位运算符        <code>&amp;</code>  <code>|</code>  <code>~</code> <code>^</code>  <code>&lt;&lt;</code> <code>&gt;&gt;</code></li>
<li>赋值运算符      <code>=</code>   <code>+=</code>   <code>-=</code>   <code>*=</code>   <code>/=</code>    <code>%=</code>    <code>&amp;=</code>   <code>\=</code>   <code>^=</code>   <code>&lt;&lt;=</code>   <code>&gt;&gt;=</code></li>
<li>空间申请与释放  <code>new</code>   <code>delete</code>   <code>new[ ]</code>    <code>delete[]</code></li>
<li>其他运算符      <code>()</code>(函数调用)  <code>-&gt;</code>(成员访问)  <code>,</code>(逗号)  <code>[]</code>(下标)</li>
<li>强制类型转换运算符</li>
</ul>
<p>下面是不可重载的运算符列表：</p>
<ul>
<li><code>.</code> 成员访问运算符</li>
<li><code>.</code> <code>-&gt;</code> 成员指针访问运算符</li>
<li><code>::</code> 域运算符</li>
<li><code>sizeof</code> 长度运算符</li>
<li><code>?:</code> 条件运算符</li>
<li><code>#</code>  预处理符号</li>
</ul>
<p>重载不能改变运算符的优先级和结合性。运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数。运算符重载函数既可以作为类的成员函数，也可以作为全局函数（声明为友元函数）。</p>
<p>将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。</p>
<p><strong>强制类型转换运算符</strong></p>
<p>强制类型转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。经过适当重载后，<code>(类型名)对象</code>就等价于<code>对象.operator 类型名()</code>，即变成对运算符函数的调用。</p>
<p>重载强制类型转换运算符时，不需要指定返回值类型，因为返回值类型是确定的，就是运算符本身代表的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> real;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> real; &#125;  <span class="comment">//重载强制转换double类型运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>派生类可以访问基类中所有的非私有成员，继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="keyword">public</span> People, <span class="keyword">public</span> Worker &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span></span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>多继承的各个基类之间用逗号，分隔。创建派生类对象时，按基类继承的顺序执行基类的构造函数，再执行派生类构造函数。销毁派生类对象时，先执行派生类析构函数，再执行基类析构函数。</p>
<p>当多个基类中有同名的成员时，需要在成员名字前面加上类名和域解析符<code>::</code>，显式的指明使用哪个类的成员。</p>
<p><strong>向上转型</strong></p>
<p>将派生类赋值给基类，称为向上转型，只复制共同的基类部分，而不是整个对象，派生类包含的信息将丢失。相应地，将基类赋值给派生类称为向下转型。赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，不会影响成员函数，也不会影响 this 指针。</p>
<p><strong>覆盖</strong></p>
<p>覆盖也叫重写，是指派生类中重新对基类中的虚函数重新实现，即函数名相同，参数类型和顺序，返回値类型都相同，且基类函数必须有virtual关键字。只有父类指针指向子类对象，或父类对象引用子类对象才能使用，特点是对象是什么就调用什么的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::func(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    a.<span class="built_in">func</span>();</span><br><span class="line">    b.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    A &amp;a2 = b;</span><br><span class="line">    a2.<span class="built_in">func</span>();</span><br><span class="line">    a2.A::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// b.func(1); // error: no matching function for call to B::func(int)</span></span><br><span class="line">    a2.<span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    a2.A::<span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>A::func()<br>B::func()</p>
<p>B::func()<br>A::func()</p>
<p>A::func(int)<br>A::func(int)<br>A::func(int)</p>
</blockquote>
<p><strong>隐藏</strong></p>
<p>隐藏是指派生类的函数屏蔽了与其同名的基类函数，在以下2种情况会出现：</p>
<ol>
<li>派生类与基类的函数名相同，但参数不同，不管没有virtual关键字。</li>
<li>派生类与基类的函数名和参数相同，但是基类函数没有virtual关键字。</li>
</ol>
<p>隐藏的特性是类型是什么就调用什么的函数，当在派生类中误用了一个隐藏的基类函数，你以为是继承了，其实编译会报错找不到这个函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::func2(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::func3(float)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// func3(1.0);  // error: no matching function for call to ‘B::func3(double)’</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">char</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::func2(char)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    a.<span class="built_in">func</span>();</span><br><span class="line">    a.<span class="built_in">func2</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=====================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b.<span class="built_in">func</span>();</span><br><span class="line">    b.<span class="built_in">func2</span>(<span class="number">1</span>);</span><br><span class="line">    b.A::<span class="built_in">func</span>();</span><br><span class="line">    b.A::<span class="built_in">func2</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=====================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    A &amp;a2 = b;</span><br><span class="line">    a2.<span class="built_in">func</span>();</span><br><span class="line">    a2.A::<span class="built_in">func</span>();</span><br><span class="line">    a2.<span class="built_in">func2</span>(<span class="number">1</span>);</span><br><span class="line">    a2.A::<span class="built_in">func2</span>(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>A::func()<br>A::func2(int)<br>=====================<br>B::func()<br>B::func2(char)<br>A::func()<br>A::func2(int)<br>=====================<br>A::func()<br>A::func()<br>A::func2(int)<br>A::func2(int)</p>
</blockquote>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>默认是 private 继承。</p>
<table>
<thead>
<tr>
<th align="center">继承方式</th>
<th align="center">public成员</th>
<th align="center">protected成员</th>
<th align="center">private成员</th>
<th align="center">概括</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public继承</td>
<td align="center">仍为public</td>
<td align="center">仍为protected</td>
<td align="center">不可见</td>
<td align="center">基类的非私有成员在子类的访问属性不变</td>
</tr>
<tr>
<td align="center">protected继承</td>
<td align="center">变为protected</td>
<td align="center">变为protected</td>
<td align="center">不可见</td>
<td align="center">基类的非私有成员都为子类的保护成员</td>
</tr>
<tr>
<td align="center">private继承</td>
<td align="center">变为private</td>
<td align="center">变为private</td>
<td align="center">不可见</td>
<td align="center">基类中的非私有成员都称为子类的私有成员</td>
</tr>
</tbody></table>
<p><strong>改变访问权限</strong></p>
<p>使用 using 关键字可以改变基类成员在派生类中的访问权限， 但只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限，因为基类中 private 成员在派生类中是不可见<br>的，在派生类中无论如何都不能访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">char</span> *m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> People &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> People::m_name;  <span class="comment">//将protected改为public</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> People::show;    <span class="comment">//将public改为private</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>using改变基类成员的访问权限是由该声明语句所在的访问修饰符决定的，放到public下，就成了公有成员。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>在菱形继承中，一个派生类中可能会保留间接基类的多份同名成员，在继承方式前面加上<code>virtual</code>关键字就是虚继承，使得在派生类中只保留一份间接基类的成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;  <span class="comment">//虚继承</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虚继承的目的就是让某个类做出声明共享它的基类，这个被共享的基类就称为虚基类。在这种机制下，在派生类中都只包含一份虚基类的成员。</p>
<p>在虚继承中，虚基类是由最终的派生类初始化的，因为要避免2个间接基类对虚基类有不同的初始化，最终派生类的构造函数必须要调用虚基类的构造函数，面且这个虚基类的构造函数会先被调用。在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是在调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。将派生类对象视为基类对象，并执行派生类的方法。</p>
<p>多态行为是在运行阶段实现的，构造函数只能创建固定类型的对象，不具备多态性，因此不允许使用虚复制构造函数。</p>
<p><strong>动态绑定</strong></p>
<p><strong>静态多态</strong></p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>编译器通过指针来访问类成员，指针指向哪个对象就使用哪个对象的数据，指针属于哪个类的类型就使用哪个类的函数。也就是说，基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。为了让基类指针能够访问派生类的成员函数，C++增加了虚函数，虚函数的作用就是为了实现覆盖。</p>
<p>虚函数是在基类函数声明处加上<code>virtual</code>关键字，函数定义处可以加也可以不加。在派生类中重新定义基类中定义的函数时，会告诉编译器不要静态链接到该函数，这种在程序中任意点可以根据所调用的对象类型来选择调用的函数的操作，被称为后期绑定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内联是在编译期建议编译器内联，而虚函数的多态性在运行期间确定的，因此虚函数表现为多态性时不可以内联。</p>
<p><strong>纯虚函数</strong></p>
<p>在基类中不对虚函数给出有意义的实现，派生类必须实现基类成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>有虚函数的类在实例化时会创建一个虚函数表，里面存储指向相应的虚函数的函数指针。派生类的虚函数表会继承基类的虚函数的函数指针，如果重写了基类的虚函数，则存储的是自己的虚函数的函数指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">FuncN</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">FuncN</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在用g++编译代码时，加入<code>-fdump-class-hierarchy</code>选项可以打印类的虚表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Vtable for Base</span><br><span class="line">Base::_ZTV4Base: 5u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">8     (int (*)(...))(&amp; _ZTI4Base)</span><br><span class="line">16    (int (*)(...))Base::Func1</span><br><span class="line">24    (int (*)(...))Base::Func2</span><br><span class="line">32    (int (*)(...))Base::FuncN</span><br><span class="line"></span><br><span class="line">Class Base</span><br><span class="line">   size=8 align=8</span><br><span class="line">   base size=8 base align=8</span><br><span class="line">Base (0x0x7f2e8287b5a0) 0 nearly-empty</span><br><span class="line">    vptr=((&amp; Base::_ZTV4Base) + 16u)</span><br><span class="line"></span><br><span class="line">Vtable for Derived</span><br><span class="line">Derived::_ZTV7Derived: 5u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">8     (int (*)(...))(&amp; _ZTI7Derived)</span><br><span class="line">16    (int (*)(...))Derived::Func1</span><br><span class="line">24    (int (*)(...))Base::Func2</span><br><span class="line">32    (int (*)(...))Derived::FuncN</span><br><span class="line"></span><br><span class="line">Class Derived</span><br><span class="line">   size=8 align=8</span><br><span class="line">   base size=8 base align=8</span><br><span class="line">Derived (0x0x7f2e82712208) 0 nearly-empty</span><br><span class="line">    vptr=((&amp; Derived::_ZTV7Derived) + 16u)</span><br><span class="line">  Base (0x0x7f2e8287b600) 0 nearly-empty</span><br><span class="line">      primary-for Derived (0x0x7f2e82712208)</span><br></pre></td></tr></table></figure>

<p><img src="/images/cpp/VFT.png" alt="虚函数表"></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是利用纯虚函数来实现的，抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，或派生类没有重写纯虚函数，都会导致编译错误，以保证派生类必须实现抽象方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> Worker &#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ exception</title>
    <url>/2022/06/07/cpp/exception/</url>
    <content><![CDATA[<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>捕获异常的语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//可能抛出异常的语句</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (exception_type_1 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (exception_type_2 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">catch</span>(exceptionType variable)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到。</p>
<p><code>throw</code>关键字用来抛出一个异常，这个异常会被 try 检测到，检测到异常后程序的执行流会发生跳转，从异常点跳转到 catch 所在的位置，进而被 catch 捕获。位于异常点之后的、并且在当前 try 块内的语句就都不会再执行了。即使 catch 语句成功地处理了错误，程序也不会再回退到异常点。</p>
<p><code>exceptionType</code>是异常类型，它指明了当前的 catch 可以处理什么类型的异常，<code>variable</code>是一个变量，用来接收异常信息。异常类型可以是 int、char、double、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型。</p>
<p><code>exceptionType variable</code>和函数的形参非常类似，当异常发生后，会将异常数据传递给 variable 这个变量。当然，只有跟 exceptionType 类型匹配的异常数据才会被传递给 variable，否则 catch 不会接收这份异常数据，也不会执行 catch 块中的语句。如果不希望 catch 处理异常数据，可以将 variable 省略掉，这样就不会传递异常数据，只会匹配异常类型。</p>
<p>一个 try 后面可以跟多个 catch，当异常发生时，程序会按照从上到下的顺序逐个匹配。如果没有匹配则会层层往上抛，如果最终也没找到匹配的 catch，就只能交给系统处理，终止程序的运行。</p>
<p>catch 在匹配过程中会将实参的类型进行适当的转换：</p>
<ul>
<li>向上转型，也就是派生类向基类的转换。</li>
<li>非 const 类型转换为 const 类型。</li>
<li>数组或函数指针转换，如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。</li>
</ul>
<h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p>std::exception类是异常基类，它定义了虚方法what()方法详细地描述了导致异常的原因。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">exception</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">exception</span> () <span class="keyword">throw</span>();</span><br><span class="line">    <span class="built_in">exception</span> (<span class="type">const</span> exception&amp;) <span class="keyword">throw</span>();</span><br><span class="line">    exception&amp; <span class="keyword">operator</span>= (<span class="type">const</span> exception&amp;) <span class="built_in">throw</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">exception</span>() <span class="keyword">throw</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过下面的语句来捕获所有的标准异常：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="built_in">catch</span>(exception &amp;e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/cpp/exception.png" alt="exception"></p>
<table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>exception</strong></td>
<td>所有标准异常的父类。</td>
</tr>
<tr>
<td>bad_alloc</td>
<td>new 或 new[ ] 分配内存失败时</td>
</tr>
<tr>
<td>bad_cast</td>
<td>dynamic_cast 转换失败时</td>
</tr>
<tr>
<td>bad_exception</td>
<td>如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型</td>
</tr>
<tr>
<td>bad_typeid</td>
<td>使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类</td>
</tr>
<tr>
<td>domain_error</td>
<td>使用了一个无效的数学域时</td>
</tr>
<tr>
<td>invalid_argument</td>
<td>使用了无效的参数时</td>
</tr>
<tr>
<td>length_error</td>
<td>创建了太长的 string 时</td>
</tr>
<tr>
<td>ios_base::failure</td>
<td>io 过程中出现的异常</td>
</tr>
<tr>
<td><strong>logic_error</strong></td>
<td>代码逻辑错误</td>
</tr>
<tr>
<td><strong>runtime_error</strong></td>
<td>代码运行错误</td>
</tr>
<tr>
<td>out_of_range</td>
<td>库函数抛出的异常，如 vector 和 bitset&lt;&gt;::operator。</td>
</tr>
<tr>
<td>range_error</td>
<td>计算结果超出范围</td>
</tr>
<tr>
<td>overflow_error</td>
<td>算术运算上溢</td>
</tr>
<tr>
<td>underflow_error</td>
<td>算术运算下溢</td>
</tr>
</tbody></table>
<h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(string str) : <span class="built_in">message_</span>(<span class="string">&quot;Error : &quot;</span> + str) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MyException</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message_.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string message_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(MyException&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::flush;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>condition_variable</title>
    <url>/2022/06/07/cpp/condition_variable/</url>
    <content><![CDATA[<h1 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h1><p>condition_variable 条件变量用于线程间的同步，先阻塞调用的线程，直到被通知唤醒为止。当 condition_variable 对象的 wait 函数被调用的时候，它使用 mutex 锁住当前的线程，当前的线程会被系统调入阻塞队列，进入睡眠，直到有其他的线程在同一个 condition_variable 对象上调用 notify 函数来唤醒它。在此阻塞过程中，wait 会释放所在线程持有的 mutex 锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::mutex              mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span>                    ready = <span class="literal">false</span>; <span class="comment">// 全局标志位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printId</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 如果标志位不为true，则等待</span></span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">        <span class="comment">// 线程被阻塞，直到标志位变为true，此时 mtx 被释放，go</span></span><br><span class="line">        <span class="comment">// 线程能够获取到锁。</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; id: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 改变全局标志位</span></span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread threads[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(printId, i);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create threads done.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">go</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread join done.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>condition_variable 要和 lock 配合使用，是保证阻塞跟唤醒这两部分代码的原子性，并不是为了保护内部资源。wait传入锁不是为了加锁，而是为了解锁，进入睡眠状态后释放锁，被唤醒后加锁。</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line">  <span class="function">cv_status <span class="title">wait_for</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line">       <span class="function"><span class="type">bool</span> <span class="title">wait_for</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line">  <span class="function">cv_status <span class="title">wait_until</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line">       <span class="function"><span class="type">bool</span> <span class="title">wait_until</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在线程被阻塞时，该函数会自动调用 <code>lck.unlock()</code> 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知，wait 函数也是自动调用 <code>lck.lock()</code>，使得 lck 的状态和 wait 函数被调用时相同。</p>
<p>设置了 Predicate，只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后，只有当 pred 为 true 时才会被解除阻塞。这种情况类似以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">pred</span>())</span><br><span class="line">    <span class="built_in">wait</span>(lck);</span><br></pre></td></tr></table></figure>

<p>wait_for可以指定一个时间段，而wait_until可以指定一个时间点，在线程收到唤醒通知或者时间超时之前，该线程都会处于阻塞状态，当收到唤醒通知或者时间超时，才会返回。</p>
<h2 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 唤醒某个等待线程，如果同时存在多个等待线程，则唤醒某个线程是不确定的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 唤醒所有的等待线程</span></span><br></pre></td></tr></table></figure>

<h2 id="condition-variable-any"><a href="#condition-variable-any" class="headerlink" title="condition_variable_any"></a>condition_variable_any</h2><p>std::condition_variable_any 的 wait 函数可以接受任何 lock，使用方式和 condition_variable 完全一样。</p>
<h2 id="cv-status"><a href="#cv-status" class="headerlink" title="cv_status"></a>cv_status</h2><ul>
<li><code>cv_status::no_timeout</code> wait_for 或 wait_until 没有超时，即在规定的时间段内线程收到了通知。</li>
<li><code>cv_status::timeout</code> wait_for 或 wait_until 超时。</li>
</ul>
<h2 id="notify-all-at-thread-exit"><a href="#notify-all-at-thread-exit" class="headerlink" title="notify_all_at_thread_exit"></a>notify_all_at_thread_exit</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all_at_thread_exit</span><span class="params">(condition_variable&amp; cond, unique_lock&lt;mutex&gt; lck)</span></span>; <span class="comment">// lck 参数是右值</span></span><br></pre></td></tr></table></figure>

<p>通过引用其第一个参数，获取条件变量，当线程退出时（join或detach），将会调用 notify_all() 该条件变量，从而唤醒等待条件变量的线程。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ bind and function</title>
    <url>/2022/06/07/cpp/function/</url>
    <content><![CDATA[<h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>bind是一个函数包装器，事先绑定一些参数到调用函数，可以用来将一个有参数的函数转换为一个无参的函数对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt; <span class="built_in">bind</span> (Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure>

<ul>
<li>fn: 可调用对象（函数对象、函数指针、函数引用）。</li>
<li>args: 要绑定的参数列表，未绑定的参数用<code>std::placeholders</code>的占位符<code>_1</code> <code>_2</code> <code>_3</code>…替换。</li>
</ul>
<p>绑定类成员函数时，第一个参数是对象的成员函数指针，因为编译器不会将对象的成员函数隐式转换成函数指针，所以必须在前面添加&amp;符号取地址。第二个参数表示对象的地址或引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a+b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line">  <span class="type">double</span> a, b;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a*b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binding functions:</span></span><br><span class="line">    <span class="keyword">auto</span> fn1 = std::<span class="built_in">bind</span>(Sum, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">fn1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fn2 = std::<span class="built_in">bind</span>(Sum, _1, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">fn2</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fn3 = std::<span class="built_in">bind</span>(Sum, _2, _1);</span><br><span class="line">    <span class="built_in">fn3</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*psum)(<span class="type">int</span>, <span class="type">int</span> );</span><br><span class="line">    psum = Sum;</span><br><span class="line">    <span class="keyword">auto</span> fn4 = std::<span class="built_in">bind</span>&lt;<span class="type">int</span>&gt;(psum, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">fn4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binding members:</span></span><br><span class="line">    MyPair pair &#123;<span class="number">10</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> bound_member_fn = std::<span class="built_in">bind</span> (&amp;MyPair::multiply, _1); <span class="comment">// returns x.multiply()</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bound_member_fn</span>(pair) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bound_member_data = std::<span class="built_in">bind</span> (&amp;MyPair::a, pair); <span class="comment">// returns pair.a</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bound_member_data</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="function"><a href="#function" class="headerlink" title="function()"></a>function()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">function</span>&lt;<span class="built_in">R</span>(Args...)&gt;</span><br></pre></td></tr></table></figure>

<p>function可以对普通函数、函数指针、函数对象、Lambda等进行封装，实现函数回调，它不能检查相等与否，只能对其判空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">testFun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> lamdaExps = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.类成员函数</span></span><br><span class="line"><span class="comment">// 2.类静态成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">classMemberFun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">staticMemberFun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 普通函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; functional = testFun;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">functional</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通函数: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通函数指针</span></span><br><span class="line">    functional = &amp;testFun;</span><br><span class="line">    ret = <span class="built_in">functional</span>(<span class="number">10</span> ,<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通函数指针: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line">    functional = lamdaExps;</span><br><span class="line">    ret = <span class="built_in">functional</span>(<span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lambda表达式: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仿函数</span></span><br><span class="line">    Functor testFunctor;</span><br><span class="line">    functional = testFunctor;</span><br><span class="line">    ret = <span class="built_in">functional</span>(<span class="number">10</span>, <span class="number">40</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;仿函数: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类成员函数（使用std::bind绑定类成员函数）</span></span><br><span class="line">    TestClass testObj;</span><br><span class="line">    functional = std::<span class="built_in">bind</span>(&amp;TestClass::classMemberFun, testObj, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line">    ret = <span class="built_in">functional</span>(<span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;类成员函数: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类静态成员函数</span></span><br><span class="line">    functional = TestClass::staticMemberFun;</span><br><span class="line">    ret = <span class="built_in">functional</span>(<span class="number">10</span>, <span class="number">60</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;类静态成员函数: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ future</title>
    <url>/2022/06/17/cpp/future/</url>
    <content><![CDATA[<h2 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a>std::future</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">future</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="built_in">future</span>(<span class="type">const</span> future&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="built_in">future</span>(future&amp;&amp; x) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>

<p><code>std::future</code> 一般由 <code>std::async</code>, <code>std::promise::get_future</code>, <code>std::packaged_task::get_future</code> 创建，</p>
<p><code>std::future</code> 用来获取异步任务的结果，由某个 Provider(异步任务的提供者)，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 <code>std::future</code> 对象调用 <code>get()</code> 就可以获取该值，如果共享状态的标志不为 ready，则调用 <code>std::future::get()</code> 会阻塞当前的调用者，直到 Provider 设置了共享状态的值。</p>
<ul>
<li><code>get()</code>: 获取与该 std::future 对象相关联的共享状态的值或异常。</li>
<li><code>valid()</code>: 有效性检查。</li>
<li><code>wait()</code>: 等待与该 std::future 对象相关联的共享状态的标志变为 ready。</li>
<li><code>wait_for()</code>: 等待一段时间与该 std::future 对象相关联的共享状态的标志变为 ready。</li>
<li><code>wait_until()</code>: 等待一个时间点与该 std::future 对象相关联的共享状态的标志变为 ready。</li>
<li><code>share()</code>: 返回一个 <code>std::shared_future</code> 对象，调用该函数之后，该 <code>std::future</code> 对象就不和任何共享状态相关联。</li>
</ul>
<p><strong>std::shared_future</strong></p>
<p>std::shared_future 可以拷贝构造，多个 std::shared_future 可以共享某个共享状态的最终结果或异常。</p>
<h2 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a>std::promise</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">promise</span>();</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line">    <span class="built_in">promise</span> (<span class="type">allocator_arg_t</span> aa, <span class="type">const</span> Alloc&amp; alloc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">promise</span> (<span class="type">const</span> promise &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="built_in">promise</span> (promise &amp;&amp;x) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::future&lt;R&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>promise 对象是异步 Provider，它可以在某一时刻设置共享状态的值。future 对象可以异步返回共享状态的值，通过 <code>get_future()</code> 来获取与该 promise 对象相关联的 future 对象，或者在必要的情况下阻塞调用者并等待共享状态标志变为 ready，然后才能获取共享状态的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>     <span class="comment">// std::ref</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>         <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>         <span class="comment">// std::promise, std::future</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_int</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; fut)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = fut.<span class="built_in">get</span>(); <span class="comment">// 获取共享状态的值.</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom; <span class="comment">// 生成一个 std::promise&lt;int&gt; 对象.</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>(); <span class="comment">// 和 future 关联.</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_int, std::ref(fut))</span></span>; <span class="comment">// 将 future 交给另外一个线程.</span></span><br><span class="line">    </span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">10</span>); <span class="comment">// 设置共享状态的值, 此处和线程保持同步.</span></span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">packaged_task</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">( F&amp;&amp; f )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">( std::<span class="type">allocator_arg_t</span>, <span class="type">const</span> Allocator&amp; a, F&amp;&amp; f )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">packaged_task</span>( <span class="type">const</span> packaged_task&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="built_in">packaged_task</span>( packaged_task&amp;&amp; rhs ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>

<p>packaged_task 包装一个可调用的对象，并且允许一个 future 对象异步获取该可调用对象产生的结果。packaged_task 对象内部包含了两个最基本元素:</p>
<ul>
<li>被包装的任务，任务是一个可调用的对象，如函数指针、成员函数指针或者函数对象。</li>
<li>共享状态，用于保存任务的返回值，可以通过 future 对象来达到异步访问共享状态的效果。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 lambda 表达式初始化一个 packaged_task 对象.</span></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="type">int</span> x)&#123; <span class="keyword">return</span> x * x; &#125;)</span></span>;</span><br><span class="line"><span class="comment">// 获取与 packaged_task 共享状态相关联的 future 对象.</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; ret = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task), <span class="number">10</span>).<span class="built_in">detach</span>(); <span class="comment">// 产生线程，调用被包装的任务.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = ret.<span class="built_in">get</span>(); <span class="comment">// 等待任务完成并获取结果.</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;value =  &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="std-async"><a href="#std-async" class="headerlink" title="std::async()"></a>std::async()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line">    std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="keyword">typename</span> std::decay&lt;Function&gt;::<span class="built_in">type</span>(</span><br><span class="line">        <span class="keyword">typename</span> std::decay&lt;Args&gt;::type...)&gt;::type&gt; <span class="built_in">async</span>( Function&amp;&amp; f, Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure>

<p><code>std::async()</code> 的 fn 和 args 参数用来指定异步任务及其参数，其返回一个 <code>std::future</code> 对象，通过该对象可以获取异步任务的值或异常。</p>
<p><code>std::launch</code>枚举类型用于设置异步任务的启动策略。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>launch::async</code></td>
<td>异步任务会在另外一个线程中调用</td>
</tr>
<tr>
<td><code>launch::deferred</code></td>
<td>异步任务将会在共享状态被访问时调用</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>([](<span class="type">int</span> x)&#123; <span class="keyword">return</span> x * x; &#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = fut.<span class="built_in">get</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;value =  &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>glog源码分析</title>
    <url>/2022/06/07/cpp/glog/</url>
    <content><![CDATA[<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(severity) COMPACT_GOOGLE_LOG_ ## severity.stream()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMPACT_GOOGLE_LOG_ERROR google::LogMessage( \</span></span><br><span class="line"><span class="meta">      __FILE__, __LINE__, google::GLOG_ERROR)</span></span><br><span class="line"></span><br><span class="line">LogMessage::<span class="built_in">LogMessage</span>(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line, LogSeverity severity)</span><br><span class="line">    : <span class="built_in">allocated_</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">Init</span>(file, line, severity, &amp;LogMessage::SendToLog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream&amp; <span class="title">LogMessage::stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data_-&gt;stream_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogMessage::LogMessageData::<span class="built_in">LogMessageData</span>()</span><br><span class="line">  : <span class="built_in">stream_</span>(message_text_, LogMessage::kMaxLogMessageLen, <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建一个 LogMessage 匿名对象，然后执行 stream()方法，又会创建一个 LogStream 对象，里面使用rdbuf()方法来接收流缓存。</p>
<h2 id="日志对象"><a href="#日志对象" class="headerlink" title="日志对象"></a>日志对象</h2><p>LogMessage 类里有一个指向全局静态 LogMessageData 的指针，LogMessageData 里有一个 LogStream 类的成员，通过 LogStreamBuf 来储存流缓存。LogFileObject 是用于操作日志文件。</p>
<h3 id="LogMessage"><a href="#LogMessage" class="headerlink" title="LogMessage"></a>LogMessage</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GOOGLE_GLOG_DLL_DECL</span> LogMessage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// icc 8 requires this typedef to avoid an internal compiler error.</span></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(LogMessage::*SendMethod)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LogMessage</span>(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line, LogSeverity severity, <span class="type">int</span> ctr,</span><br><span class="line">             SendMethod send_method);</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">LogMessage</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush a buffered message to the sink set in the constructor.  Always</span></span><br><span class="line">  <span class="comment">// called by the destructor, it may also be called from elsewhere if</span></span><br><span class="line">  <span class="comment">// needed.  Only the first call is actioned; any later ones are ignored.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An arbitrary limit on the length of a single log message.  This</span></span><br><span class="line">  <span class="comment">// is so that streaming can be done more efficiently.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kMaxLogMessageLen;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Theses should not be called directly outside of logging.*,</span></span><br><span class="line">  <span class="comment">// only passed as SendMethod arguments to other LogMessage methods:</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SendToLog</span><span class="params">()</span></span>;  <span class="comment">// Actually dispatch to the logs</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SendToSyslogAndLog</span><span class="params">()</span></span>;  <span class="comment">// Actually dispatch to syslog and the logs</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call abort() or similar to perform LOG(FATAL) crash.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> __attribute__((noreturn)) <span class="built_in">Fail</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">std::ostream&amp; <span class="title">stream</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">preserved_errno</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Must be called without the log_mutex held.  (L &lt; log_mutex)</span></span><br><span class="line">  <span class="function"><span class="type">static</span> int64 <span class="title">num_messages</span><span class="params">(<span class="type">int</span> severity)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">LogMessageData</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SaveOrSendToLog</span><span class="params">()</span></span>;  <span class="comment">// Save to stringvec if provided, else to logs</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line, LogSeverity severity,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">void</span> (LogMessage::*send_method)())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used to fill in crash information during LOG(FATAL) failures.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">RecordCrashReason</span><span class="params">(glog_internal_namespace_::CrashReason* reason)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Counts of messages sent at each priority:</span></span><br><span class="line">  <span class="type">static</span> int64 num_messages_[NUM_SEVERITIES];  <span class="comment">// under log_mutex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// We keep the data in a separate struct so that each instance of</span></span><br><span class="line">  <span class="comment">// LogMessage uses less stack space.</span></span><br><span class="line">  LogMessageData* allocated_;</span><br><span class="line">  LogMessageData* data_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LogDestination</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LogMessage</span>(<span class="type">const</span> LogMessage&amp;);</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> LogMessage&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LogStream"><a href="#LogStream" class="headerlink" title="LogStream"></a>LogStream</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GOOGLE_GLOG_DLL_DECL</span> LogStream : <span class="keyword">public</span> std::ostream &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LogStream</span>(<span class="type">char</span> *buf, <span class="type">int</span> len, <span class="type">int</span> ctr)</span><br><span class="line">      : std::<span class="built_in">ostream</span>(<span class="literal">NULL</span>),</span><br><span class="line">        <span class="built_in">streambuf_</span>(buf, len),</span><br><span class="line">        <span class="built_in">ctr_</span>(ctr),</span><br><span class="line">        <span class="built_in">self_</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="built_in">rdbuf</span>(&amp;streambuf_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">ctr</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ctr_; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_ctr</span><span class="params">(<span class="type">int</span> ctr)</span> </span>&#123; ctr_ = ctr; &#125;</span><br><span class="line">  <span class="function">LogStream* <span class="title">self</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> self_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Legacy std::streambuf methods.</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">pcount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> streambuf_.<span class="built_in">pcount</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">pbase</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> streambuf_.<span class="built_in">pbase</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">pbase</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">LogStream</span>(<span class="type">const</span> LogStream&amp;);</span><br><span class="line">  LogStream&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LogStream&amp;);</span><br><span class="line">  base_logging::LogStreamBuf streambuf_;</span><br><span class="line">  <span class="type">int</span> ctr_;  <span class="comment">// Counter hack (for the LOG_EVERY_X() macro)</span></span><br><span class="line">  LogStream *self_;  <span class="comment">// Consistency check hack</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LogStreamBuf"><a href="#LogStreamBuf" class="headerlink" title="LogStreamBuf"></a>LogStreamBuf</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GOOGLE_GLOG_DLL_DECL</span> LogStreamBuf : <span class="keyword">public</span> std::streambuf &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// REQUIREMENTS: &quot;len&quot; must be &gt;= 2 to account for the &#x27;\n&#x27; and &#x27;\0&#x27;.</span></span><br><span class="line">  <span class="built_in">LogStreamBuf</span>(<span class="type">char</span> *buf, <span class="type">int</span> len) &#123;</span><br><span class="line">    <span class="built_in">setp</span>(buf, buf + len - <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This effectively ignores overflow.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> int_type <span class="title">overflow</span><span class="params">(int_type ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Legacy public ostrstream method.</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">pcount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">pptr</span>() - <span class="built_in">pbase</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">pbase</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> std::streambuf::<span class="built_in">pbase</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LogMessageData"><a href="#LogMessageData" class="headerlink" title="LogMessageData"></a>LogMessageData</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LogMessage</span>::LogMessageData  &#123;</span><br><span class="line">  <span class="built_in">LogMessageData</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> preserved_errno_;      <span class="comment">// preserved errno</span></span><br><span class="line">  <span class="comment">// Buffer space; contains complete message text.</span></span><br><span class="line">  <span class="type">char</span> message_text_[LogMessage::kMaxLogMessageLen+<span class="number">1</span>];</span><br><span class="line">  LogStream stream_;</span><br><span class="line">  <span class="type">char</span> severity_;      <span class="comment">// What level is this LogMessage logged at?</span></span><br><span class="line">  <span class="type">int</span> line_;                 <span class="comment">// line number where logging call is.</span></span><br><span class="line">  <span class="built_in">void</span> (LogMessage::*send_method_)();  <span class="comment">// Call this in destructor to send</span></span><br><span class="line">  <span class="keyword">union</span> &#123;  <span class="comment">// At most one of these is used: union to keep the size low.</span></span><br><span class="line">    LogSink* sink_;             <span class="comment">// NULL or sink to send message to</span></span><br><span class="line">    std::vector&lt;std::string&gt;* outvec_; <span class="comment">// NULL or vector to push message onto</span></span><br><span class="line">    std::string* message_;             <span class="comment">// NULL or string to write message into</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">time_t</span> timestamp_;            <span class="comment">// Time of creation of LogMessage</span></span><br><span class="line">  <span class="keyword">struct</span> ::tm tm_time_;         <span class="comment">// Time of creation of LogMessage</span></span><br><span class="line">  <span class="type">size_t</span> num_prefix_chars_;     <span class="comment">// # of chars of prefix in this message</span></span><br><span class="line">  <span class="type">size_t</span> num_chars_to_log_;     <span class="comment">// # of chars of msg to send to log</span></span><br><span class="line">  <span class="type">size_t</span> num_chars_to_syslog_;  <span class="comment">// # of chars of msg to send to syslog</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* basename_;        <span class="comment">// basename of file that called LOG</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* fullname_;        <span class="comment">// fullname of file that called LOG</span></span><br><span class="line">  <span class="type">bool</span> has_been_flushed_;       <span class="comment">// false =&gt; data has not been flushed</span></span><br><span class="line">  <span class="type">bool</span> first_fatal_;            <span class="comment">// true =&gt; this was first fatal msg</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">LogMessageData</span>(<span class="type">const</span> LogMessageData&amp;);</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> LogMessageData&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LogFileObject"><a href="#LogFileObject" class="headerlink" title="LogFileObject"></a>LogFileObject</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogFileObject</span> : <span class="keyword">public</span> base::Logger &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LogFileObject</span>(LogSeverity severity, <span class="type">const</span> <span class="type">char</span>* base_filename);</span><br><span class="line">  ~<span class="built_in">LogFileObject</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">bool</span> force_flush, <span class="comment">// Should we force a flush here?</span></span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">time_t</span> timestamp,  <span class="comment">// Timestamp for this entry</span></span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">char</span>* message,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> message_len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Configuration options</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetBasename</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* basename)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetExtension</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ext)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetSymlinkBasename</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* symlink_basename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Normal flushing routine</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It is the actual file length for the system loggers,</span></span><br><span class="line">  <span class="comment">// i.e., INFO, ERROR, etc.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> uint32 <span class="title">LogSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;lock_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> file_length_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Internal flush routine.  Exposed so that FlushLogFilesUnsafe()</span></span><br><span class="line">  <span class="comment">// can avoid grabbing a lock.  Usually Flush() calls it after</span></span><br><span class="line">  <span class="comment">// acquiring lock_.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">FlushUnlocked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> uint32 kRolloverAttemptFrequency = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">  Mutex lock_;</span><br><span class="line">  <span class="type">bool</span> base_filename_selected_;</span><br><span class="line">  string base_filename_;</span><br><span class="line">  string symlink_basename_;</span><br><span class="line">  string filename_extension_;     <span class="comment">// option users can specify (eg to add port#)</span></span><br><span class="line">  FILE* file_;</span><br><span class="line">  LogSeverity severity_;</span><br><span class="line">  uint32 bytes_since_flush_;</span><br><span class="line">  uint32 dropped_mem_length_;</span><br><span class="line">  uint32 file_length_;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> rollover_attempt_;</span><br><span class="line">  int64 next_flush_time_;         <span class="comment">// cycle count at which to flush log</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Actually create a logfile using the value of base_filename_ and the</span></span><br><span class="line">  <span class="comment">// supplied argument time_pid_string</span></span><br><span class="line">  <span class="comment">// REQUIRES: lock_ is held</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">CreateLogfile</span><span class="params">(<span class="type">const</span> string&amp; time_pid_string)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="日志构建"><a href="#日志构建" class="headerlink" title="日志构建"></a>日志构建</h2><p>初始化 LogMessage，创建LogMessageData对象，并填充数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> thread_msg_data[<span class="built_in">sizeof</span>(<span class="type">void</span>*) + <span class="built_in">sizeof</span>(LogMessage::LogMessageData)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogMessage::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">int</span> line,</span></span></span><br><span class="line"><span class="params"><span class="function">                      LogSeverity severity,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">void</span> (LogMessage::*send_method)())</span> </span>&#123;</span><br><span class="line">  allocated_ = <span class="literal">NULL</span>;</span><br><span class="line">  data_ = <span class="built_in">new</span> (&amp;thread_msg_data) LogMessageData;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">stream</span>().<span class="built_in">fill</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  data_-&gt;preserved_errno_ = errno;</span><br><span class="line">  data_-&gt;severity_ = severity;</span><br><span class="line">  data_-&gt;line_ = line;</span><br><span class="line">  data_-&gt;send_method_ = send_method;</span><br><span class="line">  data_-&gt;sink_ = <span class="literal">NULL</span>;</span><br><span class="line">  data_-&gt;outvec_ = <span class="literal">NULL</span>;</span><br><span class="line">  WallTime now = <span class="built_in">WallTime_Now</span>();</span><br><span class="line">  data_-&gt;timestamp_ = <span class="built_in">static_cast</span>&lt;<span class="type">time_t</span>&gt;(now);</span><br><span class="line">  <span class="built_in">localtime_r</span>(&amp;data_-&gt;timestamp_, &amp;data_-&gt;tm_time_);</span><br><span class="line">  <span class="type">int</span> usecs = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((now - data_-&gt;timestamp_) * <span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">  data_-&gt;num_chars_to_log_ = <span class="number">0</span>;</span><br><span class="line">  data_-&gt;num_chars_to_syslog_ = <span class="number">0</span>;</span><br><span class="line">  data_-&gt;basename_ = <span class="built_in">const_basename</span>(file);</span><br><span class="line">  data_-&gt;fullname_ = file;</span><br><span class="line">  data_-&gt;has_been_flushed_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取文件名，去除路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">const_basename</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filepath)</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* base = <span class="built_in">strrchr</span>(filepath, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_WINDOWS  <span class="comment">// Look for either path separator in Windows</span></span></span><br><span class="line">  <span class="keyword">if</span> (!base)</span><br><span class="line">    base = <span class="built_in">strrchr</span>(filepath, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> base ? (base+<span class="number">1</span>) : filepath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取用户名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="built_in">string</span> g_my_user_name;</span><br><span class="line"><span class="type">const</span> <span class="built_in">string</span>&amp; <span class="title function_">MyUserName</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> g_my_user_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">MyUserNameInitializer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(OS_WINDOWS)</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* user = getenv(<span class="string">&quot;USERNAME&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* user = getenv(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (user != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    g_my_user_name = user;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> passwd pwd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span>* <span class="title">result</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">uid_t</span> uid = geteuid();</span><br><span class="line">    <span class="type">int</span> pwuid_res = getpwuid_r(uid, &amp;pwd, buffer, <span class="keyword">sizeof</span>(buffer), &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (pwuid_res == <span class="number">0</span>) &#123;</span><br><span class="line">      g_my_user_name = pwd.pw_name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;uid%d&quot;</span>, uid);</span><br><span class="line">      g_my_user_name = buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_my_user_name.empty()) &#123;</span><br><span class="line">      g_my_user_name = <span class="string">&quot;invalid-user&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日志销毁"><a href="#日志销毁" class="headerlink" title="日志销毁"></a>日志销毁</h2><p>LogMessage 对象析构时会刷新缓冲，执行日志写入方法，使日志落盘。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LogMessage::~<span class="built_in">LogMessage</span>() &#123;</span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_ == <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;thread_msg_data)) &#123;</span><br><span class="line">    data_-&gt;~<span class="built_in">LogMessageData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogMessage::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data_-&gt;has_been_flushed_ || data_-&gt;severity_ &lt; FLAGS_minloglevel)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  data_-&gt;num_chars_to_log_ = data_-&gt;stream_.<span class="built_in">pcount</span>();</span><br><span class="line">  data_-&gt;num_chars_to_syslog_ =</span><br><span class="line">    data_-&gt;num_chars_to_log_ - data_-&gt;num_prefix_chars_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do we need to add a \n to the end of this message?</span></span><br><span class="line">  <span class="type">bool</span> append_newline =</span><br><span class="line">      (data_-&gt;message_text_[data_-&gt;num_chars_to_log_<span class="number">-1</span>] != <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="type">char</span> original_final_char = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we do need to add a \n, we&#x27;ll do it by violating the memory of the</span></span><br><span class="line">  <span class="comment">// ostrstream buffer.  This is quick, and we&#x27;ll make sure to undo our</span></span><br><span class="line">  <span class="comment">// modification before anything else is done with the ostrstream.  It</span></span><br><span class="line">  <span class="comment">// would be preferable not to do things this way, but it seems to be</span></span><br><span class="line">  <span class="comment">// the best way to deal with this.</span></span><br><span class="line">  <span class="keyword">if</span> (append_newline) &#123;</span><br><span class="line">    original_final_char = data_-&gt;message_text_[data_-&gt;num_chars_to_log_];</span><br><span class="line">    data_-&gt;message_text_[data_-&gt;num_chars_to_log_++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent any subtle race conditions by wrapping a mutex lock around</span></span><br><span class="line">  <span class="comment">// the actual logging action per se.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;log_mutex)</span></span>;</span><br><span class="line">    (<span class="keyword">this</span>-&gt;*(data_-&gt;send_method_))();</span><br><span class="line">    ++num_messages_[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data_-&gt;severity_)];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (append_newline) &#123;</span><br><span class="line">    <span class="comment">// Fix the ostrstream back how it was before we screwed with it.</span></span><br><span class="line">    <span class="comment">// It&#x27;s 99.44% certain that we don&#x27;t need to worry about doing this.</span></span><br><span class="line">    data_-&gt;message_text_[data_-&gt;num_chars_to_log_<span class="number">-1</span>] = original_final_char;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If errno was already set before we enter the logging call, we&#x27;ll</span></span><br><span class="line">  <span class="comment">// set it back to that value when we return from the logging call.</span></span><br><span class="line">  <span class="comment">// It happens often that we log an error message after a syscall</span></span><br><span class="line">  <span class="comment">// failure, which can potentially set the errno to some other</span></span><br><span class="line">  <span class="comment">// values.  We would like to preserve the original errno.</span></span><br><span class="line">  <span class="keyword">if</span> (data_-&gt;preserved_errno_ != <span class="number">0</span>) &#123;</span><br><span class="line">    errno = data_-&gt;preserved_errno_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note that this message is now safely logged.  If we&#x27;re asked to flush</span></span><br><span class="line">  <span class="comment">// again, as a result of destruction, say, we&#x27;ll do nothing on future calls.</span></span><br><span class="line">  data_-&gt;has_been_flushed_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogFileObject::~<span class="built_in">LogFileObject</span>() &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;lock_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (file_ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fclose</span>(file_);</span><br><span class="line">    file_ = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日志写入"><a href="#日志写入" class="headerlink" title="日志写入"></a>日志写入</h2><p>高等级的日志会保存在低等级的日志中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogMessage::SendToLog</span><span class="params">()</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(log_mutex)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">bool</span> already_warned_before_initgoogle = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  log_mutex.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RAW_DCHECK</span>(data_-&gt;num_chars_to_log_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             data_-&gt;message_text_[data_-&gt;num_chars_to_log_<span class="number">-1</span>] == <span class="string">&#x27;\n&#x27;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// log this message to all log files of severity &lt;= severity_</span></span><br><span class="line">    LogDestination::<span class="built_in">LogToAllLogfiles</span>(data_-&gt;severity_, data_-&gt;timestamp_,</span><br><span class="line">                                     data_-&gt;message_text_,</span><br><span class="line">                                     data_-&gt;num_chars_to_log_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">LogDestination::LogToAllLogfiles</span><span class="params">(LogSeverity severity,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">time_t</span> timestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> <span class="type">char</span>* message,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = severity; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">      LogDestination::<span class="built_in">MaybeLogToLogfile</span>(i, timestamp, message, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">LogDestination::MaybeLogToLogfile</span><span class="params">(LogSeverity severity,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">time_t</span> timestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">const</span> <span class="type">char</span>* message,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> should_flush = severity &gt; FLAGS_logbuflevel;</span><br><span class="line">  LogDestination* destination = <span class="built_in">log_destination</span>(severity);</span><br><span class="line">  destination-&gt;logger_-&gt;<span class="built_in">Write</span>(should_flush, timestamp, message, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogFileObject::Write</span><span class="params">(<span class="type">bool</span> force_flush,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">time_t</span> timestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">char</span>* message,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int</span> message_len)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(file_length_ &gt;&gt; <span class="number">20</span>) &gt;= <span class="built_in">MaxLogSize</span>() ||</span><br><span class="line">      <span class="built_in">PidHasChanged</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_ != <span class="literal">NULL</span>) <span class="built_in">fclose</span>(file_);</span><br><span class="line">    file_ = <span class="literal">NULL</span>;</span><br><span class="line">    file_length_ = bytes_since_flush_ = dropped_mem_length_ = <span class="number">0</span>;</span><br><span class="line">    rollover_attempt_ = kRolloverAttemptFrequency<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there&#x27;s no destination file, make one before outputting</span></span><br><span class="line">  <span class="keyword">if</span> (file_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Try to rollover the log file every 32 log messages.  The only time</span></span><br><span class="line">    <span class="comment">// this could matter would be when we have trouble creating the log</span></span><br><span class="line">    <span class="comment">// file.  If that happens, we&#x27;ll lose lots of log messages, of course!</span></span><br><span class="line">    <span class="keyword">if</span> (++rollover_attempt_ != kRolloverAttemptFrequency) <span class="keyword">return</span>;</span><br><span class="line">    rollover_attempt_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> ::tm tm_time;</span><br><span class="line">    <span class="built_in">localtime_r</span>(&amp;timestamp, &amp;tm_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The logfile&#x27;s filename will have the date/time &amp; pid in it</span></span><br><span class="line">    ostringstream time_pid_stream;</span><br><span class="line">    time_pid_stream.<span class="built_in">fill</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    time_pid_stream &lt;&lt; <span class="number">1900</span>+tm_time.tm_year</span><br><span class="line">                    &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="number">1</span>+tm_time.tm_mon</span><br><span class="line">                    &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time.tm_mday</span><br><span class="line">                    &lt;&lt; <span class="string">&#x27;-&#x27;</span></span><br><span class="line">                    &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time.tm_hour</span><br><span class="line">                    &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time.tm_min</span><br><span class="line">                    &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time.tm_sec</span><br><span class="line">                    &lt;&lt; <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                    &lt;&lt; <span class="built_in">GetMainThreadPid</span>();</span><br><span class="line">    <span class="type">const</span> string&amp; time_pid_string = time_pid_stream.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If no base filename for logs of this severity has been set, use a</span></span><br><span class="line">      <span class="comment">// default base filename of</span></span><br><span class="line">      <span class="comment">// &quot;&lt;program name&gt;.&lt;hostname&gt;.&lt;user name&gt;.log.&lt;severity level&gt;.&quot;.  So</span></span><br><span class="line">      <span class="comment">// logfiles will have names like</span></span><br><span class="line">      <span class="comment">// webserver.examplehost.root.log.INFO.19990817-150000.4354, where</span></span><br><span class="line">      <span class="comment">// 19990817 is a date (1999 August 17), 150000 is a time (15:00:00),</span></span><br><span class="line">      <span class="comment">// and 4354 is the pid of the logging process.  The date &amp; time reflect</span></span><br><span class="line">      <span class="comment">// when the file was created for output.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Where does the file get put?  Successively try the directories</span></span><br><span class="line">      <span class="comment">// &quot;/tmp&quot;, and &quot;.&quot;</span></span><br><span class="line">      <span class="function">string <span class="title">stripped_filename</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          glog_internal_namespace_::ProgramInvocationShortName())</span></span>;</span><br><span class="line">      string hostname;</span><br><span class="line">      <span class="built_in">GetHostName</span>(&amp;hostname);</span><br><span class="line"></span><br><span class="line">      string uidname = <span class="built_in">MyUserName</span>();</span><br><span class="line">      <span class="comment">// We should not call CHECK() here because this function can be</span></span><br><span class="line">      <span class="comment">// called after holding on to log_mutex. We don&#x27;t want to</span></span><br><span class="line">      <span class="comment">// attempt to hold on to the same mutex, and get into a</span></span><br><span class="line">      <span class="comment">// deadlock. Simply use a name like invalid-user.</span></span><br><span class="line">      <span class="keyword">if</span> (uidname.<span class="built_in">empty</span>()) uidname = <span class="string">&quot;invalid-user&quot;</span>;</span><br><span class="line"></span><br><span class="line">      stripped_filename = stripped_filename+<span class="string">&#x27;.&#x27;</span>+hostname+<span class="string">&#x27;.&#x27;</span></span><br><span class="line">                          +uidname+<span class="string">&quot;.log.&quot;</span></span><br><span class="line">                          +LogSeverityNames[severity_]+<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      <span class="comment">// We&#x27;re going to (potentially) try to put logs in several different dirs</span></span><br><span class="line">      <span class="type">const</span> vector&lt;string&gt; &amp; log_dirs = <span class="built_in">GetLoggingDirectories</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Go through the list of dirs, and try to create the log file in each</span></span><br><span class="line">      <span class="comment">// until we succeed or run out of options</span></span><br><span class="line">      <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (vector&lt;string&gt;::const_iterator dir = log_dirs.<span class="built_in">begin</span>();</span><br><span class="line">           dir != log_dirs.<span class="built_in">end</span>();</span><br><span class="line">           ++dir) &#123;</span><br><span class="line">        base_filename_ = *dir + <span class="string">&quot;/&quot;</span> + stripped_filename;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">CreateLogfile</span>(time_pid_string) ) &#123;</span><br><span class="line">          success = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write a header message into the log file</span></span><br><span class="line">    ostringstream file_header_stream;</span><br><span class="line">    file_header_stream.<span class="built_in">fill</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    file_header_stream &lt;&lt; <span class="string">&quot;Log file created at: &quot;</span></span><br><span class="line">                       &lt;&lt; <span class="number">1900</span>+tm_time.tm_year &lt;&lt; <span class="string">&#x27;/&#x27;</span></span><br><span class="line">                       &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="number">1</span>+tm_time.tm_mon &lt;&lt; <span class="string">&#x27;/&#x27;</span></span><br><span class="line">                       &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time.tm_mday</span><br><span class="line">                       &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">                       &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time.tm_hour &lt;&lt; <span class="string">&#x27;:&#x27;</span></span><br><span class="line">                       &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time.tm_min &lt;&lt; <span class="string">&#x27;:&#x27;</span></span><br><span class="line">                       &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time.tm_sec &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">                       &lt;&lt; <span class="string">&quot;Running on machine: &quot;</span></span><br><span class="line">                       &lt;&lt; LogDestination::<span class="built_in">hostname</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">                       &lt;&lt; <span class="string">&quot;Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu &quot;</span></span><br><span class="line">                       &lt;&lt; <span class="string">&quot;threadid file:line] msg&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="type">const</span> string&amp; file_header_string = file_header_stream.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> header_len = file_header_string.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">fwrite</span>(file_header_string.<span class="built_in">data</span>(), <span class="number">1</span>, header_len, file_);</span><br><span class="line">    file_length_ += header_len;</span><br><span class="line">    bytes_since_flush_ += header_len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write to LOG file</span></span><br><span class="line">  <span class="keyword">if</span> ( !stop_writing ) &#123;</span><br><span class="line">    <span class="comment">// fwrite() doesn&#x27;t return an error when the disk is full, for</span></span><br><span class="line">    <span class="comment">// messages that are less than 4096 bytes. When the disk is full,</span></span><br><span class="line">    <span class="comment">// it returns the message length for messages that are less than</span></span><br><span class="line">    <span class="comment">// 4096 bytes. fwrite() returns 4096 for message lengths that are</span></span><br><span class="line">    <span class="comment">// greater than 4096, thereby indicating an error.</span></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fwrite</span>(message, <span class="number">1</span>, message_len, file_);</span><br><span class="line">    file_length_ += message_len;</span><br><span class="line">    bytes_since_flush_ += message_len;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">CycleClock_Now</span>() &gt;= next_flush_time_ )</span><br><span class="line">      stop_writing = <span class="literal">false</span>;  <span class="comment">// check to see if disk has free space.</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// no need to flush</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See important msgs *now*.  Also, flush logs at least every 10^6 chars,</span></span><br><span class="line">  <span class="comment">// or every &quot;FLAGS_logbufsecs&quot; seconds.</span></span><br><span class="line">  <span class="keyword">if</span> ( force_flush ||</span><br><span class="line">       (bytes_since_flush_ &gt;= <span class="number">1000000</span>) ||</span><br><span class="line">       (<span class="built_in">CycleClock_Now</span>() &gt;= next_flush_time_) ) &#123;</span><br><span class="line">    <span class="built_in">FlushUnlocked</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OS_LINUX</span></span><br><span class="line">    <span class="comment">// Only consider files &gt;= 3MiB</span></span><br><span class="line">    <span class="keyword">if</span> (FLAGS_drop_log_memory &amp;&amp; file_length_ &gt;= (<span class="number">3</span> &lt;&lt; <span class="number">20</span>)) &#123;</span><br><span class="line">      <span class="comment">// Don&#x27;t evict the most recent 1-2MiB so as not to impact a tailer</span></span><br><span class="line">      <span class="comment">// of the log file and to avoid page rounding issue on linux &lt; 4.7</span></span><br><span class="line">      uint32 total_drop_length = (file_length_ &amp; ~((<span class="number">1</span> &lt;&lt; <span class="number">20</span>) - <span class="number">1</span>)) - (<span class="number">1</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">      uint32 this_drop_length = total_drop_length - dropped_mem_length_;</span><br><span class="line">      <span class="keyword">if</span> (this_drop_length &gt;= (<span class="number">2</span> &lt;&lt; <span class="number">20</span>)) &#123;</span><br><span class="line">        <span class="comment">// Only advise when &gt;= 2MiB to drop</span></span><br><span class="line">        <span class="built_in">posix_fadvise</span>(<span class="built_in">fileno</span>(file_), dropped_mem_length_, this_drop_length,</span><br><span class="line">                      POSIX_FADV_DONTNEED);</span><br><span class="line">        dropped_mem_length_ = total_drop_length;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>C++ Lambda</title>
    <url>/2022/06/07/cpp/lambda/</url>
    <content><![CDATA[<p>对于有捕获的lambda，其等价于对象;对于没有捕获的lambda，其等价于函数。</p>
<p>Lambda表达式完整的声明格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125;</span><br></pre></td></tr></table></figure>

<p>其中只有捕获外部变量列表和函数体是必要的，<code>mutable</code>指示符用来说明是否可以修改捕获的变量，不管是那种捕获方式。</p>
<p>在Lambda表达式中传递参数还有一些限制：</p>
<ol>
<li>参数列表中不能有默认参数</li>
<li>不支持可变参数</li>
<li>所有参数必须有参数名</li>
</ol>
<p><strong>捕获外部变量</strong></p>
<p>Lambda表达式捕获外部变量的方式有值捕获、引用捕获、隐式捕获。</p>
<table>
<thead>
<tr>
<th>捕获形式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>不捕获任何外部变量</td>
</tr>
<tr>
<td>[变量名, …]</td>
<td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要&amp;显示声明</td>
</tr>
<tr>
<td>[this]</td>
<td>以值的形式捕获this指针</td>
</tr>
<tr>
<td>[=]</td>
<td>以值的形式捕获所有外部变量</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>以引用形式捕获所有外部变量</td>
</tr>
<tr>
<td>[=, &amp;x]</td>
<td>变量x以引用形式捕获，其余变量以传值形式捕获</td>
</tr>
<tr>
<td>[&amp;, x]</td>
<td>变量x以值的形式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun1 = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;</span><br><span class="line">a = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">fun1</span>(); <span class="comment">// a= 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun2 = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;</span><br><span class="line">a = <span class="number">222</span>;</span><br><span class="line"><span class="built_in">fun2</span>(); <span class="comment">// a=222</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun3 = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;</span><br><span class="line">a = <span class="number">333</span>;</span><br><span class="line"><span class="built_in">fun3</span>(); <span class="comment">// a= 333</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun4 = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;</span><br><span class="line">a = <span class="number">444</span>;</span><br><span class="line"><span class="built_in">fun4</span>(); <span class="comment">// a=444</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun5 = [&amp;]() <span class="keyword">mutable</span> &#123; a = <span class="number">666</span>; cout &lt;&lt; a &lt;&lt; endl; &#125;;</span><br><span class="line"><span class="built_in">fun5</span>(); <span class="comment">// a=666</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> fun7 = [a, b]() <span class="keyword">mutable</span> &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl; &#125;;</span><br><span class="line">a = <span class="number">777</span>;</span><br><span class="line"><span class="built_in">fun7</span>(); <span class="comment">// a=666 b=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun9 = [&amp;, b]() <span class="keyword">mutable</span> &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl; &#125;;</span><br><span class="line">a = <span class="number">777</span>;</span><br><span class="line">b = <span class="number">777</span>;</span><br><span class="line"><span class="built_in">fun9</span>(); <span class="comment">// a=666 b=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun8 = [=, &amp;b]() <span class="keyword">mutable</span> &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl; &#125;;</span><br><span class="line">a = <span class="number">888</span>;</span><br><span class="line">b = <span class="number">888</span>;</span><br><span class="line"><span class="built_in">fun8</span>(); <span class="comment">// a=666 b=888</span></span><br></pre></td></tr></table></figure>

<p><strong>泛型lambda表达式</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>JsonCpp</title>
    <url>/2022/06/07/cpp/jsoncpp/</url>
    <content><![CDATA[<p>JsonCpp 中所有对象、类名都在 namespace Json 中，只需要包含 json/json.h 即可。JsonCpp 主要包含三个类:</p>
<ul>
<li><p>Json::Value：表示json对象或数组，支持的类型有int, double, string, object, array等。其包含节点的类型判断(isNull, isBool, isInt, isArray, isMember, isValidIndex等)，类型获取(type)，类型转换(asInt, asString等)，节点获取(get, [])，节点比较(重载&lt;, &lt;=, &gt;, &gt;=, ==, !=)，节点操作(compare, swap, removeMember, removeindex, append等)等函数。</p>
</li>
<li><p>Json::Reader：将文件流或字符串解析到Json::Value中，主要使用parse函数。Json::Reader的构造函数还允许用户使用特性Features来自定义Json的严格等级。</p>
</li>
<li><p>Json::Writer：将Json::Value转换成字符串流，Writer类是一个纯虚类，并不能直接使用。在此我们使用 Json::Writer 的子类：Json::FastWriter(将数据写入一行, 没有格式)，Json::StyledWriter(按json格式化输出, 易于阅读)。</p>
</li>
</ul>
<h2 id="解析json属性"><a href="#解析json属性" class="headerlink" title="解析json属性"></a>解析json属性</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aaa&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">16</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;conf.json&quot;</span>);</span><br><span class="line">reader.<span class="built_in">parse</span>(ifs, root, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; root[<span class="string">&quot;name&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age: &quot;</span> &lt;&lt; root[<span class="string">&quot;age&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="解析json对象"><a href="#解析json对象" class="headerlink" title="解析json对象"></a>解析json对象</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;param&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;job&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;worker&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;income&quot;</span> <span class="punctuation">:</span> <span class="number">1000</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;conf.json&quot;</span>);</span><br><span class="line">reader.<span class="built_in">parse</span>(ifs, root, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">Json::Value param = root[<span class="string">&quot;param&quot;</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;job: &quot;</span> &lt;&lt; param[<span class="string">&quot;job&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;income: &quot;</span> &lt;&lt; param[<span class="string">&quot;income&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="解析json数组"><a href="#解析json数组" class="headerlink" title="解析json数组"></a>解析json数组</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;files&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;./a.txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;./jsontest.cpp&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">Json::Reader reader;</span><br><span class="line">Json::Value root;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;conf.json&quot;</span>);</span><br><span class="line">reader.<span class="built_in">parse</span>(ifs, root, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">Json::Value files = root[<span class="string">&quot;files&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    cout &lt;&lt; files[i].<span class="built_in">asString</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封装json属性"><a href="#封装json属性" class="headerlink" title="封装json属性"></a>封装json属性</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Json::Value root;</span><br><span class="line">Json::FastWriter writer;</span><br><span class="line">root[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;tony&quot;</span>;</span><br><span class="line">root[<span class="string">&quot;age&quot;</span>] = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; writer.<span class="built_in">write</span>(root) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="封装json对象"><a href="#封装json对象" class="headerlink" title="封装json对象"></a>封装json对象</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Json::Value root;</span><br><span class="line">Json::FastWriter writer;</span><br><span class="line">Json::Value param;</span><br><span class="line">param[<span class="string">&quot;job&quot;</span>] = <span class="string">&quot;worker&quot;</span>;</span><br><span class="line">param[<span class="string">&quot;income&quot;</span>] = <span class="number">21</span>;</span><br><span class="line">root[<span class="string">&quot;param&quot;</span>] = param;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; writer.<span class="built_in">write</span>(root) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="封装json数组"><a href="#封装json数组" class="headerlink" title="封装json数组"></a>封装json数组</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Json::Value root;</span><br><span class="line">Json::FastWriter writer;</span><br><span class="line">Json::Value files;</span><br><span class="line"></span><br><span class="line">files[<span class="number">0</span>] = <span class="string">&quot;./a.txt&quot;</span>;</span><br><span class="line">files[<span class="number">1</span>] = <span class="string">&quot;.jsontest.c&quot;</span>;</span><br><span class="line"></span><br><span class="line">Json::Value link;</span><br><span class="line">link[<span class="string">&quot;src&quot;</span>] = <span class="string">&quot;b_link&quot;</span>;</span><br><span class="line">link[<span class="string">&quot;dest&quot;</span>] = <span class="string">&quot;b.exe&quot;</span>;</span><br><span class="line">files.<span class="built_in">append</span>(link);</span><br><span class="line"></span><br><span class="line">root[<span class="string">&quot;files&quot;</span>] = files;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; writer.<span class="built_in">write</span>(root) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 智能指针</title>
    <url>/2022/06/07/cpp/shared_ptr/</url>
    <content><![CDATA[<p>在C++中，用new和delete动态内存管理经常会出现忘记或错误释放内存问题，为了更加容易和安全的使用动态内存，才引入了智能指针。</p>
<p>智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。智能指针通过引用计数技术来维护对象的生命周期。每当有一个新指针指向这个对象时，这个对象的引用计数就加1，相反当指针不再指向对象时，这个对象的引用计数就减1，当对象的引用计数为0时，就会自动释放。</p>
<p>智能指针访问auto_ptr的成员函数用的是<code>.</code>，访问指向对象的成员时用的是<code>-&gt;</code>。</p>
<p>智能指针限制：</p>
<ul>
<li>不能delete get()返回的指针。</li>
<li>不要把一个原始指针给多个智能指针管理。</li>
<li>不要用get()返回的原始指针去初始化或reset另一个智能指针。</li>
<li>如果使用get()返回的指针，当最后一个对应的智能指针销毁后就无效。</li>
<li>智能指针管理的资源只会默认删除new分配的内存，如果不是则需要自定义删除器作参数。</li>
</ul>
<h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><p>auto_ptr已经被c++11弃用。对auto_ptr进行赋值时会隐式转移所有权，如p2 = p，p2会接管p原来的内存管理权，p会变为空指针，如果p2原来不为空，则它会释放原来的资源，基于这个原因，应该避免把auto_ptr放到容器中，因为算法对容器操作时对容器实现了赋值传递操作，这样会使容器中很多元素被置为NULL。</p>
<p>判断一个auto_ptr是否为空不能使用<code>if (p == NULL)</code>，应该使用<code>if (p.get() == NULL)</code>。</p>
<p>成员函数release()会把智能指针赋值为空，但只是释放了对资源的所有权，它指向的内存并没有被释放。可以使用<code>p.reset()</code>方法来提前释放资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(string s) : <span class="built_in">str_</span>(s) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; str_ &lt;&lt; <span class="string">&quot; destory.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Printf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;printf: &quot;</span> &lt;&lt; str_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string str_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">auto_ptr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;p1&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">auto_ptr&lt;Test&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;p2&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    Test *tmp = p1.<span class="built_in">get</span>();</span><br><span class="line">    tmp-&gt;<span class="built_in">Printf</span>();</span><br><span class="line"></span><br><span class="line">    p1 = p2;</span><br><span class="line">    <span class="keyword">if</span> (p2.<span class="built_in">get</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;auto_ptr p2 is null&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&quot;p4&quot;</span>));</span><br><span class="line">    p1-&gt;<span class="built_in">Printf</span>();</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">release</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p.release()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    p1.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr是独占对象所有权的智能指针，是用于取代auto_ptr的，虽然不能拷贝构造或者赋值操作，但可以通过调用release()或reset()方法将指针所有权从一个非const的unique_ptr转移给另一个unique。虽然无法使两个unique_ptr指向同一个对象，但可进行移动构造和移动赋值操作。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator*()</td>
<td>指针解引用</td>
</tr>
<tr>
<td>swap()</td>
<td>交换2个unique_ptr 指针的内容</td>
</tr>
<tr>
<td>reset()</td>
<td>重置指针，并销毁当前unique_ptr管理的对象</td>
</tr>
<tr>
<td>release()</td>
<td>解放指针，释放所有权，并不会销毁被管理的对象，会将其返回</td>
</tr>
<tr>
<td>get()</td>
<td>获取内部包含的原生指针</td>
</tr>
<tr>
<td>operator bool()</td>
<td>判断是否为空智能指针</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(string s) : <span class="built_in">str_</span>(s) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; str_ &lt;&lt; <span class="string">&quot; destory.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Printf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;printf: &quot;</span> &lt;&lt; str_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string str_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;p1&quot;</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;Test&gt; p2 = <span class="built_in">make_unique</span>&lt;Test&gt;(<span class="string">&quot;p2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Test *tmp = p1.<span class="built_in">get</span>();</span><br><span class="line">    tmp-&gt;<span class="built_in">Printf</span>();</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">swap</span>(p2);</span><br><span class="line">    p1-&gt;<span class="built_in">Printf</span>();</span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">move</span>(p2); <span class="comment">//不能直接赋值</span></span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unique_ptr p2 is null&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&quot;p4&quot;</span>));</span><br><span class="line">    p1-&gt;<span class="built_in">Printf</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// auto p6 = p1.release();</span></span><br><span class="line">    <span class="comment">// p6-&gt;Printf();</span></span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr 允许多个指针指向同一个对象。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator=()</td>
<td>赋值运算符，同一类型的 shared_ptr 智能指针可以相互赋值</td>
</tr>
<tr>
<td>operator*()</td>
<td>指针解引用</td>
</tr>
<tr>
<td>swap()</td>
<td>交换2个shared_ptr 指针的内容</td>
</tr>
<tr>
<td>reset()</td>
<td>当参数为空时，重置为一个空指针，引用计数减1；当传入新堆内存时，则获得该存储空间的所有权，并且引用计数的初始值为1</td>
</tr>
<tr>
<td>get()</td>
<td>获取内部包含的原生指针</td>
</tr>
<tr>
<td>use_count()</td>
<td>返回引用计数</td>
</tr>
<tr>
<td>unique()</td>
<td>判断是否有其它 shared_ptr 对象指向它</td>
</tr>
<tr>
<td>operator bool()</td>
<td>判断是否为空智能指针</td>
</tr>
</tbody></table>
<p>对于申请的数组内存，可以自定义释放规则:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123; <span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(string s) : <span class="built_in">str_</span>(s) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; str_ &lt;&lt; <span class="string">&quot; destory.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Printf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;printf: &quot;</span> &lt;&lt; str_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string str_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;p1&quot;</span>))</span></span>;</span><br><span class="line">    shared_ptr&lt;Test&gt; p2 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;p2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;shared_ptr p is null&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is unique: &quot;</span> &lt;&lt; p1.<span class="built_in">unique</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Test&gt; p3 = p1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is unique: &quot;</span> &lt;&lt; p1.<span class="built_in">unique</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> tmp = p1.<span class="built_in">get</span>();</span><br><span class="line">    tmp-&gt;<span class="built_in">Printf</span>();</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">swap</span>(p2);</span><br><span class="line">    p1-&gt;<span class="built_in">Printf</span>();</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&quot;p4&quot;</span>));</span><br><span class="line">    p1-&gt;<span class="built_in">Printf</span>();</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dynamic-pointer-cast"><a href="#dynamic-pointer-cast" class="headerlink" title="dynamic_pointer_cast"></a>dynamic_pointer_cast</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">  <span class="function">shared_ptr&lt;T&gt; <span class="title">dynamic_pointer_cast</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;U&gt;&amp; sp)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>dynamic_pointer_cast常用于shared_ptr之间的类型转换，它返回一个shared_ptr副本，其存储的指针从U *动态地转换为T *。</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr 是用来解决2个shared_ptr相互引用时的死锁问题的，如果两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能减少为0，资源永远不会释放。weak_ptr是对对象的一种弱引用，指向shared_ptr所管理的对象，不会改变对象的引用计数，和shared_ptr之间可以相互转化。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator=()</td>
<td>赋值运算符，可以直接被 weak_ptr 或 shared_ptr 类型指针赋值</td>
</tr>
<tr>
<td>swap()</td>
<td>互换2个weak_ptr 指针内容</td>
</tr>
<tr>
<td>use_count()</td>
<td>返回和当前 weak_ptr 指针相同指向的 shared_ptr 指针的数量，每次lock后加1</td>
</tr>
<tr>
<td>reset()</td>
<td>将当前 weak_ptr 指针置为空指针</td>
</tr>
<tr>
<td>expired()</td>
<td>判断当前 weak_ptr 指针是否过期（为空或者已经被释放）</td>
</tr>
<tr>
<td>lock()</td>
<td>返回 shared_ptr 指针，有可能为空</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Printf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; pb_.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// shared_ptr&lt;A&gt; pa_; </span></span><br><span class="line">    weak_ptr&lt;A&gt; pa_;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Printf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; pa_.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line"></span><br><span class="line">    pa-&gt;<span class="built_in">Printf</span>();</span><br><span class="line">    pb-&gt;<span class="built_in">Printf</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">weak_ptr&lt;A&gt; <span class="title">wpa</span><span class="params">(pa)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wpa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> tmp = wpa.<span class="built_in">lock</span>();</span><br><span class="line">    tmp-&gt;<span class="built_in">Printf</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wpa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;expired: &quot;</span> &lt;&lt; wpa.<span class="built_in">expired</span>() &lt;&lt; endl;</span><br><span class="line">    wpa.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;expired: &quot;</span> &lt;&lt; wpa.<span class="built_in">expired</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Mutex and Lock</title>
    <url>/2022/06/11/cpp/lock/</url>
    <content><![CDATA[<h2 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mutex</span> &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">constexpr</span> <span class="title">mutex</span><span class="params">()</span></span>;</span><br><span class="line">            ~<span class="built_in">mutex</span>();</span><br><span class="line">            <span class="built_in">mutex</span>(<span class="type">const</span> mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            mutex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">typedef</span> implementation-defined native_handle_type;</span><br><span class="line">            <span class="function">native_handle_type <span class="title">native_handle</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::mutex</code>不允许拷贝构造，也不允许 move 拷贝。</p>
<h2 id="timed-mutex"><a href="#timed-mutex" class="headerlink" title="timed_mutex"></a>timed_mutex</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">timed_mutex</span> &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">timed_mutex</span>();</span><br><span class="line">            ~<span class="built_in">timed_mutex</span>();</span><br><span class="line">            <span class="built_in">timed_mutex</span>(<span class="type">const</span> timed_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            timed_mutex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> timed_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">try_lock_for</span><span class="params">(<span class="type">const</span> chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">try_lock_until</span><span class="params">(<span class="type">const</span> chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">typedef</span> implementation-defined native_handle_type; </span><br><span class="line">            <span class="function">native_handle_type <span class="title">native_handle</span><span class="params">()</span></span>;    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::time_mutex</code>比 <code>std::mutex</code> 多了两个成员函数：<code>try_lock_for()</code>，<code>try_lock_until()</code>。<code>try_lock_for()</code> 函数接受一个时间范围，在这一段时间范围之内，如果没有获得锁则被阻塞住，如果超时没有获得锁，则返回 false。<code>try_lock_until()</code> 函数则接受一个时间点作为参数，在指定时间点未到来之前，如果没有获得锁则被阻塞住，如果超时，则返回 false。</p>
<h2 id="recursive-mutex"><a href="#recursive-mutex" class="headerlink" title="recursive_mutex"></a>recursive_mutex</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">recursive_mutex</span> &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">recursive_mutex</span>();</span><br><span class="line">            ~<span class="built_in">recursive_mutex</span>();</span><br><span class="line">            <span class="built_in">recursive_mutex</span>(<span class="type">const</span> recursive_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            recursive_mutex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> recursive_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">typedef</span> implementation-defined native_handle_type;</span><br><span class="line">            <span class="function">native_handle_type <span class="title">native_handle</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::recursive_mutex</code> 允许递归上锁来获得对互斥量对象的多层所有权，重复对该互斥量进行上锁操作不会产生死锁，但必须保证上锁和解锁的次数相同。。</p>
<h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Mutex</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">lock_guard</span> &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> Mutex mutex_type;</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(mutex_type&amp; m)</span></span>;</span><br><span class="line">            <span class="built_in">lock_guard</span>(mutex_type&amp; m, <span class="type">adopt_lock_t</span>) <span class="keyword">noexcept</span>;</span><br><span class="line">            ~<span class="built_in">lock_guard</span>();</span><br><span class="line">            <span class="built_in">lock_guard</span>(lock_guard <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            lock_guard&amp; <span class="keyword">operator</span>=(lock_guard <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            mutex_type&amp; pm; <span class="comment">// exposition only</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lock_guard</code> 对象并不负责管理 Mutex 对象的生命周期，只是简化了 Mutex 对象的上锁和解锁操作，在 <code>lock_guard</code> 对象构造时，传入的 Mutex 对象会被当前线程锁住。在<code>lock_guard</code> 对象被析构时，它所管理的 Mutex 对象会自动解锁。</p>
<h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Mutex</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">unique_lock</span> &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> Mutex mutex_type;</span><br><span class="line">            <span class="comment">// 构造/拷贝/析构:</span></span><br><span class="line">            <span class="built_in">unique_lock</span>() <span class="keyword">noexcept</span>;</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">unique_lock</span><span class="params">(mutex_type&amp; m)</span></span>;</span><br><span class="line">            <span class="built_in">unique_lock</span>(mutex_type&amp; m, <span class="type">defer_lock_t</span>) <span class="keyword">noexcept</span>;</span><br><span class="line">            <span class="built_in">unique_lock</span>(mutex_type&amp; m, <span class="type">try_to_lock_t</span>) <span class="keyword">noexcept</span>;</span><br><span class="line">            <span class="built_in">unique_lock</span>(mutex_type&amp; m, <span class="type">adopt_lock_t</span>) <span class="keyword">noexcept</span>;</span><br><span class="line">            <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line">            <span class="built_in">unique_lock</span>(mutex_type&amp; m, <span class="type">const</span> chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) <span class="keyword">noexcept</span>;</span><br><span class="line">            <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line">            <span class="built_in">unique_lock</span>(mutex_type&amp; m, <span class="type">const</span> chrono::duration&lt;Rep, Period&gt;&amp; rel_time) <span class="keyword">noexcept</span>;</span><br><span class="line">            ~<span class="built_in">unique_lock</span>();</span><br><span class="line">            <span class="built_in">unique_lock</span>(unique_lock <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            unique_lock&amp; <span class="keyword">operator</span>=(unique_lock <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            <span class="built_in">unique_lock</span>(unique    _lock&amp;&amp; u) <span class="keyword">noexcept</span>;</span><br><span class="line">            unique_lock&amp; <span class="keyword">operator</span>=(unique_lock&amp;&amp; u) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上锁操作:</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">try_lock_for</span><span class="params">(<span class="type">const</span> chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line">            <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">try_lock_until</span><span class="params">(<span class="type">const</span> chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改操作</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_lock&amp; u)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function">mutex_type *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// observers:</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">owns_lock</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function">mutex_type* <span class="title">mutex</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            mutex_type *pm; <span class="comment">// exposition only</span></span><br><span class="line">            <span class="type">bool</span> owns; <span class="comment">// exposition only</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Mutex</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_lock&lt;Mutex&gt;&amp; x, unique_lock&lt;Mutex&gt;&amp; y)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unique_lock</code> 对象以独占所有权的方式管理 mutex 对象，也会自动上锁和解锁操作，提供了更多的操作函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL</title>
    <url>/2022/06/17/cpp/stl/</url>
    <content><![CDATA[<p>STL 是Standard Template Library，标准模板库。STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。例如，vector 的底层为顺序表，list 的底层为双向链表，deque 的底层为循环队列，set 的底层为红黑树，hash_set 的底层为哈希表。</p>
<p><a href="https://github.com/gcc-mirror/gcc">https://github.com/gcc-mirror/gcc</a></p>
<p>STL是一个标准，只规定了STL的接口，内部实现没有要求。C++ <a href="http://c.biancheng.net/stl/">STL</a> 规范版本正式通过以后，由于其实开源的，各个 C++ 编译器厂商在此标准的基础上，实现了满足自己需求的 C++ STL 泛型库，所以STL有许多实现版本。PJ STL被Visual C++采用，RW STL等。，是最流行的版本。</p>
<p>HP STL 是 Alexandar Stepanov在惠普 Palo Alto 实验室工作时，与 Meng Lee 合作完成的。HP STL 是开放源码的，即任何人都可以免费使用、复制、修改、发布和销售该软件以及相关文档，但前提是必须在相关文档中，加入 HP STL 版本信息和授权信息。</p>
<p>PJ STL（全称为 P.J. Plauger STL）是由 P.J.Plauger参照 HP STL 实现出来的，也是 HP STL 的一个继承版本，因此该头文件中不仅含有 HP STL 的相关授权信息，同时还有 P.J.Plauger 本人的版权信息。PJ STL 被 Visual C++ 编译器所采用，但和 PH STL、SGI STL 不同的是，PJ STL 并不是开源。</p>
<p>Rouge Wave STL是由 Rouge Wave 公司开发的，也是继承 HP STL 的一个版本，它也不是开源的。<br>Rouge Wave STL 用于 Borland C++ Builder 编译器中。不过由于 Rouge Wave STL 版本不仅更新频率慢，费用还高，所以Borland 在 6.0 版本决定弃用 Rouge Wave STL 而改用 STLport。</p>
<p>Stepanov 在离开 HP 之后，就加入到了 SGI 公司，并和 Matt Austern 等人开发了 SGI STL。SGI STL 是开源的，版本注释丰富，结构清晰，可读性最强，被GCC采用。SGI STL 文件分布：</p>
<ul>
<li>C++ 标准规范下的 C 头文件（无扩展名），如 cstdio、cstdlib、cstring</li>
<li>C++ 标准程序库中不属于 STL 范畴者，如 stream、string</li>
<li>STL 标准头文件（无扩展名），如 vector、deque、list、map、algorithm、functional</li>
<li>C++ Standard 定案前，HP 所规范的STL 头文件，如 vector.h、deque.h、list.h、map.h、algo.h、function.h</li>
<li>SGI STL 内部文件（STL 真正实现于此），如 stl_vector.h、stl_deque.h、stl_list.h、stl_map.h、stl_algo.h、stl_function.h</li>
</ul>
<p>为了使 SGI STL 的基本代码都适用于 VC++ 和 C++ Builder 等多种编译器，俄国人 Boris Fomitchev 建立了一个 free 项目来开发 STLport，此版本 STL 是开放源码的。</p>
<p>STL6大组件的交互关系：container通过 allocator取得数据储存空间，algorithm通过 iterator存取 container内容，functor可以协助 algorithm完成不同的策略变化，adapter可以修饰或套接 functor。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器是一种类模板，包含各种数据结构的实现，用来存放数据。按元素是否线性，且插入时是否会自动排序，可分为序列式容器和关联式容器。</p>
<p>序列式容器按顺序存储数据，顺序容器具有插入速度快但查找操作相对较慢的特征。</p>
<p>关联式容器每个元素都有一个键值和一个实値，以key-value对形式存在。当元素被插入到容器中时，容器内部会依照其键値大小安排放置的位置，所以关联式容器没有所谓头尾，但在查询方面有很大的优势。</p>
<table>
<thead>
<tr>
<th align="center">容器</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vector</td>
<td>插入数据时间固定<br/>随机访问</td>
<td>调整大小时将影响性能<br/>搜索时间与容器包含的元素个数成反比<br/>只能在末尾插入数据</td>
</tr>
<tr>
<td align="center">deque</td>
<td>插入数据时间固定</td>
<td>不能随机访问</td>
</tr>
<tr>
<td align="center">queue</td>
<td>队列</td>
<td>先进先出<br/>只能在访问队首，在队尾插入</td>
</tr>
<tr>
<td align="center">priority_queue</td>
<td>以特定顺序存储元素，优先级高在队列开头</td>
<td></td>
</tr>
<tr>
<td align="center">list</td>
<td>插入时间固定<br/>插入或删除元素后，迭代器仍有效</td>
<td>不能随机访问<br/>搜索速度慢，因为内存不连续<br/>搜索时间与容器中的元素个数成反比</td>
</tr>
<tr>
<td align="center">forward_list</td>
<td>单向链表</td>
<td>只能沿一个方向遍历<br/>只能在开头插入</td>
</tr>
<tr>
<td align="center">stack</td>
<td>栈</td>
<td>后进先出<br/>只能在栈顶压入和弹出元素</td>
</tr>
<tr>
<td align="center">set</td>
<td>搜索速度快，与元素个数的对数成反比</td>
<td>存储的值唯一<br/>插入速度慢，因为插入时要对元素排序</td>
</tr>
<tr>
<td align="center">multiset</td>
<td>允许存储多个值相同的项</td>
<td>插入时要对元素排序</td>
</tr>
<tr>
<td align="center">unordered_set</td>
<td>查找、插入和删除复杂度为常数</td>
<td>由于元素未被严格排序，因此不能依赖元素在容器中的相对位置</td>
</tr>
<tr>
<td align="center">map</td>
<td>搜索速度快，与元素个数的对数成反比</td>
<td>key唯一<br/>插入时要对元素排序</td>
</tr>
<tr>
<td align="center">multimap</td>
<td>key可以不唯一</td>
<td>插入时要对元素排序</td>
</tr>
<tr>
<td align="center">unordered_map</td>
<td>查找、插入和删除复杂度为常数，不受容器长度影响</td>
<td>元素未被严格排序,不适合用于顺序很重要的情形</td>
</tr>
</tbody></table>
<p>push_back() 向容器添加元素时，先会调用构造函数构造一个临时对象，而 emplace_back() 是直接在容器空间内原地构造临时对象，省去移动或复制的过程。其传入的参数不是对象，而是对象的构造参数。但要保证容器是有剩余空间存放新元素的，不然跟 push_back() 一样。一般左值用 push_back()，右值用 emplace_back()。</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>可以通过swap()方法与一个小容量的vector交换的方式来减小过剩容量。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set基于红黑树实现，具有自动排序的功能，适合需要有序数据，能顺序遍历场合。</p>
<p>unordered_set基于哈希表实现，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存。数据插入和查找的时间复杂度是常数，会消耗较多的内存，无自动排序功能。适合不需要排序，单个元素访问场合。</p>
<p>multiset与 set 类似，但允许存储多个值相同的项。务必使用 multiset::count(value)确定有多少个元素包含特定的值。</p>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>迭代器是一种行为类似指针的对象，通过对迭代器解引用，它将引用对象，对容器中元素进行迭代遍历，扮演着容器和算法之间的胶合剂。常用的迭代器按功能强弱分为:</p>
<ul>
<li>输入迭代器:只能以只读的方式访问对象。</li>
<li>输出迭代器:只能执行写入操作。</li>
<li>前向迭代器:允许输入与输出，可以是 const 的,只能读取它指向的对象;也可以改变对象,即可读写对象。通常用于单向链表。</li>
<li>双向迭代器:可对其执行递减操作,从而向后移动。通常用于双向链表。</li>
<li>随机访问迭代器:可将其加减一个偏移量,还可将两个迭代器相减以得到集合中两个元素的相对距离。通常用于数组。</li>
</ul>
<p><strong>迭代器失效</strong>：</p>
<ul>
<li><p>对于数组型容器(如vector,deque)，其元素的内存是连续分配的，insert和erase操作都会使得删除点和插入点之后的元素向前挪位置，所以，插入点和删除掉之后的迭代器全部失效。比如在<code>erase(*iter++)</code>后，iter++是没有意义的，可使用<code>erase(*iter)</code>的返回值作为下一个有效迭代器的值。</p>
</li>
<li><p>对于链表型容器(如list)，使用的是不连续内存，插入、删除一个结点并不会对其他结点造成影响。删除运算只会使当前的迭代器失效。解决办法两种：使用erase(*iter)方法返回的下一个有效迭代器，或erase(iter++)。</p>
</li>
<li><p>对于树形容器(如map, set,multimap,multiset)，使用红黑树来存储数据，插入不会使得任何迭代器失效，删除运算仅仅会使当前的iterator失效。因为其erase()方法没有返回值，故只能采用<code>erase(iter++)</code>的方式删除迭代器。</p>
</li>
</ul>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><p>STL提供了一套常用的算法，在实现上是一种函数模板。不改变容器中元素的顺序和内容的算法称为非变序算法，反之为变序算法。</p>
<ul>
<li>count() 在指定范围内查找值与指定值匹配的所有元素。</li>
<li>count_if() 在指定范围内查找值满足指定条件的所有元素。</li>
<li>search() 在一个序列中查找另一个序列</li>
<li>search_n() 在容器中查找n个相邻的指定值</li>
<li>find() 在给定范围内搜索与指定值匹配的第一个元素。</li>
<li>find_if() 在给定范围内搜索满足指定条件的第一个元素。</li>
<li>find_end() 在指定范围内搜索最后一个满足特定条件的元素。</li>
<li>find_first_of() 在目标范围内搜索指定序列中的任何一个元素第一次出现的位置</li>
<li>adjacent_find() 在集合中搜索两个相等或满足指定条件的元素。</li>
<li>equal() 比较两个元素是否相等或使用指定的二元谓词判断两者是否相等</li>
<li>mismatch() 使用指定的二元谓词找出两个元素范围的第一个不同的地方</li>
<li>lexicographical_compare() 比较两个序列中的元素，以判断哪个序列更小</li>
<li>fill() 将指定范围内的元素设置为指定值</li>
<li>fill_n() 将n个相邻元素设置为指定值</li>
<li>generate() 将指定函数对象的返回值分配给指定范围中的每个元素</li>
<li>generate_n() 将指定函数的返回值分配给n个相邻元素</li>
<li>for_each() 对指定范围内的每个元素执行指定操作。</li>
<li>transform() 对指定范围中的每个元素执行指定操作，能够处理一对来自两个不同范围的元素</li>
<li>copy() 将一个范围复制到另一个范围</li>
<li>copy_backward() 沿反方向将一个范围复制到另一个范围</li>
<li>remove() 将指定范围中包含指定值的元素删除</li>
<li>remove_if() 将指定范围中满足指定条件的元素删除</li>
<li>unique() 比较指定范围内的相邻元素，并删除重复的元素</li>
<li>unique_copy() 将源范围内的所有元素复制到目标范围，但相邻的重复元素除外</li>
<li>replace() 用一个值来替换指定范围中与指定值匹配的所有元素</li>
<li>replace_if() 用一个值来替换指定范围中满足指定条件的所有元素</li>
<li>sort() 使用指定的排序标准对指定范围内的元素进行排序</li>
<li>stable_sort() 类似于 sort，但在排序时保持相对顺序不变</li>
<li>partial_sort() 将源范围内指定数量的元素排序</li>
<li>partial_sort_copy() 将源范围内的元素复制到目标范围，同时对它们排序</li>
<li>partition() 在指定范围中将满足指定条件的元素放在第一个组中，其他元素放在第二组中</li>
<li>stable_partition() 与 partition 一样将指定范围分为两组，但保持元素的相对顺序不变</li>
<li>binary_search() 用于判断一个元素是否存在于一个排序集合中</li>
<li>lower_bound() 根据元素的值或满足条件判断元素可能插入到排序集合中的第一个位置，并返回指向该位置的迭代器</li>
<li>upper_bound() 根据元素的值或满足条件判断元素可能插入到排序集合中的最后一个位置，并返回指向该位置的迭代器</li>
</ul>
<h2 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h2><p>空间配置器为容器提供空间配置和释放，对象构造和析构的服务。它的实际实现在三个文件中：</p>
<ul>
<li>stl_construct.h: 对象的构造和析构</li>
<li>stl_alloc.h: 空间的配置和释放</li>
<li>stl_uninitialized.h: 内存基本工具，用于提升性能。</li>
</ul>
<h2 id="functor"><a href="#functor" class="headerlink" title="functor"></a>functor</h2><p>仿函数是行为类似函数的对象，也叫函数对象，用于泛化算法的策略，其实就是在类中重载了operator() 运算符。和函数指针相似，让类使用起来像函数一样。函数对象与函数指针相比，有2个优点：</p>
<ol>
<li>编译器可以内联执行函数对象的调用，性能好。</li>
<li>函数对象内部可以保持状态。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FuncObj</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FuncObj</span>(<span class="type">char</span> *name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FuncObj <span class="title">f1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">f1</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">FuncObj <span class="title">f2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">f2</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="adapter"><a href="#adapter" class="headerlink" title="adapter"></a>adapter</h2><p>适配器用来修饰容器、迭代器和仿函数的接口，比如queue和stack容器是借助deque实现的。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Template</title>
    <url>/2022/06/07/cpp/template/</url>
    <content><![CDATA[<p>模板所支持的类型是宽泛的，没有限制的，我们可以使用任意类型来替换，这种编程方式称为泛型编程。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板就是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个标识符来占位，等发生函数调用时再根据传入的实参来逆推出真正的类型，也可以指定默认参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , ...&gt; 返回值类型  函数名(形参列表)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型参数可以有多个，它们之间以逗号<code>,</code>分隔。类型参数列表以<code>&lt; &gt;</code>包围，形式参数列表以<code>( )</code>包围。其中<code>typename</code>关键字也可以使用<code>class</code>关键字替代，C++ 早期用 class 来指明类型参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , …&gt; <span class="keyword">class</span> 类名 &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类外定义成员函数时需要带上模板头，格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , …&gt;</span><br><span class="line">返回值类型 类名&lt;类型参数<span class="number">1</span> , 类型参数<span class="number">2</span>, ...&gt;::函数名(形参列表) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。如果模板类包含静态成员，<br>该成员将只在对T具体化的所有实例之间共享。</p>
<h2 id="参数可变模板"><a href="#参数可变模板" class="headerlink" title="参数可变模板"></a>参数可变模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Res, <span class="keyword">typename</span> ValType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sum</span><span class="params">(Res&amp; result, ValType&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    result = result + val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Res, <span class="keyword">typename</span> First, <span class="keyword">typename</span>... Rest&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sum</span><span class="params">(Res&amp; result, First val1, Rest... valN)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    result = result + val1;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Sum</span>(result, valN ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Sum</span>(result, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ thread</title>
    <url>/2022/06/07/cpp/thread/</url>
    <content><![CDATA[<h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">thread</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread</span>(<span class="type">const</span> thread&amp;) = <span class="keyword">delete</span>; <span class="comment">// 拷贝构造被禁用</span></span><br><span class="line"><span class="built_in">thread</span>(thread&amp;&amp; x) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(thread&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">id <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">native_handle_type <span class="title">native_handle</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>get_id()</code>: 获取线程 ID。<br><code>swap()</code>: 交换两个线程对象所代表的底层句柄。<br><code>native_handle()</code>: 返回线程句柄，与 Posix 标准的pthread函数配合使用。<br><code>joinable()</code>: 检查线程是否可被 join，活动的线程是可以被 join 的，由默认构造函数创建的线程是不能被 join 的。<br><code>join()</code>: 阻塞当前线程，直到由 <code>*this</code> 所标示的线程执行完毕才返回。当线程自己返回或pthread_exit时都不会释放线程堆栈和描述符，只有join后，这些资源才会被释放。<br><code>detach()</code>: 将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以单独进行。分离的线程不能被其他线程回收或杀死，它的资源由系统释放。调用 detach 函数之后：</p>
<ol>
<li><code>*this</code> 不再代表任何的线程执行实例。</li>
<li><code>joinable() == false</code>，会抛出 <code>std::system_error</code>异常。</li>
<li><code>get_id() == std::thread::id()</code></li>
</ol>
<p>std::thread 线程执行体可以是任何可调用的对象：</p>
<ol>
<li>普通函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">()</span> <span class="comment">//不带参数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std::string arg)</span> <span class="comment">//带参数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(callback)</span></span>; </span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(callback, <span class="string">&quot;test&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">callback</span> <span class="comment">// 不带参数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">callback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="built_in">callback</span>() &#123;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string arg)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t3</span><span class="params">(callback())</span></span>; </span><br><span class="line"><span class="function">std::thread <span class="title">t4</span><span class="params">(callback(), <span class="string">&quot;test&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>类成员函数</li>
</ol>
<p>因为回调函数需要是一个函数指针，而类没有实例对象，还没有分配内存地址，所以编译器不知道成员函数的存在。使用时必须在成员函数前面加<code>&amp;</code>符号，让编译器把对象的成员函数转换成函数指针，同时还要将对象作为第二个参数传入，告知调用者是谁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">callback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="built_in">entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">entity</span><span class="params">(<span class="type">const</span> std::string arg)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">callback obj;</span><br><span class="line"><span class="function">std::thread <span class="title">t5</span><span class="params">(&amp;callback::entity, &amp;obj)</span></span>;</span><br><span class="line"><span class="comment">// std::thread t5(&amp;callback::entity, this);</span></span><br><span class="line"><span class="function">std::thread <span class="title">t6</span><span class="params">(&amp;callback::entity,  &amp;obj, <span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// std::thread t6(&amp;callback::entity,  this, &quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::thread  <span class="title">t5</span><span class="params">(std::bind(&amp;callback::entity, &amp;obj))</span></span>;</span><br><span class="line"><span class="function">std::thread  <span class="title">t6</span><span class="params">(std::bind(&amp;callback::entity,  &amp;obj, <span class="string">&quot;test&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>lambda 函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t7</span><span class="params">([](T var1, T var2) &#123;&#125;, arg..)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="std-this-thread"><a href="#std-this-thread" class="headerlink" title="std::this_thread"></a>std::this_thread</h2><p><code>get_id()</code>: 获取线程 ID。<br><code>yield()</code>: 当前线程放弃时间片，操作系统调度另一线程继续执行。<br><code>sleep_until()</code>: 线程休眠至某个指定的时间点，该线程才被重新唤醒。<br><code>sleep_for()</code>: 线程休眠某个指定的时间片，该线程才被重新唤醒，不过由于线程调度等原因，实际休眠时间可能更长。</p>
<h2 id="线程本地变量"><a href="#线程本地变量" class="headerlink" title="线程本地变量"></a>线程本地变量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        var++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread id [%d] var(%p) = %d\n&quot;</span>, std::this_thread::<span class="built_in">get_id</span>(), &amp;var, var); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(callback)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(callback)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统线程库使用<code>__thread</code>关键字来声明线程本地变量。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ stream and string</title>
    <url>/2022/06/07/cpp/stream_string/</url>
    <content><![CDATA[<h2 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h2><ul>
<li>cout 标准输出流，通常被重定向到控制台。</li>
<li>cin 标准输入流，通常用于将数据读入变量。</li>
<li>cerr 用于显示错误信息的标准输出流。</li>
<li>clog 重定向到标准错误设备，但clog对象是缓冲的，会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。</li>
<li>fstream 用于操作文件的输入和输出流，继承了 ofstream 和 ifstream。</li>
<li>ofstream 用于操作文件的输出流类，即用于创建文件。</li>
<li>ifstream 用于操作文件的输入流类，即用于读取文件。</li>
<li>stringstream 用于操作字符串的输入和输出流类，继承了 istringstream 和 ostringstream，通常用于在字符串和其他类型之间进行转换。</li>
</ul>
<p>cout、cin 和cerr 分别是流类 ostream、istream 和 ostream 的全局对象。由于是全局对象，它们在main()开始之前就已初始化。</p>
<p><img src="/images/cpp/stream_opt.png" alt="常用于流的控制符"></p>
<h3 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h3><p>cin可以将输入直接写入变量，也可将输入直接写入char数组，但为了避免缓冲区溢出，应该使用get()函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val;</span><br><span class="line">cin &gt;&gt; val;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">16</span>];</span><br><span class="line">cin.<span class="built_in">get</span>(buf, <span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<h2 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h2><p>各种模式下打开文件流：</p>
<ul>
<li><code>ios_base::app</code>: 附加到现有文件末尾,而不是覆盖它。</li>
<li><code>ios_base::ate</code>: 切换到文件末尾,但可在文件的任何地方写入数据。</li>
<li><code>ios_base::trunc</code>: 导致现有文件被覆盖,这是默认设置。</li>
<li><code>ios_base::binary</code>: 创建二进制文件(默认为文本文件)。</li>
<li><code>ios_base::in</code>: 以只读方式打开文件。</li>
<li><code>ios_base::out</code>: 以只写方式打开文件。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ofstream file;</span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;./test&quot;</span>, ios_base::out);</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        file &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ifstream read;</span><br><span class="line">    read.<span class="built_in">open</span>(<span class="string">&quot;./test&quot;</span>, ios_base::in);</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">if</span> (read.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="built_in">getline</span>(read, s);</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        read.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>字符串类 std::string 和 std::wstring 分别模拟了普通字符串和宽字符串，其长度可以动态增长，提供了一些方便操作的函数和运算符。</p>
<p><strong>实例化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1;</span><br><span class="line">string s2 = s1;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">string s3 = <span class="string">&quot;hello&quot;</span>;  <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;   <span class="comment">//直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>;   <span class="comment">//内容是10个c</span></span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(s4.begin(), s4.end())</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>getline</strong></p>
<p>使用getline读取一整行，保留输入的空白符，直到换行符为止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可使用下标运算符<code>[]</code>获取字符，使用成员函数c_str()返回字符串指针。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>无线电</title>
    <url>/2022/09/04/hardware/RF/</url>
    <content><![CDATA[<h2 id="电磁波"><a href="#电磁波" class="headerlink" title="电磁波"></a>电磁波</h2><p>电磁波的波长和频率成正比（光速=波长×频率）。</p>
<p><strong>频率越高，波长越短，越趋近于直线传播（绕射能力越差）。频率越高，在传播介质中的衰减也越大。</strong></p>
<h2 id="天线"><a href="#天线" class="headerlink" title="天线"></a>天线</h2><p><strong>天线长度应与波长成正比，大约在1/10~1/4之间</strong>，当天线的长度是无线电信号波长的1/4时，天线的发射和接收转换效率最高。</p>
<h2 id="射频"><a href="#射频" class="headerlink" title="射频"></a>射频</h2><p>射频（Radio Frequency）是指频率范围在300KHz~300GHz的高频电磁波。频率低于100kHz的电磁波会被地表吸收，不能形成有效的传输。频率高于100kHz的电磁波可以在空气中传播，并经大气层外缘的电离层反射，形成远距离传输能力。</p>
<p>900MHz的GSM频段，1.9GHz的4G LTE频段，3.5GHz的5G频段。</p>
<p>基本频带(Baseband)是指一段特殊的频率带宽，也就是频率范围在零频附近（从直流到几百KHz）的这段带宽的信号。</p>
<p><img src="/images/hardware/RF/sem_module.webp" alt="img"></p>
<p>射频芯片指的就是将无线电信号转换成一定的无线电信号波形， 并通过天线谐振发送出去的一个电子元器件，它包括功率放大器、低噪声放大器和天线开关。射频芯片架构包括接收通道和发射通道两大部分。</p>
<h2 id="检波"><a href="#检波" class="headerlink" title="检波"></a>检波</h2><p>检波又称振幅解调，它的作用是从已调制的高频振荡中恢复出原来的调制信号。从频谱上看，检波就是将幅度调制波中的边带信号不失真地从载波频率附近搬移到零频率附近。</p>
<p>在测试和测量应用中，射频功率检波器用于精密测量射频功率，以及用作频谱和网络分析仪中输入保护电路的一部分。在通信和医疗应用中，射频检波器用于监测和控制发射功率和天线回波损耗。</p>
<h2 id="基带"><a href="#基带" class="headerlink" title="基带"></a>基带</h2><p>基带（Base Band）是频谱中心点在0Hz的信号，有人也把基带叫做“未调制信号”。</p>
<p>基带芯片可以认为是包括调制解调器，但不止于调制解调器，还包括信道编解码、信源编解码，以及一些信令处理。</p>
<h2 id="LPWAN"><a href="#LPWAN" class="headerlink" title="LPWAN"></a>LPWAN</h2><p><img src="/images/hardware/RF/v2-da2f5994249683a8d1f301d9c84e95fe_720w.jpg" alt="img"></p>
<p><strong>LPWAN</strong> (Low Power Wide Area Network，低功耗广域网)，特点是低功耗和广覆盖。也叫做蜂窝物联网。目前市场上主要的LPWAN技术包括NB-IoT、eMTC、LORA。</p>
<p><img src="/images/hardware/RF/b622410ef1194adb8b52409d4ec0df39.png" alt="img"></p>
<p><img src="/images/hardware/RF/8b307fed446e4b9899ce10a248141c9e.png" alt="img"></p>
<p><strong>IMSI</strong> 国际移动用户识别码，是区别移动用户的标识，储存在SIM卡中，可用于区别移动用户的有效信息，通过IMSI可反查运营商、归属地、手机号码等信息，在接入网络时会到运营商服务器中进行验证。格式：15位0-9的数字。</p>
<p><strong>ICCID</strong> SIM卡卡号，是卡的标识，不作接入网络的鉴权认证，可在SIM卡卡后查询到。格式：大多为19或20位0-9的数字，亦存在6位/12位的情况。</p>
<h2 id="NB-IoT"><a href="#NB-IoT" class="headerlink" title="NB-IoT"></a>NB-IoT</h2><p>NB-IoT（窄带物联网），Narrow Band Internet of Things。</p>
<h2 id="ZigBee"><a href="#ZigBee" class="headerlink" title="ZigBee"></a>ZigBee</h2><p>ZigBee是基于IEEE802.15.4标准的低功耗局域网协议，可工作在2.4GHz(全球流行)、868MHz(欧洲流行)和915 MHz(美国流行)3个频段上,分别具有最高250kbit/s、20kbit/s和40kbit/s的传输速率，它的传输距离在10-75m的范围内。</p>
<ul>
<li><p>低功耗：在低耗电待机模式下，2节5号干电池可支持1个节点工作6-24个月，甚至更长。这是ZigBee的突出优势。相比之下蓝牙可以工作数周、WiFi可以工作数小时;</p>
</li>
<li><p>低成本：通过大幅简化协议是成本很低（不足蓝牙的1/10），降低了对通信控制器的要求，按预测分析，以8051的8位微控制器测算，全功能的主节点需要32KB代码，子功能节点少至4KB代码，而且ZigBee的协议专利免费;</p>
</li>
<li><p>低速率：ZigBee工作在250kbps的通讯速率，满足低速率传输数据的应用需求;</p>
</li>
<li><p>近距离：传输范围一般介于10～100m之间，在增加RF发射功率后，亦可增加到1-3km。这指的是相邻节点间的距离。如果通过路由和节点间通信的接力，传输距离将可以更远;</p>
</li>
<li><p>短时延：ZigBee的响应速度较快，一般从睡眠转入工作状态只需15ms，节点连接进入网络只需30ms，进一步节省了电能。相比较，蓝牙需要3-10s、WiFi需要3s;</p>
</li>
<li><p>高容量：ZigBee可采用星状、片状和网状网络结构，由一个主节点管理若干子节点，最多一个主节点可管理254个子节点;同时主节点还可由上一层网络节点管理，最多可组成65000个节点的大网;</p>
</li>
<li><p>高安全：ZigBee提供了三级安全模式，包括无安全设定、使用接入控制清单（ACL）防止非法获取数据以及采用高级加密标准（AES128）的对称密码，以灵活确定其安全属性;</p>
</li>
<li><p>免执照频段：采用直接序列扩频在工业科学医疗2.4GHz（全球）频段。</p>
</li>
</ul>
<h2 id="Z-Wave"><a href="#Z-Wave" class="headerlink" title="Z-Wave"></a>Z-Wave</h2><p>Z-Wave是一种基于射频的、低成本、低功耗、高可靠、适于网络的短距离无线通信技术。工作频带为908.42MHz(美国)~868.42MHz(欧洲)，采用FSK(BFSK/GFSK)调制方式，数据传输速率可达40 kbps，信号的有效覆盖范围在室内是30m，室外可超过100m，适合于窄带宽应用场合。</p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
  </entry>
  <entry>
    <title>二极管参数</title>
    <url>/2022/06/07/hardware/diode/</url>
    <content><![CDATA[<h3 id="常规参数"><a href="#常规参数" class="headerlink" title="常规参数"></a>常规参数</h3><ul>
<li><strong>正向导通压降</strong></li>
</ul>
<p>压降：二极管的电流流过负载以后相对于同一参考点的电势（电位）变化称为电压降，简称压降。</p>
<p>导通压降：二极管开始导通时对应的电压。</p>
<p>正向特性：在二极管外加正向电压时，在正向特性的起始部分，正向电压很小，不足以克服PN结内电场的阻挡作用，正向电流几乎为零。当正向电压大到足以克服PN结电场时，二极管正向导通，电流随电压增大而迅速上升。</p>
<p>反向特性：外加反向电压不超过一定范围时，通过二极管的电流是少数载流子漂移运动所形成反向电流。由于反向电流很小，二极管处于截止状态。反向电压增大到一定程度后，二极管反向击穿。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ewiaKibzhXCHPUoeYgxyMhPTaIb3eDgrZk45v8aXXoyHQFJzOFxsD6dlX5tS0N9pnSKSvMUapO88vPM7AkAe5X7w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<ul>
<li><strong>正向导通压降与导通电流的关系</strong></li>
</ul>
<p>在二极管两端加正向偏置电压时，其内部电场区域变窄，可以有较大的正向扩散电流通过PN结。只有当正向电压达到某一数值(这一数值称为“门槛电压”，锗管约为0.2V，硅管约为0.6V)以后，二极管才能真正导通。但二极管的导通压降是恒定不变的吗?它与正向扩散电流又存在什么样的关系?通过下图1的测试电路在常温下对型号为SM360A的二极管进行导通电流与导通压降的关系测试，可得到如图2所示的曲线关系：正向导通压降与导通电流成正比，其浮动压差为0.2V。从轻载导通电流到额定导通电流的压差虽仅为0.2V，但对于功率二极管来说它不仅影响效率也影响二极管的温升，所以在价格条件允许下，尽量选择导通压降小、额定工作电流较实际电流高一倍的二极管。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ewiaKibzhXCHPUoeYgxyMhPTaIb3eDgrZkt1qDGpibE7o3uMEAmbxHjNEnSUJdfPtibiaorfW589WicrHqibV2K9wN97w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="二极管导通压降测试电路"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ewiaKibzhXCHPUoeYgxyMhPTaIb3eDgrZkV1ibwvm5JYmzWcFADEI1gW1VHwib0tYXwfGbDxPQUKn84hvsOFNAyp6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="导通压降与导通电流关系"></p>
<ul>
<li><strong>正向导通压降与环境的温度的关系</strong></li>
</ul>
<p>在我们开发产品的过程中，高低温环境对电子元器件的影响才是产品稳定工作的最大障碍。环境温度对绝大部分电子元器件的影响无疑是巨大的，二极管当然也不例外，在高低温环境下通过对SM360A的实测数据表1与图3的关系曲线可知道：二极管的导通压降与环境温度成反比。在环境温度为-45℃时虽导通压降最大，却不影响二极管的稳定性，但在环境温度为75℃时，外壳温度却已超过了数据手册给出的125℃，则该二极管在75℃时就必须降额使用。这也是为什么开关电源在某一个高温点需要降额使用的因素之一。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ewiaKibzhXCHPUoeYgxyMhPTaIb3eDgrZkZ4lic7M3Y3AdqNV1icQQo0XshwZ0yKZ6CLTZttnadD6jRVsibp4EI2ImQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="导通压降与导通电流测试数据"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ewiaKibzhXCHPUoeYgxyMhPTaIb3eDgrZkibMhpkDI5dcqVGMviaOGgChmvSu9kXYd8PZqfpO8C5X1owAPTNZV3Oiaw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="导通压降与环境温度关系曲线"></p>
<ul>
<li><strong>最大整流电流IF</strong></li>
</ul>
<p>是指二极管长期连续工作时，允许通过的最大正向平均电流值，其值与PN结面积及外部散热条件等有关。因为电流通过管子时会使管芯发热，温度上升，温度超过容许限度（硅管为141左右，锗管为90左右）时，就会使管芯过热而损坏。所以在规定散热条件下，二极管使用中不要超过二极管最大整流电流值。例如，常用的IN4001－4007型锗二极管的额定正向工作电流为1A。</p>
<ul>
<li><strong>最高反向工作电压Udrm</strong></li>
</ul>
<p>加在二极管两端的反向电压高到一定值时，会将管子击穿，失去单向导电能力。为了保证使用安全，规定了最高反向工作电压值。例如，IN4001二极管反向耐压为50V，IN4007反向耐压为1000V。</p>
<ul>
<li><strong>反向电流Idrm</strong></li>
</ul>
<p>反向电流是指二极管在常温（25℃）和最高反向电压作用下，流过二极管的反向电流。反向电流越小，管子的单方向导电性能越好。值得注意的是反向电流与温度有着密切的关系，大约温度每升高10℃，反向电流增大一倍。例如2AP1型锗二极管，在25℃时反向电流若为250uA，温度升高到35℃，反向电流将上升到500uA，依此类推，在75℃时，它的反向电流已达8mA，不仅失去了单方向导电特性，还会使管子过热而损坏。又如，2CP10型硅二极管，25℃时反向电流仅为5uA，温度升高到75℃时，反向电流也不过160uA。故硅二极管比锗二极管在高温下具有较好的稳定性。</p>
<p>外加反向电压不超过一定范围时，通过二极管的电流是少数载流子漂移运动所形成反向电流。由于反向电流很小，二极管处于截止状态。这个反向电流又称为反向饱和电流或漏电流，二极管的反向饱和电流受温度影响很大。</p>
<p>一般硅管的反向电流比锗管小得多，小功率硅管的反向饱和电流在nA数量级，小功率锗管在μA数量级。温度升高时，半导体受热激发，少数载流子数目增加，反向饱和电流也随之增加。</p>
<p>二极管漏电流与反向电压的关系</p>
<p>在二极管两端加反向电压时，其内部电场区域变宽，有较少的漂移电流通过PN结，形成我们所说的漏电流。漏电流也是评估二极管性能的重要参数，二极管漏电流过大不仅使其自身温升高，对于功率电路来说也会影响其效率，不同反向电压下的漏电流是不同的，关系如图4所示：反向电压愈大，漏电流越大，在常温下肖特基管的漏电流可忽略。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ewiaKibzhXCHPUoeYgxyMhPTaIb3eDgrZkkIWySV60Xq8vNcObvDWy33UUKLxNiaLicrNOCmgibWhX2u1ZAjgpUsnpw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="反向电压与漏电流关系曲线"></p>
<p>二极管漏电流与环境温度的关系</p>
<p>其实对二极管漏电流影响最大的还是环境温度，下图5是在额定反压下测试的关系曲线，从中可以看出：温度越高，漏电流越大。在75℃后成直线上升，该点的漏电流是导致二极管外壳在额定电流下达到125℃的两大因素之一，只有通过降额反向电压和正向导通电流才能降低二极管的工作温度。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ewiaKibzhXCHPUoeYgxyMhPTaIb3eDgrZk2C3xjuEd0PKlI8KicqunibJgOVDyfqcFOAWrMjko8yfQbib7f8YcJ3FlA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="漏电流与环境温度关系曲线"></p>
<ul>
<li><strong>电压温度系数αuz</strong></li>
</ul>
<p>αuz指温度每升高一摄氏度时的稳定电压的相对变化量。uz为6v左右的稳压二极管的温度稳定性较好</p>
<h3 id="极限参数"><a href="#极限参数" class="headerlink" title="极限参数"></a>极限参数</h3><ul>
<li><strong>最大反向峰值电压VRM</strong></li>
</ul>
<p>即使没有反向电流,只要不断地提高反向电压,迟早会使二极管损坏。这种能加上的反向电压,不是瞬时电压,而是反复加上的正反向电压。因给整流器加的是交流电压,它的最大值是规定的重要因子。</p>
<ul>
<li><strong>最大直流反向电压VR</strong></li>
</ul>
<p>上述最大反向峰值电压是反复加上的峰值电压,VR是连续加直流电压时的值。用于直流电路,最大直流反向电压对于确定允许值和上限值是很重要的。</p>
<ul>
<li><strong>最大浪涌电流Isurge</strong></li>
</ul>
<p>允许流过的过量的正向电流。它不是正常电流,而是瞬间电流,这个值相当大。</p>
<ul>
<li><strong>最大平均整流电流IO</strong></li>
</ul>
<p>在半波整流电路中,流过负载电阻的平均整流电流的最大值。这是设计时非常重要的值。</p>
<ul>
<li><strong>最大交流输入电压VI</strong></li>
</ul>
<p>在半波整流电路(电阻负荷)上加的正弦交流电压的有效值。这也是选择整流器时非常重要的参数。最大峰值正向电流IFM 正向流过的最大电流值,这也是设计整流电路时的重要参数。</p>
<ul>
<li><strong>最大功率P</strong></li>
</ul>
<p>二极管中有电流流过,就会吸热,而使自身温度升高。最大功率P为功率的最大值。具体讲就是加在二极管两端的电压乘以流过的电流。这个极限参数对稳压二极管,可变电阻二极管显得特别重要。</p>
<ul>
<li><strong>反向电流IR</strong></li>
</ul>
<p>一般说来,二极管中没有反向电流流过,实际上,加一定的反向电压,总会有电流流过,这就是反向电流。不用说,好的二极管,反向电流较小。</p>
<ul>
<li><strong>反向恢复时间tre</strong></li>
</ul>
<p>指在规定的负载、正向电流及最大反向瞬态电压下的反向恢复时间。从正向电压变成反向电压时,理想情况是电流能瞬时截止,实际上,一般要延迟一点点时间。决定电流截止延时的量,就是反向恢复时间。虽然它直接影响二极管的开关速度,但不一定说这个值小就好。</p>
<ul>
<li><strong>IF— 最大平均整流电流</strong></li>
</ul>
<p>指二极管工作时允许通过的最大正向平均电流。该电流由PN结的结面积和散热条件决定。使用时应注意通过二极管的平均电流不能大于此值，并要满足散热条件。例如1N4000系列二极管的IF为1A。</p>
<ul>
<li><strong>VR— 最大反向工作电压</strong></li>
</ul>
<p>指二极管两端允许施加的最大反向电压。若大于此值，则反向电流(IR)剧增，二极管的单向导电性被破坏，从而引起反向击穿。通常取反向击穿电压(VB)的一半作为(VR)。例如1N4001的VR为50V，1N4007的VR为1OOOV.</p>
<ul>
<li><p><strong>IR— 反向电流。</strong><br>指二极管未击穿时反向电流值。温度对IR的影响很大。例如1N4000系列二极管在100°C条件IR应小于500uA;在25°C时IR应小于5uA。</p>
</li>
<li><p><strong>VR— 击穿电压。</strong></p>
</li>
</ul>
<p>指二极管反向伏安特性曲线急剧弯曲点的电压值。反向为软特性时，则指给定反向漏电流条件下的电压值。</p>
<h3 id="交流参数"><a href="#交流参数" class="headerlink" title="交流参数"></a>交流参数</h3><ul>
<li><strong>CO— 零偏压电容。</strong></li>
</ul>
<p>指二极管两端电压为零时，扩散电容及结电容的容量之和。值得注意的，由于制造工艺的限制，即使同一型号的二极管其参数的离散性也很大。手册中给出的参数往往是一个范围，若测试条件改变，则相应的参数也会发生变化，例如在25°C时测得1N5200系列硅塑封整流二极管的IR小于1OuA，而在 100°C时IR则变为小于500uA。</p>
<p>我们知道二极管具有容易从P型向N型半导体通过电流,而在相反方向不易通过的的特性。这两种特性合起来就产生了电容器的作用,即蓄积电荷的作用。蓄积有电荷,当然要放电。放电可以在任何方向进行。而二极管只在一个方向有电流流过这种说法,严格来说是不成立的。这种情况在高频时就明显表现出来。因此,二极管的极电容以小为好。</p>
<ul>
<li><strong>动态电阻Rd</strong></li>
</ul>
<p>二极管特性曲线静态工作点Q附近电压的变化与相应电流的变化量之比。</p>
<ul>
<li><strong>最高工作频率Fm</strong></li>
</ul>
<p>Fm是二极管工作的上限频率。因二极管与PN结一样，其结电容由势垒电容组成。所以Fm的值主要取决于PN结结电容的大小。若是超过此值。则单向导电性将受影响。</p>
<ul>
<li><strong>二极管反向恢复时间</strong></li>
</ul>
<p>如图6所示，二极管的反向恢复时间为电流通过零点由正向转换成反向，再由反向转换到规定低值的时间间隔，实际上是释放二极管在正向导通期间向PN结的扩散电容中储存的电荷。反向恢复时间决定了二极管能在多高频率的连续脉冲下做开关使用，如果反向脉冲的持续时间比反向恢复时间短，则二极管在正向、反向均可导通就起不到开关的作用。PN结中储存的电荷量与反向电压共同决定了反向恢复时间，而在高频脉冲下不但会使其损耗加重，也会引起较大的电磁干扰。所以知道二极管的反向恢复时间正确选择二极管和合理设计电路是必要的，选择二极管时应尽量选择PN结电容小、反向恢复时间短的，但大多数厂家都不提供该参数数据。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ewiaKibzhXCHPUoeYgxyMhPTaIb3eDgrZkxqBM8wAn7vicNLsDcantI8m8Via5cQicpLkX8PHibWQMDt8XRf9n0M15bA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="二极管恢复时间示意图"></p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
  </entry>
  <entry>
    <title>kernel flash device</title>
    <url>/2022/06/07/hardware/flash/</url>
    <content><![CDATA[<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>Linux 内核支持众多的逻辑文件系统,如 Ext2、Ext3、Ext4、btrfs、NFS、VFAT 等。<br>VFS 则是 Linux 基于各种逻辑文件系统抽象出的一种内存中的文件系统,隐藏了各种硬件设<br>备细节,为用户提供统一的操作接口,使用户访问各种不同文件系统和设备时,不用区分具<br>体的逻辑文件系统。</p>
<p>虚拟文件系统(VFS)隐藏各种了硬件的具体细节，为所有的设备提供了统一的接口，使用户访问各种不同文件系统和设备时，不用区分具体的逻辑文件系统。</p>
<p><img src="/images/kernel/kernel/VFS.webp" alt="img"></p>
<p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。文件系统层之下是缓冲区缓存，这个缓存层通过将数据保留一段时间。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p>
<p>文件系统使用超级块super block 存放文件系统相关信息，使用索引节点inode存放文件的物理信息，使用目录项dentry存放文件的逻辑信息。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>gpio structure</title>
    <url>/2022/06/07/hardware/gpio/</url>
    <content><![CDATA[<p><strong>TTL电平</strong></p>
<p>TTL(Transistor-Transistor Logic)晶体管-晶体管逻辑，电路规格：</p>
<ul>
<li>输出高电平&gt;=2.4V，输出低电平&lt;=0.4V；</li>
<li>输入高电平&gt;=2.0V，输入低电平&lt;=0.8V。</li>
<li>噪声容限是0.4V。</li>
</ul>
<p>开漏输出要输出高电平需要接一个上拉电阻，I2C支持多个主设备与多个从设备在一条总线上，用推挽输出，会造成主从设备之间短路，故要用开漏输出。</p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
  </entry>
  <entry>
    <title>i2c总线</title>
    <url>/2022/06/07/hardware/i2c-bus/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://www.i2c-bus.org/">https://www.i2c-bus.org/</a></p>
<p>I2C总线(Inter Integrated-Circuit)是由PHILIPS公司在上世纪80年代发明的一种电路板级串行总线标准，通过时钟线SCL和数据线SDA即可完成主从机的单工通信，广泛应用于电路板级的内部通信。</p>
<ul>
<li><p>总线上的所有设备通过软件寻址且具有唯一的地址。</p>
</li>
<li><p>总线上所有器件都具有自动应答功能，保证数据传输的正确性；</p>
</li>
<li><p>主机和从机的区别在于对SCL的发送权，只有主机才能发送SCL；</p>
</li>
<li><p>I2C数据传输速率有标准模式(100 kbps)、快速模式(400 kbps)和高速模式(3.4 Mbps)。</p>
</li>
</ul>
<p><img src="/images/i2c/i2c-bus.png" alt=" I2C连接示意图"></p>
<p>I2C总线上所有器件的SDA、SCL引脚输出驱动都为漏极开路结构，因此SDA和SCL可以被拉低为低电平，但是不能被驱动为高电平，低电平输出电压最大为0.4V，上拉电阻一般为4.7KΩ。通过外接上拉电阻实现总线上所有节点SDA、SCL信号的线与逻辑关系。<strong>线与</strong>的意思是只要总线上有一个设备输出底电平，总线信号就会被拉底。线与的作用在于可以实现总线的仲裁控制，总线的控制权会交给最后一个输出低电平的设备，其它设备(输出为高)通过检测总线上的电平状态(表现为低)，对比与自己输出状态不一致，则自动退出对总线的控制请求。</p>
<p>漏极开路/集电极开路的缺点是对于一个距离长的数据线，信号传输速率得不到有效保证。更长的走线对于输出驱动器表现为更大的容性负载，等效容性负载C和信号线的上拉电阻R构成RC振荡器。RC越大，意味着反射和振荡越强，从而影响总线的信号完整性。所以I2C总线允许挂载最多的设备数量取决于总线上最大电容值，一般为400pf(Hs模式100pf)。</p>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><p><img src="/images/i2c/i2c-data.webp" alt="数据序列"></p>
<h3 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h3><p>协议没有规定I2C逻辑1和0的电平值。每传输一比特数据SDA，对应产生一个时钟脉冲SCL。<strong>SCL为高时，SDA不允许变化；只有在SCL为低时，SDA才可以变化</strong>。</p>
<p><img src="/images/i2c/bit.png" alt="位的传输"></p>
<h3 id="开始-结束条件"><a href="#开始-结束条件" class="headerlink" title="开始/结束条件"></a>开始/结束条件</h3><p>如果I2C总线空闲，那么SCL和SDA信号线将都为高电平。<strong>在SCL为高电平时，将SDA由高到低电平跳变，作为起始信号，SDA由低到高电平跳变，作为结束信号</strong>。</p>
<p><img src="/images/i2c/start-stop.png" alt="开始和结束条件"></p>
<p>开始/结束条件总是由主机发起的。主机发出开始条件后，总线处于忙的状态；主机发出结束条件后，总线处于空闲状态。如果两个主机在同一时刻都希望获得总线的所有权，那么谁先将SDA拉低，谁就赢得了总线的控制权。</p>
<p>当所有数据都发送完成时，主设备需要产生一个停止信号，告诉从设备自己已经操作完成。停止信号在SDA置于低电平时，将SCL拉高并保持高电平，然后将SDA拉高。在正常传输数据过程中，当SCL处于高电平时，SDA上的值不应该变化，防止意外产生一个停止信号。</p>
<p>在操作中，如果主机发出重复开始条件而非结束条件，则总线仍处于忙的状态。也就是说重复开始条件和开始条件在功能上是相同的。</p>
<h3 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h3><p>在地址帧发送之后，就可以开始传输数据了。主设备负责产生时钟，并且在时钟上升沿之前准备好数据。每个数据帧8bits，数据帧的数量可以是任意的，直到产生停止条件。每一帧数据传输之后，接收方就需要回复一个ACK或NACK。数据传输过程中，<strong>先发送高位，再发送低位</strong>。</p>
<p>如果在数据传输过程中，从机如果没有准备好接收或发送下一个字节（比如内部中断需要处理等），它可以通过拉低SCL强制主机进入等待状态。直到从机释放SCL，主机才开始下一个字节的发送或接收。</p>
<p><img src="/images/i2c/tu4.png" alt="I2C总线的数据传输"></p>
<h3 id="应答"><a href="#应答" class="headerlink" title="应答"></a>应答</h3><p><img src="/images/i2c/ack.png" alt="I2C总线的数据应答"></p>
<p>当主设备发送完地址帧之后，在应答时钟周期内，会放弃SDA总线控制权，让从设备获得SDA控制权，这样从设备才能通过将SDA拉低通知发送器数据已被成功接收。此时从设备应该在第9个时钟脉冲之前回复一个ACK以表示接收正常。SCL为高的时候，SDA数据才是有效的，因此接收器发送ACK时，要保证SCL为高的同时，SDA为低电平；建立和保持时间也要满足规范要求。</p>
<p>如果在第9个时钟周期，SDA为高，表明接收设备无应答（NACK）。主机可以据此发出结束条件命令结束此次传输，或发起重传请求重新传输数据。有5种情况可能导致无应答：</p>
<ul>
<li>总线上没有报文中所指定地址的设备不存在。</li>
<li>接收器件尚未准备好与主机的通信。</li>
<li>接收器件无法解析读取的数据。</li>
<li>接收器件无法收取更多的数据，比如程序或者芯片内置缓冲区已经满了。</li>
<li>主机作为接收器时，在读取从机发出的最后一个字节数据后，发出NACK通知从发送器释放数据线SDA，以便主机发起结束或重传指令。</li>
</ul>
<p>主机作为发送器和接收器在写和读情况下的数据格式：</p>
<h3 id="重复开始信号"><a href="#重复开始信号" class="headerlink" title="重复开始信号"></a>重复开始信号</h3><p>主设备可以发起多个开始信号来完成数据的传输，只要不发停止信号，总线上的其他主设备就不能占据这条总线，有时候发送完一组数据后，希望重新发数据，所以就有了重复开始信号。重复的开始信号为，SDA在SCL低电平时拉高，然后SCL拉高。重复开始条件的传输时序如下图所示：</p>
<p><img src="/images/i2c/restart.jpg" alt="重复开始条件的传输时序"></p>
<h2 id="时钟同步和仲裁"><a href="#时钟同步和仲裁" class="headerlink" title="时钟同步和仲裁"></a>时钟同步和仲裁</h2><p>I2C的一大特点是可以在同一条总线上接多个主机，当两个及以上的主机同时发起传输请求时，需要通过某种机制确定哪个主机获得总线的使用权；另外，每个主机都独立产生时钟，时钟速率可能千差万别，这也需要某种机制解决时钟速率不一致的问题。这种机制就是时钟同步（Clock Synchronization）和仲裁（Arbitration）。在单主机的I2C系统中，不需要时钟同步和仲裁。</p>
<h3 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h3><p>每个I2C的主机内部都有两个计数器，分别计数SCL上高电平和低电平的时间。如果总线上只有一个主机，则这两个计数器的值取决于系统时钟速率。当多个主机存在时，不同设备的计数器速度可能不一致，因此涉及时钟同步的概念。</p>
<p>时钟同步是通过I2C接口的“线与”逻辑实现的。SCL信号线由高变低时，所有连接在SCL上的主机都开始计数低电平的时间（低电平计数器复位），由线与的逻辑可知：只有当SCL总线上所有主机的时钟输出端都为高时，SCL总线才会由低变高。SCL的低电平时间由总线上低电平时间最长的主机决定。时钟端口先跳变为高的其它主机进入等待状态。这样所有主机的时钟输出和SCL线上的状态保持相同；当SCL由低变高后，所有主机（高电平计数器）开始计数SCL高电平的时间；最早由高跳变到低的主机再次将SCL拉低。通过这种方式产生的同步时钟：其低电平时间是所有主机时钟中最长的低电平时间，其高电平时间是所有主机时钟中最短的高电平时间。</p>
<p><img src="/images/i2c/clock_sync.png" alt="仲裁阶段的时钟同步"></p>
<h3 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h3><p>当总线上有一个以上的主机时，协议通过仲裁的方法确定哪个主机获得总线的使用权。从机不参与仲裁的过程。</p>
<p>当总线处于空闲状态时，在最小的保持时间内，多个主机都可能发起开始条件在总线上传输数据。仲裁用来判断哪个主机的传输可以正常进行。</p>
<p>仲裁是按位进行的。仲裁开始时，对于每一位数据，SCL为高时，每个主机都检测SDA上的数据是否和自己发送的数据相同。可能需要进行多个位的比较，主机才开始检测到SDA上数据和自己发送的不一致。实际上，只要SDA上的数据和主机发送的数据一致，这些主机就可以将数据一致发送下去。当主机发送为HIGH，检测SDA上电平却为LOW，那么该主机就在仲裁中失去主控权，并将其SDA输出关闭。余下的主机获得总线控制权并继续数据的传输。如图8，当主机1在检测到SDA数据和它自身的输出DATA1不一致时，将自动关闭DATA1的输出，停止向总线上发送数据。</p>
<p>由此可见，在仲裁过程中胜出的主机是没有丢失数据的。在仲裁中失去总线控制权的主机在本次字节传输结束后继续产生时钟，并在总线空闲时开始上次数据的重传。如果同一个器件可以工作在主从两种模式，它在仲裁过程中失去总线控制权，那么有可能是仲裁胜出的主机将要访问该器件，该器件应该立即切换到从机模式。</p>
<p><img src="/images/i2c/arbitration.png" alt="两个主机的仲裁过程"></p>
<p>从上面的原理分析可知，I2C不存在核心主机，是没有优先级的概念的。总线的控制权仅取决于主机在SDA上的竞争（SDA包含地址和数据）。</p>
<p>在仲裁过程中，存在以下未定条件会导致不可预期的结果：</p>
<ul>
<li>主机1在主机2发送数据的过程中发出重复开始条件</li>
<li>主机1在主机2发送数据的过程中发出结束条件</li>
<li>主机1在主机发出结束条件的过程中发出重复开始条件</li>
</ul>
<h3 id="时钟拉伸"><a href="#时钟拉伸" class="headerlink" title="时钟拉伸"></a>时钟拉伸</h3><p>如果主设备发送的速度比从设备接收的速度快，因为是同步传输，可能就会出现问题，这时候，从设备可以通过控制时钟线，要求主设备线暂停传输，这就叫时钟拉伸(clock stretching)。</p>
<p>时钟拉伸通过拉低SCL延迟数据的传输。从机在主机释放SCL后，将SCL主动拉低并保持，此时主机停止在SCL上产生脉冲以及在SDA上发送数据，直到slave释放SCL，让SCL变成高电平。之后，主机便可以继续正常的数据传输了。可见时钟拉伸实际上是利用了时钟同步的机制，只是时钟由从机产生。</p>
<p>时钟拉伸是可选功能，实际上许多从机不包括SCL驱动器，因此也无法拉伸时钟。</p>
<p>包含时钟拉伸的I2C数据传输时序图为：</p>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><h3 id="7位地址"><a href="#7位地址" class="headerlink" title="7位地址"></a>7位地址</h3><p>7位从机地址，其高4位为设备类型地址，由生产厂家制定，低3位为器件引脚定义地址，由使用者定义。</p>
<p>8位地址的第0位是数据方向控制位：为0表示主机写数据，1表示主机读数据。</p>
<p>主机发送结束条件（P）终止一次传输。主机也可以通过发起重复开始条件（Sr）进行一次新的传输，而不需要先产生结束条件（P）。在一次传输过程中，可能存在多种读写组合，包括：</p>
<ul>
<li>主机作为发送，向从机发送（写）数据，传输的方向不变；</li>
</ul>
<p><img src="/images/i2c/tu10.png" alt="7位地址主发从收模式"></p>
<ul>
<li>主机发送开始条件（S）以及其后的第一个字节，立即改为从总线上读取状态。收到从机的应答（ACK）后，主机由主发模式切换到主收模式，从机由从收模式切换到从发模式。第一个应答是从机发出的。主机先发送NACK，再发送结束条件（P）结束本次传输；</li>
</ul>
<p><img src="/images/i2c/tu11.png" alt="主机在第一个字节后立即读取从机内容"></p>
<p><img src="/images/i2c/tu12.png" alt="混合模式"></p>
<h3 id="10位地址"><a href="#10位地址" class="headerlink" title="10位地址"></a>10位地址</h3><p>任何I2C设备都有一个7位地址，理论上，现实中只能有127种不同的IIC设备。实际上，已有IIC的设备种类远远多于这个限制，在一条总线上出现相同的地址的IIC设备的概率相当高。为了突破这个限制，很多设备使用了双重地址，7位地址加引脚地址。IIC 标准也预知了这种限制，提出10位的地址方案。</p>
<p>在10-bit地址的I2C系统中，需要两帧来传输slave的地址。第一个帧的前<strong>5个bit固定为b11110</strong>，后接slave地址的高2位，第8位仍然是R/W位，接着是一个ACK位，然后再发送另外8bit的地址，发送完后从设备会给出应答。</p>
<p><img src="/images/i2c/10-addr.bmp" alt="10位地址"></p>
<p><img src="/images/i2c/tu13.png" alt="主发送器寻址从接收器"></p>
<p>主接收器读取10位地址的从发送器发送的数据。数据传送方向在第二个R/W后发生改变。如图15所示，A2之前的操作和主发送器向从接收器写数据没有区别。通过Sr，匹配地址的从机得知它就是被寻址的设备，接下来从机检测Sr后的七个比特是否和先前START后的七比特一致（1111 0XX），并检测第八位（R/W）是否为1。如果是，则从机据此判断它被寻址并将要作为发送器往总线上发送数据，此时从机产生响应A3。从机一直占用总线，直到接收到STOP或Sr指向另一个从机地址。收到Sr信号后，所有从机都会对比Sr后第一个字节的前七位（1111 0XX），并检测该字节的第八位（R/W）。对于10位地址设备R/W=1，对于7位地址设备，地址（1111 0XX）不匹配，因此这些设备都不会响应Sr，不会被寻址。</p>
<p><img src="/images/i2c/tu14.png" alt="主接收器寻址从发送器"></p>
<h3 id="保留地址"><a href="#保留地址" class="headerlink" title="保留地址"></a>保留地址</h3><table>
<thead>
<tr>
<th align="left">设备地址</th>
<th align="left">读写位</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0000 000</td>
<td align="left">0</td>
<td align="left">广播地址</td>
</tr>
<tr>
<td align="left">0000 000</td>
<td align="left">1</td>
<td align="left">启动字节</td>
</tr>
<tr>
<td align="left">0000 001</td>
<td align="left">X</td>
<td align="left">CBUS 地址</td>
</tr>
<tr>
<td align="left">0000 010</td>
<td align="left">X</td>
<td align="left">预留给不同的总线格式</td>
</tr>
<tr>
<td align="left">0000 011</td>
<td align="left">X</td>
<td align="left">预留未来扩展使用</td>
</tr>
<tr>
<td align="left">0000 1XX</td>
<td align="left">1</td>
<td align="left">Hs-mode 主代码</td>
</tr>
<tr>
<td align="left">1111 1XX</td>
<td align="left">1</td>
<td align="left">设备 ID</td>
</tr>
<tr>
<td align="left">1111 0XX</td>
<td align="left">X</td>
<td align="left">10 位从地址</td>
</tr>
</tbody></table>
<h3 id="通用广播地址"><a href="#通用广播地址" class="headerlink" title="通用广播地址"></a>通用广播地址</h3><p>通用广播地址是为了寻址总线上所有设备。如果一个设备不需要使用广播功能，可以不响应广播。如果设备需要使用广播功能，则它在检测到广播地址后发送响应，并作为从接收器读取总线上发送的数据。主机不知道总线上有多少从机发送响应。总线上所有可以响应广播的从机读取广播地址后的第二个及后面的字节。不能处理这些广播数据的从机通过不发送响应的方式忽略它。同样地，如果有一个或一个以上的从机发送响应，则主机就检测不到总线上其它没有响应的设备。广播消息的含义总是定义在第二个字节。</p>
<p><img src="/images/i2c/tu15.png" alt="广播消息格式"></p>
<p>有两种可能情况：</p>
<ul>
<li>最低位“B”为0</li>
<li>最低位“B”为1</li>
</ul>
<p><strong>“B”为0</strong>，第二个字节包括以下定义：</p>
<ul>
<li><strong>0000 0110（06h）</strong>：复位并通过硬件写内容到从机的可编程部分。所有可以响应此类广播的从机，收到此两字节后，进行复位并进入它们地址的可编程部分。注意确保设备在加电后不会将SDA或SCL拉低，因为这些低电平会阻塞总线；</li>
<li><strong>0000 0100（04h）</strong>：通过硬件写内容到从机的可编程部分，作用类似（06h），但设备不会复位；</li>
<li><strong>0000 0000（00h）</strong>：这个不应该作为第二个字节用。</li>
</ul>
<p>编程时序参考相应设备的DATASHEET。</p>
<p><strong>“B”为1</strong>，两字节广播定义为“硬件广播”。主机（如键盘扫描器）在编程后，可以发送既定的从机地址到总线上，构成两字节序列的“硬件广播”。既然主机可能并不知道总线上从机的地址，它只能通过硬件广播的方式，将自身地址通知给系统。</p>
<p><img src="/images/i2c/tu16.png" alt="主发送器的数据传输格式"></p>
<p>硬件广播的第二个字节的前七位包括主机的地址。总线上的智能设备如微控制器，读取此地址并接收主机发送的其它信息。如果主机也可以作为从机使用，则以上读取的主机地址实际上也就是（切换主从模式后的）从机地址。</p>
<p>在系统中，一种可能是系统复位后设备由主机发送模式切换到从机接收模式，这时由系统主机先告诉硬件主机数据应送往的从机地址，这样当硬件主机发送数据时就可以直接向指定从机地址发送数据了。</p>
<p><strong>软件复位</strong></p>
<p>通用广播地址0000 0000后发送0000 0110（06h）可以使总线上设备进入复位过程。该功能是可选的，所有预留该功能的设备在收到该两字节序列（00 06h）后，开始响应（复位），并进入它们地址的可编程部分。注意确保设备在加电后不会将SDA或SCL拉低，因为这些低电平会阻塞总线。</p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>液晶显示器原理</title>
    <url>/2022/06/07/hardware/lcd/</url>
    <content><![CDATA[<h3 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a>LCD</h3><p>液晶（Liquid Crystal）是一种介于液态与结晶态之间的一种物质状态的高分子材料。液晶具有双折射性，使得能对偏振光选择性透过。</p>
<p>LCD是英文Liquid Crystal Display 的简称，指的是液晶显示屏。主要有TFT、UFB、TFD、STN等几种类型。其构造包括塑料球、玻璃球、边框胶、玻璃基板、上偏光片、定向层、液晶、导电ITO图案、导通点、IPO电极和下偏光片。</p>
<p><img src="/images/lcd/LCD-struct.jpeg" alt="TN"></p>
<p>两块偏光板相互垂直时光线就完全无法通过，液晶显示器就是在上下两片栅栏之间互垂直的偏光板之间充满液晶，利用电场控制液晶分子产生扭曲，从而对穿越其中的光线进行有规则的折射，来改变光的行进方向，如此一来，不同的电场大小，就会形成不同颜色。</p>
<p>因为液晶材料本身并不发光，所以在显示屏两边都设有作为光源的灯管，而在液晶显示屏背面有一块背光板和反光膜，背光板是由荧光物质组成的可以发射光线，其作用主要是提供均匀的背景光源。</p>
<p>液晶显示的原理基于液晶的透光率随其所施电压大小而变化的特性。当光通过下偏振片后，变成线性偏振光，偏振方向与偏振片振动方向一致，与上下玻璃基板上面液晶分子排列顺序一致。当光通过液晶层时，由于受液晶折射，线性偏振光被分解为两束光。又由于这两束光传播速度不同（相位相同），因而当两束光合成后，必然使振光的振动方向发生变化。通过液晶层的光，则被逐渐扭曲。当光达到上偏振片时，其光轴振动方向被扭曲了90度，且与上偏振片的振动方向保持一致。这样，光线通过上偏振片形成亮场。加上电压以后，液晶在电场作用下取向，扭曲消失。这时，通过下偏振片的线性偏振光，在液晶层不再旋转，无法通过上偏振片而形成暗场。可见液晶本身不发光，在外光源的调制下，才能显示，在整个显示过程中，液晶起到一个电压控制的光阀作用。</p>
<p>LCD依据驱动方式可分为静态驱动、简单矩阵驱动以及主动<br>矩阵驱动 3 种。其中简单矩阵型又可再细分扭转向列型(TN)和超扭转式向列型(STN)两种，而主动矩阵型则以薄膜式晶体管型(TFT)为主流。</p>
<p>NW(Normally white)是指当液晶面板不施加电压时，面板是亮的画面。另外一种， 液晶面板不施加电压时，面板无法透光, 看起来是黑色的，就称之为NB(Normally black)。</p>
<p><strong>可视角度</strong>指的是使用者能从不一样的方位清晰地看见荧幕上所有显示内容的角度。液晶显示器的可视角度左右对称，而上下则不一定对称。当背光源的入射光通过偏光板、液晶及取向膜后，输出光便具备了特定的方向特性。假如从一个非常斜的角度观看一个全白的画面，我们可能会看到黑色或是色彩失真。一般来说，上下角度要小于或等于左右角度。现在有些厂商就开发出各种广视角技术，试图改善液晶显示器的视角特性，如：IPS(In Plane Switching)、MVA(Multidomain Vertical Alignment)、TN+FILM。</p>
<h3 id="TFT"><a href="#TFT" class="headerlink" title="TFT"></a>TFT</h3><h2 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h2><p>OLED是Organic Light-Emitting Diode 的简称，中文名是有机发光二极管。</p>
<p>不同于LCD需要通过背光板照射才能显示，OLED是自发光。</p>
]]></content>
  </entry>
  <entry>
    <title>mipi接口</title>
    <url>/2022/06/07/hardware/mipi/</url>
    <content><![CDATA[<p>MIPI (Mobile Industry Processor Interface) 是2003年由ARM, Nokia, ST ,TI等公司成立的一个联盟，目的是把手机内部的接口如摄像头、显示屏接口、射频/基带接口等标准化，从而减少手机设计的复杂程度和增加设计灵活性。</p>
<p>MIPI联盟下面有不同的WorkGroup，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI、显示接口DSI、射频接口DigRF、麦克风 /喇叭接口SLIMbus等。统一接口标准的好处是手机厂商根据需要可以从市面上灵活选择不同的芯片和模组，更改设计和功能时更加快捷方便。下图是按照 MIPI的规划下一代智能手机的内部架构。</p>
<p><img src="/images/mipi/MIPI-Protocol-865x1024.png" alt="img"></p>
<h2 id="MIPI规范"><a href="#MIPI规范" class="headerlink" title="MIPI规范"></a>MIPI规范</h2><p>已经完成和正在计划中的规范如下:<br><a href="https://zh.wikipedia.org/wiki/MIPI#cite_note-Working_Groups:_Overview-1">https://zh.wikipedia.org/wiki/MIPI#cite_note-Working_Groups:_Overview-1</a></p>
<table>
<thead>
<tr>
<th><strong>工作组</strong></th>
<th><strong>规范名称</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Camera工作组</td>
<td>MIPI Camera Serial Interface 2 (MIPI CSI-2) v2.0 (March 2017)MIPI Camera Serial Interface 3 (MIPI CSI-3) v1.1 (March 2014)MIPI Camera Command Set (MIPI CCS) v1.0 (October 2017)</td>
</tr>
<tr>
<td>Device Descriptor Block工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>DigRF工作组</td>
<td>DigRF Baseband/RF Digital Interface Specification v4 (Feb. 2014)</td>
</tr>
<tr>
<td>Display工作组</td>
<td>DBI-2DPI-2DSI-2 v1.0 (January 2016)DCS</td>
</tr>
<tr>
<td>高速同步接口工作组</td>
<td>HSI 1.0</td>
</tr>
<tr>
<td>接口管理框架工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>低速多点连接工作组</td>
<td>SLIMbus v2.0 (August 2015)SoundWire v1.1 (August 2016)</td>
</tr>
<tr>
<td>NAND软件工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>物理层工作组</td>
<td>C-PHY v1.2 (March 2017)D-PHY v2.1 (March 2017)M-PHY v4.1 (March 2017)</td>
</tr>
<tr>
<td>软件工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>系统电源管理工作组</td>
<td>SPMI v2.0 (August 2012)</td>
</tr>
<tr>
<td>检测与调试工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>统一协议工作组</td>
<td>UniPro 1 point-to-point v1.61 (October 2015)PIE</td>
</tr>
</tbody></table>
<h3 id="DSI-CSI"><a href="#DSI-CSI" class="headerlink" title="DSI/CSI"></a>DSI/CSI</h3><p>MIPI是一个比较新的标准，其规范也在不断修改和改进，目前比较成熟的接口应用有DSI(显示接口)和CSI（摄像头接口）。CSI/DSI分别是指其承载的是针对Camera或Display应用，都有复杂的协议结构。以DSI为例，其协议层结构如下：</p>
<p><img src="/images/mipi/MIPI-DSI.png" alt="img"></p>
<p>CSI/DSI的物理层（Phy Layer）由专门的WorkGroup负责制定，其目前的标准是D-PHY。D-PHY采用1对源同步的差分时钟和1～4对差分数据线来进行数据传输。数据传输采用DDR方式，即在时钟的上下边沿都有数据传输。</p>
<p>D-PHY的物理层支持HS(High Speed)和LP(Low Power)两种工作模式。HS模式下采用低压差分信号，功耗较大，但是可以传输很高的数据速率（数据速率为80M～1Gbps）； LP模式下采用单端信号，数据速率很低（&lt;10Mbps），但是相应的功耗也很低。两种模式的结合保证了MIPI总线在需要传输大量数据（如图像） 时可以高速传输，而在不需要大数据量传输时又能够减少功耗。</p>
<p><img src="/images/mipi/MIPI-DPHY.png" alt="img"></p>
<p><a href="https://zhuanlan.zhihu.com/p/100476927">https://zhuanlan.zhihu.com/p/100476927</a></p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>mipi</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel mmu</title>
    <url>/2022/06/07/hardware/mmu/</url>
    <content><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存管理单元(MMU)的作用是控制和管理多个进程，使之能够安全的共享主内存区域，为各进程实现虚拟地址和物理地址转换、内存访问权限保护等功能，这将使得操作系统能单独为系统的每个用户进程分配独立的内存空间并保证用户空间不能访问内核空间的地址。</p>
<p>在 32 位系统上，Linux 内核将 4G 空间分为 1G 内核空间(3<del>4G)和 3G(0</del>3G)用户空间，通过内存管理，每个进程都可以使用 3G 的用户空间。</p>
<p><img src="/images/kernel/kernel/mmu.png" alt="mmu"></p>
<h3 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h3><p><strong>逻辑地址</strong>是由程式产生的和段相关的偏移地址部分。机器语言指令中出现的内存地址，都是逻辑地址。编译器编译程序时，会为程序生成代码段和数据段，然后将所有代码放到代码段中，将所有数据放到数据段中。最后程序中的每句代码和每条数据都会有自己的逻辑地址。</p>
<p><strong>线性地址</strong>是逻辑地址到物理地址变换之间的中间物。段中的偏移地址，加上段基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址能再变换成物理地址。</p>
<p>CPU加载程序后，会为程序分配代码段内存和数据段内存，代码段内存的基址保存在CS中，数据段内存的基址保存在DS中。</p>
<p><strong>物理地址</strong>是CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果没有启用分页机制，物理地址等于线性地址。</p>
<p><strong>虚拟地址与物理地址转化</strong></p>
<p>要将一个逻辑地址转换为物理地址，需要两步：首先利用段式内存管理单元将逻辑地址转换成线性地址，再利用页式内存管理单元，把线性地址转换为物理地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">phys_addr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*内核虚拟地址转化为物理地址*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">phys_addr_t</span> <span class="title function_">virt_to_phys</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __virt_to_phys((<span class="type">unsigned</span> <span class="type">long</span>)(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*物理地址转化为内核虚拟地址*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">phys_to_virt</span><span class="params">(<span class="type">phys_addr_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)__phys_to_virt(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h3><p>因为intel的CPU有20位的地址总线，而寄存器16位，要寻址2^20^=1M的内存空间，只能采用分段管理。线性地址 = 段基址 * 16 + 逻辑地址</p>
<h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><p>CPU的页式内存管理单元负责把线性地址转换为物理地址。从管理和效率的角度出发，线性地址被分为固定长度单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，用4KB为一个页来划分，整个线性地址就被划分为共有2^20^个页的数组，我们称之为页目录。目录中的每一个目录项，就是对应的页的地址。这个数组有2^20^个成员，每个成员是一个地址（32位机，一个地址4字节），那么要表示这个数组，就要4MB的内存空间。为了节省空间，引入二级管理模式来组织分页单元。</p>
<p><img src="/images/kernel/kernel/mmu_page.jpg" alt="img"></p>
<p><strong>每个进程都有其独立的虚似内存，拥有惟一的页目录和页表</strong>，它的地址放在CPU的cr3寄存器中，是进行地址转换的开始点。每一个32位的线性地址被划分为三部分：页目录索引(10位)、页表索引(10位)、偏移(12位) 。依据以下步骤进行转换：</p>
<ol>
<li><p>从cr3中取出进程的页目录地址。</p>
</li>
<li><p>根据线性地址的页目录索引，找到页表地址。</p>
</li>
<li><p>根据线性地址的页表索引，在页表中找到页的起始地址。</p>
</li>
<li><p>将页的起始地址与线性地址中的偏移相加。</p>
</li>
</ol>
<p>在二级管理模式中，页目录共有2^10^项，每项有2^10^个页表，每个页中可寻址2^12^个字节，2^10^ * 2^10^ * 2^12^ = 2^32^ = 4GB。能够表示4G的地址。同时页目录项和页表项共占空间 (2^10 * 4 + 2 ^10 *4) = 8KB，节省了空间。</p>
<p><strong>Linux的页式内存管理</strong></p>
<p>有些CPU，还有三级，甚至四级架构，Linux为了在更高层次提供抽像，为每个CPU提供统一的界面。提供了一个四层页管理架构，来兼容这些二级、三级、四级管理架构的CPU。这四级分别为： 页全局目录PGD、页上级目录PUD、页中间目录PMD、页表PT。 整个转换依据硬件转换原理，多了二次数组的索引。</p>
<p><img src="/images/kernel/kernel/mmu_page2.jpg" alt="img"></p>
<p>逻辑地址、线性地址和物理地址之间的变换过程如下图所示：</p>
<p><img src="/images/kernel/kernel/mem_t.jpg" alt="虚拟地址、线性地址和物理地址的转换"></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>Linux采用虚拟内存管理技术，使得每个进程都有独立的进程地址空间，Linux将4GB的虚拟内存空间分成两个部分：0 ~ 3GB属于用户空间，3 ~ 4GB 属于内核空间。用户进程只能访问用户空间，只能通过系统调用访问内核空间。</p>
<p><img src="/images/kernel/kernel/user_space.png" alt="img"></p>
<p>用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。</p>
<p>内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。</p>
<p>进程 fork(),execve(),malloc()等操作分配的内存仅仅是虚拟内存。只有当进程真正去访问地址时，才会产生缺页异常，内核才会为进程分配物理页，并建立对应的页表。</p>
<h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>ARM处理器分为7种工作模式:</p>
<ul>
<li>用户模式(usr)：大多数的应用程序运行在用户模式下,当处理器运行在用户模式下时,某些被保护的系统资源是不能被访问的。</li>
<li>快速中断模式(fiq)：用于高速数据传输或通道处理。</li>
<li>外部中断模式(irq)：用于通用的中断处理。</li>
<li>管理模式(svc)：操作系统使用的保护模式。</li>
<li>数据访问终止模式(abt)：当数据或指令预取终止时进入该模式,可用于虚拟存储及存储保护。</li>
<li>系统模式(sys)：运行具有特权的操作系统任务。</li>
<li>未定义指令中止模式(und)：当未定义的指令执行时进入该模式,可用于支持硬件协处理器的软件仿真。</li>
</ul>
<p>Linux为了保护内核的安全，只使用处理器的2个模式，把系统分成了2部分。内核可进行任何操作，特权指令只能在内核态使用，从而起到保护作用。而应用程序则被禁止对硬件的直接访问和对内存的未授权访问。内核空间和用户空间使用不同的地址空间。用户空间只能通过系统调用和硬件中断转移到内核空间。</p>
<p>Linux 中 1GB 的内核地址空间又被划分为物理内存映射区、虚拟内存分配区、高端页面映射区、专用页面映射区和系统保留映射区这几个区域。</p>
<p>物理内存映射区是从3G开始最896MB的线性空间，物理内存顺序映射在这个区域中，虚拟地址 = 3G + 物理地址。</p>
<p>动态内存映射区由vmalloc()分配，其线性空间连续，但物理空间不一定连续，可能处于低端内存，也可能处于高端内存。</p>
<p>超过直接映射区896MB的那部分内存称为高端内存，内核在存取高端内存时必须将它们映射到高端页面映射区。内核空间最顶部 FIXADDR_TOP~4GB 的区域作为保留区。</p>
<p>内核空间与用户空间的内存不能直接互访，必需借助函数 <code>copy_from_user()</code>完成用户空间到内核空间的拷贝，以及<code>copy_to_user()</code>完成内核空间到用户空间的拷贝。如果要复制的内存是简单类型，如char、int、long等，则可以使用<code>put_user()</code>和<code>get_user()</code>。宏__user 是一个指向用户空间地址的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __user  __attribute__((noderef, address_space(1)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> __user *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line"></span><br><span class="line">put_user(val, <span class="type">void</span> __user *ptr); <span class="comment">/* 内核→用户 */</span></span><br><span class="line">get_user(val, <span class="type">void</span> __user *ptr); <span class="comment">/* 用户→内核 */</span></span><br></pre></td></tr></table></figure>

<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *objp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">kzalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">return</span> kmalloc(size, flags | __GFP_ZERO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kmalloc在物理内存映射区域申请一个连续存储空间，保留内存原有的数据，不清零。分配的内存最小32Byte，最大128KB。flags参数：</p>
<ul>
<li>GFP_ATOMIC  原子性分配内存，分配内存的过程不会被高优先级进程或中断打断。若不存在空闲页，则不等待，直接返回。</li>
<li>GFP_KERNEL  在内核空间的进程中申请内存，若不存在空闲页会引起阻塞，因此不能在中断上下文或持有自旋锁时使用。</li>
<li>GFP_DMA  给DMA控制器分配内存（DMA要求分配虚拟地址和物理地址连续）。</li>
</ul>
<p>kzalloc() 会对申请到的内存内容清零。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>

<p>vmalloc() 能在高端内存区分配，用来分配虚拟地址空间连续，而物理地址不一定连续的内存。常用于申请大内存空间。因为要建立新的页表，将不连续的物理内存映射成连续的虚拟内存，所以开销比较大。分配内存时则可能产生阻塞，因此不能从中断上下文调用。</p>
<h2 id="I-O端口"><a href="#I-O端口" class="headerlink" title="I/O端口"></a>I/O端口</h2><p>设备通常会提供一组寄存器来用于控制设备、读写设备和获取设备状态，即控制寄存器、数据寄存器和状态寄存器。这些寄存器可能位于 I/O 空间，也可能位于内存空间。当位于 I/O 空间时，通常被称为 I/O 端口，端口号标识了外设的寄存器地址。位于内存空间时，对应的内存空间被称为 I/O 内存。内存空间是必须的，而 I/O 空间是可选的。</p>
<p>I/O 端口访问的一种途径是直接使用 I/O 端口操作函数，在设备打开或驱动模块被加载时申请<br>I/O 端口区域，之后使用 inb()、outb()等进行端口访问，最后在设备关闭或驱动被卸载时释放 I/O<br>端口范围。</p>
<img src=".img/mem/io_port.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">request_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">release_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>request_region()函数向内核申请n个端口，这些端口从start开始，name 参数为设备的名称。如果返回NULL，则意味着申请端口失败。可以用来检查申请的资源是否可用，如果申请成功，则将其标志为已经使用，其他驱动再申请该资源时就会失败。</p>
<p>release_region()函数用来释放申请的IO资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*读写字节端口(8 位宽)*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">inb</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte, <span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写字端口(16 位宽)*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">inw</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outw</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> word, <span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写长字端口(32 位宽)*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">inl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> longword, <span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写一串字节*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insb</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsb</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写一串字*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insw</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsw</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写一串长字*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><code>/proc/ioports</code>显示使用request_region( )分配的IO端口的情况。</p>
<h2 id="I-O内存"><a href="#I-O内存" class="headerlink" title="I/O内存"></a>I/O内存</h2><p>I/O 内存的访问步骤：首先是调用 request_mem_region()申请资源，接着将寄存器地址通过 ioremap()映射到内核空间虚拟地址，之后就可以通过 Linux 设备访问编程接口访问这些设备的寄存器了。访问完成后，应对 ioremap()申请的虚拟地址进行释放，并释放 release_mem_<br>region()申请的 I/O 内存资源。</p>
<p><img src="/images/kernel/mem/io_mem.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">request_mem_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">release_mem_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __iomem *<span class="title function_">ioport_map</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioport_unmap</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __iomem *<span class="title function_">ioremap</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> physaddr, <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">void</span> __iomem * <span class="title function_">ioremap_nocache</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iounmap</span><span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span>;</span><br></pre></td></tr></table></figure>

<p>ioremap()函数将设备所处的物理地址映射到虚拟地址。</p>
<p>ioremap_nocache()返回一个线性地址，此时CPU可以访问设备的内存空间。<em>phys_addr</em>要映射的物理地址 ；<em>size</em>要映射资源的大小。返回的映射地址必须使用<code>iounmap</code>来释放。</p>
<p>ioport_map()函数可以把 port 开始的 count 个连续的 I/O 端口重映射为一段内存空间，然后就可以在其返回的地址上像访问 I/O 内存一样访问这些 I/O 端口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*读I/O内存*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ioread8</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ioread16</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ioread32</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">readb</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> __force *)addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">readw</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> le16_to_cpu(*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> __force *)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">readl</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> le32_to_cpu(*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> __force *)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*写I/O内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8</span><span class="params">(u8 val, <span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8</span><span class="params">(u16 val, <span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8</span><span class="params">(u32 val, <span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*读一串 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ioread8_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioread16_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioread32_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写一串 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite16_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite32_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*复制 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy_fromio</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *from, <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy_toio</span><span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memset_io</span><span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr, <span class="type">unsigned</span> <span class="type">char</span> val, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><code>/proc/iomem</code>文件记录物理地址的分配情况，这些地址范围是通过 requset_mem_region 函数申请得到的。</p>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA 是一种无需 CPU 的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制。因为DMA的目的地址与Cache 所缓存的内存地址可能重叠，所以要禁止 DMA 目标地址范围内内存的Cache 功能。</p>
<p>DMA 操作在整个常规内存区域进行，DMA 的硬件使用总线地址而非物理地址。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>modbus协议</title>
    <url>/2022/06/07/hardware/modbus/</url>
    <content><![CDATA[<h2 id="Modbus"><a href="#Modbus" class="headerlink" title="Modbus"></a>Modbus</h2><p>Modbus协议是一种广泛应用于工业控制领域的通用通讯协议，使用的是主从通讯技术，即由主设备主动查询和操作从设备。通讯物理接口可以选用串口（包括RS232、RS485和RS422），也可以选择以太网口。有三种通信方式：</p>
<ul>
<li>以太网：对应的通信模式是MODBUS TCP/IP。</li>
<li>异步串行传输（各种介质如有线RS-232-/422/485/；光纤、无线等），对应的通信模式是MODBUS RTU或MODBUS ASCII。</li>
<li>高速令牌传递网络：对应的通信模式是Modbus PLUS</li>
</ul>
<h3 id="ASCII模式"><a href="#ASCII模式" class="headerlink" title="ASCII模式"></a>ASCII模式</h3><p><img src="/images/uart/Modbus-frame-structure-ASCII-mode.jpg" alt="Modbus帧结构-ASCII模式"></p>
<p>在ASCII模式下，消息以冒号（:）字符（ASCII码 3AH）开始，以回车换行符结束（ASCII码 0DH,0AH）。其它域可以使用的传输字符是十六进制的0…9,A…F。网络上的设备不断侦测“:”字符，当有一个冒号接收到时，每个设备都解码地址域来判断是否发给自己的。消息中字符间发送的时间间隔最长不能超过1秒，否则接收的设备将认为传输错误。</p>
<p>错误检测域包含两个ASCII字符，使用LRC（纵向冗长检测）方法对消息内容计算得出的，不包括开始的冒号符及回车换行符。</p>
<h3 id="RTU模式"><a href="#RTU模式" class="headerlink" title="RTU模式"></a>RTU模式</h3><p><img src="/images/uart/RTU.bmp" alt="RTU报文帧"></p>
<p><img src="/images/uart/1.5T.jpg" alt="img"></p>
<p>RTU模式规定消息发送至少要以3.5个字符时间的停顿间隔开始。至少3.5个字符时间的停顿标定了消息的结束。消息帧内字节间隔为1.5个字符时间。</p>
<p>从设备的地址范围是1~247，地址0是用作广播地址。主设备通过将要联络的从设备的地址放入消息中的地址域来选通从设备。当从设备发送回应消息时，它把自己的地址放入回应的地址域中，以便主设备知道是哪一个设备作出回应。</p>
<h3 id="功能码"><a href="#功能码" class="headerlink" title="功能码"></a>功能码</h3><p>Modbus的操作对象有四种：线圈、离散输入、输入寄存器、保持寄存器。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>线圈</td>
<td>1bit，ON或OFF，可读可写，有效的地址范围是1-9999</td>
</tr>
<tr>
<td>离散量</td>
<td>1bit，ON或OFF，只读，有效地址范围是10001-19999</td>
</tr>
<tr>
<td>输入寄存器</td>
<td>16位的寄存器，只读，可以用作模拟量或16位打包输入点，有效地址范围是30001-39999</td>
</tr>
<tr>
<td>保持寄存器</td>
<td>16位的寄存器，可读可写，既可以是一个模拟量或16位打包输入点，也可以是模拟量或16位打包输出点，有效地址范围是40001-49999</td>
</tr>
</tbody></table>
<p>Modbus的功能码有：</p>
<table>
<thead>
<tr>
<th>功能码</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>读线圈状态</td>
<td>读位（读N个bit）—读从机线圈寄存器，位操作</td>
</tr>
<tr>
<td>02</td>
<td>读输入离散量</td>
<td>读位（读N个bit）—读离散输入寄存器，位操作</td>
</tr>
<tr>
<td>03</td>
<td>读多个寄存器</td>
<td>读整型、字符型、状态字、浮点型（读N个words）—读保持寄存器，字节操作</td>
</tr>
<tr>
<td>04</td>
<td>读输入寄存器</td>
<td>读整型、状态字、浮点型（读N个words）—读输入寄存器，字节操作</td>
</tr>
<tr>
<td>05</td>
<td>写单个线圈</td>
<td>写位（写一个bit）—写线圈寄存器，位操作</td>
</tr>
<tr>
<td>06</td>
<td>写单个保持寄存器</td>
<td>写整型、字符型、状态字、浮点型（写一个word）—写保持寄存器，字节操作</td>
</tr>
<tr>
<td>07</td>
<td>读取异常状态</td>
<td>取得8个内部线圈的通断状态，这8个线圈的地址由控制器决定，用户逻辑可以将这些线圈定义，以说明从机状态，短报文适宜于迅速读取状态</td>
</tr>
<tr>
<td>08</td>
<td>回送诊断校验</td>
<td>把诊断校验报文送从机，以对通信处理进行评鉴</td>
</tr>
<tr>
<td>09</td>
<td>编程（只用于484）</td>
<td>使主机模拟编程器作用，修改PC从机逻辑</td>
</tr>
<tr>
<td>0A</td>
<td>控询（只用于484）</td>
<td>可使主机与一台正在执行长程序任务从机通信，探询该从机是否已完成其操作任务，仅在含有功能码9的报文发送后，本功能码才发送</td>
</tr>
<tr>
<td>0B</td>
<td>读取事件计数</td>
<td>可使主机发出单询问，并随即判定操作是否成功，尤其是该命令或其他应答产生通信错误时</td>
</tr>
<tr>
<td>0C</td>
<td>读取通讯事件记录</td>
<td>可是主机检索每台从机的ModBus事务处理通信事件记录。如果某项事务处理完成，记录会给出有关错误</td>
</tr>
<tr>
<td>0D</td>
<td>编程（184/384/484/584）</td>
<td>可使主机模拟编程器功能修改PC从机逻辑</td>
</tr>
<tr>
<td>0E</td>
<td>探询（184/384/484/584）</td>
<td>可使主机与正在执行任务的从机通信，定期控询该从机是否已完成其程序操作，仅在含有功能13的报文发送后，本功能码才得发送</td>
</tr>
<tr>
<td>0F</td>
<td>写多个线圈</td>
<td>可以写多个线圈—强置一串连续逻辑线圈的通断</td>
</tr>
<tr>
<td>10</td>
<td>写多个保持寄存器</td>
<td>写多个保持寄存器—把具体的二进制值装入一串连续的保持寄存器</td>
</tr>
<tr>
<td>11</td>
<td>报告从机标识</td>
<td>可使主机判断编址从机的类型及该从机运行指示灯的状态</td>
</tr>
<tr>
<td>12</td>
<td>（884和MICRO84）</td>
<td>可使主机模拟编程功能，修改PC状态逻辑</td>
</tr>
<tr>
<td>13</td>
<td>重置通信链路</td>
<td>发生非可修改错误后，是从机复位于已知状态，可重置顺序字节</td>
</tr>
<tr>
<td>14</td>
<td>读取通用参数（584L）</td>
<td>显示扩展存储文件中的数据信息</td>
</tr>
<tr>
<td>15</td>
<td>写入通用参数（584L）</td>
<td>把通用参数写入扩展存储文件</td>
</tr>
<tr>
<td>16~40</td>
<td>保留做扩展功能备用</td>
<td></td>
</tr>
<tr>
<td>41~48</td>
<td>保留以备用户功能所用</td>
<td>留作用户功能的扩展编码</td>
</tr>
<tr>
<td>49~77</td>
<td>非法功能</td>
<td></td>
</tr>
<tr>
<td>78~7F</td>
<td>保留</td>
<td>留作内部作用</td>
</tr>
<tr>
<td>80~FF</td>
<td>保留</td>
<td>用于异常应答</td>
</tr>
</tbody></table>
<p>常用功能码如下：</p>
<table>
<thead>
<tr>
<th>功能码</th>
<th>名称</th>
<th>功能</th>
<th>对应的地址类型</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>读线圈状态</td>
<td>读位（读N个bit）—读从机线圈寄存器，位操作</td>
<td>0x</td>
</tr>
<tr>
<td>02</td>
<td>读输入离散量</td>
<td>读位（读N个bit）—读离散输入寄存器，位操作</td>
<td>1x</td>
</tr>
<tr>
<td>03</td>
<td>读多个寄存器</td>
<td>读整型、字符型、状态字、浮点型（读N个words）—读保持寄存器，字节操作</td>
<td>4X</td>
</tr>
<tr>
<td>04</td>
<td>读输入寄存器</td>
<td>读整型、状态字、浮点型（读N个words）—读输入寄存器，字节操作</td>
<td>3x</td>
</tr>
<tr>
<td>05</td>
<td>写单个线圈</td>
<td>写位（写一个bit）—写线圈寄存器，位操作</td>
<td>0x</td>
</tr>
<tr>
<td>06</td>
<td>写单个保持寄存器</td>
<td>写整型、字符型、状态字、浮点型（写一个word）—写保持寄存器，字节操作</td>
<td>4x</td>
</tr>
<tr>
<td>0F</td>
<td>写多个线圈</td>
<td>写位（写n个bit）—强置一串连续逻辑线圈的通断</td>
<td>0x</td>
</tr>
<tr>
<td>10</td>
<td>写多个保持寄存器</td>
<td>写整形、字符型、状态字、浮点型（写n个word）—把具体的二进制值装入一串连续的保持寄存器</td>
<td>4x</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>modbus</tag>
      </tags>
  </entry>
  <entry>
    <title>Media Independent Interface</title>
    <url>/2022/06/07/hardware/mii/</url>
    <content><![CDATA[<h2 id="MII"><a href="#MII" class="headerlink" title="MII"></a>MII</h2><p>MII（Media Independent Interface）即媒体独立接口，MII接口是MAC与PHY连接的标准接口。它是IEEE-802.3定义的以太网行业标准。MII接口提供了MAC与PHY之间、PHY与STA(Station Management)之间的互联技术，该接口支持10Mb/s与100Mb/s的数据传输速率，单向传输的数据线有4根，整个接口由14根线组成。媒体独立的意思，是指不管铜轴、光纤、电缆等媒体的变化，媒体处理的相关工作都由PHY和MAC的芯片完成。</p>
<p>MII接口主要包括四个部分。一是从MAC层到PHY层的发送数据接口，二是从PHY层到MAC层的接收数据接口，三是从PHY层到MAC层的状态指示信号，四是MAC层和PHY层之间传送控制和状态信息的MDIO接口。</p>
<p><img src="/images/net/mii/MII.jpg" alt="MII"></p>
<ul>
<li><p>TXD[3:0]：数据发送信号，共4根信号线；</p>
</li>
<li><p>TX_CLK：发送数据使用的时钟信号，对于10M位/s的数据传输，此时钟为2.5MHz，对于100M位/s的数据传输，此时钟为25MHz。</p>
</li>
<li><p>TX_ER（transmit coding error）： TX_ER同步于TX_CLK，在数据传输过程中，如果TX_ER有效超过一个时钟周期，并且此时TX_EN是有效的，则数据通道中传输的数据是无效的，没用的。注：当TX_ER有效并不影响工作在10Mb/s的PHY或者TX_EN无效时的数据传输。在MII接口的连线中，如果TX_ER信号线没有用到，必须将它下拉接地。</p>
</li>
<li><p>TX_EN：传输使能信号，此信号必需与数据前导符的起始位同步出现，并在传输完毕前一直保持。</p>
</li>
<li><p>TXD[3:0]：发送数据线，每次传输4位数据，数据在TX_EN信号有效时有效。当TX_EN信号无效时，PHY忽略传输的数据。</p>
</li>
<li><p>RX_CLK：接收数据使用的时钟信号，对于10M位/s的数据传输，此时钟为2.5MHz，对于100M位/s的数据传输，此时钟为25MHz。</p>
</li>
<li><p>RXD[3:0]：接收数据线，每次接收4位数据，数据在RX_DV信号有效时有效。当RX_EN无效，而RX_ER有效时，RXD[3:0]数据值代表特定的信息。</p>
</li>
<li><p>RX_DV：接收数据使能信号，由PHY控制，当PHY准备好数据供MAC接收时，使能该信号。此信号必需和帧数据的首位同步出现，并保持有效直到数据传输完成。在传送最后4位数据后的第一个时钟之前，此信号必需变为无效状态。为了正确的接收一个帧，有效电平不能滞后于数据线上的SFD位出现。</p>
</li>
<li><p>RX_ER：接收出错信号，保持一个或多个时钟周期(RX_CLK)的有效状态，表明MAC在接收过程中检测到错误。具体错误原因需配合RX_DV的状态及RXD[3:0]的数据值。</p>
</li>
<li><p>CRS：载波侦听信号，仅工作在半双工模式下，由PHY控制，当发送或接收的介质非空闲时，使能此信号。 PHY必需保证CRS信号在发生冲突的整个时间段内都保持有效，不需要此信号与发送/接收的时钟同步。</p>
</li>
<li><p>COL：冲突检测信号，仅工作在半双工模式下，由PHY控制，当检测到介质发生冲突时，使能此信号，并且在整个冲突的持续时间内，保持此信号有效。此信号不需要和发送/接收的时钟同步。</p>
</li>
<li><p>MDC：配置接口时钟。</p>
</li>
<li><p>MDIO：配置接口I/O，是PHY和STA之间的双向信号。 它用于在PHY和STA之间传输控制信息和状态。 控制信息由STA同步地针对MDC驱动并且由PHY同步地采样。 状态信息由PHY针对MDC同步驱动并由STA同步采样。需要1.5K电阻上拉。</p>
</li>
</ul>
<p>MII接口的类型有很多，常用的有MII、RMII、SMII、SSMII、SSSMII、GMII、RGMII、SGMII、TBI、RTBI、XGMII、XAUI、XLAUI等。</p>
<table>
<thead>
<tr>
<th></th>
<th>MII</th>
<th>RMII</th>
<th>GMII</th>
<th>RGMII</th>
<th>SMII</th>
</tr>
</thead>
<tbody><tr>
<td>传输速度</td>
<td>100/10M</td>
<td>100/10M</td>
<td>1000/100/10M</td>
<td>1000/100/10M</td>
<td>100M</td>
</tr>
<tr>
<td>单向数据线数</td>
<td>4</td>
<td>2</td>
<td>8</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>时钟速率</td>
<td>25/2.5M</td>
<td>50/5M</td>
<td>25/2.5M</td>
<td>125/25/2.5M</td>
<td>125M</td>
</tr>
</tbody></table>
<h2 id="RMII"><a href="#RMII" class="headerlink" title="RMII"></a>RMII</h2><p>RMII即Reduced MII，是简化的MII接口。连线数量由MII的16根减少为8根，对于10Mbps线速，MII的时钟速率是2.5MHz就可以了，RMII则需要5MHz；对于100Mbps线速，MII需要的时钟速率是25MHz，RMII则是50MHz。</p>
<p><img src="/images/net/mii/RMII.jpg" alt="RMII"></p>
<ul>
<li><p>TXD[1:0]：数据发送信号线，数据位宽为2</p>
</li>
<li><p>RXD[1:0]：数据接收信号线，数据位宽为2</p>
</li>
<li><p>TX_EN(Transmit Enable)：数据发送使能信号</p>
</li>
<li><p>RX_ER(Receive Error)：数据接收错误提示信号</p>
</li>
<li><p>CLK_REF：是由外部时钟源提供的50MHz参考时钟，与MII接口不同，MII接口中的接收时钟和发送时钟是分开的，而且都是由PHY芯片提供给MAC芯片的。这里需要注意的是，由于数据接收时钟是由外部晶振提供而不是由载波信号提取的，所以在PHY层芯片内的数据接收部分需要设计一个FIFO，用来协调两个不同的时钟,在发送接收的数据时提供缓冲。PHY层芯片的发送部分则不需要FIFO，它直接将接收到的数据发送到MAC就可以了。</p>
</li>
<li><p>CRS_DV：此信号是由MII接口中的RX_DV和CRS两个信号合并而成。当介质不空闲时，CRS_DV和RE_CLK相异步的方式给出。当CRS比RX_DV早结束时(即载波消失而队列中还有数据要传输时)，就会出现CRS_DV在半位元组的边界以25MHz/2.5MHz的频率在0、1之间的来回切换。因此，MAC能够从 CRS_DV中精确的恢复出RX_DV和CRS。</p>
</li>
</ul>
<p>在100Mbps速率时，TX/RX每个时钟周期采样一个数据；在10Mbps速率时，TX/RX每隔10个周期采样一个数据，因而TX/RX数据需要在数据线上保留10个周期，相当于一个数据发送10次。</p>
<p>当PHY层芯片收到有效的载波信号后，CRS_DV信号变为有效，此时如果FIFO中还没有数据，则它会发送出全0的数据给MAC，然后当FIFO中填入有效的数据帧，数据帧的开头是“101010—”交叉的前导码，当数据中出现“01”的比特时，代表正式数据传输开始，MAC芯片检测到这一变化，从而开始接收数据。</p>
<p>当外部载波信号消失后，CRS_DV会变为无效，但如果FIFO中还有数据要发送时，CRS_DV在下一周期又会变为有效，然后再无效再有效，直到FIFO中数据发送完为止。在接收过程中如果出现无效的载波信号或者无效的数据编码，则RX_ER会变为有效，表示物理层芯片接收出错。</p>
<h2 id="SMII"><a href="#SMII" class="headerlink" title="SMII"></a>SMII</h2><p>SMII即Serial MII，串行MII的意思，跟RMII相比，连线进一步减少到4根。只用一根信号线传送发送数据，一根信号线传输接受数据，所以在时钟上为了满足100的需求，它的时钟频率高达到125M，数据线里面还会传送一些控制信息。所有端口的数据收发都公用同一个外部的125M时钟。</p>
<p><img src="/images/net/mii/SMII.jpg" alt="SMII"></p>
<ul>
<li>TXD：发送数据信号，位宽为1；</li>
<li>RXD：接收数据信号，位宽为1；</li>
<li>SYNC：收发数据同步信号，每10个时钟周期置1次高电平，指示同步。</li>
<li>CLK_REF：所有端口共用的一个参考时钟，频率为125MHz，为什么100Mbps速率要用125MHz时钟？因为在每8位数据中会插入2位控制信号，请看下面介绍。</li>
</ul>
<p>TXD/RXD以10比特为一组，以SYNC为高电平来指示一组数据的开始，在SYNC变高后的10个时钟周期内，TXD上依次输出的数据是：TXD[7:0]、TX_EN、TX_ER，控制信号的含义与MII接口中的相同；RXD上依次输出的数据是：RXD[7:0]、RX_DV、CRS，RXD[7:0]的含义与RX_DV有关，当RX_DV为有效时(高电平)，RXD[7:0]上传输的是物理层接收的数据。当RX_DV为无效时(低电平)，RXD[7:0]上传输的是物理层的状态信息数据。见下表：</p>
<p><img src="/images/net/mii/SMII2.jpg" alt="img"></p>
<p>当速率为10Mbps时，每一组数据要重复10次，MAC/PHY芯片每10个周期采样一次。MAC/PHY芯片在接收到数据后会进行串/并转换。</p>
<h2 id="SSMII"><a href="#SSMII" class="headerlink" title="SSMII"></a>SSMII</h2><p>SSMII即Serial Sync MII，叫串行同步接口，跟SMII接口很类似，只是收发使用独立的参考时钟和同步时钟，不再像SMII那样收发共用参考时钟和同步时钟，传输距离比SMII更远。</p>
<p><img src="/images/net/mii/SSMII.jpg" alt="img"></p>
<h2 id="SSSMII"><a href="#SSSMII" class="headerlink" title="SSSMII"></a>SSSMII</h2><p>SSSMII即Source Sync Serial MII，叫源同步串行MII接口，SSSMII与SSMII的区别在于参考时钟和同步时钟的方向，SSMII的TX/RX参考时钟和同步时钟都是由PHY芯片提供的，而SSSMII的TX参考时钟和同步时钟是由MAC芯片提供的，RX参考时钟和同步时钟是由PHY芯片提供的，所以顾名思义叫源同步串行。</p>
<p><img src="/images/net/mii/SSSMII.jpg" alt="img"></p>
<h2 id="GMII"><a href="#GMII" class="headerlink" title="GMII"></a>GMII</h2><p>GMII(Gigabit MII)是千兆网的MII接口。GMII采用8位接口数据，工作时钟125MHz，因此传输速率可达1000Mbps。同时兼容MII所规定的10/100 Mbps工作方式。GMII接口数据结构符合IEEE 802.3-2000以太网标准。</p>
<p>与MII接口相比，GMII的数据宽度由4位变为8位，GMII接口中的控制信号如TX_ER、TX_EN、RX_ER、RX_DV、CRS和COL的作用同MII接口中的一样，发送参考时钟GTX_CLK和接收参考时钟RX_CLK的频率均为125MHz(1000Mbps/8=125MHz)。</p>
<p>发送参考时钟GTX_CLK，它和MII接口中的TX_CLK是不同的，MII接口中的TX_CLK是由PHY芯片提供给MAC芯片的，而GMII接口中的GTX_CLK是由MAC芯片提供给PHY芯片的。两者方向不一样。绝大多数GMII接口都是兼容MII接口的，所以GMII接口都有两个发送参考时钟：TX_CLK和GTX_CLK(两者方向不一样)，在用作MII模式时，使用TX_CLK和8根数据线中的4根。</p>
<p><img src="/images/net/mii/GMII.jpg" alt="GMII"></p>
<p>在千兆速率下，向PHY提供GTXCLK信号、TXD、TXEN、TXER信号与此时钟信号同步。否则在10/100Mbps速率下，PHY提供TXCLK时钟信号，其它信号与此信号同步。其工作频率为25MHz(100M网络)或2.5MHz(10M网络)。</p>
<h2 id="RGMII"><a href="#RGMII" class="headerlink" title="RGMII"></a>RGMII</h2><p>RGMII即Reduced GMII，是GMII的简化版本，将接口信号线数量从24根减少到14根，时钟频率仍旧为125MHz，TX/RX数据宽度从8为变为4位，为了保持1000Mbps的传输速率不变，RGMII接口在时钟的上升沿和下降沿都采样数据。在参考时钟的上升沿发送GMII接口中的TXD[3:0]/RXD[3:0]，在参考时钟的下降沿发送GMII接口中的TXD[7:4]/RXD[7:4]。RGMI同时也兼容100Mbps和10Mbps两种速率，此时参考时钟速率分别为25MHz和2.5MHz。</p>
<p>TX_EN信号线上传送TX_EN和TX_ER两种信息，在TX_CLK的上升沿发送TX_EN，下降沿发送TX_ER；同样的，RX_DV信号线上也传送RX_DV和RX_ER两种信息，在RX_CLK的上升沿发送RX_DV，下降沿发送RX_ER。</p>
<p><img src="/images/net/mii/RGMII.jpg" alt="RGMII"></p>
<p><img src="/images/net/mii/RGMII2.jpg" alt="img"></p>
<h2 id="SGMII"><a href="#SGMII" class="headerlink" title="SGMII"></a>SGMII</h2><p>SGMII即Serial GMII，串行GMII，收发各一对差分信号线，时钟频率625MHz，在时钟信号的上升沿和下降沿均采样，参考时钟RX_CLK由PHY提供，是可选的，主要用于MAC侧没有时钟的情况，一般情况下，RX_CLK不使用。收发都可以从数据中恢复出时钟。</p>
<p>在TXD发送的串行数据中，每8比特数据会插入TX_EN/TX_ER 两比特控制信息，同样，在RXD接收数据中，每8比特数据会插入RX_DV/RX_ER 两比特控制信息，所以总的数据速率为1.25Gbps=625Mbps*2。</p>
<p>其实，大多数MAC芯片的SGMII接口都可以配置成SerDes接口(在物理上完全兼容，只需配置寄存器即可)，直接外接光模块，而不需要PHY层芯片，此时时钟速率仍旧是625MHz，不过此时跟SGMII接口不同，SGMII接口速率被提高到1.25Gbps是因为插入了控制信息，而SerDes端口速率被提高是因为进行了8B/10B变换，本来8B/10B变换是PHY芯片的工作，在SerDes接口中，因为外面不接PHY芯片，此时8B/10B变换在MAC芯片中完成了。8B/10B变换的主要作用是扰码，让信号中不出现过长的连“0”和连“1”情况，影响时钟信息的提取，关于8B/10B变换知识，我后续会单独介绍。</p>
<p><img src="/images/net/mii/SGMII.jpg" alt="SGMII"></p>
<h2 id="TBI"><a href="#TBI" class="headerlink" title="TBI"></a>TBI</h2><p>TBI即Ten Bit Interface，接口数据位宽由GMII接口的8位增加到10位，其实，TBI接口跟GMII接口的差别不是很大，多出来的2位数据主要是因为在TBI接口下，MAC芯片在将数据发给PHY芯片之前进行了8B/10B变换(8B/10B变换本是在PHY芯片中完成的，前面已经说过了)，另外，RX_CLK+/-是从接收数据中恢复出来的半频时钟，频率为62.5MHz，RX_CLK+/-不是差分信号，而是两个独立的信号，两者之间有180度的相位差，在这两个时钟的上升沿都采样数据。RX_CLK+/-也叫伪差分信号。除掉上面说到的之外，剩下的信号都跟GMII接口中的相同。大多数芯片的TBI接口和GMII接口兼容。在用作TBI接口时，CRS和COL一般不用。</p>
<p><img src="/images/net/mii/TBI.jpg" alt="img"></p>
<h2 id="RTBI"><a href="#RTBI" class="headerlink" title="RTBI"></a>RTBI</h2><p>RTBI即Reduced TBI，简化版TBI，接口数据位宽为5bit，时钟频率为125MHz，在时钟的上升沿和下降沿都采样数据，同RGMII接口一样，TX_EN线上会传送TX_EN和TX_ER两种信息，在时钟的上升沿传TX_EN，下降沿传TX_ER；RX_DV线上传送RX_DV和RX_ER两种信息，在RX_CLK上升沿传RX_DV，下降沿传RX_ER。</p>
<p><img src="/images/net/mii/RTBI.jpg" alt="img"></p>
<h2 id="XGMII"><a href="#XGMII" class="headerlink" title="XGMII"></a>XGMII</h2><p>XGMII–10 Gigabit Media Independent Interface 即10Gb独立于媒体的接口，X对应罗马数字10。</p>
<p><img src="/images/net/mii/XGMII.jpg" alt="XGMII"></p>
<p>XGMII接口共74根连线，单端信号，采用HSTL/SSTL_2逻辑，端口电压1.5V/2.5V，由于SSTL_2的端口电压高，功耗大，现在已很少使用。</p>
<ul>
<li><p>TXD[31:0]：数据发送通道，32位并行数据。</p>
</li>
<li><p>RXD[31:0]：数据接收通道，32位并行数据。</p>
</li>
<li><p>TXC[3:0]：发送通道控制信号，TXC=0时，表示TXD上传输的是数据；TXC=1时，表示TXD上传输的是控制字符。TXC[3:0]分别对应TXD[31:24], TXD[23:16], TXD[15:8], TXD[7:0]。</p>
</li>
<li><p>RXC[3:0]：接收通道控制信号，RXC=0时，表示RXD上传输的是数据；RXC=1时，表示RXD上传输的是控制字符。RXC[3:0]分别对应RXD[31:24], RXD[23:16], RXD[15:8], RXD[7:0]。</p>
</li>
<li><p>TX_CLK：TXD和TXC的参考时钟，时钟频率156.25MHz，在时钟信号的上升沿和下降沿都采样数据。156.25MHz - 2 - 32 = 10Gbps 。</p>
</li>
<li><p>RX_CLK：RXD和RXC的参考时钟，时钟频率156.25MHz，在时钟信号的上升沿和下降沿都采样数据。</p>
</li>
</ul>
<p>HSTL即High Speed Transceiver Logic，高速发送逻辑的意思。</p>
<p>SSTL，即Stub Series Terminated Logic，短路终止逻辑，主要用于高速内存接口，SSTL目前存在两种标准，SSTL_3是3.3V标准；SSTL_2是2.5V标准。</p>
<h2 id="XAUI"><a href="#XAUI" class="headerlink" title="XAUI"></a>XAUI</h2><p>由于受电气特性的影响，XGMII接口的PCB走线最大传输距离仅有7cm，并且XGMII接口的连线数量太多，给实际应用带来不便，因此，在实际应用中，XGMII接口通常被XAUI接口代替，XAUI即10 Gigabit attachment unit interface，将XGMII集成到芯片内部，XAUI在XGMII的基础上实现了XGMII接口的物理距离扩展，将PCB走线的传输距离增加到50cm，使背板走线成为可能。</p>
<p>源端XGMII把收发32位宽度数据流分为4个独立的lane通道，每个lane通道对应一个字节，经XGXS(XGMII Extender Sublayer)完成8B/10B编码后，将4个lane分别对应XAUI的4个独立通道，XAUI端口速率为：<code>2.5Gbps - 1.25 - 4＝12.5Gbps</code>。</p>
<p><img src="/images/net/mii/XAUI.jpg" alt="img"></p>
<p>在发送端的XGXS模块中，将TXD[31:0]/ RXD[31:0],TXC[3:0]/ RXC[3:0], TX_CLK/ RX_CLK转换成串行数据从TX Lane[3:0]/ RX Lane[3:0]中发出去，在接收端的XGXS模块中，串行数据被转换成并行，并且进行时钟恢复和补偿，完成时钟去抖，经过5B/4B解码后，重新聚合成XGMII。</p>
<p>万兆以太网接口的端口速率为10Gbps，主要有XGMII和XAUI两种，另外还有HIGIG。</p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
  </entry>
  <entry>
    <title>motor</title>
    <url>/2022/06/07/hardware/motor/</url>
    <content><![CDATA[<h2 id="步进电机"><a href="#步进电机" class="headerlink" title="步进电机"></a>步进电机</h2><h3 id="24BYJ48"><a href="#24BYJ48" class="headerlink" title="24BYJ48"></a>24BYJ48</h3><p>24BYJ48-5V型号的具体含义：</p>
<pre><code>24——表示此步进电机的有效最大外径是24mm。

B——表示是步进电机，“步”字的汉语拼音（Bu）开头字母。

Y——表示该步进电机是永磁式，“永”汉语拼音（Yong）开头字母。

J——表示该步进减速电机的减速型式，“减”汉语拼音（Jian）开头字母。

那么“BYJ”合起来就表示——永磁式减速步进电机。

48——表示四相八拍。

5V——表示这个步进电机的额定电压为5V。
</code></pre>
<ul>
<li><p><strong>参数</strong></p>
<p>  减速比:1/64<br>  步距角:5.625°/64<br>  驱动方式:4相8拍<br>  直流电阻:50Ω±7%(25℃)<br>  起动转矩100PPS g.cm ≥300<br>  起动频率PPS ≥500<br>  起位转矩g.cm ≥300<br>  空载牵入频率:≥500Hz<br>  空载牵出频率:≥900Hz<br>  牵入转矩:29.4mN.m(120Hz)<br>  自定位转矩:34.3mN.m<br>  绝缘电阻:＞50MΩ(500V)<br>  绝缘介电强度:600VAC/1mA/1S<br>  绝缘等级:A<br>  温升:＜40K(120Hz)<br>  噪音:＜40dB(120Hz)<br>  重量:大约40g<br>  转向：CCW</p>
</li>
<li><p><strong>内部结构</strong></p>
</li>
</ul>
<p>内圈上面有6个齿，分别标注为0～5，这个叫做转子，转子的每个齿上都带有永久的磁性，是一块永磁体，这就是“永磁式”的概念。外圈就是定子，它是跟电机的外壳固定在一起的，上面有8个齿，而每个齿上都缠上了一个线圈绕组，正对着的2个齿上的绕组又是串联在一起的，也就是说正对着的2个绕组总是会同时导通或关断的，如此就形成了4相，在图中分别标注为 A-B-C-D，这就是“4相”的概念。</p>
<p><img src="/images/motor/24BYJ48.png" alt="步进电机内部结构示意图"></p>
<ul>
<li><strong>工作原理</strong></li>
</ul>
<p>假定电机的起始状态就如图所示，B相绕组的开关闭合，B相绕组导通，那么导通电流就会在正上和正下两个定子齿上产生磁性，这两个定子齿上的磁性就会对转子上的0和3号齿产生最强的吸引力，转子的0号齿在正上、3号齿在正下而处于平衡状态。转子的1号齿与右上的定子齿也就是C相的一个绕组呈现一个很小的夹角。</p>
<p>接下来，我们把B相绕组断开，而使C相绕组导通，右上的定子齿将对转子1号齿产生最大的吸引力，转子就转过了起始状态时1号齿和C相绕组那个夹角的角度。再接下来，断开C相绕组，导通D相绕组，过程与上述的情况完全相同，最终将使转子2、5号齿与定子D相绕组对齐，转子又转过了上述同样的角度。</p>
<p>当A相绕组再次导通，完成一个 B-C-D-A 的四节拍操作后，转子的0、3号齿将由原来对齐到B相绕组上变为了对齐到A相绕组上，即转子转过了一个定子齿的角度。依此类推，再来一个四节拍，转子就将再转过一个齿的角度，8个四节拍后转子将转过完整的一圈，那么单个节拍使转子转过的角度为360度/(8*4)=11.25度，这个值就叫做步进角度。</p>
<p>在单四拍的两个节拍之间再插入一个双绕组导通的中间节拍，组成八拍模式。新插入的节拍使转子转了单四拍模式中步进角度的一半，即5.625度，转动精度增加了一倍，而转子转动一圈则需要8*8=64拍。另外还会在原来单四拍的两个节拍引力之间又加了一把引力，从而大大增加电机的扭力。</p>
<p><img src="/images/motor/24BYJ48_p.png" alt="线序"></p>
<p><img src="/images/motor/24BYJ48_2.png" alt="励磁方式"></p>
<p>对力矩要求高使用2相励磁，对精度要求高使用1-2相励磁。</p>
<h3 id="2相4线"><a href="#2相4线" class="headerlink" title="2相4线"></a>2相4线</h3><p><img src="/images/motor/2p4l.jpeg" alt="内部结构图"></p>
<p><img src="/images/motor/2p4l.jpg" alt="规格"></p>
<h2 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a>舵机</h2><p>舵机（Servo）由直流电机、减速齿轮组、传感器和控制电路组成的一套自动控制系统。通过发送信号，指定输出轴旋转角度。最大旋转180度。与普通直流电机的区别主要在，直流电机是一圈圈转动的，舵机只能在一定角度内转动，不能一圈圈转。</p>
<p>舵机内部有一个基准电路，产生周期为20ms、宽度为1.5ms的基准信号，将获得的直流偏置电压与电位器的电压比较，获得电压差输出。经过电路板IC方向判断，再驱动无核心马达开始转动，透过减速齿轮将动力传至摆臂，同时由位置检测器送回信号，判断是否已经到位。</p>
<p>舵机转动的角度是通过调节PWM的占空比来实现的。标准的PWM信号的<strong>周期固定为20ms，高电平脉宽应该在0.5~2.5ms范围之间</strong>，脉宽与转角0°—180°相对应。</p>
<p>0.5ms————-0度</p>
<p>1.0ms————45度</p>
<p>1.5ms————90度</p>
<p>2.0ms———–135度</p>
<p>2.5ms———–180度</p>
<p>![舵机]](/images/motor/servo.gif)</p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
  </entry>
  <entry>
    <title>PHY</title>
    <url>/2022/06/07/hardware/phy/</url>
    <content><![CDATA[<p>PHY（Physical Layer）即物理接口收发器，它实现OSI模型的物理层。包括MII/GMII（介质独立接口）子层、PCS（物理编码子层）、PMA（物理介质附加）子层、PMD（物理介质相关）子层、MDI子层。PHY是IEEE802.3中定义的一个标准模块，STA（station management entity，管理实体，一般为MAC或CPU）通过SMI（Serial Manage Interface）对PHY的行为、状态进行管理和控制，而具体管理和控制动作是通过读写PHY内部的寄存器实现的。<br>10BaseT 和 100BaseTX PHY两种实现的帧格式是一样的，但信令机制不同，而且10BaseT采用曼彻斯特编码，100BaseTX 采用4B/5B编码。</p>
<p><img src="/images/net/phy/PHY.png" alt="img"></p>
<p>PHY里面的部分寄存器是IEEE定义的，这样PHY把自己的目前的状态反映到寄存器里面，MAC通过SMI总线不断的读取PHY的状态寄存器以得知目前PHY的状态，例如连接速度，双工的能力等。当然也可以通过SMI设置PHY的寄存器达到控制的目的，例如流控的打开关闭，自协商模式还是强制模式等。不论是物理连接的MII总线和SMI总线还是PHY的状态寄存器和控制寄存器都是有IEEE的规范的，因此不同公司的MAC和PHY一样可以协调工作。当然为了配合不同公司的PHY的自己特有的一些功能，驱动需要做相应的修改。</p>
<ul>
<li><strong>工作过程</strong></li>
</ul>
<p>PHY在发送数据的时候，收到MAC过来的数据(对PHY来说，没有帧的概念，对它来说，都是数据而不管什么地址，数据还是CRC)，每4bit就增加1bit的检错码，然后把并行数据转化为串行流数据，再按照物理层的编码规则(10Based-T的NRZ编码或100based-T的曼彻斯特编码)把数据编码，再变为模拟信号把数据送出去。收数据时的流程反之。</p>
<h2 id="PHY寄存器"><a href="#PHY寄存器" class="headerlink" title="PHY寄存器"></a>PHY寄存器</h2><p>PHY寄存器的地址空间为5位，从0到31最多可以定义32个寄存器（随着芯片功能不断增加，很多PHY芯片采用分页技术来扩展地址空间以定义更多的寄存器），IEEE802.3定义了地址为0-15这16个寄存器的功能，地址16-31的寄存器留给芯片制造商自由定义，如下表所示。</p>
<p><img src="/images/net/phy/PHY_REG.png" alt="PHY_REG"></p>
<h3 id="Control-Register-Register-0"><a href="#Control-Register-Register-0" class="headerlink" title="Control Register (Register 0)"></a>Control Register (Register 0)</h3><p>寄存器0是PHY控制寄存器，通过Control Register可以对PHY的主要工作状态进行设置。应该保证控制寄存器每个位的默认值，以便在没有管理干预的情况下，上电或复位时PHY的初始状态为正常操作状态。Control Register的每一位完成的功能见下。</p>
<p><img src="/images/net/phy/PHY_CTRL_REG.png" alt="PHY_CTRL_REG"></p>
<ul>
<li><strong>Reset：</strong> 通过将位0.15设置为逻辑1来完成复位PHY。 该操作应将状态和控制寄存器设置为其默认状态。 因此，此操作可能会改变PHY的内部状态以及与PHY关联的物理链路的状态。复位过程中Bit15保持为1，复位完成之后该位应该自动清零。在复位过程完成之前，PHY不需要接受对控制寄存器的写入操作，并且在复位过程完成之前写入0.15以外的控制寄存器位可能不起作用。 复位过程应在0.15位设置的0.5 s内完成。</li>
</ul>
<blockquote>
<p>（1）一般要改变端口的工作模式（如速率、双工、流控或协商信息等）时，在设置完相应位置的寄存器之后，需要通过Reset位复位PHY来使配置生效。<br>（2）该比特位的默认值为 0。</p>
</blockquote>
<ul>
<li><strong>Loopback：</strong> 当位0.14被设置为逻辑1时，PHY应置于环回操作模式。 当位0.14置位时，PHY接收电路应与网络介质隔离，并且MII或GMII处的TX_EN断言不应导致网络介质上的数据传输。 当位0.14置位时，PHY应接受来自MII或GMII发送数据路径的数据，并将其返回给MII或GMII接收数据路径，以响应TX_EN的断言。 当位0.14置位时，从断言TX_EN到断言RX_DV的延迟应小于512 BT。 当位0.14置位时，除非设置了位0.7，否则COL信号应始终保持无效，在这种情况下，COL信号的行为应如22.2.4.1.9所述。 清0.14位为零允许正常操作。</li>
</ul>
<p>Loopback是一个调试以及故障诊断中常用的功能，Bit14置1之后，PHY和外部MDI的连接在逻辑上将被断开，从MAC经过MII/GMII（也可能是其他的MAC/PHY接口）发送过来的数据将不会被发送到MDI上，而是在PHY内部（一般在PCS）回环到本端口的MII/GMII接收通道上，通过Loopback功能可以检查MII/GMII以及PHY接口部分是否工作正常，对于端口不通的情况可用于故障定位。</p>
<blockquote>
<p>（1）需要注意的是，很多时候PHY设置Loopback后端口可能就Link down了，MAC无法向该端口发帧，这时就需要通过设置端口Force Link up才能使用Loopback功能。<br>（2）该比特位的默认值为 0。</p>
</blockquote>
<ul>
<li><p><strong>Speed Selection：</strong> <em><strong>Bit13和Bit6两位联合实现</strong></em>对端口的速率控制功能。链接速度可以通过自动协商过程或手动速度选择来选择。 通过将位0.12清零来禁用自动协商时，允许手动速度选择。</p>
</li>
<li><p>当禁用自动协商并将位0.6清除为逻辑0时，将位0.13设置为逻辑1将PHY配置为100 Mb / s操作，并将位0.13清除为逻辑0将PHY配置为10 Mb / s操作 。</p>
</li>
<li><p>当禁用自动协商并将位0.6设置为逻辑1时，将位0.13清零为逻辑0会选择1000 Mb / s的操作。 将位0.6和0.13设置为逻辑1的组合保留用于未来的标准化。</p>
</li>
<li><p>当使能自动协商时，可以读取或写入位0.6和0.13，但位0.6和位0.13的状态对链路配置没有影响，位0.6和位0.13不需要反映当它被读取时链接。</p>
</li>
</ul>
<p>如果PHY通过比特1.15：9和比特15.15：12报告它不能工作在所有速度时，则比特0.6和0.13的值应该与PHY可以操作的速度相对应。并且任何试图将该位设置为无效的操作均将被忽略。</p>
<blockquote>
<p>（1）对Speed Selection的修改设置，往往需要复位端口才能配置生效。因此在设置该位置的时候需要检查自动协商的设置并通过Bit15复位端口。<br>（2）位0.6和0.13的默认值是根据位1.15：9和15.15：12所指示的PHY可以操作的最高数据速率的编码组合。</p>
</blockquote>
<ul>
<li><strong>Auto-Negotiation Enable：</strong> 自动协商过程应通过将位0.12设置为逻辑1来启用。 如果位0.12设置为逻辑1，则位0.13、0.8和0.6不应对链路配置和除了自动协商协议规定之外的站操作产生影响。 如果将位0.12清零为逻辑0，则无论链路配置和自动协商过程的先前状态如何，位0.13、0.8和0.6都将确定链路配置。</li>
</ul>
<p>如果PHY通过位1.3报告它缺乏执行自动协商的能力，则PHY应在位0.12返回零值。 如果PHY通过位1.3报告它缺乏执行自动协商的能力，则位0.12应该始终写为0，并且任何尝试将1写入位0.12都应该被忽略。</p>
<blockquote>
<p>必须注意的是，对于1000BASE-T接口,自动协商必须打开。</p>
</blockquote>
<ul>
<li><strong>Power Down：</strong> 通过将位0.11设置为逻辑1，可以将PHY置于低功耗状态。 清0.11位为零允许正常操作。 PHY在掉电状态下的具体行为是特定实现的。 处于掉电状态时，PHY应响应管理事务。 在转换到掉电状态期间和处于掉电状态期间，PHY不应在MII或GMII上产生寄生信号。</li>
</ul>
<p>当位0.11或位0.10被设置为逻辑1时，PHY不需要满足RX_CLK和TX_CLK信号功能要求。 在位0.11和0.10清零后，PHY应在0.5 s内满足22.2.2中定义的RX_CLK和TX_CLK信号功能要求。</p>
<blockquote>
<p>（1）Power Down模式一般在软件shut down端口的时候使用，需要注意的是端口从Power Down模式恢复，需要复位端口以保证端口可靠的连接。<br>（2）该位的默认值为 0。</p>
</blockquote>
<ul>
<li><strong>Isolate：</strong> 通过将位0.10设置为逻辑1，PHY可能被迫将其数据路径与MII或GMII电隔离。 清零位0.10允许正常操作。 当PHY与MII或GMII隔离时，它不会响应TXD数据包和TX_EN，TX_ER、GTX_CLK的输入。并且它的TX_CLK，RX_CLK，RX_DV，RX_ER，RXD数据包、COL和CRS输出均应为高阻态。 当PHY与MII或GMII隔离时，它将响应管理事务（MDC/MDIO接口的信号）。</li>
</ul>
<blockquote>
<p>（1）IEEE802.3没有对Isolate 时MDI接口的状态进行规范，此时MDI端可能还在正常运行。Isolate在实际应用中并没有用到。<br>（2）由于目前很多百兆的PHY芯片其MAC接口主流的都是SMII/S3MII，8个端口的接口是相互关联的，一个端口设置Isolate可能会影响其他端口的正常使用，因此在使用中注意不要随意更改bit10的状态。</p>
</blockquote>
<ul>
<li><strong>Restart Auto-Negotiation：</strong> 如果PHY通过位1.3报告它缺乏执行自动协商的能力，或者如果自动协商被禁用，则PHY应在位0.9返回零值。 如果PHY通过位1.3报告它缺乏执行自动协商的能力，或者如果禁用了自动协商，则应将位0.9始终写为0，并且任何尝试将1写入位0.9应被忽略。</li>
</ul>
<p>Bit9置1将重新启动端口的自动协商进程，当然前提是Auto-Negotiation Enable是使能的。</p>
<blockquote>
<p>一般在修改端口的自动协商能力信息之后通过Bit9置1重新启动自动协商来使端口按照新的配置建立link。</p>
</blockquote>
<ul>
<li><strong>Duplex Mode：</strong> 可以通过自动协商过程或手动双面选择来选择双工模式。 通过将位0.12清零来禁用自动协商时，允许手动双面选择。</li>
</ul>
<ul>
<li>当禁用自动协商时，将位0.8设置为逻辑1将PHY配置为全双工操作，并将位0.8清零以将逻辑0配置为用于半双工操作的PHY。</li>
<li>当启用自动协商时，可以读取或写入位0.8，但位0.8的状态对链路配置没有影响。</li>
</ul>
<p>如果PHY通过位1.15：9和15.15：12报告它只能在一个双工模式下工作，则位0.8的值应该与PHY可以工作的模式相对应，并且任何尝试改变将该位0.8修改为无效指的操作应被忽略。</p>
<blockquote>
<p>对Duplex Mode的修改配置也需要复位端口才能生效。</p>
</blockquote>
<ul>
<li><strong>Collision Test：</strong> 冲突信号（COL）测试开关。在需要对COL信号进行测试时，可以通过Bit7置1，这时PHY将输出一个COL脉冲以供测试。实际测试操作中也可以将端口配置为半双工状态，通过发帧冲突来测试COL信号，因此该配置实用价值不大。</li>
<li><strong>Unidirectional enable：</strong> 如果PHY通过比特1.7报告它不具备编码和传输来自媒体独立接口的数据的能力，而不管PHY是否确定已建立有效链路，则PHY应在比特0.5中返回零值，并且 任何尝试写一个到位0.5应该被忽略。</li>
</ul>
<h3 id="Status-register"><a href="#Status-register" class="headerlink" title="Status register"></a>Status register</h3><p>寄存器1是PHY状态寄存器，主要包含PHY的状态信息，大多数bit的值都是由芯片厂家确定的，每一个bit的功能在表3种已有详细说明。</p>
<p><img src="/images/net/phy/PHY_STA_REG.png" alt="PHY_STA_REG"></p>
<ul>
<li><strong>100BASE-T4 ability：</strong> 当读为逻辑1时，位1.15指示PHY有能力使用100BASE-T4信令规范执行链路发送和接收。 当读为逻辑0时，位1.15表示PHY缺乏使用100BASE-T4信令规范执行链路发送和接收的能力。</li>
<li><strong>100BASE-X full duplex ability：</strong> 当读为逻辑1时，位1.14指示PHY有能力使用100BASE-X信令规范执行全双工链路传输和接收。 当作为逻辑0读取时，bit1.14表示PHY缺乏使用100BASE-X信令规范执行全双工链路传输和接收的能力。</li>
<li><strong>100BASE-X half duplex ability：</strong> 当读为逻辑1时，位1.13指示PHY有能力使用100BASE-X信令规范执行半双工链路传输和接收。 当读为逻辑0时，位1.13指示PHY缺乏使用100BASE-X信令规范执行半双工链路传输和接收的能力。</li>
<li><strong>Unidirectional ability：</strong> 当读为逻辑1时，位1.7指示PHY具有编码和传输来自媒体独立接口的数据的能力，而不管PHY是否确定已建立有效链路。 当读为逻辑0时，位1.7指示PHY只有在PHY确定已建立有效链路时才能从媒体独立接口传输数据。</li>
<li><strong>MF preamble suppression ability：</strong> 当读为逻辑1时，位1.6指示PHY能够接受管理帧，而不管它们是否在22.2.4.5.2中描述的前导码模式之前。 当读为逻辑0时，位1.6指示PHY不能接受管理帧，除非它们之前是22.2.4.5.2中描述的前导码模式。</li>
<li><strong>Auto-Negotiation Complete：</strong> 当读为逻辑1时，位1.5指示自动协商过程已完成，并且由自动协商协议（条款28或条款37）实施的扩展寄存器的内容是有效的。 当读为逻辑0时，位1.5指示自动协商过程尚未完成，并且扩展寄存器的内容由自动协商协议的当前状态定义，或者为手动配置写入。 如果自动协商通过清除位0.12禁用，则PHY应在位1.5返回零值。 如果PHY缺乏执行自动协商的能力，它还应在位1.5返回零值。</li>
</ul>
<blockquote>
<p>在调试以及异常故障处理时，可以通过该位寄存器的状态判断AN是否成功，从而进一步的检查AN相关的设置是否正确，或者芯片的AN功能是否正常等。</p>
</blockquote>
<ul>
<li><strong>Remote Fault：</strong> 当读为逻辑1时，位1.4表示检测到远程故障状态。 故障类型以及故障检测的标准和方法是PHY特定的。 远程故障位必须使用锁存功能来实现，以便发生远程故障将导致远程故障位置位，并保持置位状态直至被清除。 每当通过管理接口读取寄存器1时，远程故障位应清零，并且还应通过PHY复位清零。</li>
</ul>
<p>远端错误指示位。Bit4=1代表连接对端（Link Partner）出错，至于出错的具体类型以及错误检测机制在规范中并没有定义，由PHY的制造商自由发挥，一般的厂商都会在其他的寄存器（Register16-31由厂商自行定义）指示比较详细的错误类型。在与端口相关的故障查证中，Remote Fault是一个重要的指示信息，通过互联双方的Remote Fault信息（可能要加上其他的具体错误指示），可以帮助定位故障原因。</p>
<ul>
<li><p><strong>Auto-Negotiation ability：</strong> 当读为逻辑1时，位1.3指示PHY有能力执行自动协商。 当读为逻辑0时，位1.3指示PHY缺乏执行自动协商的能力。</p>
</li>
<li><p><strong>Link Status：</strong> 当读为逻辑1时，位1.2指示PHY已经确定已建立有效链路。 当作为逻辑0读取时，位1.2指示该链接无效。 确定链路有效性的标准是PHY特定的。 链路状态位应该使用锁存功能来实现，以便发生链路故障情况将导致链路状态位清零并保持清零，直到通过管理接口读取。 此状态指示旨在支持在30.5.1.1.4，aMediaAvailable中定义的管理属性。</p>
</li>
</ul>
<p>实际应用中一般都是通过Bit2来判断端口的状态。而且，一般的MAC芯片也是通过轮询PHY的这个寄存器值来判断端口的Link状态的（这个过程可能有不同的名称，比如BCM叫做Link Scan，而Marvell叫做PHY Polling。）如前所述，在AN Enable的情况下，Link Status的信息只有在Auto-Negotiation Complete指示已经完成的情况下才是正确可靠的，否则有可能出错。</p>
<ul>
<li><strong>Jabber Detect：</strong> 当作为逻辑1读取时，位1.1指示已经检测到爆音条件。 此状态指示旨在支持30.5.1.1.6中定义的管理属性，aJabber和30.5.1.3.1 nJabber中定义的MAU通知。 检测Jabber条件的标准是PHY特定的。 Jabber检测位应该使用锁存功能来实现，以便发生Jabber条件将导致Jabber检测位置位，并保持置位状态直至被清除。 每次通过管理接口读取寄存器1时，Jabber检测位应清零，并且还应通过PHY复位清零。</li>
</ul>
<p>IEEE802.3对Jabber的解释是“A condition wherein a station transmits for a period of time longer than the maximum permissible packet length, usually due to a fault condition”。这一位指示的是Link Partner发送的时间超过了规定的最大长度。值得注意的是，Jabber Detect只有在10BASE-T模式下才有意义，100和1000M模式是没有定义Jabber这一功能的。</p>
<h3 id="PHY-Identifier-Register"><a href="#PHY-Identifier-Register" class="headerlink" title="PHY Identifier Register"></a>PHY Identifier Register</h3><p>寄存器2和3存放PHY芯片的型号代码，寄存器2(PHY ID1)为高16位，而寄存器3(PHY ID2)为低16位。由芯片制造商自行定义，实际应用中软件通过读取这两个寄存器的内容可以识别PHY的型号和版本。</p>
<p>PHY标识符应由由IEEE分配给PHY制造商的组织唯一标识符（OUI）的（<em>只需要使用第3至第24位，共22位</em>），加上6位制造商的型号以及4位制造商的修订版编号组成。 PHY标识符旨在提供足够的信息来支持30.1.2中所要求的oResourceTypeID对象。</p>
<p>OUI的第三位分配给位2.15，OUI的第四位分配给位2.14，依此类推。 位2.0包含OUI的第十八位。 位3.15包含OUI的第十九位，位3.10包含OUI的第二十四位。 位3.9包含制造商型号的MSB。 位3.4包含制造商型号的LSB。 位3.3包含制造商版本号的MSB，位3.0包含制造商版本号的LSB。具体如下图所示：</p>
<p><img src="/images/net/phy/PHY_ID_REG.png" alt="PHY_ID_REG"></p>
<h3 id="Auto-Negotiation-Advertisement-Register-Register-4-R-W"><a href="#Auto-Negotiation-Advertisement-Register-Register-4-R-W" class="headerlink" title="Auto-Negotiation Advertisement Register (Register 4) (R/W)"></a>Auto-Negotiation Advertisement Register (Register 4) (R/W)</h3><p>寄存器4是自动协商的能力通告寄存器，在AN Enable的前提下（见寄存器0），端口根据该寄存器的相关配置将自动协商信息通过FLP在MDI上进行通告。当AN配置为Disable状态的时候，寄存器4的配置将不起作用，端口的工作模式由控制寄存器中的配置决定。</p>
<p>该寄存器包含PHY的通告能力，它们将在自动协商期间传送给其链接伙伴。 基本页的位定义在IEEE标准的28.2.1.2中定义。 上电时，在自动协商开始之前，该寄存器应具有以下默认配置：</p>
<ul>
<li><strong>Selector Field （4.4：0）：</strong> 被设置为适当的代码，如IEEE标准的附件28A中所规定。</li>
<li><strong>Reserved（4.14）：</strong> 被设置为逻辑0。</li>
<li><strong>Technology Ability Field（4.11：5）：</strong> <em><strong>根据MII状态寄存器（寄存器1）（1.15：11）中设置的值或等效值设置</strong></em>。 另见28.2.1.2.3和附件28D。</li>
</ul>
<p><img src="/images/net/phy/PHY_REG_4.png" alt="PHY_REG_4"></p>
<h3 id="Link-codeword-encoding（基本链路码字）"><a href="#Link-codeword-encoding（基本链路码字）" class="headerlink" title="Link codeword encoding（基本链路码字）"></a>Link codeword encoding（基本链路码字）</h3><p>在FLP Burst内传输的基本链路代码字（基本页面）应该传达如图28-7所示的编码。 自动协商功能可以使用下一页功能支持其他页面。 下一页交换中使用的链接代码字的编码在28.2.3.4中定义。 在FLP Burst中，D0应该是第一个传输的位。</p>
<p><img src="/images/net/phy/20180428154543415.png" alt="这里写图片描述"></p>
<h3 id="Next-Page-function"><a href="#Next-Page-function" class="headerlink" title="Next Page function"></a>Next Page function</h3><p>下一页功能使用标准的自动协商仲裁机制来允许交换任意的数据。 数据由可选的下一页信息携带，其遵循用于基本链接码字的传输和确认过程。 定义了四种类型的下一页编码：消息页面，未格式化页面，扩展消息页面和扩展的未格式化页面。</p>
<p>关于该部分，具体见IEEE标准的<strong>28.2.3.4 Next Page function</strong>。</p>
<p>在IEEE标准中，Auto-Negotiation Advertisement Register中的各部分全部是在独立章节中进行介绍的。具体如下：</p>
<ul>
<li><strong>Selector Field：</strong> 选择器字段（S [4：0]）是一个5位宽的字段，编码32个可能的消息。 链路码字中的选择器字段S [4：0]应用于识别自动协商发送的消息的类型。 下表列出了可能发送的消息的类型。 随着新消息的发展，该表格将相应更新。</li>
</ul>
<p><img src="/images/net/phy/20180428155653138.png" alt="Selector Field"></p>
<p>未指定的组合保留供将来使用。 不会传输选择器字段的预留组合。<em><strong>我们所接触的以太网PHY遵从IEEE802.3规范，Selector Field=0001，该区域不可随意更改（很多PHY将此区域设计为只读寄存器，以免被修改）</strong></em>。</p>
<ul>
<li><strong>Technology Ability Field：</strong> 技术能力字段（A [6：0]）是一个7位宽的字段，其中包含指示选择器字段值特定的支持技术的信息。 这些位被映射到各个技术，以便能够针对单个选择器字段值并行通告能力。 附录28B.2和附件28D描述了IEEE 802.3选择器的技术能力字段编码。 链接代码字中可能会公布多种技术。 设备应支持其宣传的技术的数据服务能力。</li>
</ul>
<p><img src="/images/net/phy/20180428152215994.png" alt="Technology Ability Field"></p>
<ul>
<li><p><strong>Extended Next Page：</strong> 扩展下一页（XNP）被编码在基本链路码字的位D12中。 扩展下一页位指示本地设备在设置为逻辑1时支持扩展下一页的传输，并指示本地设备在设置为逻辑0时不支持扩展下一页。 Extended Next Page的使用与协商的数据速率，媒体或链接技术是正交的。 扩展下一页位按照28.2.3.4中的扩展下一页功能规范使用。</p>
</li>
<li><p><strong>Next Page：</strong> 无论选择器字段值还是链接码字编码，下一页（NP）都在D15位编码。 支持附加链接码字编码的传输和接收是可选的。 如果不支持Next Page功能，NP位应始终设置为逻辑0。 如果设备实现下一页功能并希望进行下一页交换，则应将NP位设置为逻辑1。 设备可以实现下一页功能，并通过将NP位设置为逻辑0来选择不参与下一页交换。 下一页功能在28.2.3.4中定义。</p>
</li>
<li><p><strong>Remote Fault：</strong> 远程故障（RF）编码在基本链路码字的位D13中。 默认值是逻辑零。 远程故障位为传输简单的故障信息提供了一种标准的传输机制。 当自动协商通告寄存器（寄存器4）中的RF位设置为逻辑1时，发送的基本链路码字中的RF位被设置为逻辑1。 当接收到的基本链路代码字中的RF位被设置为逻辑1时，如果存在MII管理功能，则MII状态寄存器（寄存器1）中的远程故障位将被设置为逻辑1。</p>
</li>
</ul>
<h3 id="Auto-Negotiation-Link-Partner-ability-register-Register-5-RO"><a href="#Auto-Negotiation-Link-Partner-ability-register-Register-5-RO" class="headerlink" title="Auto-Negotiation Link Partner ability register (Register 5) (RO)"></a>Auto-Negotiation Link Partner ability register (Register 5) (RO)</h3><p>寄存器5保存的是本端PHY接收到的对端PHY所通告的端口能力，寄存器5的结构和寄存器4基本一致。</p>
<h3 id="Auto-Negotiation-Expansion-Register-Register-6-RO"><a href="#Auto-Negotiation-Expansion-Register-Register-6-RO" class="headerlink" title="Auto-Negotiation Expansion Register (Register 6) (RO)"></a>Auto-Negotiation Expansion Register (Register 6) (RO)</h3><p>寄存器6保存了PHY自动协商过程的异常信息。从这个寄存其中我们可以获取到Link Partner子否支持自动协商以及自动协商下一页有没有收到的信息。</p>
<p><img src="/images/net/phy/20180428163901700.png" alt="Auto-Negotiation Expansion Register"></p>
<h3 id="Auto-Negotiation-Next-Page-transmit-register-Register-7-R-W"><a href="#Auto-Negotiation-Next-Page-transmit-register-Register-7-R-W" class="headerlink" title="Auto-Negotiation Next Page transmit register (Register 7) (R/W)"></a>Auto-Negotiation Next Page transmit register (Register 7) (R/W)</h3><p>自动协商下一页发送寄存器包含在支持下一页功能时要发送的下一页链接码字。 （见表28-6）内容在28.2.3.4中定义。 上电时，该寄存器应包含默认值2001H，该值表示消息代码设置为Null消息的消息页面。 该值可以由设备希望传输的任何有效的下一页消息代码替换。 写入该寄存器应将mr_next_page_loaded设置为true。</p>
<p><img src="/images/net/phy/2018042816462224.png" alt="Register 7"></p>
<h3 id="Auto-Negotiation-Link-Partner-Received-Next-Page-register-Register-8-RO"><a href="#Auto-Negotiation-Link-Partner-Received-Next-Page-register-Register-8-RO" class="headerlink" title="Auto-Negotiation Link Partner Received Next Page register (Register 8) (RO)"></a>Auto-Negotiation Link Partner Received Next Page register (Register 8) (RO)</h3><p><img src="/images/net/phy/20180428164942266.png" alt="Register 8"></p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
  </entry>
  <entry>
    <title>PCI总线</title>
    <url>/2022/06/07/hardware/pci/</url>
    <content><![CDATA[<p>PCI即Peripheral Component Interconnect，中文意思是“外围器件互联”，是由PCISIG (PCI Special Interest Group)推出的一种局部并行总线标准。PCI总线是由ISA(Industy Standard Architecture)总线发展而来的，是一种同步的独立于处理器的32位或64位局部总线。从结构上看，PCI是在CPU的供应商和原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，并实现上下之间的接口以协调数据的传送。广泛用于当前高档微机、工作站，以及便携式微机。主要用于连接显卡、网卡、声卡。</p>
<p>PCI总线是一种树型结构，并且独立于CPU总线，可以和CPU总线并行操作。PCI总线上可以挂接PCI设备和PCI桥，PCI总线上只允许有一个PCI主设备（同一时刻），其他的均为PCI 从设备，而且读写操作只能在主从设备之间进行，从设备之间的数据交换需要通过主设备中转。</p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>pci</tag>
      </tags>
  </entry>
  <entry>
    <title>sensor</title>
    <url>/2022/06/07/hardware/sensor/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Sensor 将从 lens 上传导过来的光线转换为电信号，再经过内部AD转换为数字信号。每个pixel像素点只能感受R、G、B中的一种，因此每个像素点中存放的数据是单色光，像素表示的就是有多少个感光点，每个感光点只能感应一种光，这些最原始的感光数据我们称为RAW Data。Raw Data数据要经过ISP的处理才能还原出三原色，也就是说如果一个像素点感应为R值，那么ISP会根据该感光点周围的G、B的值，通过插值和特效处理等，计算出该R点的G、B值，这样该点的RGB就被还原了。目前常用的sensor有两种，一种是CCD（电荷耦合）；一种是CMOS（金属氧化物导体）。</p>
<ul>
<li>CCD（Charge Coupled Device），电荷耦合器件传感器：使用一种高感光度的半导体材料制成，能把光线转变成电荷，通过模数转换器芯片转换成电信号。CCD由许多独立的感光单位组成，通常以百万像素为单位。当CCD表面受到光照时，每个感光单位都会将电荷反映在组件上，所有的感光单位产生的信号加在一起，就构成了一幅完整的图像。CCD传感器以日本厂商为主导，全球市场上有90%被日本厂商垄断，索尼、松下、夏普是龙头。</li>
<li>CMOS（Complementary Metal-Oxide Semiconductor），互补性氧化金属半导体：主要是利用硅和锗做成的半导体，使其在CMOS上共存着带N(-)和P(+)级的半导体，这两个互补效应所产生的电流可以被处理芯片记录并解读成影像。CMOS传感器主要以美国、韩国和中国台湾为主导，主要生产厂家是美国的OmnVison、Agilent、Micron，中国台湾的锐像、原相、泰视等，韩国的三星、现代。</li>
</ul>
<h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>ISP 是图像信号处理器（Image Sensor Processor）。一般用来处理Image Sensor（图像传感器）的输出数据，如做AE（自动曝光）、AGC（自动增益控制）、AWB（自动白平衡）、色彩校正、Lens Shading、Gamma 校正、祛除坏点、Auto Black Level、Auto White Level 等等功能的处理。</p>
<h3 id="AE"><a href="#AE" class="headerlink" title="AE"></a>AE</h3><p>自动曝光（Auto Exposure），根据外界光线的强弱自动调整曝光量和增益，防止曝光过度或者不足。AE 算法的主要调控对象一般是光圈、sensor增益（包含模拟增益和数字增益）、ISP数字增益这三个参数。</p>
<p>影响曝光的因素有曝光时间；光圈大小；Sensor的ISO感光度。</p>
<p>帧曝光时间Ft和帧率f的关系为：f = 1 / Ft，曝光时间的计算方法由sensor厂商提供。</p>
<p>EV曝光值（exposure value），摄影技术中定义的曝光值参数，代表能够给出同样曝光的所有相机光圈组合。它的定义是：$EV = \log(N^2 \div t)$<br>其中N是光圈的f-stop值；t是曝光时间，单位为秒。</p>
<p>EV0 对应于ISO100，曝光时间为1秒，光圈为f/1.0，以及与之等效的所有曝光组合，这些组合可以使18%的中性灰卡在所处光照条件下获得合适的曝光。因此曝光值主要体现了拍摄场景的亮度，同时在一定程度上也能反映相机的灵敏度。</p>
<p>曝光值每增加1称为增加一挡曝光，也就是将曝光量减半，比如将曝光时间或光圈面积减半，因此可以从EV0出发，按照光圈、快门加倍或减半的方式推导出其余的曝光档位，一般常用的档位在-6~20之间。</p>
<p>如果已知使画面正确曝光的EV值，则可以在下表中选择一个合适的曝光时间+光圈组合。举例来说，假设已知某拍摄场景正确曝光需要EV2，在固定ISO100的前提下，光圈和快门组合只能在（1s,f/2），（1/2s,f/1.4），（1/4s,f/1）这三个方案中选择一个。</p>
<p><img src="/images/sensor/v2-c02e83e125e4c8ef22e1ed881274f0a0_b.jpg" alt="img"></p>
<p>下表给出了EV0~EV20的典型场景。<br><img src="/images/sensor/v2-6e533fff18f0d918e10799c77da24350_b.jpg" alt="img"></p>
<p>下表给出了更完整的EV数据，同时包含了ISO，光圈和快门值<br><img src="/images/sensor/v2-fdcf59270dee877d6e1b9d79bf9c625f_b.jpg" alt="img"></p>
<p>光圈、快门、增益都可以影响画面亮度，但是这三者在效能上并不是完全等价的。摄影领域常用一个曝光三角形来形象地阐释三者之间的关系。<br><img src="/images/sensor/v2-af09e43949d8c5d8dc36214597209286_b.jpg" alt="img"></p>
<p>光圈（aperture）的副作用主要是影响景深。快门的副作用主要是影响运动模糊。一般而言，当曝光时间大于15ms时，画面中速度大于40km/h的车辆就会开始变模糊。当曝光时间大于30ms时，画面中走动的人就会变模糊。因此拍摄对象的预期移动速度基本上决定了曝光时间的上限。增益的副作用主要表现为画面噪声，尤其是数字增益会引入较大的噪声，显著降低图像质量。<br><img src="/images/sensor/v2-ed7c2425f86f43612ef449e0bff2ce4a_b.jpg" alt="img"></p>
<h3 id="AWB"><a href="#AWB" class="headerlink" title="AWB"></a>AWB</h3><p>色温随可见光的光谱成分变化而变化，在低色温光源下，白色物体偏红，在高色温光源下，白色物体偏蓝。人眼可根据大脑的记忆判断，识别物体的真实颜色，AWB（自动白平衡调整Auto White Balance ） 算法的功能是降低外界光源对物体真实颜色的影响，使得我们采集的颜色信息转变为在理想日光光源下的无偏色信息。要求在不同色温环境下，照白色的物体，屏幕中的图像应也是白色的。</p>
<ul>
<li><p>色温的定义：将黑体从绝对零度开始加温，当温度升高到一定程度时候，黑体便辐射出可见光，其光谱成份以及给人的感觉也会着温度的不断升高发生相应的变化。于是，就把黑体辐射一定色光的温度定为发射相同色光光源的色温。</p>
</li>
<li><p>白平衡：在不同色温的光源下，白色在传感器中的响应会偏蓝或偏红。白平衡算法通过调整 R, G, B 三个颜色通道的强度，使白色真实呈现。</p>
</li>
</ul>
<h3 id="3DNR"><a href="#3DNR" class="headerlink" title="3DNR"></a>3DNR</h3><p>2D降噪：只在2维空间域上进行降噪处理。对一个像素将其与周围像素平均，平均后噪声降低，但缺点是会造成画面模糊，特别是物体边缘部分。因此对这种算法的改进主要是进行边缘检测，边缘部分的像素不用来进行模糊。</p>
<p>3D降噪即3D DNR（3D Digital Noise Reducer），通过对比相邻的几帧图像，将图像信号中不重叠的噪波自动滤出。目前比较普遍的是进行Y/C分离，即从视频信号中将亮度信号（Y）和颜色信号（C）分离，然后对Y信号，C信号进行3维数字降噪。3D降噪增添了时域处理，因此变为3维。和2D降噪的不同在于，2D降噪只考虑一帧图像，而3D降噪进一步考虑帧与帧之间的时域关系，对每个像素进行时域上的平均，故计算量大，耗时更长。</p>
<h3 id="BLC"><a href="#BLC" class="headerlink" title="BLC"></a>BLC</h3><p>BLC（Black Level Correction）/ Black Level Compensate (OBC) ：黑电平校正。黑电平是在没有外界光线输入时，理想情况下像素值应该是0，但是实际中因为sensor暗电流作用仍会输出的亮度值。ISP 需要减去这个亮度值（这一个值会受到AWBGain，CCM，Gamma的影响）。</p>
<h3 id="LSC"><a href="#LSC" class="headerlink" title="LSC"></a>LSC</h3><p>LSC（Lens Shading Correction）/Color Shading ：阴影校正。Lens Shading是由于镜片从边缘到中心对入射光线的反射程度不同，镜头中心接收的光强大，边缘接收的光强较少， 造成图像从中心到边缘亮度逐渐变暗。Color Shading是由于Lens从中心到边缘，其R、G、B变暗的速率不一样，总体表现就是Gb/Gr像素值差异较大，两个像素之间有细微纹理。</p>
<h3 id="CCM"><a href="#CCM" class="headerlink" title="CCM"></a>CCM</h3><p>CCM（Color Correction Matrix/ DSC color calibration）：颜色校正矩阵。sensor 对光谱的响应在 RGB 各分量上与人眼对光谱的响应通常是有偏差的，拍摄color checker24色板，将相机拍摄图片值与色板标准值之间进行对比，得出一组能将拍摄值校正到最接近标准值的3x3矩阵。通常通过一个色彩校正矩阵对所有相机拍摄的图片进行颜色校正，使图像与人眼视觉在色彩上保持一致。</p>
<p><img src="/images/sensor/image-20200221200943546.png" alt="image-20200221200943546"><br>m<del>RR</del> + m<del>RG</del> + m<del>RB</del> = 256<br>m<del>GR</del> + m<del>GG</del> + m<del>GB</del> = 256<br>m<del>BR</del> + m<del>BG</del> + m<del>BB</del> = 256</p>
<p>（2）DPC/BPD（Defect Pixel Correction/Bad Pixel Detect）：坏点校正/坏点检测。相机中成像坏点一般是白色或者黑色的点，和周围像素点的差异明显。</p>
<p>（3）FPN（Fix Pattern Noise）：固定模式噪声。由于CMOS每个感光二极体旁都搭配一个ADC 放大器，如果以百万像素计，那么就需要百万个以上的 ADC 放大器，但是每个像素结构中的光电二极管的尺寸、掺杂浓度、生产过程中的沾污以及MOS场效应管的参数的偏差等都会造成像素输出信号的变化。对于给定的单个像素它是固定的。通常消除固定模式噪声采用“双采样降噪”方法，这是CMOS 感光器件特有的一种降噪方式。在光线较暗的环境下使用时，画面会有明显的噪声，这时通过对景物进行两次不同曝光率和敏感度的采样，然后将两次采样的结果进行综合处理，就可以有效解决低照度下的图像噪声问题。</p>
<p>（5）Flare offset：光学上称Flare也叫stray light,耀斑补偿。镜片的表面反射或镜筒、反光镜组的内面所引起的反射光，到达底面后造成画面整体或一部份产生了雾蒙，降低了图像的鲜锐度。镜片的镀膜及内面防反射处理的加强，固然可以大幅度地减少光斑，但被摄体的状况并不相同，不可能完全消除。</p>
<p>因此，在相机里面设计都是黑色的，且其内侧表明设计都是粗糙的，目前就是为了减小flare。flare如何修正？做直方图，然后每阶的亮度都往下降，这样是否会影响颜色呢？因此，flare一定要是在linear domain去做，不能在RGB domain去做。</p>
<p>（9）DM（Demosaicing/Color Filter Array Interpolation/CFA插值）：CMOS Sensor出来的RawData是Bayer格式的图像，每个像素只有一个通道的信息。DM是将Bayer格式的图像恢复成每个像素用RGB三通道表示的方式。DM的主要依据是图像在平滑的局部区域，各分量的ratio是相等的。插值算法的好坏会影响图片的细节，如摩尔纹。</p>
<p>（12）EE（Edge Enhancement/Edge Sharpening）：锐化，边缘增强。通过滤波器获取图像的高频分量，按照一定的比例将高频部分和原图进行加权求和获取锐化后的图像。</p>
<p>（13）DRC/HDR（Dynamic Range Compression/ High-Dynamic Range）：宽动态。高动态图像的拍摄出来的结果通常会有，亮部太亮，暗部太暗的问题。DRC是调整图像暗部亮度使之变亮，调整亮部亮度使之变暗，而且保持图像的对比度。</p>
<p>（14）PCA/VDE：Hue，Saturation，Contrast，Brightness调试。单独针对Hue，Saturation，Contrast，Brightness各图像分量进行调节。</p>
<p>（15）Histogram：直方图均衡化。重新分布图片的亮度。使图片的亮度分布更加均匀。</p>
<p>（16）FlashLight Control：闪光灯控制</p>
<p>（17）Cross talk：Optical cross-talk是当主光线进光角度过大，导致光线不能有效地进入本像素的Microlens内，而是进入相邻像素单元或其他无效区域内的现象。</p>
<p>Electric cross-talk：相邻单元之间的光生少数载流子通过衬底扩散和漏电相互影响造成相邻单元的现象。</p>
<p>上述原因导致结果都是图像在对角线上相邻两个像素的Gr和Gb value差异较大而产生不平滑的纹理状。</p>
<p>（18）Gradation Control（GDC）：可能是对图像数据精度进行的操作</p>
<p>（19）Scaler：对图像进行缩放，缩放的过程中采样和插值直接影响图像的细节质量。</p>
<p>（20）Adaptive tone scale：(这个没有办法处理多种场景)进来的影像，根据histogram，可以调节，让其明暗亮度的曲线比较好看。因此，它最重要的就是histogram equalization，其关键是在哪个domain去做。目前我们的做法应该是在L*做histogram，但只做edge的histogram，这样就ok了。</p>
<p>（21）Dynamic Range Compression：就是把暗的地方变亮一些，亮的地方变暗一些。AE的主要目的是避免亮度饱和的pixels，其余exposure的pixel可以通过DRC校准回来。</p>
<h2 id="Iris"><a href="#Iris" class="headerlink" title="Iris"></a>Iris</h2><p>光圈是镜头上的一个组件，由机械或电压控制，可通过控制通光孔的开合程度，控制进光量的大小，光圈的进光量与其f值的平方成反比。DC-Iris不能精确定位，P-Iris能精确定位。</p>
<p>计量光学系统的通光量时使用f-stop作为计量单位，f-stop = f （镜头焦距）/ D（光圈孔径），f-stop值越大表示光圈孔径越小，常用的f-stop值一般在1.4~22之间,如下图所示。<br><img src="/images/sensor/v2-910b34243ef1be1dfba55f6f564290a0_720w.jpg" alt="img"></p>
<p>由于f-stop反比于光圈孔径，根据圆面积公式S=πD^2/4，镜头的实际通光量与f-stop的平方成反比，它们之间名义上的对应关系如下。<br><img src="/images/sensor/v2-907684804fe2f746a039be86ab42a9cf_720w.jpg" alt="img"></p>
<p>一般来说，光圈f值从f1.8<del>f22较常见， 其中 f1.8</del>f5.4，室内用得多一些；而f5.0以上室外用得多，暗场景一般使用最小的f值光圈以获得较大的通光量。</p>
<p>曝光表示的是照片所记录的光量多少，单位是EV。控制照片的明暗程度。曝光由光圈、快门速度、ISO感光度这三大要素来决定。开大光圈、降低快门速度、提升ISO感光度可以增加曝光。</p>
<p>快门速度指的是拍摄时照片曝光的时间。是控制曝光的三大要素之一。快门速度越高，曝光量越小，容易把照片拍暗。阳光过于强烈的室外可以使用高速快门获得恰当曝光。同时，快门速度越高越能定格高速运动的被摄体，防止手抖动。相反，快门速度越低，曝光量越大，容易将暗处拍亮。同时，运动被摄体越容易拍模糊，也容易产生手抖动。可以利用低速快门进行长时间曝光，通过被摄体抖动进行摄影表现，比如拍摄星轨等。</p>
<p>光圈是镜头上的小孔，可通过开大缩小来控制镜头的通光量。是控制曝光的三大要素之一。光圈值用F表示，F值越小光圈越大，小于F2.8的光圈一般被称为大光圈。光圈越大照片的曝光量也越大，有利于将暗处拍亮，或提升快门速度防止手抖动、定格运动被摄体。光圈大的时候，景深（照片中清晰的范围）也会变小，合焦面之外的虚化增大，可利用虚化营造柔美表现。相反，光圈越小照片的曝光量越小，景深则增大。可获得画面整体清晰的泛焦效果。但要注意快门速度可能降低。</p>
<p>ISO感光度原本是胶片时代，指代胶片上的感光材料对光线敏感程度的指标。是控制曝光的三大要素之一。数码时代，图像感应器取代了胶片，光信号要在图像感应器上转换为电信号才能记录为照片。提高ISO感光度相当于图像感应器对光信号进行电子增幅，对微弱光线增幅，可以把暗处拍亮。但因为是电子增幅，高感光度下会出现噪点，影响画质。相机的标准感光度为ISO 100。使用相对低的感光度不会出现噪点，但光线不够强的时候，可能需要大光圈或低速快门来增加曝光量。相同曝光量下，提高ISO感光度可以提升快门速度，定格运动被摄体或抑制手抖动。</p>
<p>测光模式<br>测光指的是相机对拍摄画面的明暗程度进行测量，以此为基准决定曝光。相机的测光模式一般有评价测光、局部测光、点测光、中央重点平均测光。最通常的测光模式是评价测光。评价测光将画面分成多个区域并分别进行测光估算出画面亮度的平均值，同时还会结合所用自动对焦点位置的信息综合考虑合焦被摄体的亮度，在大多数场景下，评价测光能够获得基本合适的曝光。其他几种测光模式则是以画面中央部分的亮度为基础来计算曝光。</p>
<p>曝光补偿<br>相机的自动曝光会倾向于将画面拍得不太暗也不太亮的中间亮度。所以在拍摄本身很黑或很白的被摄体时容易将其拍得发灰，不是肉眼所见的亮度。当相机的自动曝光无法获得所需画面亮度时，可以通过曝光补偿手动调节亮度，获得想要的明暗效果。相机曝光补偿的范围一般是±3EV，可以1/3级为单位调节。负向补偿照片变暗，正向补偿照片变亮。如现场很难判断补偿程度，可以结合自动包围曝光一次拍摄3张亮度不同照片选出理想的一张。</p>
<p>焦距指的是镜头中心到图像感应器的距离。单位是mm表。焦距直接反应的是镜头的视角，即镜头能够收入多大范围的画面。焦距越短收入的画面范围越大，焦距越长收入的画面范围越小。</p>
<p>被摄体的颜色会受环境光源的影响而产生偏色。AWB（自动白平衡）用于调节照片颜色，令白色能够还原为白色。</p>
<p>虚化<br>对焦后，画面中对上焦的合焦面是清晰的，从合焦面开始向前及向后的部分，成像会逐渐模糊。这种模糊就是虚化，虚化也被称为焦外。虚化与景深直接相关，影响虚化大小的要素是光圈、镜头焦距、拍摄距离（相机与被摄体之间的距离）。光圈越大（光圈值越小）虚化越大，此外镜头焦距越长，拍摄距离越近虚化也越大。作为摄影的表现手法，虚化又分为前景虚化及背景虚化。</p>
<h3 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h3><p>对焦后，画面中以合焦面为中心，向前及向后看起来清晰锐利的范围就是景深，也被称为焦内。景深与虚化直接相关，景深的大小由光圈、镜头焦距、拍摄距离（相机与被摄体之间的距离）这三个要素决定。光圈越小（光圈值越大）、镜头焦距越短、拍摄距离越远，相应景深就越大，照片整体越清晰，趋向于泛焦效果。相反的，光圈越大、镜头焦距越长、拍摄距离越近，相应景深就越小，合焦面前后更容易虚化，被摄体与背景趋于分离。</p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>sensor</tag>
      </tags>
  </entry>
  <entry>
    <title>spi总线</title>
    <url>/2022/06/07/hardware/spi-bus/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SPI(Serial Peripheral Interface)串行外设接口是一种用于芯片通信的串行同步传输总线协议，最初由Motorola在2000年提出。</p>
<ul>
<li><p>SPI允许传输单个bit数据，甚至允许暂停，因为SCK时钟线由主控设备控制，当没有时钟跳变时，从设备不采集或传送数据。</p>
</li>
<li><p>支持全双工通信，每个从设备需要独立的使能信号。</p>
</li>
<li><p>推挽输出的驱动性能相比开漏输出信号完整性更好，支持高速应用（100MHz以上）。</p>
</li>
<li><p>协议支持字长不限于8bits，可根据应用特点灵活选择消息字长。</p>
</li>
<li><p>相比I2C和SMbus节省上拉电阻，不需要仲裁机制。</p>
</li>
<li><p>没有寻址机制，只能靠设备片选选择不同从设备，故没有数据流控制和应答机制。</p>
</li>
<li><p>SPI没有规定最大传输速率，通常能达到10Mbps。</p>
</li>
</ul>
<p><strong>Dual SPI</strong>是针对SPI Flash而言，不是针对所有SPI外设。对于SPI Flash，全双工并不常用，因此修改了mosi和miso的用法，使其工作在半双工，能够加倍传输数据。也就是说对于Dual SPI Flash，可以发送一个命令字节进入dual mode，这样mosi变成SIO0，mosi变成SIO1，这样一个时钟周期内就能传输2个bit数据。</p>
<p><strong>Qual SPI</strong>也是针对SPI Flash，Qual SPI 在Dual SPI基础上增加了两根线（SIO2、SIO3），目的是一个时钟内能传输4个bit数据。</p>
<h2 id="信号定义"><a href="#信号定义" class="headerlink" title="信号定义"></a>信号定义</h2><p><strong>MOSI</strong>：主设备数据输出，从设备数据输入。</p>
<p><strong>MISO</strong>：主设备数据输入，从设备数据输出。</p>
<p><strong>SCLK</strong>：时钟信号，由主设备产生。</p>
<p><strong>CS/SS</strong>：片选，从设备使能信号，由主设备控制。</p>
<p>SPI总线定义两个及以上设备间的数据传输，提供时钟的设备为主设备，接收时钟的设备为从设备。片选信号SS通常低电平有效。SPI数据传输原理是基于主从设备内部移位寄存器的数据交换。在主设备SCK的控制下，待传数据由各自设备的数据寄存器传输到移位寄存器，再通过MOSI和MISO信号线完成主从设备间的数据交换。</p>
<p><img src="/images/spi/spi_ms_mod_reg.png" alt="spi框图"></p>
<h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p>SPI有4种操作模式，每种模式由一对参数决定，主从设备必须使用相同的工作参数，才能正常工作。</p>
<p>CPOL时钟极性(clock polarity)，决定时钟空闲时的电平为高或低，对于SPI数据传输格式没有显著影响。</p>
<ul>
<li>0 : 时钟高电平时有效，空闲时为低。</li>
<li>1 : 时钟低电平时有效，空闲时为高。</li>
</ul>
<p>CPHA时钟相位(clock phase)，定义时钟脉冲在哪条边沿转换输出信号，哪条边沿采样输入信号。</p>
<ul>
<li>0 : 数据采样发生在时钟奇数边沿。</li>
<li>1 : 数据采样发生在时钟偶数边沿。</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>Mode 0</td>
<td>SCLK 空闲是为低电平，数据在上升沿有效</td>
</tr>
<tr>
<td>Mode 1</td>
<td>SCLK 空闲是为低电平，数据在下降沿有效</td>
</tr>
<tr>
<td>Mode 2</td>
<td>SCLK 空闲是为高电平，数据在下降沿有效</td>
</tr>
<tr>
<td>Mode 3</td>
<td>SCLK 空闲是为高电平，数据在上升沿有效</td>
</tr>
</tbody></table>
<p><img src="/images/spi/4mode.png" alt="4种模式"></p>
<p><img src="/images/spi/timing_diagram.png" alt="时序"></p>
<h2 id="多个从设备"><a href="#多个从设备" class="headerlink" title="多个从设备"></a>多个从设备</h2><ul>
<li><strong>片选方式</strong></li>
</ul>
<p>每个从设备都需要单独的片选信号，主设备每次只能选择其中一个从设备进行通信。因为所有从设备的SCK、MOSI、MISO都是连在一起的，未被选中从设备的MISO要表现为高阻状态以避免数据传输错误。由于每个设备都需要单独的片选信号，如果需要的片选信号过多，可以使用译码器产生所有的片选信号。</p>
<p><img src="/images/spi/multiple-slaves.png" alt="主设备以片选方式控制多个从设备"></p>
<ul>
<li><strong>菊花链方式</strong></li>
</ul>
<p>数据信号经过主从设备所有的移位寄存器构成闭环。数据通过主设备发送（绿色线）经过从设备返回（蓝色线）到主设备。在这种方式下，片选和时钟同时接到所有从设备。</p>
<p>菊花链式连接常用于仅需主设备发送数据而不需要接收返回数据的场合，如LED驱动器。在这种应用下，主设备MISO可以不连。如果需要接收从设备的返回数据，则需要连接主设备的MISO形成闭环。同样地，切记要发送足够多的接收指令以确保数据移位送达主设备。</p>
<p><img src="/images/spi/multiple-slaves2.png" alt="主设备以菊花链方式控制多个从设备"></p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>spi</tag>
      </tags>
  </entry>
  <entry>
    <title>RJ45 interface</title>
    <url>/2022/06/07/hardware/rj45/</url>
    <content><![CDATA[<p>以太网信号最终是通过RJ45接头接入网络的。RJ是Registered Jack的缩写，意思是注册的插座。在FCC（美国联邦通信委员会标准和规章）中RJ是描述公用电信网络的接口，计算机网络的RJ45是标准8位模块化接口的俗称。连接器由插头（8P8C接头，水晶头）和插座组成。</p>
<p>RJ45型网线插头又称水晶头，有两种连接方式，分别称作 T568A 线序和 T568B 线序。两者的主要区别是橙色和绿色双绞线进行了交换。</p>
<p>这两种标准只是在线缆颜色上有所区别，目的是在线缆侧实现交叉互连。直连线常用于异种网络之间的互连（比如计算机交换机之间），交叉线常用于同种网络之间的互联（比如计算机与之间）。</p>
<p><img src="/images/net/RJ45/RJ-45_T568AB.jpg" alt="RJ-45接线图"></p>
<p><img src="/images/net/RJ45/T568AB.bmp" alt="RJ-45接线图2"></p>
<p>交叉互连，所谓交叉是指网线的一端和另一端与 RJ45 网线插头的接法不同，一端按 T568A 线序接，另一端按 T568B 线序接，即有几根网线在另一端是先做了交叉才接到 RJ45 插头上去的，适用的场合：</p>
<ul>
<li>电脑——电脑，称对等网连接</li>
<li>集线器——集线器</li>
<li>交换机——交换机</li>
</ul>
<p>直连线互连的网线的两端均按T568B接线，适用场合：</p>
<ul>
<li>电脑——ADSL 猫</li>
<li>ADSL猫——ADSL 路由器的 WAN 口</li>
<li>电脑——ADSL 路由器的 LAN 口</li>
<li>电脑——集线器或交换机</li>
</ul>
<p>现在PHY芯片大部分具有自动交叉（auto MDI-X）的能力，它可以实现RJ-45接口的传送信号线和接收信号线的功能自动互相交换，有的PHY甚至支持一对线中的正信号和负信号的功能自动交换，这样就不必考虑选用直连网线还是交叉网线，只需要直连即可。</p>
<p><img src="/images/net/RJ45/T-568A.jpg" alt="T-568A"></p>
<p><img src="/images/net/RJ45/T-568B.jpg" alt="T-568B"></p>
<p><img src="/images/net/RJ45/RJ45-pinout.jpg" alt="RJ45-pinout"></p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
  </entry>
  <entry>
    <title>speaker</title>
    <url>/2022/06/07/hardware/speaker/</url>
    <content><![CDATA[<ul>
<li><strong>额定阻抗</strong></li>
</ul>
<p>额定阻抗是指音频为400Hz时，从扬声器输入端测得的阻抗。它一般是音圈直流电阻的1.2~1.5倍。一般动圈式扬声器常见的阻抗有4Ω、8Ω、16Ω、32Ω等。</p>
<ul>
<li><strong>功率</strong></li>
</ul>
<p>扬声器的功率分为额定功率、最小功率、最大功率和瞬间功率，单位均为W。</p>
<p>额定功率也称标称功率，是指扬声器长时间正常连续工作而无明显失真的输入平均电功率。</p>
<p>最小功率也称起步功率，是指扬声器能被推动工作的基准电功率值。</p>
<p>最大功率也称最大承载功率，是指扬声器长时间连续工作时所能承受的最大输入功率。</p>
<p>瞬间功率也称瞬时承受功率，是指扬声器在短时间内（10ms）所能承受的最大功率，一般为额定功率的8~30倍。</p>
<ul>
<li><strong>频率特性</strong></li>
</ul>
<p>扬声器的频率特性是指当输入扬声器的信号电压恒定不变时，扬声器有参考轴上的输出声压随输入信号的频率变化而变化的规律。它是一条随频率变化的频率响应（简称频响）曲线，反映了扬声器对不同频率声波的辐射能力。</p>
<p>扬声器的频响曲线是具有许多峰谷点的不规则连续曲线，将扬声器的谐振频率作为低频不限频率，而将频响曲线高频端的交点作为高频上限频率。低频下限与高频上限之间的频率范围。称为扬声器的有效频率范围。</p>
<p>扬声器的频响曲线越平坦，说明频率失真越小，有效频率范围越宽。</p>
<p>一般低音扬声器的频率范围在20 ~ 3kHZ之间，中音扬声器的频率范围在500 ~ 5kHZ之间，高音扬声器的频率范围在2 ~ 20kHZ之间。</p>
<ul>
<li><strong>谐振频率</strong></li>
</ul>
<p>谐振频率是扬声器频率范围的下限，谐振频率低，扬声器的低音重放的质感和力度也越好。</p>
<p>低音扬声器的谐振频率值一般是随其口径的增大而降低，6in（in=0.0254m）低音扬声器的谐振频率为50HZ左右，8in（in=0.0254m）低音扬声器的谐振频率为40HZ左右，10in低音扬声器的谐振频率为30HZ左右，12in低音扬声器的谐振频率为20HZ左右。</p>
<ul>
<li><strong>灵敏度（dB/W）</strong></li>
</ul>
<p>灵敏度也称输出声压级，主要用来反映扬声器的电-声转换效率。高灵敏度扬声器，用较小的电功率即可推动它。</p>
<p>扬声器的灵敏度有特性灵敏度级和平均特性灵敏度两种表示方法，前者最常用且误差较小。</p>
<p>扬声器的灵敏度是指输入功率为1W的噪声电压时，在扬声器轴向正面1m处所测得的声压大小。灵敏度是衡量扬声器对音频信号中的细节能否巨细无遗地重放的指标。灵敏度越高，则扬声器对音频信号中细节均能作出的响应。作为Hi-Fi扬声器的灵敏度应大于86dB/W。</p>
<ul>
<li><strong>失真度</strong></li>
</ul>
<p>扬声器的失真主要表现为重放声音与原始声音有差异。它又分为谐波失真、瞬态失真、互调失真和相位失真。</p>
<ul>
<li><strong>等效质量</strong></li>
</ul>
<p>扬声器的等效质量也称振动质量，是扬声器振动系统的静态质量（指振膜和音圈本身的质量）与同振质量（指振膜两边随之一起振动的部分空气层的质量）之和。</p>
<p>等效质量与扬声器的口径成正比，与扬声器的谐振频率成反比。</p>
<ul>
<li><strong>等效顺性</strong></li>
</ul>
<p>等效顺性也称力顺或声顺，表示扬声器悬置系统的松紧度（指折环和定位支片的柔软程度）或称为受力后位移的顺从性。</p>
<ul>
<li><strong>弹性系数</strong></li>
</ul>
<p>扬声器的弹性系数也称振动系统的等效力劲度，是表示锥盆折环和定位支片刚性的参数，它与扬声器的谐振频率成正比，与振动系统的等效质量成反比。</p>
<ul>
<li><strong>总品质因数</strong></li>
</ul>
<p>扬声器的总品质因数也称Qts值，用来反映其振动系统消耗能量的较慢，即表示振动系统损耗的大小。</p>
<ul>
<li><strong>等效容积</strong></li>
</ul>
<p>扬声器等效容积是指扬声器振动系统顺性的等效空气容积。扬声器的口径越大，其等效容积也越大。</p>
<ul>
<li><strong>等效振动半径</strong></li>
</ul>
<p>扬声器的等效振动半径也称振膜有效面积，它表示有助于声音辐射的面积，一般指从振膜中心到折环中间处的长度。</p>
<ul>
<li><strong>磁感应强度与磁通量</strong></li>
</ul>
<p>磁感应强度也称磁隙强度，用来表示扬声器空气隙中磁场强度的品质标记。</p>
<p>磁通量等于磁感应强度与空气隙面积平均值的乘积。</p>
<ul>
<li><strong>线性范围</strong></li>
</ul>
<p>扬声器的线性范围是指振膜的最大线性位移。扬声器工作时，若振膜的位移超过线性范围值，放音失真就会增大。</p>
<ul>
<li><strong>指向性</strong></li>
</ul>
<p>指向性是指扬声器在不同方向的声压辐射能力随频率而变化的特性，或指扬声器声波辐射到空间各个方向的能力。输入扬声器的信号频率越高，指向性越强。指向性与扬声器的口径有关，口径大时指向性尖，口径小时指向性宽。指向性还与频率有关，一般而言，对250Hz以下的低频信号，没有明显的指向性。对1.5kHz以下的高频信号则有明显的指向性。</p>
<ul>
<li><strong>谐波失真（TMD%）</strong></li>
</ul>
<p>扬声器的失真有很多种，常见的有谐波失真（多由扬声器磁场不均匀以及振动系统的畸变而引起，常在低频时产生）、互调失真（因两种不同频率的信号同时加入扬声器，互相调制引起的音质劣化）和瞬态失真（因振动系统的惯性不能紧跟信号的变化而变化，从而引起信号失真）等。谐波失真是指重放时，增加了原信号中没有的谐波成份。扬声器的谐波失真来源于磁体磁场不均匀、振动膜的特性、音圈位移等非线性失真。目前，较好的扬声器的谐波失真指标不大于5%。</p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
  </entry>
  <entry>
    <title>usb协议</title>
    <url>/2022/06/07/hardware/usb/</url>
    <content><![CDATA[<h2 id="USB规范"><a href="#USB规范" class="headerlink" title="USB规范"></a>USB规范</h2><p>USB最初是由英特尔与微软公司倡导发起，其最大的特点是支持热插拔(Hot plug)和即插即用(Plug&amp;Play)。</p>
<p><strong>电压范围4.75 ~ 5.25V</strong>，普通USB接口<strong>最大提供500mA电流</strong>，USB符号后有一个“+”号的，输出电流可达1A。</p>
<p><strong>一个USB主控制器最多可连接127个设备，各设备之间的距离不超过5米</strong>。</p>
<table>
<thead>
<tr>
<th align="left">USB版本</th>
<th align="left">速率称号</th>
<th align="left">传输速率</th>
<th align="left">理论速度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">USB 3.2</td>
<td align="left">超高速+  Super-Speed+</td>
<td align="left">20Gbps</td>
<td align="left">2560MB/s</td>
</tr>
<tr>
<td align="left">USB 3.1 Gen2</td>
<td align="left">超高速+  Super-Speed+</td>
<td align="left">10Gbps</td>
<td align="left">1280MB/s</td>
</tr>
<tr>
<td align="left">USB 3.1 Gen1</td>
<td align="left">超高速 Super-Speed</td>
<td align="left">5Gbps</td>
<td align="left">640MB/s</td>
</tr>
<tr>
<td align="left">USB 2.0</td>
<td align="left">高速 Hi-Speed</td>
<td align="left">480Mbps</td>
<td align="left">60MB/s</td>
</tr>
<tr>
<td align="left">USB 1.1</td>
<td align="left">全速 Full-Speed</td>
<td align="left">12Mbps</td>
<td align="left">1.5MB/s</td>
</tr>
<tr>
<td align="left">USB 1.0</td>
<td align="left">低速 Low-Speed</td>
<td align="left">1.5Mbps</td>
<td align="left">0.192MB/s</td>
</tr>
</tbody></table>
<p>USB2.0 支持 3 种传输速度:低速模式(1.5Mb/s)、全速模式(12Mb/s)和高速模式(480Mb/s)。在低速和全速模式中，采用的是电压传输模式；高速模式下，是电流传输模式。</p>
<p>USB2.0 规范要求集线器必须支持高速模式，USB2.0 设备则没有这个要求。一个高速的上行收发器不能支持低速信号传输模式。而 USB2.0 下行收发器必须支持高速、全速和低速模式。</p>
<h3 id="插入检测机制"><a href="#插入检测机制" class="headerlink" title="插入检测机制"></a>插入检测机制</h3><p>在 USB 集线器的每个下游端口的 D+和 D-上，分别接了一个 15kΩ的下拉电阻。当集线器端口没有设备插入时，输入端被这两个下拉电阻拉到了低电平。而在USB 设备端，在 D+或者 D-上，接了一个 1.5kΩ的上拉电阻到 3.3V 的电源。<strong>对于高速设备和全速设备，上拉电阻接在 D+上；低速设备，上拉电阻接在 D-上</strong>。</p>
<p>当设备插入到集线器时，接了上拉电阻的数据线的电压由 1.5kΩ的上拉电阻和 15kΩ的下拉电阻分压，大概 3V 左右。这是一个高电平信号。集线器检测到该状态后就上报给 Host控制器，这样就检测到设备插入。通过检测高电平的数据线是 D+还是 D-来判断设备是什么速度类型。</p>
<p>高速设备会首先被判断为全速设备，然后通过集线器和设备两者确认，切换到高速模式下。高速模式下是电流传输模式，此时需要把 D+的上拉电阻断开。</p>
<h2 id="USB结构"><a href="#USB结构" class="headerlink" title="USB结构"></a>USB结构</h2><p><img src="/images/usb/bus-topology.png" alt="usb拓扑结构"></p>
<p>USB是一种主从结构的系统，主机叫做Host，从机叫做设备。USB的设计为非对称式的，它由一个主机(host)控制器和若干通过集线器设备以树形连接的设备组成。以根集线器为起点，最多支持7层，也就是说在USB系统中最多允许5个hub级联。一个USB主控制器最多连接127个设备，这是因为协议规定每个USB设备具有一个7bit的地址，地址0是保留给未初始化的设备使用。</p>
<h3 id="USB-Host"><a href="#USB-Host" class="headerlink" title="USB Host"></a>USB Host</h3><p>主机具有一个或多个usb主控制器和根集线器(root hub)。主控制器负责数据处理。根集线器则提供一个连接主控制器与设备之间的接口和通道，它集成在主机控制器里，不占用地址。</p>
<p>Host 主要负责:</p>
<ul>
<li>检测 USB 设备拔插</li>
<li>管理 Host 和 Device 之间的控制流、数据流</li>
<li>收集 USB 总线状态和活动数据信息</li>
<li>为连入 USB 总线的设备供电</li>
</ul>
<h3 id="USB-Device"><a href="#USB-Device" class="headerlink" title="USB Device"></a>USB Device</h3><p>USB 设备通过 HUB 连接到 USB 总线上，此时 HUB 上的接入点称为端口(Port)。连接到 Hub 上的设备可能是单个设备，也可以是复合设备(Compound<br>Device)。每一个 USB 设备提供不同的功能，又被称作 Function。</p>
<p>USB 设备支持热插拔。USB 设备通过 HUB 连接到 USB 总线。Hub 有一个状态位，标记 USB 设备是插入还是拔出。Host 会查询 Hub 端口的状态位，当检测到设备插入时，Host 将使能该 Hub 对应的 port，并通过默认地址(0)从设备控制管道为设备分配地址。当一个设备从 Hub 的某个 port 拔出时，Hub 将禁能该 port 并报告给 Host。</p>
<p>从 USB 系统角度而言，一个逻辑上的 USB 设备是一个端点的集合。分组的端点构成一个接口(Interface)。USB 系统通过管道来管理接口，通过 Host 上的 Buffer 和 USB 设备上的端点来请求数据。 Host Controller 打包数据并将数据包发送出去。</p>
<h3 id="USB-Hub"><a href="#USB-Hub" class="headerlink" title="USB Hub"></a>USB Hub</h3><p>USB集线器是一种可以对原有的USB口在数量上进行扩展的设备。hub提供了设备连接检测和设备移除检测的能力，并给各下行端口供电。 可以单独使能下行端口，不同端口可以工作在不同的速度等级。</p>
<h2 id="USB通信协议"><a href="#USB通信协议" class="headerlink" title="USB通信协议"></a>USB通信协议</h2><h3 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h3><p>数据在 USB 线里传送是低位在前高位在后。USB 采用 NRZI(非归零编码)对发送的数据包进行编码，即:输入数据 0，编码成“电平翻转”；输入数据 1，编码成“电平保持”。</p>
<p><img src="/images/usb/NRZI.png" alt="NRZI编码"></p>
<p>USB提供了4 种传输方式：</p>
<ul>
<li>控制(Control)传输方式。双向传输，数据量通常较小，主要用来进行查询、配置和给 USB 设备发送通用的命令。</li>
<li>同步(Synchronization)传输方式。提供了确定的带宽和间隔时间，它被用于时间严格并具有较强容错性的流数据传输，或者用于要求恒定的数据传送率的即时应用。例如进行语音业务传输时，使用同步传输方式是很好的选择</li>
<li>中断(Interrupt)传输方式。传送是单向的，对于 USB 主机而言，只有输入。中断传输方式主要用于定时查询设备是否有中断数据要传送，该传输方式应用在少量的、分散的、不可预测的数据传输场合，键盘、游戏杆和鼠标属于这一类型。</li>
<li>批量(Bulk)传输方式。主要应用在没有带宽和间隔时间要求的批量数据的传送和接收，它要求保证传输打印机和扫描仪属于这种类型。</li>
</ul>
<h2 id="USB协议"><a href="#USB协议" class="headerlink" title="USB协议"></a>USB协议</h2><p>USB 是一种轮询总线，由 Host 发起所有的数据传输。总线传输包含 3 个包(packet)。每个传输都由 Host 先发出令牌包(Token Packet)，明确传输类型、传输方向、USB 设备地址和端点号。对应地址的 USB 设备接收并解析包。一次传输可以由 Host 发向设备，也可以由设备发送至 Host，方向由令牌包说明。</p>
<h3 id="USB数据包"><a href="#USB数据包" class="headerlink" title="USB数据包"></a>USB数据包</h3><ul>
<li><strong>USB数据包格式</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">偏移量</th>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">HeaderChksum</td>
<td align="center">1</td>
<td align="center">利用添加包头进行效验，不包括包头本身的校验。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">HeaderSize</td>
<td align="center">1</td>
<td align="center">包头的大小，包括可用的字符串。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Signature</td>
<td align="center">2</td>
<td align="center">数据值为0x1234</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">VendorID</td>
<td align="center">2</td>
<td align="center">USB提供商的ID</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">ProductID</td>
<td align="center">2</td>
<td align="center">USB产品ID</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">ProductVersion</td>
<td align="center">1</td>
<td align="center">产品版本号</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">FirmwareVersion</td>
<td align="center">1</td>
<td align="center">固件版本号</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">USB属性</td>
<td align="center">1</td>
<td align="center">USB Attribute: Bit 0：如果设为1，包头包括以下三个字符串：语言、制造商、产品字符串；如果设为0，包头不包括任何字符串。 Bit 2：如果设为1，设备自带电源；如果设为0，无自带电源。 Bit 3：如果设为1，设备可以通过总线供电；如果设为0，无法通过总线供电。 Bits 1 and 4—7：保留。</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">最大电力</td>
<td align="center">1</td>
<td align="center">设备需要的最大电力，以2mA为单位。</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">设备属性</td>
<td align="center">1</td>
<td align="center">Device Attributes: Bit 0：如果设为1，CPU运行在24 MHz；如果设为0，CPU运行在12 MHz。 Bit 3：如果设为1，设备的EEPROM可以支持400 MHz；如果设为0，不支持400 MHz。 Bits 1, 2 and 4 … 7：保留。</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">WPageSize</td>
<td align="center">1</td>
<td align="center">I2C的最大写入页面大小</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">数据类型</td>
<td align="center">1</td>
<td align="center">该数值定义设备是软件EEPROM还是硬件EEPROM。0x02：硬件EEPROM 其它数值无效。</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">RpageSize</td>
<td align="center">1</td>
<td align="center">I2C最大读取页面大小。如果值为0，整个负载大小由一个I2C读取设备读取。</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">PayLoadSize</td>
<td align="center">2</td>
<td align="center">如果将EEPROM作为软件EEPROM使用，表示软件的大小；除此之外该值都是0。</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Language string</td>
<td align="center">4</td>
<td align="center">语言字符串。以标准USB字符串格式表示。（非必要字段）</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Manufacture string</td>
<td align="center">…</td>
<td align="center">制造商字符串。以标准USB字符串格式表示。（非必要字段）</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Product string</td>
<td align="center">…</td>
<td align="center">产品字符串，以标准USB字符串格式表示。（非必要字段）</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Application Code</td>
<td align="center">…</td>
<td align="center">表示应用代码。以标准USB字符串格式表示。（非必要字段）</td>
</tr>
</tbody></table>
<h2 id="USB设备"><a href="#USB设备" class="headerlink" title="USB设备"></a>USB设备</h2><h3 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h3><p>依附在总线上的设备可以是需要特定的驱动程序的完全定制的设备，也可能属于某个设备类别。这些类别定义设备的行为和接口描述符，这样一个驱动程序可能用于所有此种类别的设备。一般操作系统都为支持这些设备类别，为其提供通用驱动程序。设备分类由USB设计论坛设备工作组决定，并分配ID。</p>
<p>如果一个设备类型属于整个设备，该设备的描述符的bDeviceClass域保存类别ID；如果它这是设备的一个接口，其ID保存在接口描述符的bInterfaceClass域。他们都占用一个字节，所以最多有253种设备类别。（0x00和0xFF保留）。当bDeviceClass设为0x00，操作系统会检查每个接口的bInterfaceClass以确定其类别。</p>
<p>常用设备类别和ID有：<br>|  ID  |       设备        |                             例子                             |<br>| :–: | :—————:| :———————————————————-: |<br>| 0x00 | 保留值       |                              无                              |<br>| 0x01 | 音效设备      |                             声卡                             |<br>| 0x02 | USB通信控制设备   |                  网卡、调制解调器、串列端口                   |<br>| 0x03 | 人机界面设备(HID)  |                          键盘、鼠标                          |<br>| 0x05 | 物理接口设备      |        控制杆    |<br>| 0x06 | 静止图像捕捉设备  | 影像扫描仪、Picture Transfer Protocol |<br>| 0x07 |  打印设备        |        打印机      |<br>| 0x08 | 大容量访问设备    | U盘、移动硬盘、存储卡读卡器、数字相机 |<br>| 0x09 | 集线器       |                            集线器                            |<br>| 0x0A | 通信设备      | 调制解调器、网络卡、ISD、传真 |<br>| 0x0B | 智能卡设备     |                            读卡器                            |<br>| 0x0E | 影像设备    |      摄像头   |<br>| 0xE0 | 无线传输设备   |          蓝牙   |<br>| 0xFE | 特殊的应用    |                       红外线资料桥接器                       |<br>| 0xFF | 定制设备      |                                                              |</p>
<h3 id="lsusb"><a href="#lsusb" class="headerlink" title="lsusb"></a>lsusb</h3><p>显示本机的usb设备列表，可以显示出usb的详细信息，包括设备的读取速度和描述符。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-v</td>
<td>告诉lsusb详细显示所示设备的详细信息。这包括设备当前速度的配置描述符。如果可用，类描述符将显示USB设备类，包括集线器、音频、HID、通信和芯片卡。</td>
</tr>
<tr>
<td>-s [[bus]:][devnum]</td>
<td>显示指定总线和设备号的设备信息，总线和设备号用十进制标识。格式：lsusb –s 00:01</td>
</tr>
<tr>
<td>-d [vendor]:[product]</td>
<td>显示指定厂商和产品编号的设备，用十六进制表示编号。格式：lsusb –d 8086:</td>
</tr>
<tr>
<td>-D</td>
<td>显示指定设备文件的设备信息，例如：<code>lsusb –D /proc/bus/usb/001/001</code>。只有root用户才可以使用这个选项</td>
</tr>
<tr>
<td>-t</td>
<td>以树状结构显示</td>
</tr>
<tr>
<td>-V</td>
<td>指令版本信息</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>usb</tag>
      </tags>
  </entry>
  <entry>
    <title>串口通信协议</title>
    <url>/2022/06/07/hardware/uart-bus/</url>
    <content><![CDATA[<h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p>UART通用异步接收器/发送。传输数据包由起始位、数据帧、奇偶校验位和停止位组成。</p>
<p><img src="/images/uart/uart.png" alt="img"></p>
<p><strong>起始位</strong></p>
<p>当不传输数据时，UART数据传输线通常保持高电压电平。若要开始数据传输，发送UART会将传输线从高电平拉到低电平并保持1个时钟周期。当接收UART检测到高到低电压跃迁时，便开始以波特率对应的频率读取数据帧中的位。</p>
<p><strong>数据帧</strong></p>
<p>数据帧包含所传输的实际数据，如果使用奇偶校验位，数据帧长度可以是5 - 8位。如果不使用奇偶校验位，数据帧长度可以是9位。低位先发送。</p>
<p><strong>校验</strong></p>
<p>通过奇偶校验位，接收器就可以判断传输期间是否有数据发生改变，当奇偶校验位与数据匹配时，则认为传输未出错。</p>
<ul>
<li>奇校验(odd parity)：让传输的数据（包含校验位）中1的个数是否为奇数，即如果传输字节中1的个数是偶数，则校验位就要为1，否则为0。</li>
<li>偶校验(even parity)：传输的数据（包含校验位）中1的个数是否为偶数，即如果传输字节中1的个数是偶数，则校验位就要为0，否则为0。</li>
<li>1校验(mark parity): 校验位始终为1。</li>
<li>0校验(space parity): 校验位始终为0。</li>
</ul>
<p><strong>停止位</strong></p>
<p>表示一帧数据的结束，发送端将数据传输线从低电压驱动到高电压并保持1、1.5、2bit的时间。</p>
<p>波特率：意思是每秒传输这么多个比特位数(bit)。</p>
<p>1、当为奇数校验：”A”字符的8个bit位中有两个1,那么奇偶校验位为1才能满足1的个数为奇数(奇校验)。图-1的波形就是这种情况。<br>2、当为偶数校验：”A”字符的8个bit位中有两个1,那么奇偶校验位为0才能满足1的个数为偶数(偶校验)。<br>此位还可以去除，即不需要奇偶校验位。</p>
<h2 id="RS232"><a href="#RS232" class="headerlink" title="RS232"></a>RS232</h2><p>RS232是串口的一个标准，RS232是负逻辑电平，它定义+5 ~ +12V为低电平，而-12 ~ -5V为高电平。</p>
<ul>
<li>最大传输距离 50 米。</li>
<li>传输速率较低，在异步传输时，波特率为 20Kbps。</li>
<li>只允许一对一通信。</li>
</ul>
<p><img src="/images/uart/RS232.webp" alt="img"><br><img src="/images/uart/max3232.png" alt="max3232"></p>
<h2 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a>RS485</h2><p>RS-232接口只能点对点的通信，不能实现联网功能，于是一个新的标准RS-485产生了。RS-485使用一对双绞线采用差分传输方式，由于是差分通信，因此数据的接收和发送数据不能同时进行，只能工作在半双工模式，常用于总线网。</p>
<ul>
<li>电气特性：逻辑1以两线间的电压差为+2 ~ 6V表示；逻辑0以两线间的电压差为-2 ~ 6V表示。</li>
<li>最大的通信距离约为1200米（9600bps 时），实际上可达 3000 米。</li>
<li>最大传输速率为10Mb/s。</li>
<li>RS-485总线一般最大支持32个节点。</li>
</ul>
<p><img src="/images/uart/max485.png" alt="MAX485"></p>
<p>为了提高RS485的抗干扰性能，需要在靠近MAX485的AB引脚之间并接一个100 ~ 1K的电阻。</p>
<h2 id="RS422"><a href="#RS422" class="headerlink" title="RS422"></a>RS422</h2><p>RS-422（EIA RS-422-A Standard）是Apple的Macintosh计算机的串口连接标准。有4根信号线：两根发送，两根接收。由于RS-422 的收与发是分开的，所以可以全双工，适用于两个站之间通信，星型网、环网，不可用于总线网。</p>
<ul>
<li>最大传输距离为1219米，最大传输速率为10Mb/s。</li>
<li>最多可接10个节点。</li>
<li>支持点对多的双向通信。</li>
</ul>
<p><img src="/images/uart/RS-xxx.webp" alt="RS-xxx"></p>
<h2 id="帧协议"><a href="#帧协议" class="headerlink" title="帧协议"></a>帧协议</h2><p><img src="/images/uart/uart-protocol.jpg" alt="img"></p>
<hr>
<p><a href="https://www.analog.com/cn/analog-dialogue/articles/uart-a-hardware-communication-protocol.html">https://www.analog.com/cn/analog-dialogue/articles/uart-a-hardware-communication-protocol.html</a></p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>uart</tag>
      </tags>
  </entry>
  <entry>
    <title>常用贴片三极管丝印与型号对照表</title>
    <url>/2022/06/07/hardware/triode/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>丝印</th>
<th>三极管型号</th>
</tr>
</thead>
<tbody><tr>
<td>1A</td>
<td>BC846A</td>
</tr>
<tr>
<td>1AM</td>
<td>MMBT3904</td>
</tr>
<tr>
<td>1AMZ</td>
<td>MMBT3904LT1</td>
</tr>
<tr>
<td>1B</td>
<td>BC846B</td>
</tr>
<tr>
<td>1D</td>
<td>MMBTA42</td>
</tr>
<tr>
<td>1E</td>
<td>BC847A</td>
</tr>
<tr>
<td>1F</td>
<td>BC847B</td>
</tr>
<tr>
<td>1G</td>
<td>BC847C</td>
</tr>
<tr>
<td>1J</td>
<td>BC848A</td>
</tr>
<tr>
<td>1K</td>
<td>BC848B</td>
</tr>
<tr>
<td>1L</td>
<td>BC848C</td>
</tr>
<tr>
<td>1T</td>
<td>S9011</td>
</tr>
<tr>
<td>1P</td>
<td>MMBT2222</td>
</tr>
<tr>
<td>2T</td>
<td>S9012</td>
</tr>
<tr>
<td>2A</td>
<td>MMBT3906</td>
</tr>
<tr>
<td>2AM</td>
<td>S8550</td>
</tr>
<tr>
<td>2D</td>
<td>MMBTA92</td>
</tr>
<tr>
<td>2F</td>
<td>MMBT2907</td>
</tr>
<tr>
<td>2L</td>
<td>MMBT5401</td>
</tr>
<tr>
<td>2T1</td>
<td>S9012</td>
</tr>
<tr>
<td>2TY</td>
<td>S8550</td>
</tr>
<tr>
<td>2X</td>
<td>2N4401</td>
</tr>
<tr>
<td>3A</td>
<td>BC856A</td>
</tr>
<tr>
<td>3B</td>
<td>BC856B</td>
</tr>
<tr>
<td>3E</td>
<td>BC857A</td>
</tr>
<tr>
<td>3F</td>
<td>BC857B</td>
</tr>
<tr>
<td>3J</td>
<td>BC858A</td>
</tr>
<tr>
<td>3K</td>
<td>BC858B</td>
</tr>
<tr>
<td>3L</td>
<td>BC858C</td>
</tr>
<tr>
<td>5A</td>
<td>BC807-16</td>
</tr>
<tr>
<td>5B</td>
<td>BC807-25</td>
</tr>
<tr>
<td>5C</td>
<td>BC807-40</td>
</tr>
<tr>
<td>6A</td>
<td>BC817-16</td>
</tr>
<tr>
<td>6B</td>
<td>BC817-25</td>
</tr>
<tr>
<td>6C</td>
<td>BC817-40</td>
</tr>
<tr>
<td>702</td>
<td>2N7002</td>
</tr>
<tr>
<td>AD</td>
<td>2SC3838</td>
</tr>
<tr>
<td>BA</td>
<td>2SA1015</td>
</tr>
<tr>
<td>CR</td>
<td>2SC945</td>
</tr>
<tr>
<td>CS</td>
<td>2SA733</td>
</tr>
<tr>
<td>G1</td>
<td>MMBT5551</td>
</tr>
<tr>
<td>HF</td>
<td>2SC1815</td>
</tr>
<tr>
<td>J3</td>
<td>S9013</td>
</tr>
<tr>
<td>J3Y</td>
<td>S8050</td>
</tr>
<tr>
<td>J6</td>
<td>S9014</td>
</tr>
<tr>
<td>J8</td>
<td>S9018</td>
</tr>
<tr>
<td>KL4</td>
<td>BAT54S</td>
</tr>
<tr>
<td>L6</td>
<td>2SC1623</td>
</tr>
<tr>
<td>M5C</td>
<td>MMBD7000</td>
</tr>
<tr>
<td>M6</td>
<td>S9015</td>
</tr>
<tr>
<td>R23</td>
<td>2SC3356</td>
</tr>
<tr>
<td>V1</td>
<td>UN2111</td>
</tr>
<tr>
<td>V2</td>
<td>UN2112</td>
</tr>
<tr>
<td>V3</td>
<td>UN2113</td>
</tr>
<tr>
<td>V4</td>
<td>UN2211</td>
</tr>
<tr>
<td>V5</td>
<td>UN2212</td>
</tr>
<tr>
<td>V6</td>
<td>UN2213</td>
</tr>
<tr>
<td>W2A</td>
<td>PMBT3906</td>
</tr>
<tr>
<td>Y1</td>
<td>S8050</td>
</tr>
<tr>
<td>Y2</td>
<td>S8550</td>
</tr>
<tr>
<td>Y6</td>
<td>S9016</td>
</tr>
<tr>
<td>Z14</td>
<td>BZX84-C3V3</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
  </entry>
  <entry>
    <title>usb接口</title>
    <url>/2022/06/07/hardware/usb_if/</url>
    <content><![CDATA[<p><img src="/images/usb/usb-if2.png" alt="usb接口"></p>
<p><img src="/images/usb/usb-if3.png" alt="usb接口"></p>
<p><img src="/images/usb/usb_if.bmp" alt="usb接口"></p>
<p><img src="/images/usb/usb-if.png" alt="usb接口"></p>
<p>标准USB接口使用标记为D+(绿线)和D-(白线) 的双绞线传输，它们各自使用半双工的差分信号并协同工作，以抵消长导线的电磁干扰。</p>
<p>Mini USB接口把第4针作为ID线，用来标识身份，mini-A插头的ID引脚接地，而mini-B插头悬空。<strong>USB OTG根据ID线状态判断是主机还是从机，接地为主机，悬空为从机</strong>。</p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>usb</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM Trusted Firmware</title>
    <url>/2022/09/25/cpu/ATF/</url>
    <content><![CDATA[<p>ARM Trusted Firmware启动实现分为5个步骤：</p>
<p><img src="/images/cpu/arm/ATF3.png" alt="img"><br><img src="/images/cpu/arm/ATF2.jpg" alt="img"></p>
<h2 id="BL1"><a href="#BL1" class="headerlink" title="BL1"></a>BL1</h2><p>BL1是Trusted Boot ROM，就是BootRom，是信任链的根所在，位于ROM中。BL1主要目的是建立Trusted SRAM、exception vector、初始化串口等。然后找到并验证BL2（验签CSF头），然后跳转过去。</p>
<ul>
<li>决定启动路径：冷启动还是热启动。</li>
<li>架构初始化：异常向量、CPU复位处理函数配置、控制寄存器设置(SCRLR_EL3/SCR_EL3/CPTR_EL3/DAIF)</li>
<li>平台初始化：使能Trusted Watchdog、初始化控制台、配置硬件一致性互联、配置MMU、初始化相关存储设备。</li>
<li>固件更新处理</li>
<li>BL2镜像加载和执行</li>
</ul>
<p>bl1_main()开始就是c程序了，那c运行依靠的堆和栈空间在哪里呢？在CPU内部的SRAM里。SRAM一启动就已经可以访问了，bl1_plat_arch_setup（）简单地在其中划分出来一块作为Trusted SRAM给c程序用，而不用像x86在cache里面扣一块出来，简单了很多。</p>
<p>BL1镜像的异常向量表初始化了两个：一个是入口bl1_entrypoint，EL1镜像正常执行流程；另一个是SMC调用接口，EL2执行结束会通过SMC返回执行BL31。</p>
<h2 id="BL2"><a href="#BL2" class="headerlink" title="BL2"></a>BL2</h2><p>BL2在Flash上，作为Trusted Boot Firmware，也叫Trusted Bootloader。</p>
<ul>
<li>架构初始化：EL1/EL0使能浮点单元和ASMID。</li>
<li>平台初始化：控制台初始化、相关存储设备初始化、MMU、相关设备安全配置、</li>
<li>SCP_BL2：系统控制核镜像加载，单独核处理系统功耗、时钟、复位等控制。</li>
<li>寻找BL31，BL32和BL33镜像加载到RAM中，验签并运行BL31。</li>
</ul>
<h2 id="BL31"><a href="#BL31" class="headerlink" title="BL31"></a>BL31</h2><p>BL31是EL3 Runtime Firmware，一般为SML，管理SMC执行处理和中断，运行在secure monitor中，通过SMC指令在Secure World和Non-Secure World之间进行切换。它的主要任务是找到BL32，验签，并运行BL32。</p>
<ul>
<li>PSCI服务初始化，后续提供CPU功耗管理操作。</li>
<li>BL32镜像运行初始化。</li>
<li>初始化非安全EL2或EL1，跳转到BL33执行。</li>
<li>负责安全非安全世界切换。</li>
<li>进行安全服务请求的分发。</li>
</ul>
<h2 id="BL32"><a href="#BL32" class="headerlink" title="BL32"></a>BL32</h2><p>BL32是Trust OS，，它是一个可信安全的OS运行在EL1并在EL0启动可信任APP（如指纹信息，移动支付的密码等），并在Trust OS运行完成后通过SMC指令返回BL31，BL31找到BL33，验签并切换到Non-Seucre World运行BL33。</p>
<h2 id="BL33"><a href="#BL33" class="headerlink" title="BL33"></a>BL33</h2><p>BL33运行的都是非安全固件，如UEFI 或u-boot。</p>
<p><img src="/images/cpu/arm/ATF.jpg" alt="img"><br><img src="/images/cpu/arm/ATF.png" alt="img"></p>
<hr>
<p><a href="https://www.cnblogs.com/arnoldlu/p/14175126.html">https://www.cnblogs.com/arnoldlu/p/14175126.html</a></p>
]]></content>
      <categories>
        <category>cpu</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>TrustZone</title>
    <url>/2022/09/25/cpu/TrustZone/</url>
    <content><![CDATA[<p>TrustZone是ARM针对消费电子设备设计的一种硬件架构，其目的是为消费电子产品构建一个安全框架来抵御各种可能的攻击。</p>
<p>TrustZone在概念上将SoC的硬件和软件资源划分为Secure World和Normal World两个世界，所有需要保密的操作在安全世界执行（如指纹识别、密码处理、数据加解密、安全认证等），其余操作在非安全世界执行（如用户操作系统、各种应用程序等），安全世界和非安全世界通过一个名为Monitor Mode的模式进行转换。</p>
<p>实现TrustZone需要组件有：</p>
<ul>
<li>AMBA3 AXI总线，安全机制的基础设施。</li>
<li>虚拟化的ARM Core，虚拟安全和非安全核。</li>
<li>TZPC (TrustZone Protection Controller)，根据需要控制外设的安全特性。</li>
<li>TZASC (TrustZone Address Space Controller)，对内存进行安全和非安全区域划分和保护。</li>
<li>TZMA (TrustZone Memory Adapter)，片上ROM或RAM安全区域和非安全区域的划分和保护，可选。</li>
<li>AXI-to-APB bridge，桥接APB总线，配合TZPC使APB总线外设支持TrustZone安全特性，可选。</li>
</ul>
<p><img src="/images/cpu/arm/TrustZone.png" alt="img"></p>
<h2 id="总线设计"><a href="#总线设计" class="headerlink" title="总线设计"></a>总线设计</h2><p>AMBA3 AXI(AMBA3 Advanced eXtensible Interface)系统总线作为TrustZone的基础架构设施，提供了安全世界和非安全世界的隔离机制，确保非安全核只能访问非安全世界的系统资源，而安全核能访问所有资源。</p>
<p>AMBA-AXI总线的扩展，增加了标志secure读和写地址线：AWPROT[1]和ARPROT[1]。</p>
<p>TrustZone 在系统总线上针对每一个信道的读写增加了一个额外的控制信号位，这个控制位叫做Non-Secure或者NS位。所有非安全世界的主设备在操作时必须将信号的NS位置高，而NS位置高又使得其无法访问总线上安全世界的从设备，简单来说就是对非安全世界主设备发出的地址信号进行解码时在安全世界中找不到对应的从设备，从而导致操作失败。当然，非安全世界的主设备尝试访问安全世界的从设备会引发访问错误。</p>
<p>在TrustZone出现前，ARM的外设基于AMBA2 APB (Advanced Peripheral Bus)总线协议，由于APB总线的设备不支持AXI总线的NS控制信号，所以AXI到APB总线需要AXI-to-APB bridge设备连接。AXI-to-APB bridge负责管理APB总线设备的安全事宜，其会拒绝不合理的安全请求，保证这些请求不会被转发到相应的外设。</p>
<h2 id="处理器设计"><a href="#处理器设计" class="headerlink" title="处理器设计"></a>处理器设计</h2><p>TrustZone将每个物理核虚拟为两个核，非安全核，运行非安全世界的代码；和安全核，运行安全世界的代码。两个虚拟的核以基于时间片的方式运行，根据需要实时占用物理核，并通过Monitor Mode实现了同一CPU上两个操作系统间的切换。</p>
<p>安全世界和非安全世界都有自己的虚拟MMU，各自管理物理地址的映射。实际上只是两个世界都有一份TTBR0、TTBR1、TTBCR寄存器，因此就会对应两个MMU表。尽管MMU有两套，但TBL缓存硬件上只有一套，因此TBL对于两个世界来说是共享的，其通过NS位来标志其每一项具体属于哪一个世界。这样在两个世界间进行切换时不再需要重新刷新TLB，提高执行效率。</p>
<p>Cache也是两个世界共享，具体Cache数据属于哪一个世界也由其NS位指定，在世界间切换也不需要刷新Cache。</p>
<p>在gicv2、gicv3的版本中，都增加了对安全扩展的支持:</p>
<p>在gicv2/gicv3中，支持了安全中断，配置有如下：<br>gicv2分组</p>
<ul>
<li>group0：安全中断，由nFIQ驱动</li>
<li>group1：非安全中断，由nIRQ驱动</li>
</ul>
<p>gicv3分组</p>
<ul>
<li>group0：安全中断</li>
<li>non-secure group1：非安全中断</li>
<li>secure group1：安全中断</li>
</ul>
<h2 id="隔离机制"><a href="#隔离机制" class="headerlink" title="隔离机制"></a>隔离机制</h2><p>内存隔离和保护通过总线组件TZASC和TZMA的设置来实现。</p>
<ul>
<li><p>TZASC (TrustZone Address Space Controller)可以把外部DDR分成多个区域，每个区域可以单独配置为安全或非安全区域，非安全世界的代码和应用只能访问非安全区域。TZASC只能用于内存设备，不适合用于配置块设备，如Nand Flash。</p>
</li>
<li><p>TZMA (TrustZone Memory Adapter)可以把片上ROM和SRAM隔离出安全和非安全区域。TZMA最大可以将片上存储的低2MB配置为安全区域，其余部分配置为非安全区域。大小划分上，片上安全区域可以在芯片出厂前设置为固定大小，或运行时通过TZPC动态配置。TZMA使用上有些限制，其不适用于外部内存划分，而且也只能配置一个安全区域。</p>
</li>
</ul>
<p>在外设上需要TZPC (TrustZone Protection Controller) 来向APB总线上的设备提供类似AXI上的NS控制信号。由于TZPC可以在运行时动态设置，这就决定了外设的安全特性是动态变化的，例如键盘平时可以作为非安全的输入设备，在输入密码时可以配置为安全设备，只允许安全世界访问。</p>
<h2 id="安全启动"><a href="#安全启动" class="headerlink" title="安全启动"></a>安全启动</h2><p>系统上电复位后，先从安全世界开始执行。安全世界会对非安全世界的bootloader进行验证，确保非安全世界执行的代码经过授权而没有被篡改过。然后非安全世界的bootloader会加载非安全世界的OS，完成整个系统的启动。下一级的安全依赖于上一级的验证，逐级的验证构成了整个系统的信任链。</p>
]]></content>
      <categories>
        <category>cpu</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>arm体系架构</title>
    <url>/2022/09/25/cpu/arm-arch/</url>
    <content><![CDATA[<h2 id="ARM指令集架构命名"><a href="#ARM指令集架构命名" class="headerlink" title="ARM指令集架构命名"></a>ARM指令集架构命名</h2><blockquote>
<p>| ARMv | n | variants | x（variants） |</p>
</blockquote>
<ul>
<li>ARMv – 固定字符，即ARM Version</li>
<li>n – 指令集版本号。迄今为之，ARM架构版本发布了8个系列，所以n=[1:8]。</li>
<li>variants – 变种</li>
<li>x（variants） – 排除x后指定的变种</li>
</ul>
<p>常见的variants有以下字母可选：</p>
<ul>
<li>T – Thumb指令集</li>
<li>M – 长乘法指令</li>
<li>E – 增强型DSP指令</li>
<li>J – Java加速器Jazelle</li>
<li>SIMD – ARM媒体功能扩展</li>
<li>D – Debug，提供调试支持</li>
<li>I – 芯片上带有内置的ICE，从而支持程序内的断点和数据空间的观察点设置。</li>
</ul>
<p>比如：ARMv5TxM表示ARM指令集版本为5，支持T变种，不支持M变种。</p>
<h2 id="ARM体系变种"><a href="#ARM体系变种" class="headerlink" title="ARM体系变种"></a>ARM体系变种</h2><p><strong>T变种</strong></p>
<p>thumb指令集是ARM指令集的一个子集重新编码而成的。它使ARM更加高效地进行运作。</p>
<p>ARM的指令长度为32位，而Thumb指令长度只有16位，对于一些冗余空余位的操作来讲的话，在使用16位的基础上，明显比使用32位更加高效。但是thumb自身也有一定的局限性：</p>
<ul>
<li><p>完成相同的操作时，Thumb指令通常情况下需要比ARM更多的指令。</p>
</li>
<li><p>Thumb指令集是不包含异常处理时的一些指令的</p>
</li>
</ul>
<p>因此ARM是不能舍弃ARM的32位指令的，它与16位的Thumb指令配合才能更加有效率地执行。</p>
<p><strong>M变种</strong></p>
<p>增加了两条长乘法的ARM指令：</p>
<ul>
<li><p>长乘法操作：32位整数乘以32位整数，生成64位整数</p>
</li>
<li><p>长乘加操作：32位整数乘以32位整数，然后加上加上32位整数，生成64位整数</p>
</li>
</ul>
<p>它其实做版本3中正式引入，版本2的时候仅是有了这个思想的，然后在版本4以后，M变种就变成了系统中的标准部分。我们也不再说M变种了，因为我们在开发ARM过程中直接是使用相应的指令的。</p>
<p><strong>E变种</strong></p>
<p>增强型DSP指令，针对于ARM的应用范围越来越广阔，为了满足DSP算法，就需要增强这个算法的处理性能。</p>
<ul>
<li><p>增加了新的16位数据乘法与乘加操作指令</p>
</li>
<li><p>实现饱和的带符号数的加减法操作指令</p>
</li>
<li><p>进行双字数据操作的指令，包含LDRD、STDR、MCRR\MRRC</p>
</li>
<li><p>cache预取指令PLD</p>
</li>
</ul>
<p>E变种是在版本5T中开始使用的。值得注意的是：早期的E变种未有包含LDRD、STRD、MCRR\MRRC、PLD。</p>
<p><strong>J变种</strong></p>
<p>ARM能跑android和java不得不归功于这个变种——java加数器jazelle，与一般的java虚拟机相比，它将java代码运行速度提高了整整8倍，而功耗竟降低了80%。</p>
<p><strong>SIMD变种</strong></p>
<p>媒体功能扩展，它将音频\视频处理性能提高了4倍。</p>
<ul>
<li>音频\视频处理性能提高了4倍</li>
<li>提供小数算术运算</li>
<li>可同时进行两个16位操作数或者4个8位操作数的运算</li>
<li>用户可以定义饱和运算模式</li>
<li>两套16位操作数的乘加/乘减运算</li>
<li>32位乘以32位的小数MAC</li>
</ul>
<h2 id="ARM处理器系列命名"><a href="#ARM处理器系列命名" class="headerlink" title="ARM处理器系列命名"></a>ARM处理器系列命名</h2><p>在 ARMv3 ~ ARMv6 时期规则：</p>
<blockquote>
<p>ARM{x}{y}{z}{T}{D}{M}{I}{E}{J}{F}{-S}</p>
</blockquote>
<ul>
<li>x – 处理器系列</li>
<li>y – 存储管理/保护单元</li>
<li>z – cache</li>
<li>T – 支持Thumb指令集</li>
<li>D – 支持片上调试</li>
<li>M – 支持快速乘法器</li>
<li>I – 支持Embedded ICE，支持嵌入式跟踪调试</li>
<li>E – 支持增强型DSP指令</li>
<li>J – 支持Jazelle</li>
<li>F – 具备向量浮点单元VFP</li>
<li>-S – 可综合版本</li>
</ul>
<p>比如：ARM926 是 ARM9系列的，2个存储管理/保护单元，6个Cache</p>
<p>在 ARMv7 后期，统一用 <strong>Cortex</strong> 作为主名，分为了3个款式：A、R、M &amp; SC：</p>
<ul>
<li>A 系列，应用级处理器，手机。</li>
<li>R 系列，实时处理器，执行一个指令段的耗时是固定时钟周期数。</li>
<li>M 系列，微处理器单片机。</li>
<li>SC（SecurCore）系列，主打安全，面向支付、政府、SIM 卡。</li>
</ul>
<h2 id="ARM处理器工作模式"><a href="#ARM处理器工作模式" class="headerlink" title="ARM处理器工作模式"></a>ARM处理器工作模式</h2><ul>
<li><p>用户模式（usr，User Mode）：ARM处理器正常的程序执行状态。</p>
</li>
<li><p>快速中断模式（fiq，Fast Interrupt Request Mode）：用于高速数据传输或通道处理。当触发快速中断时进入此模式。</p>
</li>
<li><p>外部中断模式（irq，Interrupt Request Mode）：用于通用的中断处理。当触发外部中断时进入此模式。</p>
</li>
<li><p>管理模式（svc，Supervisor Mode）：操作系统使用的保护模式。在系统复位或执行软件中断指令SWI时进入。</p>
</li>
<li><p>数据访问中止模式（abt，Abort Mode）：当数据或指令预取中止时进入该模式，可用于虚拟存储及存储保护。</p>
</li>
<li><p>系统模式（sys，System Mode）：运行具有特权的操作系统任务。</p>
</li>
<li><p>未定义指令中止模式（und，Undefined Mode）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。</p>
</li>
</ul>
<p>除了用户模式之外，其余六种模式都是特权模式。除了用户模式和系统模式之外，其余五种模式都是异常模式。</p>
<p>在特权模式下程序可以访问所有的系统资源。非特权模式和特权模式之间的区别在于有些操作只能在特权模式下才被允许，例如直接改变模式和中断使能等。而且为了保证数据安全，一般MMU会对地址空间进行划分，只有特权模式才能访问所有的地址空间。而用户模式如果需要访问硬件，必须切换到特权模式下，才允许访问硬件。</p>
<p><strong>工作模式的切换</strong></p>
<ul>
<li><p>执行软中断（SWI）或复位命令（Reset）指令。如果在用户模式下执行SWI指令，CPU就进入管理（Supervisor）模式。当然，在其他模式下执行SWI，也会进入该模式，不过一般操作系统不会这么做，因为除了用户模式属于非特权模式，其他模式都属于特权模式。执行SWI指令一般是为了访问系统资源，而在特权模式下可以访问所有的系统资源。SWI指令一般用来为操作系统提供API接口。</p>
</li>
<li><p>外部中断。如果发生了外部中断，CPU就会进入IRQ或FIQ模式。</p>
</li>
<li><p>CPU执行过程中产生异常。最典型的异常是由于MMU保护所引起的内存访问异常，此时CPU会切换到Abort模式。如果是无效指令，则会进入Undefined模式。</p>
</li>
<li><p>有一种模式是CPU无法自动进入的，这种模式就是System模式，要进入System模式必须由程序员编写指令来实现。要进入System模式只需改变CPSR的模式位为System模式对应的模式位即可。进入System模式一般是为了利用System模式和用户模式下的寄存器相同的特点，因此一般情况下，操作系统在通过SWI进入Supervisor模式后，做一些操作后，就进入System模式。</p>
</li>
<li><p>在任何特权模式下，都可以通过修改CPSR的MODE域来进入其他模式。不过需要注意的是由于修改的CPSR是该模式下的影子CPSR，即SPSR，因此并不是实际的CPSR，所以一般的做法是修改影子CPSR，然后执行一个MOVS指令来恢复执行某个断点并切换到新模式。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>cpu</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8 架构</title>
    <url>/2022/09/25/cpu/armv8/</url>
    <content><![CDATA[<h2 id="特权等级"><a href="#特权等级" class="headerlink" title="特权等级"></a>特权等级</h2><p>ARMv8中，引入了Secure World和Non-Secure World（Normal World）两种安全状态，四种异常级别。</p>
<ul>
<li><p>EL0是无特权模式，就是用户空间，运行应用程序，在Secure world就是Trust Application。</p>
</li>
<li><p>EL1是一个特权模式，能够执行一些特权指令，用于运行操作系统，在Secure World则就是Trusted OS，比如OP-TEE，豌豆荚的TEE等。</p>
</li>
<li><p>EL2提供了对虚拟化的支持，只在Noraml world使用。</p>
</li>
<li><p>EL3具有最高管理权限，负责安全监测和Secure World和Normal World之间的切换。当noraml world想要访问Secure world需要通过安全监视器调用SMC指令进入监视模式然后切换。</p>
</li>
</ul>
<p>安全状态主要是影响资源的访问，比如memory，系统寄存器等。</p>
<p>对于memory，有时候需要做数据隔离，用于保护数据的安全性。因此就可以将memory分成两个区域，secure区域和non-secure区域。对于secure的memory区域，只允许secure状态去访问，而对于non-secure的memory区域，允许secure状态和non-secure状态都可访问。这样可以保护数据的安全。</p>
<p>对于系统寄存器，有些系统寄存器限制了最低EL的访问，这样可以有效的保护系统。不让低EL运行的程序，误操作这些系统寄存器而使整个系统崩溃掉。</p>
<p>对于EL1和EL0，可以是non-secure状态，也可以是secure状态。对于EL2，只能是non-secure状态。对于EL3，只能是secure状态。</p>
<p>secure和non-secure状态的切换，只能通过EL3进行切换，也就是如果想从non-secure的EL0切换到secure的EL0，首先要先从non-secure的EL0，通过异常切换到EL3，然后再通过异常，返回到secure的EL0。</p>
]]></content>
      <categories>
        <category>cpu</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv7 寄存器</title>
    <url>/2022/09/25/cpu/armv7_reg/</url>
    <content><![CDATA[<h2 id="ARMv7寄存器"><a href="#ARMv7寄存器" class="headerlink" title="ARMv7寄存器"></a>ARMv7寄存器</h2><p>ARM处理器共有37个寄存器。其中包括：31个通用寄存器（包括PC在内）和6个状态寄存器。</p>
<p><img src="/images/cpu/arm/reg.jpg" alt="img"></p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器包括R0-R15，均为32位寄存器，可以分为3类：</p>
<p><strong>未分组寄存器(R0-R7)</strong></p>
<p>在所有运行模式下，未分组寄存器都指向同一个物理寄存器。在中断或异常处理进行异常模式转换时，由于不同的处理器运行模式均使用相同的物理寄存器，所以可能造成寄存器中数据的破坏。</p>
<p><strong>分组寄存器(R8-R14)</strong></p>
<p>对于分组寄存器，他们每次所访问的物理寄存器都与当前的处理器运行模式相关。</p>
<p>R13常用作存放堆栈指针，用户也可以使用其他寄存器存放堆栈指针，但在Thumb指令集下，某些指令强制要求使用R13存放堆栈指针。</p>
<p>R14称为链接寄存器（LR，Link Register），当执行子程序时，R14可得到R15（PC）的备份，执行完子程序后，又将R14的值复制回PC，即使用R14保存返回地址。</p>
<p><strong>程序计数器PC（R15）</strong></p>
<p>寄存器R15用作程序计数器（PC），在ARM状态下，位[1:0]为0，位[31:2]用于保存PC；在Thumb状态下,位[0]为0，位[31:1]用于保存PC。</p>
<p>由于ARM体系结构采用了多级流水线技术，对于ARM指令集而言，PC总是指向当前指令的下两条指令的地址，即PC的值为当前指令的地址值加8个字节。</p>
<h3 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h3><ul>
<li>CPSR（Current Program Status Register）当前程序状态寄存器1个。</li>
<li>SPSR（Saved Progarm Status Register）备份程序状态寄存器6个，用于异常发生时保存CPSR的值，异常退出时恢复CPSR。</li>
</ul>
]]></content>
      <categories>
        <category>cpu</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>处理器设计</title>
    <url>/2022/09/25/cpu/cpu/</url>
    <content><![CDATA[<h2 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h2><p>ISA（Instruction Set Architecture）指令集架构定义了一个处理器支持的指令和指令的字节级编码，包括很多个部分：</p>
<ul>
<li>指令集</li>
<li>指令集编码</li>
<li>基本数据类型</li>
<li>一组编程规范</li>
<li>寄存器</li>
<li>寻址模式</li>
<li>存储体系</li>
<li>异常事件处理</li>
<li>中断</li>
<li>外部I/O</li>
</ul>
<p><strong>CISC</strong>（Complex Instruction Set Computer，复杂指令集计算机）的每个指令可执行若干低阶操作，诸如从内存读取、储存、和计算操作，全部集于单一指令之中。CISC特点：</p>
<ul>
<li><p>指令系统庞大，指令功能复杂，指令格式、寻址方式多；</p>
</li>
<li><p>绝大多数指令需多个机器周期完成；- 各种指令都可访问存储器；</p>
</li>
<li><p>采用微程序控制；</p>
</li>
<li><p>有专用寄存器，少量；</p>
</li>
<li><p>难以用优化编译技术生成高效的目标代码程序；</p>
</li>
</ul>
<p>在CISC指令集的各种指令中，大约有20%的指令会被反复使用，占整个程序代码的80%。而余下的80%的指令却不经常使用，在程序设计中只占20%。</p>
<p><strong>RISC</strong>（Reduced Instruction Set Computer，精简指令集计算机）对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。它能够以更快的速度执行操作。RISC设计的根本原则量对流水线的优化。RISC特点：</p>
<ul>
<li>统一指令编码（例如，所有指令中的op-code永远位于同样的位元位置、等长指令），可快速解译；</li>
<li>泛用的暂存器，所有暂存器可用于所有内容，以及编译器设计的单纯化（不过暂存器中区分了整数和浮点数）；</li>
<li>单纯的寻址模式（复杂寻址模式以简单计算指令序列取代）。</li>
<li>硬件中支援少数资料型别（例如，一些CISC电脑中存有处理字节字串的指令。这在RISC电脑中不太可能出现）。</li>
<li>所有计算都要在寄存器中完成。而寄存器和内存的通信则由单独的指令完成。</li>
<li>有非常多的通用寄存器，并采用了重叠寄存器窗口和寄存器堆等技术使寄存器资源得到充分的利用。</li>
</ul>
<p><strong>CISC和RISC的区别</strong></p>
<ul>
<li>指令系统：RISC设计者把主要精力放在那些经常使用的指令上，尽量使它们具有简单高效的特色。对不常用的功能，常通过组合指令来完成。因此，在RISC机器上实现特殊功能时，效率可能较低。但可以利用流水技术和超标量技术加以改进和弥补。而CISC计算机的指令系统比较丰富，有专用指令来完成特定的功能。因此，处理特殊任务效率较高。</li>
<li>存储器操作：RISC对存储器操作有限制，使控制简单化；而CISC机器的存储器操作指令多，操作直接。</li>
<li>程序：RISC汇编语言程序一般需要较大的内存空间，实现特殊功能时程序复杂，不易设计；而CISC汇编语言程序编程相对简单，科学计算及复杂操作的程序社设计相对容易，效率较高。</li>
<li>中断：RISC机器在一条指令执行的适当地方可以响应中断；而CISC机器是在一条指令执行结束后响应中断。</li>
<li>CPU：RISC CPU包含有较少的单元电路，因而面积小、功耗低；而CISCCPU包含有丰富的电路单元，因而功能强、面积大、功耗大。</li>
<li>设计周期：RISC微处理器结构简单，布局紧凑，设计周期短，且易于采用最新技术；CISC微处理器结构复杂，设计周期长。</li>
<li>用户使用：RISC微处理器结构简单，指令规整，性能容易把握，易学易用；CISC微处理器结构复杂，功能强大，实现特殊功能容易。</li>
<li>应用范围：由于RISC指令系统的确定与特定的应用领域有关，故RISC机器更适合于专用机；而CISC机器则更适合于通用机。</li>
</ul>
<h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>MIPS处理器在设计时，将处理器的执行过程划分为5个阶段：IF取指、ID译码、EX执行、MEM内存数据读或写、WB数据写回到通用寄存器中。</p>
<p><img src="/images/cpu/%E6%B5%81%E6%B0%B4%E7%BA%BF.jpg" alt="img"></p>
<p>流水线在实际执行过程中会遇到一些因素导致流水线停顿，这些就被称为流水线冒险。</p>
<p><strong>结构冒险</strong></p>
<p>流水线中取指阶段和读写存储器阶段都需要访问存储器，处理器中，程序和数据存储器没有分开，IF和MEM操作同时访问存储器导致其中一个操作要等待。哈弗架构不存在这个问题。</p>
<p><strong>数据冒险</strong></p>
<p>由于从指令取指到数据更新至存储器/寄存器之间具有时钟延迟，当出现某些指令的组合时，可能会导致后面的指令使用了错误的数据。</p>
<p>解决方法一是加入几个cycle的等待，但这影响了执行效率。另一种更好的解决办法是使用直通（Forwarding）技术。当硬件检测到当前指令的源操作数正好在EX/MEM流水线寄存器中时，就直接将EX/MEM寄存器的值传递给ALU的输入，而不是从寄存器堆中读数据。</p>
<p><strong>控制冒险</strong></p>
<p>由于使用流水线操作，在当前指令正在执行时，后面的很多条指令已经完成了取指和译码等步骤。然而，程序中有很多跳转语句，如果程序的实际执行路径是要跳转到其它的地址去执行，那么流水线中已经做的这些取指和译码工作就白做了，这就是流水线的控制冒险。</p>
<p>此时处理器需要排空流水线，跳转到新的地址处重新进入流水线。x86处理器使用硬件冲刷流水线来保证发生跳转时，流水线能正确执行。在TI的DSP中，硬件不处理这些冒险，而是通过软件的方式，在跳转语句后增加5个NOP操作来保证流水线正确，编译器也可以将指令乱序，用有效指令代替NOP指令。</p>
<h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>流水线的控制冒险将可能引起流水线排空，这对程序性能的损害是巨大的，流水线越深，损害越大。现代的很多处理器采用了分支预测技术来避免跳转带来的损失。</p>
<p>采用分支预测，处理器猜测进入哪个分支，并且基于预测的结果来取指、译码。如果猜测正确，就能节省时间，若果猜测错误，则刷新流水线，在新的地址上取指、译码。因此，分支预测需要有足够的准确性。</p>
<p>介绍两种简单的分支预测算法：</p>
<ul>
<li><p>1位预测：如果该跳转指令上一次发生跳转，就预测这一次也会跳转，如果上一次没有跳转，就预测这一次也没有跳转。</p>
</li>
<li><p>2位预测：用2bit计数器保存跳转信息，如果跳转执行就加1，跳转未执行就减1,。当计数器值为0和1时，就预测该分支不执行；当计数器值为2和3时，就预测这个分支执行。</p>
</li>
</ul>
<p>分支预测会消耗大量的资源，很多低功耗处理器没有分支预测，取而代之的是使用条件执行来减少跳转指令，如TI的DSP和ARM的cortex系列内核等。</p>
<h2 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h2><p>指令在执行时常常因为一些限制而等待，后面的指令都要等待。如果处理器足够智能，就可以先执行后面不依赖该数据的指令，这就是处理器的乱序执行（out -of-order execution）。</p>
<p>乱序执行最大的障碍就是指令间的相关性。指令间相关大致有三种情况：</p>
<ul>
<li>寄存器相关，即前后指令使用了相同的寄存器。</li>
<li>控制相关，跳转指令之后执行哪些指令需要依赖于跳转的结果。</li>
<li>数据相关，即后面指令需要的数据依赖于前面指令的计算结果。</li>
</ul>
<p>对于寄存器相关，处理器通过<strong>寄存器重命名</strong>技术解决这一问题。相同的ISA寄存器可以映射到不同的物理寄存器，经过映射后，新的指令就可以使用不同的物理寄存器，指令间的相关性依赖也就消除了。</p>
<p>对于控制相关，处理器通过分支预测来决定哪些指令将会得到执行。</p>
<p>对于数据相关，这往往是由程序算法特性以及程序的设计共同决定的，它和处理器无关，和程序员以及编译器有关。在很多时候，编程人员可以通过调整代码设计将数据间的相关性降至最小。如下面这段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = a + b;</span><br><span class="line">y = x + c;</span><br><span class="line">z = y + d;</span><br></pre></td></tr></table></figure>

<p>可以改写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = a + b;</span><br><span class="line">y = c + d;</span><br><span class="line">z = x + y;</span><br></pre></td></tr></table></figure>

<p>乱序执行比顺序执行要耗费更多的处理器资源，通常只有高端处理器才会使用。</p>
<h2 id="并行设计"><a href="#并行设计" class="headerlink" title="并行设计"></a>并行设计</h2><p><strong>指令并行</strong></p>
<p>多发射是指将多条指令同时发射到不同的译码器或者后续处理流水线中。</p>
<p>超标量是指一个时钟周期内能发射多条指令的流水线架构，内部有多个执行单元，</p>
<p><strong>数据并行</strong></p>
<p>SIMD（Single Instruction Multiple Data，单指令多数据）指令通过一条语句处理多个数据。在多媒体应用中，同一操作会重复处理多个数据，SIMD指令就特别适合处理这一类数据。</p>
<p><strong>线程并行</strong></p>
<p>线程并行的方式有：单核内多线程、多核、多处理器。</p>
<p>流水线是一种在垂直方向上对指令处理进行重叠来提升性能的技术，相对地，在水平方向上将指令进行重叠的技术称为<strong>超标量</strong>（superscalar），每个核内放置冗余单元如ALU，同一时钟内可以执行多条指令。</p>
<p>超线程是Intel公司提出的一种提高CPU性能的技术，利用特殊的硬件指令，把两个逻辑内核模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和应用软件，减少CPU的闲置时间，提高CPU的运行效率。</p>
<h2 id="核间通信"><a href="#核间通信" class="headerlink" title="核间通信"></a>核间通信</h2><p>多核处理器的多个核之间会共用处理器的外设与接口，如内存控制器、PCI-E接口等，通常也会共享一段Cache。核与核之间有时需要交换信息，因此核间连接/通信方式的选取也很关键。常见的几种多核组织结构：</p>
<ul>
<li><p>Bus结构比较简单，缺点是每两个内核通信都要占用总线，导致其它核不能通信，通信效率低。</p>
</li>
<li><p>Switch结构通信效率最高。但如果核太多，这种连接方式需耗费大量的互联资源，通常4个核左右的处理器采用这种方式。</p>
</li>
<li><p>Ring结构介于Bus和Switch结构之间。1和3通信需要经过2，越近的两个核通信效率越高，通信连线并不复杂，实现成本也低。通常8个核左右采用这种方式，Intel的很多处理器采用这种结构。</p>
</li>
<li><p>Mesh结构适用于核数非常多的情况，类似于二维的Ring结构。</p>
</li>
</ul>
<p><img src="/images/cpu/%E5%A4%9A%E6%A0%B8%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.jpg" alt="img"></p>
<p>因为核间通信会影响内核的运算效率，1个核可以做5件事情，并不代表4个核可以做20件事情，核越多时，数据交换延时越长。</p>
]]></content>
      <categories>
        <category>cpu</category>
      </categories>
      <tags>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>存储器</title>
    <url>/2022/09/04/cpu/memory/</url>
    <content><![CDATA[<h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>ROM(Read Only Memory)程序存储器，在掉电之后仍然可以保持数据，用于存储各种固化程序和数据。</p>
<p><strong>PROM</strong> (Programmable ROM，可编程ROM)，写入时，烧录器通过高电压在芯片内永久地烧断或者建立内部连接（熔丝或反熔丝），因此只能一次编程。</p>
<p><strong>EPROM</strong> (Erasable Programmable ROM，可擦去可编程ROM)，使用紫外线照射此类型的ROM可以抹去其中的数据。</p>
<p><strong>EEPROM</strong> (Electrically Erasable Programmable ROM，电可擦去可编程ROM)，使用电来对其进行擦写，常用于电脑系统的BIOS。</p>
<h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p>RAM(Random Access Memory)随机访问存储器，存储单元的内容可按照需要随机取出或存入，且存取的速度与存储单元的位置无关。在掉电之后就丢失数据，主要用来存储程序中用到的变量。</p>
<p><strong>DRAM</strong> (Dynamic RAM/DRAM)动态随机存储器，DRAM保留数据的时间很短，需要周期性地刷新。计算机内存就是DRAM的。</p>
<p>DRAM利用MOS管的栅电容上的电荷来存储信息，存储单元存储的是0还是1取决于电容是否有电荷，有电荷代表1，无电荷代表0。由于栅极会漏电，所以每隔一定的时间就需要一个刷新机构给这些栅电容补充电荷，这个就叫动态刷新。刷新操作定期对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电；若电量小于1/2，则认为其代表0，并把电容放电，以此来保持数据的连续性。由于它只使用一个MOS管来存信息，所以集成度可以很高，容量能够做的很大。</p>
<p><strong>SRAM</strong> (Static Random-Access Memory)静态随机存取存储器，只要保持通电，里面储存的数据就可以一直保持，不需要动态刷新，对任何数据访问的时间都是固定的。需要与CPU时钟同步</p>
<p>SRAM的优点是只要器件不掉电，存储内容就不丢失，工作速度快。缺点是集成度低、功耗大、价格高。CPU Cache就是这种。</p>
<h2 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h2><p>Flash 存储器（FLASH EEPROM）又称闪存，快闪。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备EEPROM的性能，还不会断电丢失数据同时可以快速读取数据。它于EEPROM的最大区别是，FLASH按扇区操作，而EEPROM按照字节操作。FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因此适合用于做程序存储器。</p>
<p>flash是非易失存储器，可以对称为块的存储器单元块进行擦写和再编程。任何flash器件的写入操作只能在空或已擦除的单元内进行，所以在进行写入操作之前必须先执行擦除。擦除的过程就是把所有位都写为1的过程，以块为单位，块内的所有字节变为0xFF。</p>
<h3 id="Nor-Flash"><a href="#Nor-Flash" class="headerlink" title="Nor Flash"></a>Nor Flash</h3><ul>
<li>支持随机访问，具有XIP（eXecute In Place）特性，可以像普通ROM一样执行程序。</li>
<li>存储的内容可以直接映射到 CPU 地址空间，不需要拷贝到 RAM 中即可被 CPU 访问。</li>
<li>读操作快，但擦除和写操作慢。</li>
<li>容量小，块大小范围：64~128KB。</li>
<li>带有SRAM接口，有足够的地址引脚来寻址，可以很容易地存取其内部的每一个字节。</li>
<li>最大擦写次数是十万次。</li>
</ul>
<p>Nor Flash根据数据传输的位数可以分为并行（Parallel，即地址线和数据线直接和处理器相连）和串行（SPI，即通过SPI接口和处理器相连）。早期Norflash的接口是parallel的形式，即把数据线和地址线并排与IC的管脚连接。但是后来发现不同容量的Norflash不能硬件上兼容（数据线和地址线的数量不一样），并且封装比较大，占用了较大的PCB板位置，后来逐渐被串行接口的SPI Norflash所取代，至于现在说起NOR flash都直接以SPI flash来代称。</p>
<p>spi flash 接口定义：</p>
<ul>
<li>Standard SPI: CLK, /CS, DI, DO, /WP, /Hold</li>
<li>Dual SPI: CLK, /CS, IO0, IO1, /WP, /Hold</li>
<li>Quad SPI: CLK, /CS, IO0, IO1, IO2, IO3</li>
</ul>
<h3 id="Nand-Flash"><a href="#Nand-Flash" class="headerlink" title="Nand Flash"></a>Nand Flash</h3><ul>
<li>使用串行接口传送控制、地址和数据信息。</li>
<li>读比nor flash慢，擦除和写都快，读和写操作都采用512字节的块。</li>
<li>容量大，块大小范围：8~64KB。</li>
<li>每个块的最大擦写次数是一百万次。</li>
<li>坏块是随机分布的，需要坏块处理。</li>
</ul>
<p><img src="/images/memory/nor_nand.jpg" alt="nor_nand"></p>
<p>由于Flash固有的电器特性，在读写数据过程中会偶然产生1位或几位数据错误，即<strong>位反转</strong>。Nand Flash发生位反转的几率要远大于Nor Flash，应采用错误探测/错误更正(EDC/ECC)算法。</p>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘(Hard Disk Drive，HDD)靠磁性盘片记录二进制数据。</p>
<p><img src="/images/memory/disk/hdd.jpg" alt="img"></p>
<p>硬盘片的盘面上有一层涂得很薄的磁性材料。写入数据时，通电的磁头会形成磁场，在磁性材料层上留下一个一个小磁化区，每个被磁化的区域代表二进制的1。读取数据时，磁头扫过磁化区的时候能感受到微小的磁场变化。</p>
<p>当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道(Track)。划分分区时，分区大小必须以磁道为参考，一个分区必须包含一个或多个整数磁道，不能只占半个磁道。也就是说如果磁盘有两个磁道，最多只能分成2个分区。</p>
<p>在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面(Cylinder)。</p>
<p>磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区(Sector)。硬盘的第一个扇区，叫做引导扇区。磁盘上数据读写的最小单位。</p>
<p>操作系统内核中的文件管理系统会将硬盘的扇区组合成<strong>簇</strong>(Data Cluster)，操作系统会记录文件所在簇的编号(文件数据分布在哪几个扇区)，方便查找并读写。</p>
<p>机械硬盘通过磁头读取旋转的盘片来传输数据，而盘片的转速RPM(Round Per Minute，每分钟的转数)直接决定了硬盘读取和写入数据的速度。磁盘在写入数据时，会使用磁盘缓存暂时存储数据。</p>
<h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>RAID(独立硬盘冗余阵列，Redundant Array of Independent Disks)，简称磁盘阵列。利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或数据冗余，或是两者同时提升。</p>
<ul>
<li><strong>RAID0</strong></li>
</ul>
<p>RAID0 是一种非常简单的的方式，它将多块磁盘组合在一起形成一个大容量的存储。当我们要写数据的时候，会将数据分为N份，以独立的方式实现N块磁盘的读写，那么这N份数据会同时并发的写到磁盘中，读写性能理论上是单块磁盘的N倍。</p>
<p>但RAID0的问题是，它并不提供数据校验或冗余备份，因此一旦某块磁盘损坏了，数据就直接丢失，无法恢复了。因此RAID0就不可能用于高要求的业务中，但可以用在对可靠性要求不高，对读写性能要求高的场景中。</p>
<ul>
<li><strong>RAID1</strong></li>
</ul>
<p>RAID1 是磁盘阵列中单位成本最高的一种方式。因为它的原理是在往磁盘写数据的时候，将同一份数据无差别的写两份到磁盘，分别写到工作磁盘和镜像磁盘，对数据做了冗余备份，但它的实际空间使用率只有50%了，是一种比较昂贵的方案。</p>
<ul>
<li><strong>RAID3</strong></li>
</ul>
<p>RAID3的方式是：将数据按照RAID0的形式，分成多份同时写入多块磁盘，但是还会另外留出一块磁盘用于写奇偶校验码，一旦某一块磁盘坏掉了，就可以利用那块校验码磁盘去恢复数据。但是由于任何数据的写入都会要去更新这块磁盘，导致这块磁盘的读写是最频繁的，也就非常的容易损坏。</p>
<ul>
<li><strong>RAID5</strong></li>
</ul>
<p>RAID5对RAID3进行了改进，是一种存储性能、数据安全、存储成本兼顾的方案。</p>
<p>在RAID5模式中，不再需要用单独的磁盘写校验码了。它把校验码信息分布到各个磁盘上。例如，总共有N块磁盘，那么会将要写入的数据分成N份，并发的写入到N块磁盘中，同时还将数据的校验码信息也写入到这N块磁盘中，数据与对应的校验码信息必须得分开存储在不同的磁盘上。一旦某一块磁盘损坏了，就可以用剩下的数据和对应的奇偶校验码信息去恢复损坏的数据。</p>
<p><img src="/images/memory/disk/RAID5.jpg" alt="img"></p>
<p>RAID5的方式，最少需要三块磁盘来组建磁盘阵列，允许最多同时坏一块磁盘。如果有两块磁盘同时损坏了，那数据就无法恢复了。</p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>flash</tag>
        <tag>disk</tag>
        <tag>ddr</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2022/09/04/cpu/pc/</url>
    <content><![CDATA[<h2 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h2><p><strong>计算机由控制器、存储器、运算器、输入设备和输出设备5个部件组成</strong>。</p>
<p>度量计算机性能的指标有响应时间和吞吐率，<strong>响应时间</strong>是指完成一个任务所需的总时间，<strong>吞吐量</strong>表示单位时间内完成的任务数量。</p>
<p>集成电路主要用的是CMOS，其主要能耗来源是晶体管开头过程中产生的动态能耗，其値取决于每个晶体管的负载电容和工作电压：能耗 = 负载电容 x 电压^2^ 。每个晶体管需要的功耗是一个翻转能耗和开头频率的乘积： 功耗 = 负载电容 x 电压^2^ x 开头频率。</p>
<h2 id="计算机设计思想"><a href="#计算机设计思想" class="headerlink" title="计算机设计思想"></a>计算机设计思想</h2><ol>
<li>面向摩尔定律的设计，摩尔定律是指单芯片上的集成度每18 -24月翻一番。设计者必须预测其设计完成时的工艺水平。</li>
<li>使用抽象简化设计，用抽象表示不同的设计层次，在高层次中看不到低层次的细节。</li>
<li>加速大概率事件远比优化小概率事件更能提高性能。</li>
<li>并行执行提高性能。</li>
<li>通过流水线提高性能。</li>
<li>通过预测提高性能。</li>
<li>通过使用冗余部件提高系统的可靠性。比如汽车的备用轮胎。</li>
<li>存储器层次结构，较快的存储器靠近处理器。</li>
</ol>
<h2 id="存储器结构"><a href="#存储器结构" class="headerlink" title="存储器结构"></a>存储器结构</h2><h3 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h3><p>冯·诺依曼结构，又称为普林斯顿体系结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。Inter 8086、<br>ARM7、MIPS处理器都是这种结构。</p>
<p><img src="/images/cpu/Princeton.jpg" alt="img"></p>
<ul>
<li>取指令和取操作数都在同一总线上，程序指令和数据的宽度相同，通过分时复用的方式进行。</li>
<li>程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置。</li>
<li>执行单条指令耗费的周期长，必须先取指令码，再取操作数。</li>
<li>在高速运行时，不能同时取指令和取操作数，从而形成了传输通道上的瓶颈。</li>
</ul>
<h3 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h3><p>哈佛结构是一种将程序指令存储和数据存储分开的存储器结构，程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问，在一个机器周期内可以同时获取指令和操作数。所有的DSP处理器、AVR单片机、ARM9是这种结构。</p>
<p><img src="/images/cpu/Harvard.jpg" alt="img"></p>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p><strong>原码</strong>：用第一位表示符号，其余位表示值，负数符号位为1。</p>
<p><strong>反码</strong>：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p>
<p><strong>补码</strong>：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p><strong>移码</strong>：将符号位取反的补码（不区分正负）。</p>
<p>原码使数字有了正负概念，但是计算不正确，正负相加不等于0，而且存在+0和-0。反码解决了正负相加不等于0的问题。为了追求连续性和唯一性，补码修复了存在两个0编码的问题，而且还能够多表示一个最低数，所以1个字节能表示的范围为[-128, 127]。</p>
<p>用[0000 0000]表示0, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p>
<blockquote>
<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>
</blockquote>
<h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><h4 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h4><p><img src="/images/pc/float_mem.jpg" alt="浮点表示"></p>
<ul>
<li>第一段 占 1bit，表示符号位。0代表正数，1代表负数。</li>
<li>第二段 占 8bits，表示指数。代称为 E(Exponent)。</li>
<li>第三段 占 23bits，表示尾数。代称为 M(Mantissa)。</li>
</ul>
<p>浮点数在计算机存储使用二进制科学计数法。如小数 78.375，符号位为0，指数为6，尾数是001110011。</p>
<blockquote>
<p>整数部分：(78)<del>10</del> = (100 1110)<del>2</del><br>小数部分：(0.375)<del>10</del>　=　3/8 = 1/4 + 1/8 = 2^-2^ + 2^-3^ = (0.01)<del>2</del> + (0.001)<del>2</del> = (0.011)<del>2</del><br>(78.375)<del>10</del> = (1001110.011)<del>2</del> = 1.001110011 * 2^6^</p>
</blockquote>
<p>对于 int 和 float 变量类型不能使用强制类型转换，要通过float指针来转换。</p>
<h4 id="浮点加法"><a href="#浮点加法" class="headerlink" title="浮点加法"></a>浮点加法</h4><h4 id="浮点乘法"><a href="#浮点乘法" class="headerlink" title="浮点乘法"></a>浮点乘法</h4><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>时钟周期也叫振荡周期或晶振周期，即晶振的单位时间发出的脉冲数。是计算机中最基本的、最小的时间单位。</p>
<p>机器周期：在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。8051单片机的机器周期由6个状态周期组成，也就是说一个机器周期=6个状态周期=12个时钟周期。机器周期也是单片机定时器和计数器的时间基准。例如一个单片机选择了12MHZ晶振，那么当定时器的数值加1时，实际经过的时间就是1us。</p>
<p>指令周期是执行一条指令所需要的时间，一般由若干个机器周期组成。指令不同，所需的机器周期数也不同。</p>
<p>系统时钟就是CPU指令运行的频率，系统时钟由晶振或内部RC产生。</p>
]]></content>
      <categories>
        <category>cpu</category>
      </categories>
      <tags>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2022/06/17/linux/docker/</url>
    <content><![CDATA[<p>Docker是利用 namespace 做资源隔离，用 cgroup 做资源职能制，用 unionFS 做容器文件系统和轻量级虚拟化技术。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>core dump</title>
    <url>/2022/06/07/linux/core_dump/</url>
    <content><![CDATA[<p><strong>设置core文件大小</strong></p>
<p>使用<code>ulimit -c</code>命令可查看core文件大小，若结果为0，则表示不会生成core文件。</p>
<p>使用<code>ulimit -c filesize</code>命令，可以限制core文件的大小，filesize的单位为kbyte。若设置为<code>ulimit -c unlimited</code>则表示core文件的大小不受限制。</p>
<p>永久设置，修改/etc/security/limits.conf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#*               soft    core            0</span><br></pre></td></tr></table></figure>

<p>修改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*                soft    core            unlimited</span><br></pre></td></tr></table></figure>

<p><strong>查询coredump文件路径</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/kernel/core_pattern</span><br><span class="line"></span><br><span class="line">/sbin/sysctl kernel.core_pattern</span><br></pre></td></tr></table></figure>

<p><strong>修改coredump文件路径</strong></p>
<ul>
<li>临时修改</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;/tmp/core_%e_%p_%t&quot; &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>

<ul>
<li>永久修改</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sbin/sysctl -w kernel.core_pattern=/var/log/%e.core.%p</span><br></pre></td></tr></table></figure>

<ul>
<li>永久设置, 修改<code>/etc/sysctl.conf</code>配置文件，添加一行，然后执行<code>sysctl -p</code>生效。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kernel.core_pattern = %e.core.%p</span><br></pre></td></tr></table></figure>

<p>可通过以下参数来丰富core文件的命名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% 单个%字符</span><br><span class="line">%p 所dump进程的进程ID</span><br><span class="line">%u 所dump进程的实际用户ID</span><br><span class="line">%g 所dump进程的实际组ID</span><br><span class="line">%s 导致本次core dump的信号</span><br><span class="line">%t core dump的时间 (由1970年1月1日计起的秒数)</span><br><span class="line">%h 主机名</span><br><span class="line">%e 程序文件名</span><br></pre></td></tr></table></figure>

<ul>
<li>core文件带pid</li>
</ul>
<ol>
<li>修改<code>/proc/sys/kernel/core_uses_pid</code>，如果这个文件的内容被配置成1，即使core_pattern中没有设置%p，最后生成的core dump文件名仍会加上进程ID。</li>
<li>永久设置, 修改/etc/sysctl.conf配置文件，添加一行，然后执行<code>sysctl -p</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernel.core_uses_pid = 1</span><br></pre></td></tr></table></figure>

<p><em>注意</em>：</p>
<ol>
<li><p>要保证存放coredump文件的目录存在，且进程对该目录有写权限。</p>
</li>
<li><p>若程序调用了seteuid()/setegid()改变了进程的有效用户或组，则在默认情况下系统不会为这些进程生成coredump文件。需要将<code>/proc/sys/fs/suid_dumpable</code>文件的内容设为1。</p>
</li>
<li><p>在普通用户下运行调用了setuid的程序，要将<code>/proc/sys/fs/suid_dumpable</code>设置为2才能生成coredump文件。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>ARMv8 寄存器</title>
    <url>/2022/09/25/cpu/armv8_reg/</url>
    <content><![CDATA[<h2 id="执行状态"><a href="#执行状态" class="headerlink" title="执行状态"></a>执行状态</h2><p>在 ARMv8 架构定义了两种执行状态：AArch64 以及 AArch32。这两种执行状态分别用于描述执行使用 64 位宽的通用寄存器或者使用 32 位宽的通用寄存器。系统运行在 64 位状态下的时候名字叫 Xn，运行在 32 位的时候就叫 Wn。</p>
<p>32位W寄存器使用对应64位X寄存器的低32位，即W0对应X0的低32位，W1对应X1的低32位，以此类推。读取W寄存器时，将会舍弃高32位的数据。写入W寄存器时，会将高32位清0，例如将0xFFFFFFFF写入W0后，X0中的值位0x00000000FFFFFFFF。</p>
<p><img src="/images/cpu/arm/reg.png" alt="img"></p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p><img src="/images/cpu/arm/reg2.png" alt="img"><br><img src="/images/cpu/arm/armv8_register.png" alt="img"></p>
<p>AArch64执行状态拥有 31 个通用寄存器，可以在任何时间和所有异常级别访问。</p>
<ul>
<li><p>X0-X7：参数寄存器，用于传递函数前面8个参数。</p>
</li>
<li><p>X0,X8：返回值寄存器，如果是基本数据类型，返回值保存在X0，如果是结构体，保存在X8。</p>
</li>
<li><p>X9-X15：临时寄存器，使用需要保存现场，返回时需要恢复现场。</p>
</li>
<li><p>X16 X17：程序内调用临时寄存器，使用需要保存现场，返回时需要恢复现场。</p>
</li>
<li><p>X18：平台寄存器，保留用于平台 ABI，尽量不使用</p>
</li>
<li><p>X19-X28：被保存的寄存器，这些寄存器保存在被调用者帧中。使用需要保存现场，返回时需要恢复现场。</p>
</li>
<li><p>X29：帧指针寄存器（Frame Pointer）。</p>
</li>
<li><p>X30：链接寄存器（Link Register）</p>
</li>
<li><p>X31：堆栈指针寄存器（Stack Pointer），存储栈顶地址。</p>
</li>
</ul>
<h2 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h2><p><strong>Zero register(WZR, XZR)</strong></p>
<p>当访问zero寄存器，所有的写入都被丢弃，所有的读取都返回0，AArch32执行状态使用WZR指令访问zero寄存器，AArch64执行状态使用XZR访问zero寄存器。</p>
<p><img src="/images/cpu/arm/armv8%E7%89%B9%E6%AE%8A%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="img"></p>
<p><strong>Program Counter(PC)</strong></p>
<p>程序计数寄存器，是一个各个异常级别通用的一个寄存器。PC寄存器不能作为命名寄存器访问，而是通过确定的指令隐含的访问，如相对PC的加载和产生地址。PC寄存器不能明确的作为数据处理指令或加载指令的目的寄存器。</p>
<p><strong>Stack Pointer(SP)</strong></p>
<p>栈顶指针寄存器，用来描述各个栈顶的指针寄存器。每个异常级别都拥有一个SP寄存器：SP_EL0, SP_EL1, SP_EL2, SP_EL3. 通过此寄存器就可以确定当前在那个EL。AArch32执行状态使用WSP访问当前栈指针寄存器，AArch64执行状态使用SP访问当前栈指针寄存器。</p>
<p><strong>Saved Program Status Register(SPSR)</strong></p>
<p>当异常发生时，处理器的状态将会被保存到相应异常级别的SPSR寄存器中。异常发生后，在处理异常之前，处理器会自动的将PSTATE寄存器的内容保存到SPSR中，异常返回时，会将SPSR保存的处理器状态恢复到PSTATE中。ARMv8定义的SPSR寄存器兼容ARMv7中的SPSR寄存器，只使用低32位。</p>
<p><img src="/images/cpu/arm/SPSR.png" alt="img"></p>
<p>各个位域定义如下：</p>
<ul>
<li>N (Negative)符号位标志位，记录相关指令执行后其结果是否为负数，如果为负数，则 N = 1；如果是非负数，则 N = 0。</li>
<li>Z (Zero)0标志位，记录相关指令执行后，其结果是否为0，如果结果为0，则 Z = 1；如果结果不为0，则 Z = 0。</li>
<li>C (Carry)进位标志位，当加法运算产生了进位时，C = 1，否则 C = 0 ；当减法运算（包括 CMP）产生了借位时，C = 0，否则 C = 1 。</li>
<li>V (Overflow)溢出标志位</li>
<li>SS 用于软件调试。异常发生的时候，通过设置MDSCR_EL1.SS为1启动单步调试机制</li>
<li>IL 不合法的执行状态（非法异常），保存自PSTATE.IL</li>
<li>D 处理器状态调试掩码。指示是否屏蔽来自观察点、断点和软件步骤调试事件的调试异常</li>
<li>A 软件错误掩码位</li>
<li>I IRQ掩码位</li>
<li>F FIQ掩码位</li>
<li>M[4] 发生异常时处理器的执行状态，0表示AArch64</li>
<li>M[3:0] M[3:2]发生异常的级别；M[1]保留；M[0]根据此选择栈指针寄存器，0表示t，1表示h。可以通过异常级别的栈指针后缀表明所选的栈指针。</li>
</ul>
<p><strong>Exception Link Register (ELR)</strong></p>
<p>异常链接寄存器，保存着异常返回地址。</p>
<p>比如当一个异常发生时，处理器必须去处理异常。处理异常时候就需要使用SPSR寄存器保存异常处理前的处理器状态，就是所谓的硬件上保存现场。当处理器处理完异常后，就需要从异常返回，则就需要从ELR寄存器中返回，然后再使用SPSR寄存器恢复现场即可。</p>
<h2 id="Processor-state-PSTATE"><a href="#Processor-state-PSTATE" class="headerlink" title="Processor state(PSTATE)"></a>Processor state(PSTATE)</h2><p>在AArch64执行状态中，处理器的状态使用PSTATE描述，但PSTATE不是寄存器，而是处理器状态各个位域的总称。</p>
<p>在AArch64执行状态中，使用ERET命令从异常中返回，即将SPSR_ELn寄存器中保存的发生异常时的处理器状态恢复到PSTATE中。SPSR_ELn中保存了发生异常时ALU的标志、执行状态、异常级别及处理器branches。处理器从异常返回后的执行地址保存在ELR_ELn中。</p>
<h2 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h2><table>
<thead>
<tr>
<th>名称</th>
<th>寄存器</th>
<th>描述</th>
<th>允许的异常级别</th>
</tr>
</thead>
<tbody><tr>
<td>ACTLR_ELn</td>
<td>辅助控制寄存器</td>
<td>控制处理器详细的特性</td>
<td>1，2，3</td>
</tr>
<tr>
<td>CCSIDR_ELn</td>
<td>当前Cache Size ID寄存器</td>
<td>当前架构所选择cache的信息</td>
<td>1</td>
</tr>
<tr>
<td>CLIDR_ELn</td>
<td>Cache Level ID寄存器</td>
<td>每个级别的cache类型及实现</td>
<td>1，2，3</td>
</tr>
<tr>
<td>CNTFRQ_ELn</td>
<td>计时器频率寄存器</td>
<td>反应了系统定时器的频率</td>
<td>0</td>
</tr>
<tr>
<td>CNTPCT_ELn</td>
<td>计时器物理计数寄存器</td>
<td>保存了当前64位计数值</td>
<td>0</td>
</tr>
<tr>
<td>CNTKCTL_ELn</td>
<td>内核计时器控制寄存器</td>
<td>控制从虚拟计数器生成事件流</td>
<td>1</td>
</tr>
<tr>
<td>CPACR_ELn</td>
<td>协处理器访问控制寄存器</td>
<td>控制访问Trace、 floating-point及NEON</td>
<td>1</td>
</tr>
<tr>
<td>CSSELR_ELn</td>
<td>Cache Size选择寄存器</td>
<td>定义了要求的cache级别、cache类型及指令cache或数据cache</td>
<td>1</td>
</tr>
<tr>
<td>CNTP_CTL_ELn</td>
<td>物理计时器控制寄存器</td>
<td>EL1物理计时器的控制寄存器</td>
<td>0</td>
</tr>
<tr>
<td>ELR_ELn</td>
<td>Exception Link Register</td>
<td>保存异常返回地址</td>
<td>1，2，3</td>
</tr>
<tr>
<td>ESR_ELn</td>
<td>Exception Syndrome Register</td>
<td>保存了发生异常的原因</td>
<td>1，2，3</td>
</tr>
<tr>
<td>FAR_ELn</td>
<td>Fault Address Register</td>
<td>保存了virtual faulting address</td>
<td>1，2，3</td>
</tr>
<tr>
<td>SCTLR_ELn</td>
<td>系统控制寄存器</td>
<td>控制架构特性，如MMU、caches及对齐检查</td>
<td>0，1，2，3</td>
</tr>
<tr>
<td>SPSR_ELn</td>
<td>Saved Program Status Registe</td>
<td>发生异常时，保存处理器的状态</td>
<td>abt，fiq，irq， und，1，2，3</td>
</tr>
</tbody></table>
<h2 id="NEON和浮点寄存器"><a href="#NEON和浮点寄存器" class="headerlink" title="NEON和浮点寄存器"></a>NEON和浮点寄存器</h2><p>armV8有32个128bit的浮点寄存器 V0-V31， 这些寄存器用来处理标量浮点运算时保存浮点操作数，或NEON 操作时保存标量和向量操作数。</p>
<p><img src="/images/cpu/arm/armv8_simd_reg.png" alt="img"></p>
<h2 id="兼容ARMv7"><a href="#兼容ARMv7" class="headerlink" title="兼容ARMv7"></a>兼容ARMv7</h2><p><img src="/images/cpu/arm/armv8_reg_map.png" alt="img"></p>
]]></content>
      <categories>
        <category>cpu</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>linux /etc/passwd config</title>
    <url>/2022/06/07/linux/etc/</url>
    <content><![CDATA[<h2 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h2><p>/etc/passwd该文件对所有用户可读。文件中的每个用户都有一个对应的记录行，记录着这个用户的一下基本属性，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<p><strong>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</strong></p>
<ul>
<li>用户名(login_name):是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</li>
<li>口令(passwd):一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</li>
<li>用户标识号(UID):是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。取值范围是0-65535。0是超级用户root的标识号，1-99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</li>
<li>组标识号(GID):字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。</li>
<li>注释性描述(users):字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</li>
<li>主目录(home_directory):也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</li>
<li>登录Shell(Shell):用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</li>
</ul>
<h2 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h2><p>/etc/shadow文件中的记录行与/etc/passwd中的一一对应，是passwd文件的一个影子。它由pwconv命令根据/etc/passwd中的数据自动产生。但是/etc/shadow文件只有系统管理员才能够进行修改和查看。</p>
<p><strong>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</strong></p>
<ol>
<li>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</li>
<li>“口令”字段存放的是加密后的用户口令字，格式为<code>$id$salt$hashed</code>，则表示该用户密码正常。其中<code>$id$</code>的id表示密码的加密算法，<code>$salt$</code>是加密时使用的salt，hashed才是真正的密码部分。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果为空，则对应用户没有口令，登录时不需要口令；</span><br><span class="line">* 代表帐号被锁定；</span><br><span class="line">!! 表示这个密码已经过期了；</span><br><span class="line">$1$ 是用MD5加密；</span><br><span class="line">$2a$ 是用Blowfish加密；</span><br><span class="line">$2y$ 是另一算法长度的Blowfish</span><br><span class="line">$5$ 是用 SHA-256加密；</span><br><span class="line">$6$ 表示SHA-512算法</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCOLinux中，这个时间起点是1970年1月1日。</li>
<li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li>
<li>“最大时间间隔”指的是口令保持有效的最大天数。</li>
<li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
<h2 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h2><ul>
<li>组名：组的名称，可以将其视为与数值型组标识符相对应的人类可读(符号)标识符。</li>
<li>组密码：这里的 “x” 仅仅是密码标识，真正加密后的组密码默认保存在 /etc/gshadow 文件中。</li>
<li>组 ID (GID)：该组的数值型 ID。正常情况下,对应于组 ID 号 0，只定义一个名为 root的组。</li>
<li>用户列表：属于该组的用户名列表,之间以逗号分隔。</li>
</ul>
<h2 id="省略密码验证"><a href="#省略密码验证" class="headerlink" title="省略密码验证"></a>省略密码验证</h2><p>把/etc/passwd中的<code>root:x:0:0:root:/root:/bin/bash</code>，改为<code>root::0:0:root:/root:/bin/bash</code>，就可以了，就是去掉了里面的x，这样root用户就不用密码了。其他用户也一样。</p>
<h2 id="省略输入用户名"><a href="#省略输入用户名" class="headerlink" title="省略输入用户名"></a>省略输入用户名</h2><p>修改/etc/inittab</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1:2345:respawn:/sbin/agetty tty1 9600</span><br><span class="line">2:2345:respawn:/sbin/agetty tty2 9600</span><br><span class="line">3:2345:respawn:/sbin/agetty tty3 9600</span><br><span class="line">4:2345:respawn:/sbin/agetty tty4 9600</span><br><span class="line">5:2345:respawn:/sbin/agetty tty5 9600</span><br><span class="line">6:2345:respawn:/sbin/agetty tty6 9600</span><br></pre></td></tr></table></figure>

<p>表示系统可以有六个控制台，可以用ALT+(F1~F6)来切换。而/sbin/agetty就是一个登陆验证程序，执行它，会提示用户输入用户名和密码，然后启动一个指定的shell（在passwd文件中指定的）。所以，我们只需将其修改为不执行agettty，而是执行自己编写的一个脚本，就可以跳过用户名和密码的输入。修改如下：</p>
<blockquote>
<p>1:2345:respawn:/bin/autologin tty1 9600</p>
</blockquote>
<p>autologin脚本内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">/bin/login -f root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux修复grub引导</title>
    <url>/2022/06/07/linux/grub_fix/</url>
    <content><![CDATA[<p>因为之前给硬盘分区的原故，使磁盘盘符发生了变化，进而导致grub无法引导系统，出现以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: file &#x27;/boot/grub/i386-pc/normal.mod&#x27; not found</span><br><span class="line">grub rescue&gt;</span><br></pre></td></tr></table></figure>

<p>在救援模式下，可以使用以下命令：</p>
<ul>
<li>set 设置环境变量</li>
<li>ls 查看目录</li>
<li>insmod 加载模块</li>
<li>root 指定用于启动系统的分区，即安装了grub的分区</li>
<li>prefix 设定grub配置文件和启动路径</li>
</ul>
<p>先使用 ls 命令可以列出当前的所有分区，我们的目的是要找到grub所在的分区，可以使用<code>ls (hd0, msdos6)/boot/grub</code>这样的形式一个个分区地支探测，能成功的列出文件内容的就是grub分区。</p>
<p>找到正确的分区后，接着就是用正确的分区设置环境变量，然后加载模块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set boot=(hd0,msdos2)/boot/grub</span><br><span class="line">set prefix=(hd0,msdos2)/boot/grub</span><br><span class="line">insmod normal</span><br><span class="line">normal</span><br></pre></td></tr></table></figure>

<p>执行完成后就能成功进入系统了，因为只是手动进入了系统，其实grub并没有真正修复，下次启动同样会出错。所以进入系统后需要安装Boot-Repair工具，完成grub的修复。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:yannubuntu/boot-repair</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y boot-repair</span><br><span class="line">boot-repair</span><br></pre></td></tr></table></figure>

<p>还有种情况就是grub已经损坏，已经无法进入系统了，需要重新安装grub。</p>
<p>先通过linux安装光盘进入系统，使用<code>fdisk -l</code>命令查看磁盘，将boot分区挂载到系统上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount /dev/sda5 /mnt</span><br><span class="line">sudo grub-install --boot-directory=/mnt/ /dev/sda</span><br></pre></td></tr></table></figure>

<p>安装完后，如果重启grub的引导界面上没有windows系统，则需要再更新下grub引导项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://www.cnblogs.com/zxhyJack/p/9165919.html">https://www.cnblogs.com/zxhyJack/p/9165919.html</a><br><a href="https://m.php.cn/article/373791.html">https://m.php.cn/article/373791.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>静态库与动态库</title>
    <url>/2022/06/07/linux/lib/</url>
    <content><![CDATA[<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>gcc默认情况下，采用动态连接的方式连接第三方库，gcc提供了一个<code>-static</code>参数，可以改变默认的连接方式。</p>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p><strong>生成动态库</strong><br>编译时使用<code>-shared -fPIC</code>参数。</p>
<blockquote>
<p>gcc -shared -fPIC -o libtest.so test.c</p>
</blockquote>
<p><strong>指定动态库位置</strong><br>默认/lib和/usr/lib</p>
<p>1.　gcc参数指定</p>
<blockquote>
<p>-Wl,-rpath=&lt;动态库所在路径&gt;</p>
</blockquote>
<ol start="2">
<li><p>设置环境变量</p>
<blockquote>
<p>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&lt;动态库所在位置&gt;</p>
</blockquote>
</li>
<li><p>修改``/etc/ld.so.conf<code>文件，添加动态库路径，运行命令</code>ldconfig`使修改后的配置生效。</p>
</li>
</ol>
<p><strong>显式运行时链接动态库</strong><br>显式运行时链接（explicit run-time linking），也叫运行时加载，可以使程序自己在运行时控制加载的指定的模块，并在不需要使用的时候卸载。程序一开始不必将其全部装载进来，减少了程序启动时间和内存使用，程序不必重启就可以实现模块的增加、删除、更新。动态链接器提供的API主要有4个：dlopen(), dlsym(), dlclose(), dlerror()，使用它们的时候需要包含 #include &lt;dlfcn.h&gt;。</p>
<p>-　dlopen()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure>

<p>打开一个动态库，并将其加载到进程的地址空间，完成初始化过程。</p>
<p>第一个参数是被加载动态库的路径。如果是绝对路径，函数会尝试直接打开此动态库，如果是相对路径，函数会按以下顺序查找该动态库文件：</p>
<ol>
<li>查找环境变量<code>LD_LIBRARY_PATH</code>指定的目录</li>
<li>查找由 <code>/etc/ld.so.cache</code>里面指定的共享库路径</li>
<li><code>/lib, /usr/lib</code></li>
</ol>
<p>如果把该参数设置为0，将会返回全局符号表的句柄。也就是说，我们可以在运行时找到全局符号表里的任何一个符号并执行它们。</p>
<p>第二个参数是函数符号的解析方式。取值可以是 RTLD_LAZY/RTLD_NOW|RTLD_GLOBAL，其中，RTLD_LAZY表示延迟绑定，当函数第一次被调用时才进行绑定，而RTLD_NOW则是模块被加载时就进行绑定。这两种绑定方式只能选择一个，而它们都可以与RTLD_GLOBAL一起使用，表示将被加载的模块的全局符号合并到进程的全局符号表中，使得以后加载的模块可以使用这些符号。</p>
<p>dlopen的返回值是被加载模块的句柄，供后面调用其他函数时使用。如果加载失败，返回 NULL。如果模块已经被加载过了，返回同一个句柄。</p>
<ul>
<li>dlsym()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">char</span> *symbol)</span>;</span><br></pre></td></tr></table></figure>
<p>找到指定句柄中的符号。</p>
<p>第一个参数是使用dlopen返回的句柄，第二个参数是所需要查找的符号，是一个以’\0’结尾的字符串。如果找到了该符号，返回符号的值；如果未找到符号，则返回 NULL。如果查找的是个函数，返回函数的地址；如果是变量，返回变量的地址；如果是常量，返回常量的值；如果返回的常量值刚好是NULL或0，就需要调用dlerror()函数判断是否调用成功。如果返回NULL，则调用成功且符号找到。如果返回错误信息，则未找到该符号。</p>
<ul>
<li>dlclose()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>;</span><br></pre></td></tr></table></figure>

<p>关闭打开的句柄，卸载已加载的某个模块。系统会维持一个加载引用计数器，每次使用dlopen加载某个模块时，相应的计数器加1，每次使用dlclose卸载某个模块时，相应的计数器减1。只有当计数器值减到0时，模块才被真正地卸载掉。</p>
<ul>
<li>dlerror()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>每次调用dlopen, dlsym, dlclose之后都可以调用dlerror()来判断上一次调用是否成功。返回NULL，则上一次调用成功；上一次调用失败，则返回相应的错误信息。</p>
<h2 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h2><p>pkg-config能够把这些头文件和库文件的位置指出来，给编译器使用，pkg-config命令是通过查询XXX.pc文件而知道的。通过环境变量<code>PKG_CONFIG_PATH</code>指定XXX.pc的路径。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><code>--enable-shared</code>    生成动态库</p>
<h3 id="x86-64机器上编译32位库"><a href="#x86-64机器上编译32位库" class="headerlink" title="x86_64机器上编译32位库"></a>x86_64机器上编译32位库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/home/luoyou/home/usr32 --host=i686-linux-gnu      --build=i686-linux-gnu CC=&quot;gcc -m32&quot; CXX=&quot;g++ -m32&quot; CFLAGS=&quot;-O2 -march=i686&quot; CXXFLAGS=&quot;-O2 -march=i686&quot; --enable-shared</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux file mode</title>
    <url>/2022/07/14/linux/file_mode/</url>
    <content><![CDATA[<p>实际用户ID：真实用户，就是登陆系统时的身份ID。<br>有效用户ID：是进程的属性，决定了进程对文件的访问权限。</p>
<p>r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。</p>
<p>w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。</p>
<p>x(execute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。</p>
<p>i不可修改权限。通过<code>chattr + i</code>  <code>chattr - i</code>来设置，用<code>lsattr</code>命令查看。</p>
<p>a只追加权限，对于日志系统很好用，让目标文件只能追加，不能删除，而且不能通过编辑器追加。通过<code>chattr +a</code>  <code>chattr -a</code>来设置。</p>
<h2 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h2><p>SUID全称Set User ID，当小写字母s出现在文件拥有者权限的执行位上，具有这种权限的二进制会在其执行时，使调用者暂时获得该文件拥有者的权限，原理是将进程的有效ID临时更改为文件的所有者ID。例如passwd命令便是个设置了SUID的程序，使得普通用户无读写/etc/shadow文件的权限，也可以修改自己的密码。</p>
<ol>
<li>只对二进制文件有效，不能作用于目录或Shell脚本；</li>
<li>调用者对该文件有执行权，必须先设置x权限</li>
<li>在执行过程中，调用者会暂时获得该文件的所有者权限；</li>
<li>该权限只在程序执行的过程中有效。</li>
</ol>
<p>当ls -l 看到rwS，大写S说明SUID权限未生效。</p>
<h2 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h2><p>SGID全称Set Group ID，当小写字母s出现在文件用户组的执行权限位上，它对普通二进制文件和目录都有效。当它作用于普通文件时，和SUID类似，在执行该文件时，用户将获得该文件所属组的权限。当SGID作用于目录时，当用户对某一目录有写和执行权限时，该用户就可以在该目录下建立文件，如果该目录用SGID修饰，则该用户在这个目录下建立的文件都是属于这个目录所属的组。</p>
<p>大写S表明该文件的SGID属性无效，比如给一个不可执行的文件设置SGID属性。</p>
<h2 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h2><p>SBIT全称Sticky Bit（粘滞位），它出现在其他用户权限的执行位上，只能用来修饰一个目录。当某一个目录拥有SBIT权限时，则任何的用户都能够在这个目录下创建文档，但只能删除自己创建的文档，用来阻止非文件的所有者删除文件。例如/tmp目录。可通过<code>chmod + t</code>  <code>chmod - t</code>  <code>chmod 1777</code>来设置。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>install ssh samba nfs tftp service</title>
    <url>/2022/09/04/linux/nfs_tftp_samb_ssh/</url>
    <content><![CDATA[<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>SSH(Secure Shell)，是建立在应用层和传输层基础上的安全协议，可以通过网络登录远程系统，能够有效防<br>止远程管理过程中的信息泄露问题。</p>
<p>1.安装ssh服务</p>
<blockquote>
<p>sudo apt-get install openssh-server</p>
</blockquote>
<p>2.启动ssh服务</p>
<blockquote>
<p>sudo service ssh start</p>
</blockquote>
<h2 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h2><p>1.安装Samba</p>
<blockquote>
<p>sudo apt-get install samba samba-common</p>
</blockquote>
<p>2.创建分享目录，配置samba，修改<code>/etc/samba/smb.conf</code>，用<code>testparm</code>命令检查配置文件的语法错误。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">    allow insecure wide links = yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[homes]</span><br><span class="line">    create mask = 0775</span><br><span class="line">    directory mask = 0775</span><br><span class="line">    valid users = %S</span><br><span class="line">    read only = no</span><br><span class="line">    writable = yes</span><br><span class="line">    browseable = no</span><br><span class="line">    follow symlinks = yes</span><br><span class="line">    wide links = yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[share]</span><br><span class="line">    comment = share folder</span><br><span class="line">    path = /share</span><br><span class="line">    create mask = 0777</span><br><span class="line">    directory mask = 0777</span><br><span class="line">    read only = no</span><br><span class="line">    writable = yes</span><br><span class="line">    public = yes</span><br><span class="line">    browseable = yes</span><br></pre></td></tr></table></figure>

<p>3.添加登入共享文件夹的用户名和密码，其中用户名必须为linux中的用户。</p>
<blockquote>
<p>sudo smbpasswd -a root</p>
</blockquote>
<p>4.重启samba服务</p>
<blockquote>
<p>service smbd restart</p>
</blockquote>
<h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2><p>NFS(Network File-System)网络文件系统，可以通过网络让不同机器、不同系统之间可以实现文件共享。</p>
<p>1.安装nfs相关软件</p>
<blockquote>
<p>sudo apt-get install nfs-kernel-server nfs-common</p>
</blockquote>
<p>2.修改配置，添加共享目录，<code>sudo vim /etc/exports</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/nfsroot *(rw,sync,no_root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>/nfsroot  ：共享的目录</p>
</li>
<li><p>*：指定哪些用户可以访问，<br>*所有可以ping同该主机的用户；</p>
</li>
</ul>
<p>192.168.1.* 指定网段，在该网段中的用户可以挂载；<br>192.168.1.12 只有该用户能挂载；</p>
<ul>
<li>(ro,sync,no_root_squash)： 权限，<br>ro : 只读；<br>rw : 读写；<br>sync : 数据同步写入内存和硬盘；<br>no_root_squash: 不降低root用户的权限；</li>
</ul>
<p>3.创建共享目录，并设置目录权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /nfsroot</span><br><span class="line">sudo chmod -R 777 /nfsroot</span><br><span class="line">sudo chown –R nobody /nfsroot</span><br></pre></td></tr></table></figure>

<p>4.重新启动nfs服务</p>
<blockquote>
<p>sudo service nfs-kernel-server restart</p>
</blockquote>
<p>5.挂载自测</p>
<blockquote>
<p>mount -t nfs localhost:/nfsroot ~/test -o nolock</p>
</blockquote>
<h2 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h2><p>TFTP(Trivial File Transfer Protocol,简单文件传输协议)是用来在客户机和服务器之间进行简单文件传输的协议。</p>
<p>1.安装tftp服务</p>
<blockquote>
<p>sudo apt-get install xinetd tftp tftpd</p>
</blockquote>
<p>2.新建/etc/xinetd.d/tftp配置文件，指定的用户和tftp服务器根路径，若不存在，则需创建该目录，并设置访问权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service tftp</span><br><span class="line">&#123;</span><br><span class="line">    socket_type = dgram</span><br><span class="line">    wait = yes </span><br><span class="line">    user = luou</span><br><span class="line">    protocol = udp </span><br><span class="line">    server = /usr/sbin/in.tftpd</span><br><span class="line">    server_args = -s /tftp</span><br><span class="line">    disable = no</span><br><span class="line">    per_source = 11</span><br><span class="line">    cps =100 2</span><br><span class="line">    flags =IPv4</span><br></pre></td></tr></table></figure>

<p>3.重启xinetd服务</p>
<blockquote>
<p>sudo /etc/init.d/xinetd restart</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux /proc/ directory</title>
    <url>/2022/06/07/linux/proc/</url>
    <content><![CDATA[<p>/proc文件系统是一种虚拟文件系统，以文件系统目录和文件形式，提供一个指向内核数据结构的接口，通过它能够查看和改变各种系统属性，proc目录通常情况下是由系统自动挂载在/proc目录下，也可自行手动挂载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t proc proc /proc</span><br></pre></td></tr></table></figure>

<h2 id="proc-pid"><a href="#proc-pid" class="headerlink" title="/proc/pid/"></a>/proc/pid/</h2><p>这些文件和目录记录的都是pid对应进程的信息。</p>
<ul>
<li><p>/proc/pid/attr/  提供了安全相关的属性，可读可写，以支持SELinux等安全模块，需配置CONFIG_SECURITY。</p>
<ul>
<li>/proc/pid/attr/current  当前的安全相关的属性。</li>
<li>/proc/pid/attr/exec  执行命令execve时设置的安全相关的属性。</li>
<li>/proc/pid/attr/fscreate  代表进程与文件有关的权限，包括open、mkdir、symlink、mknod。</li>
<li>/proc/pid/attr/keycreate  执行命令add_key时设置的安全相关的属性。</li>
<li>/proc/pid/attr/prev  最后一次执行命令execve时的安全相关的属性。</li>
<li>/proc/pid/attr/sockcreate  创建socket时设置的安全相关的属性。</li>
</ul>
</li>
<li><p>/proc/pid/auxv  ELF解释器信息，格式为一个unsigned long类型的ID加一个unsigned long类型的值，最后为两个0（man getauxval）。</p>
</li>
<li><p>/proc/pid/cgroup  进程所属的控制组，格式为冒号分隔的三个字段，分别是结构ID、子系统、控制组，需配置CONFIG_CGROUPS。</p>
</li>
<li><p>/proc/pid/clear_refs  只写，只用于进程的拥有者，清除用于估算内存使用量的PG_Referenced和ACCESSED/YOUNG，有四种策略，1表示清除相关的所有页，2表示清除相关的匿名页，3表示清除相关的映射文件的页，4表示清除相关的soft-dirty的页，需配置CONFIG_PROC_PAGE_MONITOR。</p>
</li>
<li><p>/proc/pid/cmdline  只读，保存启动进程的完整的命令行字符串，如果是僵尸进程，这个文件为空。</p>
</li>
<li><p>/proc/pid/comm  进程的命令名，不同的线程（man clone prctl pthread_setname_np）可能有不同的线程名，位置在“task/[tid]/comm”，名字长度超过TASK_COMM_LEN时会被截断。</p>
</li>
<li><p>/proc/pid/coredump_filter  coredump过滤器，如00000033（man core），不同的二进制位表示过滤不同的信息。</p>
</li>
<li><p>/proc/pid/cpuset  控制CPU和内存的节点（man cpuset）。</p>
</li>
<li><p>/proc/pid/cwd  符号链接到当前工作目录。</p>
</li>
<li><p>/proc/pid/environ  环境变量。</p>
</li>
<li><p>/proc/pid/exe  符号链接到启动进程的完整命令。</p>
</li>
<li><p>/proc/pid/fd / 包含当前的fd，这些fd符号链接到真正打开的文件。</p>
</li>
<li><p>/proc/pid/fdinfo / 包含当前fd的信息，不同类型的fd信息不同。</p>
</li>
<li><p>/proc/pid/io  IO信息。</p>
</li>
<li><p>/proc/pid/gid_map  从用户命名空间映射的组ID的信息（man user_namespaces）。</p>
</li>
<li><p>/proc/pid/limits  资源软、硬限制（man getrlimit）。</p>
</li>
<li><p>/proc/pid/map_files / 包括一些内存映射文件（man mmap），文件名格式为BeginAddress-EndAddress，符号链接到映射的文件，需要配置CONFIG_CHECKPOINT_RESTORE。</p>
</li>
<li><p>/proc/pid/maps  当前进程映射的内存区域以及访问权限。</p>
</li>
<li><p>/proc/pid/mem  可以通过open、read和lseek访问进程的内存页，不能被用户读取。</p>
</li>
<li><p>/proc/pid/mountinfo  挂载信息，格式为<code>36 35 98:0 /mnt1 /mnt2 rw,noatime master:1 - ext3 /dev/root rw,errors=continue</code>，以空格作为分隔符，从左到右各字段的意思分别是唯一挂载ID、父挂载ID、文件系统的设备主从号码、文件系统中挂载的根节点、相对于进程根节点的挂载点、挂载权限等挂载配置、可选配置、短横线表示前面可选配置的结束、文件系统类型、文件系统特有的挂载源或者为none、额外配置。</p>
</li>
<li><p>/proc/pid/mounts  挂载在当前进程的文件系统列表，格式参照（man fstab）。</p>
</li>
<li><p>/proc/pid/mountstats  挂载信息。</p>
</li>
<li><p>/proc/pid/ns / 保存了每个名字空间的入口，详见（man namespaces）。</p>
</li>
<li><p>/proc/pid/numa_maps  numa即Non Uniform Memory Access，详见（man numa）。</p>
</li>
<li><p>/proc/pid/oom_adj  调整OOM分数，OOM即Out Of Memory，发生OOM时OOM Killer根据OOM分数杀掉分数高的进程，默认值为0，会继承自父进程的设置。</p>
</li>
<li><p>/proc/pid/oom_score  OOM分数。</p>
</li>
<li><p>/proc/pid/oom_score_adj  OOM分值介于-1000到1000之间。</p>
</li>
<li><p>/proc/pid/pagemap  当前进程的虚拟内存页映射信息，需要配置CONFIG_PROC_PAGE_MONITOR。</p>
</li>
<li><p>/proc/pid/personality  进行执行域。</p>
</li>
<li><p>/proc/pid/root  链接到了当前进程的根目录。</p>
</li>
<li><p>/proc/pid/seccomp  seccomp模式下允许的系统调用只有read、write、_exit、sigreturn，Linux 2.6.23已弃用这个文件，由prctl替代。</p>
</li>
<li><p>/proc/pid/setgroups  详见（man user_namespaces）。</p>
</li>
<li><p>/proc/pid/smaps”  内存映射信息，类似于pmap命令，需要配置CONFIG_PROC_PAGE_MONITOR。</p>
</li>
<li><p>/proc/pid/stack  内核空间的函数调用堆栈，需要配置CONFIG_STACKTRACE。</p>
</li>
<li><p>/proc/pid/stat  进程状态信息，用于ps命令。</p>
</li>
<li><p>/proc/pid/statm  进程内存使用信息，以空格分隔的7个数字，从左到右分别表示程序总大小、常驻内存大小、共享内存页大小、text code、library、data + stack、dirty pages。</p>
</li>
<li><p>/proc/pid/status  可读性好的进程相关信息。</p>
</li>
<li><p>/proc/pid/syscall  系统调用相关信息，需要配置CONFIG_HAVE_ARCH_TRACEHOOK。</p>
</li>
<li><p>/proc/pid/task/  每个线程一个子目录，目录名为线程ID。</p>
</li>
<li><p>/proc/pid/timers  POSIT定时器列表，包括定时器ID、信号等信息。</p>
</li>
<li><p>/proc/pid/uid_map  用户ID映射信息，详见（man user_namespaces）。</p>
</li>
<li><p>/proc/pid/gid_map  组ID映射信息，详见（man user_namespaces）。</p>
</li>
<li><p>/proc/pid/wchan  进程休眠时内核中相应位置的符号表示，如do_wait。</p>
</li>
</ul>
<h3 id="proc-pid-maps"><a href="#proc-pid-maps" class="headerlink" title="/proc/pid/maps"></a>/proc/pid/maps</h3><h3 id="proc-pid-status"><a href="#proc-pid-status" class="headerlink" title="/proc/pid/status"></a>/proc/pid/status</h3><h3 id="proc-pid-stat"><a href="#proc-pid-stat" class="headerlink" title="/proc/pid/stat"></a>/proc/pid/stat</h3><p>关于进程的状态信息，主要是用于 ps 命令展示，每一行的含义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. pid %d 进程PID</span><br><span class="line">2. comm %s 可执行文件的文件名</span><br><span class="line">3. state %c 进程的状态,使用RSDZTW其中一个值表示.R表示正在运行,S表示因为中断休眠,D表示进程处于不可中断的睡眠, When a process will go to ‘D’ state?. Z表示僵尸进程,T表示正在被追踪或者停止,W表示现在正在进行叶交换.</span><br><span class="line">4. ppid %d 父进程PID</span><br><span class="line">5. grid %d 进程组ID</span><br><span class="line">6. session %d 进程的session id</span><br><span class="line">7. tty_nr %d 进程的控制终端</span><br><span class="line">8. tpgid %d 进程控制终端的前台进程id</span><br><span class="line">9. minflt %n 进程因为不需要从磁盘加载内存页而造成的次要故障数</span><br><span class="line">10. cminflt %u 进程等待子进程造成的次要故障数</span><br><span class="line">11. majflt %lu 进程需要从磁盘加载内存页造成的故障数</span><br><span class="line">12. cmajflt %lu 进程等待子进程造成的故障数</span><br><span class="line">13. utime %lu 进程在用户模式下被调度的时间</span><br><span class="line">14. stime %lu 进程在内核模式下被调度的时间</span><br><span class="line">15. cutime %ld 进程在用户模式下等待子进程的时间</span><br><span class="line">16. cstime %ld 进程在内核模式下等待子进程的时间</span><br><span class="line">17. nice %ld 参见 setpriority 位于19到-20之间.</span><br><span class="line">18. num_threads %ld 当前进程的线程数量</span><br><span class="line">19. vsize %lu 使用的虚拟内存</span><br><span class="line">20. rss %ld resident set szie的缩写,表示进程在实际内存中的页数,主要是包括了text,data,栈,不包括没有加载到内存中或者已经被换出去的内存大小</span><br><span class="line">21. rsslim %lu 进程rss的限制</span><br></pre></td></tr></table></figure>

<h2 id="proc-net"><a href="#proc-net" class="headerlink" title="/proc/net/"></a>/proc/net/</h2><p>网络伪文件系统相关。</p>
<ul>
<li>/proc/net/arp   包含了用于地址解析的内核ARP表的信息。</li>
<li>/proc/net/dev   dev虚拟文件系统显示网络状态的信息，包括发送和接受的数据包的数量，错误和冲突以及其他的统计信息，可通过ifconfig查看。</li>
<li>/proc/net/raw   存储的是RAW套接字表的信息。</li>
<li>/proc/net/snmp  保存的是SNMP代理的IP，ICMP以及UDP的管理信息。</li>
<li>/proc/net/tcp   保存的是系统中的TCP表的信息。</li>
<li>/proc/net/udp   保存的是系统中的UDP表的信息。</li>
<li>/proc/net/unix  显示当前系统所有的UNIX domain socket以及它们的状态信息。</li>
</ul>
<h2 id="proc-sys"><a href="#proc-sys" class="headerlink" title="/proc/sys/"></a>/proc/sys/</h2><p>系统变量相关信息</p>
<h2 id="proc-bus"><a href="#proc-bus" class="headerlink" title="/proc/bus/"></a>/proc/bus/</h2><p>已安装的总线</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>/proc/apm  高级电源管理（APM）版本信息及电池相关状态信息，通常由apm命令使用，需要配置CONFIG_APM。</li>
<li>/proc/buddyinfo  用于诊断内存碎片问题。</li>
<li>/proc/cmdline  系统启动时传递给Linux内核的参数，如lilo、grub等boot管理模块。</li>
<li>/proc/config.gz  内核编译配置选项，需要配置CONFIG_IKCONFIG_PROC。</li>
<li>/proc/crypto  内核加密API提供的加密列表。</li>
<li>/proc/cpuinfo  CPU和系统架构信息，lscpu命令使用这个文件。</li>
<li>/proc/devices  设备相关信息。</li>
<li>/proc/diskstats  每块磁盘设备的磁盘I/O统计信息列表。</li>
<li>/proc/dma  正在使用且注册的DMA通道信息列表。</li>
<li>/proc/driver/rtc  系统运行时配置。</li>
<li>/proc/execdomains  执行域列表。</li>
<li>/proc/fb  帧缓冲设备列表文件，包含帧缓冲设备的设备号和相关驱动信息，需要配置CONFIG_FB。</li>
<li>/proc/filesystems  内核支持的文件系统类型（man filesystems）。</li>
<li>/proc/fs  挂载的文件系统信息。</li>
<li>/proc/ide  用于IDE接口。</li>
<li>/proc/interrupts  每个CPU每个IO的中断信息。</li>
<li>/proc/iomem  IO内存映射信息。</li>
<li>/proc/ioports  IO端口信息。</li>
<li>/proc/kallsyms  用于动态链接和和模块绑定的符号定义。</li>
<li>/proc/kcore  系统使用的物理内存，以ELF核心文件格式存储，其文件大小为已使用的物理内存加4KB；这个文件用来检查内核数据结构的当前状态，通常由GBD调试工具使用。</li>
<li>/proc/kmsg  用来保存由内核输出的信息，dmsg命令使用这个文件。</li>
<li>/proc/kpagecount  每个物理页帧映射的次数，需要配置CONFIG_PROC_PAGE_MONITOR。</li>
<li>/proc/kpageflags  每个物理页帧的掩码，需要配置CONFIG_PROC_PAGE_MONITOR。</li>
<li>/proc/ksyms  同kallsyms。</li>
<li>/proc/loadavg  保存关于CPU和磁盘I/O的负载平均值。</li>
<li>/proc/locks  保存当前由内核锁定的文件的相关信息。</li>
<li>/proc/malloc  需要配置CONFIG_DEBUG_MALLOC。</li>
<li>/proc/mdstat  保存RAID相关的多块磁盘的当前状态信息</li>
<li>/proc/meminfo  系统内存使用统计，free命令使用了这个文件。</li>
<li>/proc/modules  系统加载的模块信息，相关命令为lsmod。</li>
<li>/proc/mounts  链接到了/self/mounts。</li>
<li>/proc/mtrr  Memory Type Range Registers。</li>
<li>/proc/partitions  分区信息。</li>
<li>/proc/pci  PCI接口设备。</li>
<li>/proc/profile  用于readprofile命令作性能分析。</li>
<li>/proc/scsi  SCSI接口设备。</li>
<li>/proc/scsi/scsi</li>
<li>/proc/scsi/[drivername]</li>
<li>/proc/self  链接到了当前进程所在的目录。</li>
<li>/proc/slabinfo  内核缓存信息，需要配置CONFIG_SLAB。</li>
<li>/proc/stat  系统信息统计。</li>
<li>/proc/swaps  交换分区及其空间利用信息。</li>
<li>/proc/sysrq-trigger  可写，触发系统调用。</li>
<li>/proc/sysvipc  包括msg、sem、shm三个文件，为System V IPC对象。</li>
<li>/proc/thread-self  链接到了当前进程下的task目录中的线程文件<code>/proc/self/task/tid</code>。</li>
<li>/proc/timer_list  还在运行着的定时器列表。</li>
<li>/proc/timer_stats  定时器状态。</li>
<li>/proc/tty  tty设备相关。</li>
<li>/proc/uptime  系统更新时间和进程空闲时间，单位是秒。</li>
<li>/proc/version  内核版本信息。</li>
<li>/proc/vmstat  虚拟内存统计信息，以键值对形式显示。</li>
<li>/proc/zoneinfo  内存区块信息，用于分析虚拟内存的行为。</li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>linux startup</title>
    <url>/2022/06/07/linux/linux_startup/</url>
    <content><![CDATA[<p>开发一个自己的 Linux 发行版，从头开发一个 Linux 发行版这件事情被称作 Linux From Scratch （LFS）。LFS 手册是打造 LFS 的官方指南，官网：<a href="http://www.linuxfromscratch.org/index.html">http://www.linuxfromscratch.org/index.html</a></p>
<p>在线手册：<a href="https://linux.cn/lfs/LFS-BOOK-7.7-systemd/index.html">https://linux.cn/lfs/LFS-BOOK-7.7-systemd/index.html</a></p>
<h3 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h3><p>首先，在内核init/main.c文件中，init_post函数完成了对根文件系统和控制台的检测，并启动init进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">int</span> <span class="title function_">init_post</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* need to finish all async __init code before freeing the memory */</span></span><br><span class="line">    async_synchronize_full();</span><br><span class="line">    free_initmem();</span><br><span class="line">    mark_rodata_ro();</span><br><span class="line">    system_state = SYSTEM_RUNNING;</span><br><span class="line">    numa_default_policy();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    current-&gt;signal-&gt;flags |= SIGNAL_UNKILLABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">        run_init_process(ramdisk_execute_command);</span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Failed to execute %s\n&quot;</span>,</span><br><span class="line">                ramdisk_execute_command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We try each of these until one succeeds.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The Bourne shell can be used instead of init if we are</span></span><br><span class="line"><span class="comment">     * trying to recover a really broken machine.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">        run_init_process(execute_command);</span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Failed to execute %s.  Attempting &quot;</span></span><br><span class="line">                    <span class="string">&quot;defaults...\n&quot;</span>, execute_command);</span><br><span class="line">    &#125;</span><br><span class="line">    run_init_process(<span class="string">&quot;/sbin/init&quot;</span>);</span><br><span class="line">    run_init_process(<span class="string">&quot;/etc/init&quot;</span>);</span><br><span class="line">    run_init_process(<span class="string">&quot;/bin/init&quot;</span>);</span><br><span class="line">    run_init_process(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    panic(<span class="string">&quot;No init found.  Try passing init= option to kernel. &quot;</span></span><br><span class="line">          <span class="string">&quot;See Linux Documentation/init.txt for guidance.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核会先根据uboot参数<code>init=/sbin/init</code>来启动第一个进程，一般都是init，实质是指向busybox的软链接。</p>
<p>init进程的入口是busybox/init/init.c中的init_main()函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if we are supposed to be in single user mode */</span></span><br><span class="line"><span class="keyword">if</span> (argv[<span class="number">1</span>]</span><br><span class="line"> &amp;&amp; (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;single&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-s&quot;</span>) == <span class="number">0</span> || LONE_CHAR(argv[<span class="number">1</span>], <span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">/* ??? shouldn&#x27;t we set RUNLEVEL=&quot;b&quot; here? */</span></span><br><span class="line">    <span class="comment">/* Start a shell on console */</span></span><br><span class="line">    new_init_action(RESPAWN, bb_default_login_shell, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Not in single user mode - see what inittab says */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NOTE that if CONFIG_FEATURE_USE_INITTAB is NOT defined,</span></span><br><span class="line"><span class="comment">     * then parse_inittab() simply adds in some default</span></span><br><span class="line"><span class="comment">     * actions (i.e., INIT_SCRIPT and a pair</span></span><br><span class="line"><span class="comment">     * of &quot;askfirst&quot; shells) */</span></span><br><span class="line">    parse_inittab();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为内核启动init进程没有传入附加参数，所以argv[1]不存在，程序走parse_inittab()。如果没有定义<code>CONFIG_FEATURE_USE_INITTAB</code> 这个宏，程序会执行一些默认的action，这个宏是busybox配置时的选项。最后调用run_action()运行每一个action，并且首先运行的是action为sysinit的动作。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">config FEATURE_USE_INITTAB</span><br><span class="line">    bool &quot;Support reading an inittab file&quot;</span><br><span class="line">    default y</span><br><span class="line">    depends on INIT || LINUXRC</span><br><span class="line">    help</span><br><span class="line">    Allow init to read an inittab file when the system boot.</span><br></pre></td></tr></table></figure>

<p>busybox/init/init.c中的parse_inittab()函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* NOTE that if CONFIG_FEATURE_USE_INITTAB is NOT defined,</span></span><br><span class="line"><span class="comment"> * then parse_inittab() simply adds in some default</span></span><br><span class="line"><span class="comment"> * actions (i.e., runs INIT_SCRIPT and then starts a pair</span></span><br><span class="line"><span class="comment"> * of &quot;askfirst&quot; shells).  If CONFIG_FEATURE_USE_INITTAB</span></span><br><span class="line"><span class="comment"> * _is_ defined, but /etc/inittab is missing, this</span></span><br><span class="line"><span class="comment"> * results in the same set of default behaviors.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parse_inittab</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_FEATURE_USE_INITTAB</span></span><br><span class="line">    <span class="type">char</span> *token[<span class="number">4</span>];</span><br><span class="line">    <span class="type">parser_t</span> *parser = config_open2(<span class="string">&quot;/etc/inittab&quot;</span>, fopen_for_read);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* No inittab file - set up some default behavior */</span></span><br><span class="line">        <span class="comment">/* Sysinit */</span></span><br><span class="line">        new_init_action(SYSINIT, INIT_SCRIPT, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">/* Askfirst shell on tty1-4 */</span></span><br><span class="line">        new_init_action(ASKFIRST, bb_default_login_shell, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> VC_1 instead of &quot;&quot;? &quot;&quot; is console -&gt; ctty problems -&gt; angry users</span></span><br><span class="line">        new_init_action(ASKFIRST, bb_default_login_shell, VC_2);</span><br><span class="line">        new_init_action(ASKFIRST, bb_default_login_shell, VC_3);</span><br><span class="line">        new_init_action(ASKFIRST, bb_default_login_shell, VC_4);</span><br><span class="line">        <span class="comment">/* Reboot on Ctrl-Alt-Del */</span></span><br><span class="line">        new_init_action(CTRLALTDEL, <span class="string">&quot;reboot&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">/* Umount all filesystems on halt/reboot */</span></span><br><span class="line">        new_init_action(SHUTDOWN, <span class="string">&quot;umount -a -r&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">/* Swapoff on halt/reboot */</span></span><br><span class="line">        new_init_action(SHUTDOWN, <span class="string">&quot;swapoff -a&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">/* Restart init when a QUIT is received */</span></span><br><span class="line">        new_init_action(RESTART, <span class="string">&quot;init&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_FEATURE_USE_INITTAB</span></span><br><span class="line">    <span class="comment">/* optional_tty:ignored_runlevel:action:command</span></span><br><span class="line"><span class="comment">     * Delims are not to be collapsed and need exactly 4 tokens</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (config_read(parser, token, <span class="number">4</span>, <span class="number">0</span>, <span class="string">&quot;#:&quot;</span>,</span><br><span class="line">                PARSE_NORMAL &amp; ~(PARSE_TRIM | PARSE_COLLAPSE))) &#123;</span><br><span class="line">        <span class="comment">/* order must correspond to SYSINIT..RESTART constants */</span></span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> actions[] ALIGN1 =</span><br><span class="line">            <span class="string">&quot;sysinit\0&quot;</span><span class="string">&quot;wait\0&quot;</span><span class="string">&quot;once\0&quot;</span><span class="string">&quot;respawn\0&quot;</span><span class="string">&quot;askfirst\0&quot;</span></span><br><span class="line">            <span class="string">&quot;ctrlaltdel\0&quot;</span><span class="string">&quot;shutdown\0&quot;</span><span class="string">&quot;restart\0&quot;</span>;</span><br><span class="line">        <span class="type">int</span> action;</span><br><span class="line">        <span class="type">char</span> *tty = token[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!token[<span class="number">3</span>]) <span class="comment">/* less than 4 tokens */</span></span><br><span class="line">            <span class="keyword">goto</span> bad_entry;</span><br><span class="line">        action = index_in_strings(actions, token[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (action &lt; <span class="number">0</span> || !token[<span class="number">3</span>][<span class="number">0</span>]) <span class="comment">/* token[3]: command */</span></span><br><span class="line">            <span class="keyword">goto</span> bad_entry;</span><br><span class="line">        <span class="comment">/* turn .*TTY -&gt; /dev/TTY */</span></span><br><span class="line">        <span class="keyword">if</span> (tty[<span class="number">0</span>]) &#123;</span><br><span class="line">            tty = concat_path_file(<span class="string">&quot;/dev/&quot;</span>, skip_dev_pfx(tty));</span><br><span class="line">        &#125;</span><br><span class="line">        new_init_action(<span class="number">1</span> &lt;&lt; action, token[<span class="number">3</span>], tty);</span><br><span class="line">        <span class="keyword">if</span> (tty[<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">free</span>(tty);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"> bad_entry:</span><br><span class="line">        message(L_LOG | L_CONSOLE, <span class="string">&quot;Bad inittab entry at line %d&quot;</span>,</span><br><span class="line">                parser-&gt;lineno);</span><br><span class="line">    &#125;</span><br><span class="line">    config_close(parser);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先分析/etc/inittab文件，如果不存在inittab文件，则执行默认的action；如果inittab文件存在，则解析/etc/inittab文件的内容，actions[]数组的内容对应着inittab文件中的条目。</p>
<h3 id="inittab文件"><a href="#inittab文件" class="headerlink" title="inittab文件"></a>inittab文件</h3><p>busybox/examples/下面有inittab脚本的例程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/inittab init(8) configuration <span class="keyword">for</span> BusyBox</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Copyright (C) 1999-2004 by Erik Andersen &lt;andersen@codepoet.org&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Note, BusyBox init doesn&#x27;t support runlevels.  The runlevels field is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">completely ignored by BusyBox init. If you want runlevels, use sysvinit.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Format <span class="keyword">for</span> each entry: &lt;<span class="built_in">id</span>&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># &lt;id&gt;: WARNING: This field has a non-traditional meaning for BusyBox init!</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   The id field is used by BusyBox init to specify the controlling tty for</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  the specified process to run on.  The contents of this field are</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  appended to <span class="string">&quot;/dev/&quot;</span> and used as-is.  There is no need <span class="keyword">for</span> this field to</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  be unique, although <span class="keyword">if</span> it isn<span class="string">&#x27;t you may have strange results.  If this</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">  field is left blank, then the init&#x27;</span>s stdin/out will be used.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># &lt;runlevels&gt;: The runlevels field is completely ignored.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># &lt;action&gt;: Valid actions include: sysinit, respawn, askfirst, wait, once,</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                                 restart, ctrlaltdel, and shutdown.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       Note: askfirst acts just like respawn, but before running the specified</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      process it displays the line <span class="string">&quot;Please press Enter to activate this</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      console.&quot;</span> and <span class="keyword">then</span> waits <span class="keyword">for</span> the user to press enter before starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      the specified process.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       Note: unrecognized actions (like initdefault) will cause init to emit</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      an error message, and <span class="keyword">then</span> go along with its business.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># &lt;process&gt;: Specifies the process to be executed and it&#x27;s command line.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Note: BusyBox init works just fine without an inittab. If no inittab is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">found, it has the following default behavior:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">        ::sysinit:/etc/init.d/rcS</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">        ::askfirst:/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">        ::ctrlaltdel:/sbin/reboot</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">        ::shutdown:/sbin/swapoff -a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">        ::shutdown:/bin/umount -a -r</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">        ::restart:/sbin/init</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">        tty2::askfirst:/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">        tty3::askfirst:/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">        tty4::askfirst:/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Boot-time system configuration/initialization script.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is run first except when booting <span class="keyword">in</span> single-user mode.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">::sysinit:/etc/init.d/rcS</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/bin/sh invocations on selected ttys</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Note below that we prefix the shell commands with a &quot;-&quot; to indicate to the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">shell that it is supposed to be a login shell.  Normally this is handled by</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">login, but since we are bypassing login <span class="keyword">in</span> this <span class="keyword">case</span>, BusyBox lets you <span class="keyword">do</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">this yourself...</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Start an &quot;askfirst&quot; shell on the console (whatever that may be)</span></span></span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Start an <span class="string">&quot;askfirst&quot;</span> shell on /dev/tty2-4</span></span><br><span class="line">tty2::askfirst:-/bin/sh</span><br><span class="line">tty3::askfirst:-/bin/sh</span><br><span class="line">tty4::askfirst:-/bin/sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/sbin/getty invocations <span class="keyword">for</span> selected ttys</span></span><br><span class="line">tty4::respawn:/sbin/getty 38400 tty5</span><br><span class="line">tty5::respawn:/sbin/getty 38400 tty6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example of how to put a getty on a serial line (<span class="keyword">for</span> a terminal)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">::respawn:/sbin/getty -L ttyS0 9600 vt100</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">::respawn:/sbin/getty -L ttyS1 9600 vt100</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Example how to put a getty on a modem line.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">::respawn:/sbin/getty 57600 ttyS2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Stuff to <span class="keyword">do</span> when restarting the init process</span></span><br><span class="line">::restart:/sbin/init</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Stuff to <span class="keyword">do</span> before rebooting</span></span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br></pre></td></tr></table></figure>

<p>首先会去执行/etc/init.d/rcS脚本，然后启动shell到console口，开启getty，指定init进程的重启位置，处理重启之前要做的事情。</p>
<h3 id="rcS脚本"><a href="#rcS脚本" class="headerlink" title="rcS脚本"></a>rcS脚本</h3>]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux sys conf function</title>
    <url>/2022/06/07/linux/sysconf/</url>
    <content><![CDATA[<h2 id="passwd文件"><a href="#passwd文件" class="headerlink" title="passwd文件"></a>passwd文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *pw_name;        <span class="comment">/* Username*/</span></span><br><span class="line">  <span class="type">char</span> *pw_passwd;      <span class="comment">/* Hashed passphrase, if shadow database</span></span><br><span class="line"><span class="comment">                                   not in use (see shadow.h).  */</span></span><br><span class="line">  <span class="type">__uid_t</span> pw_uid;       <span class="comment">/* User ID.  */</span></span><br><span class="line">  <span class="type">__gid_t</span> pw_gid;       <span class="comment">/* Group ID.  */</span></span><br><span class="line">  <span class="type">char</span> *pw_gecos;       <span class="comment">/* Real name.  */</span></span><br><span class="line">  <span class="type">char</span> *pw_dir;         <span class="comment">/* Home directory.  */</span></span><br><span class="line">  <span class="type">char</span> *pw_shell;       <span class="comment">/* Shell program.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>口令文件在/etc/passwd，格式为：用户名:加密口令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpwnam_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> passwd *pwd, <span class="type">char</span> *buf, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> buflen, <span class="keyword">struct</span> passwd **result)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpwuid_r</span><span class="params">(<span class="type">uid_t</span> uid, <span class="keyword">struct</span> passwd *pwd, <span class="type">char</span> *buf, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> buflen, <span class="keyword">struct</span> passwd **result)</span>;</span><br></pre></td></tr></table></figure>

<p>根据用户名或UID来获取口令信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>getpwent可以查看整个口令文件，它返回一个passwd指针，并找到下一个记录，若出错或到达文件尾端则为返回NULL。setpwent定位到文件开始处，endpwent则关闭这些文件。</p>
<h2 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *gr_name;      <span class="comment">/* Group name.  */</span></span><br><span class="line">    <span class="type">char</span> *gr_passwd;        <span class="comment">/* Password.    */</span></span><br><span class="line">    <span class="type">__gid_t</span> gr_gid;     <span class="comment">/* Group ID.    */</span></span><br><span class="line">    <span class="type">char</span> **gr_mem;      <span class="comment">/* Member list. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getgrnam_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> group *grp,</span></span><br><span class="line"><span class="params">         <span class="type">char</span> *buf, <span class="type">size_t</span> buflen, <span class="keyword">struct</span> group **result)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getgrgid_r</span><span class="params">(<span class="type">gid_t</span> gid, <span class="keyword">struct</span> group *grp,</span></span><br><span class="line"><span class="params">         <span class="type">char</span> *buf, <span class="type">size_t</span> buflen, <span class="keyword">struct</span> group **result)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setgrent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endgrent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/sysctl/get_sys_data.png" alt="get_sys_data"></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>对环境变量进行操作，影响的是当前进程及其后生成的子进程的环境，不会影响父进程的环境</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<p>getenv从环境中取一个环境变量的值，返回一个指向name关联的value字符串指针。</p>
<p>putenv取形式为name=value的字符串，将其放到环境变量中。如果name已经存在，则先删除其原来的定义。</p>
<p>setenv将name设置为value。如果name已存在，那么若overwrite非0，则首先删除其现存的定义;若overwrite为0，则不设置也不出错。</p>
<p>unsetenv删除name的定义，即使不存在也不出错。</p>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;  <span class="comment">/* The current (soft) limit.  */</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_max;  <span class="comment">/* The hard limit.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br></pre></td></tr></table></figure>

<p>更改资源限制时,须遵循下列三条规则:</p>
<ul>
<li>任何一个进程都可将一个软限制更改为小于或等于硬限制。</li>
<li>任何一个进程都可降低硬限制值，但它必须大于或等于软限制值。这种降低对普通用户而言不可逆反。</li>
<li>只有超级用户可以提高硬限制。</li>
</ul>
<p>一个无限量的限制由常数RLIM_INFINITY指定。resource参数取下列值之一:</p>
<ul>
<li>RLIMIT_CORE   core文件的最大字节数，若其值为0则阻止创建core文件。</li>
<li>RLIMIT_CPU    CPU时间的最大量值(秒)，当超过此软限制时，向该进程发送SIGXCPU信号。</li>
<li>RLIMIT_DATA   数据段的最大字节长度。这是初始化数据、非初始化数据以及堆的总和。</li>
<li>RLIMIT_FSIZE  可以创建的文件的最大字节长度。超过时，向该进程发送SIGXFSZ信号。</li>
<li>RLIMIT_MEMLOCK    锁定在存储器地址空间。</li>
<li>RLIMIT_NOFILE 每个进程能打开的最多文件数。</li>
<li>RLIMIT_NPROC  每个实际用户ID所拥有的最大子进程数。</li>
<li>RLIMIT_OFILE  与SVR4的RLIMIT_NOFILE相同。</li>
<li>RLIMIT_RSS    最大驻内存集字节长度(RSS)。如果物理存储器不够，内核将从进程处取回超过的部分。</li>
<li>RLIMIT_STACK  栈的最大字节长度。</li>
<li>RLIMIT_VMEM   可映照地址空间的最大字节长度。</li>
</ul>
<h2 id="sysconf"><a href="#sysconf" class="headerlink" title="sysconf"></a>sysconf</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">sysconf</span><span class="params">(<span class="type">int</span> name)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">pathconf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> name)</span>;</span><br></pre></td></tr></table></figure>

<p>以_SC_开始的常数用作为sysconf的参数，而以_PC_开始的常数则作为pathconf或fpathconf的参数。</p>
<p>对于pathconf的参数pathname,fpathconf的参数filedes有很多限制:</p>
<ol>
<li>_PC_MAX_CANON,_PC_MAX_INPUT以及_PC_VDISABLE所涉及的文件必须是终端文件。</li>
<li>_PC_LINK_MAX所涉及的文件可以是文件或目录。如果是目录，则返回值用于目录本身。</li>
<li>_PC_NAME_MAX和_PC_NO_TRUNC所涉及的文件必须是目录，返回值用于该目录中的文件名。</li>
<li>_PC_PATH_MAX涉及的必须是目录。当所指定的目录是工作目录时，返回值是相对路径名的最大长度。</li>
<li>_PC_PIPE_BUF所涉及的文件必须是管道、FIFO或目录。在管道或FIFO情况下，返回值是对所涉及的管道或FIFO的限制值。对于目录返回值是对在该目录中创建的任一FIFO的限制值。</li>
<li>_PC_CHOWN_RESTRICTED必须是文件或目录。如果是目录则返回指明此选择项是否适用于该目录中的文件。</li>
<li>对于_SC_JOB_CONTROL、SC_SAVED_IDS、PC_CHOWN_RESTRICTED、PC_VDISABLE和_PC_NO_TRUNC的返回值若为-1(不改变errno),则表示不支持此功能。</li>
</ol>
<p><img src="/images/linux/sysctl/sysconf_name.png" alt="sysconf_name"></p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
  </entry>
  <entry>
    <title>update-alternatives</title>
    <url>/2022/06/07/linux/update-alternatives/</url>
    <content><![CDATA[<p>查看系统已装的gcc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ll /usr/bin/gcc*</span><br></pre></td></tr></table></figure>

<p>查看当前gcc版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p>安装gcc8</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gcc-8 g++-8 gcc-8-multilib g++-8-multilib</span><br></pre></td></tr></table></figure>

<p>设置优先级</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 30</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 40</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 50</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 30</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-6 40</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ gc++/usr/bin/g++-5 50</span><br><span class="line"></span><br><span class="line">--slave后面加入g++，当切换gcc版本时也同时切换g++</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 70 --slave /usr/bin/g++ g++ /usr/bin/g++-7</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">有 3 个候选项可用于替换 gcc (提供 /usr/bin/gcc)。</span><br><span class="line"></span><br><span class="line">  选择       路径          优先级  状态</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0            /usr/bin/gcc-5   50        自动模式</span><br><span class="line">  1            /usr/bin/gcc-5   50        手动模式</span><br><span class="line">  2            /usr/bin/gcc-6   40        手动模式</span><br><span class="line">  3            /usr/bin/gcc-7   30        手动模式</span><br><span class="line"></span><br><span class="line">要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --remove gcc /usr/bin/gcc-5</span><br></pre></td></tr></table></figure>

<p>当然也可以使用设置别名的方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias gcc=&#x27;/usr/bin/gcc-5&#x27;</span><br><span class="line">alias g++=&#x27;/usr/bin/g++-5&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>image</title>
    <url>/2022/06/07/media/image/</url>
    <content><![CDATA[<h2 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h2><h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p>在RGB 颜色空间上，当任何一个基色的亮度值为零时，即在原点处，就显示为黑色。当三种基色都达到最高亮度时，就表现为白色。在连接黑色与白色的对角线上，是亮度等量的三基色混合而成的灰色，该线称为灰色线。<a href="http://www.fourcc.org/rgb.php">详细</a></p>
<ul>
<li>RGB565格式每一个像素用16个bit来表示。 R, G, B分别用5， 6， 5个bit来表示。</li>
<li>RGB55格式每一个像素用16个bit，但是最高位不用，R, G, B分别用5个bit来表示。</li>
<li>RGB24每一个像素用24个bit来表示，R, G， B分量分别用8个bit来表示。</li>
<li>RGB32每一个像素用32个bit表示，R, G, B分量分别用8个bit表示，存储顺序为B, G, R，最后8个字节保留。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">R = Y + <span class="number">1.402</span> (Cr<span class="number">-128</span>)</span><br><span class="line">G = Y * <span class="number">0.34414</span> (Cb<span class="number">-128</span>) * <span class="number">0.71414</span> (Cr<span class="number">-128</span>)</span><br><span class="line">B = Y + <span class="number">1.772</span> (Cb<span class="number">-128</span>)</span><br></pre></td></tr></table></figure>

<h3 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h3><p>YUV是一种颜色编码方法，主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，YUV是数据总尺寸小于RGB格式（但用YUV444的话，和RGB888一样都是24bits），所以用YUV方式传送占用极少的频宽。</p>
<p>YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p>
<p><img src="/images/media/image/yuv.jpg" alt="彩色，Y分量，V分量，U分量"></p>
<p>YUV细分的话有Y’UV，YUV，YCbCr，YPbPr等类型，其中YCbCr主要用于数字信号。Y’CbCr也称为YUV，是YUV的压缩版本，不同之处在于Y’CbCr用于数字图像领域，YUV用于模拟信号领域，MPEG、DVD、摄像机中常说的YUV其实就是Y’CbCr。</p>
<p>其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异，而Cb反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异，此即所谓的色差信号。<a href="http://www.fourcc.org/yuv.php">详细</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Y = <span class="number">0.30</span>R + <span class="number">0.59</span>G + <span class="number">0.11B</span></span><br><span class="line">U = <span class="number">0.493</span>(B-Y) = <span class="number">-0.15</span>R - <span class="number">0.29</span>G + <span class="number">0.44B</span></span><br><span class="line">V = <span class="number">0.877</span>(R-Y) = <span class="number">0.62</span>R - <span class="number">0.52</span>G - <span class="number">0.10B</span></span><br></pre></td></tr></table></figure>

<h4 id="采样方式"><a href="#采样方式" class="headerlink" title="采样方式"></a>采样方式</h4><p>YUV的采样有许多种，常用的有444，422，420，411等。用三个图来直观地表示采集的方式，以黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量。<br><img src="/images/media/image/yuv_sample.webp" alt="YUV常用采样"></p>
<ul>
<li>4:4:4采样，每一个Y对应一组UV分量，24 Bits per Pixel</li>
<li>4:2:2采样，每两个Y共用一组UV分量，16 Bits per Pixel</li>
<li>4:2:0采样，每四个Y共用一组UV分量，12 Bits per Pixel</li>
</ul>
<h4 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h4><p>对于packed的YUV格式，每个像素点的Y,U,V是连续交错存储的。</p>
<ul>
<li><p>UYVY422<br><img src="/images/media/image/UYVY422.webp" alt="img"></p>
</li>
<li><p>YUV420<br><img src="/images/media/image/YUV420.webp" alt="img"></p>
</li>
</ul>
<p>对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。</p>
<ul>
<li><p>YUV422P<br><img src="/images/media/image/YUV422P.webp" alt="img"></p>
</li>
<li><p>YUV420P<br><img src="/images/media/image/YUV420P.webp" alt="img"></p>
</li>
</ul>
<p>对于SemiPlanar，则是先连续存储所有像素点的Y，再连续交错U和V。</p>
<ul>
<li><p>YUV422SP<br><img src="/images/media/image/YUV422SP.webp" alt="img"></p>
</li>
<li><p>YUV420SP<br><img src="/images/media/image/YUV420SP.webp" alt="img"></p>
</li>
</ul>
<h3 id="OSD字模"><a href="#OSD字模" class="headerlink" title="OSD字模"></a>OSD字模</h3><ul>
<li>单色字模，1个像素对应1bit，1个8×8的字模对应的是8个字节的数据。</li>
<li>4色字模，1个像素对应2bit，1个8×8的字模对应的是8x2个字节的数据。</li>
<li>16色字模，1个像素对应4bit，1个8×8的字模对应的是8x4个字节的数据。</li>
</ul>
<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><p>在图像处理中，常见的颜色模型包括HSB（色相、饱和度、亮度）、RGB（红色、绿色、蓝色）、CMYK（青色、品红、黄色、黑色）和CIE L<em>a</em>b*等，因此，相应的颜色模式也就有RGB、CMYK、Lab等。在HSB颜色模型中，色相、饱和度、亮度是对图像属性的基本描述。</p>
<p><strong>图象亮度</strong>（brightness）是指画面的明亮程度，单位是堪德拉每平米(cd/m2)或称nits。</p>
<p><strong>对比度</strong>（contrast）指的是图像暗和亮的落差值，即图像最大灰度级和最小灰度级之间的差值。</p>
<p><strong>饱和度</strong>（saturation）指的是图像颜色种类的多少， 上面提到图像的灰度级是[L<del>min</del>，L<del>max</del>]，则在L<del>min</del>、L<del>max</del> 的中间值越多，便代表图像的颜色种类多，饱和度也就更高，外观上看起来图像会更鲜艳，调整饱和度可以修正过度曝光或者未充分曝光的图片，使图像看上去更加自然。</p>
<p><strong>色相</strong>（hue）是从物体反射或透过物体传播的颜色。在0°到360°的标准色轮上，按位置度量色相。</p>
<p><strong>锐度</strong>（sharpness）是图像清晰度和图像边缘锐利程度。图像锐化是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰。在做图像平滑，图像滤波处理的时候经过会把丢失图像的边缘信息，通过图像锐化便能够增强突出图像的边缘轮廓。</p>
<p><strong>灰度</strong>是图像上每个像素的颜色值，指黑白图像中点的颜色深度，范围一般从0到255，白色为255，黑色为0。</p>
<ul>
<li><p>最大值法：将彩色图像中的三分量亮度的最大值作为灰度图的灰度值，这种方法转换的灰度图亮度很高。</p>
</li>
<li><p>平均值法：将彩色图像中的三分量亮度求平均得到一个灰度值，这种方法产生的灰度图像比较柔和。</p>
</li>
<li><p>加权平均值法：以不同的权值对R，G，B的值加权平均，由于人眼对绿色最为敏感，对蓝色的敏感性最低，因此得到的灰度图像效果最好。$gray = 0.299<em>R + 0.578</em>G + 0.114*B$。</p>
</li>
</ul>
<p><strong>灰阶</strong>（gray scale）在YUV空间，将UV分量丢弃，只保留Y分量，得到的黑白图像。</p>
<p><strong>复古</strong>（绿，蓝）（sepia / sepiagreen / sepiablue）就是在灰阶的基础上，对UV值额外再做了一个offset，将灰度图转换成某种颜色的梯度图。为了获得蓝色效果，应该增加蓝色差信号，减小红色差信号，即增大U，减小V。</p>
<p><strong>负片</strong>（Negative Film）就是将图像的颜色反转，看起来就像是在看胶片底片时的效果。在RGB空间，取其补色，就是用255分别减去RGB得到新的RGB值。<br><img src="/images/media/image/complementary.jpg" alt="img"></p>
]]></content>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>audio</title>
    <url>/2022/06/07/media/audio/</url>
    <content><![CDATA[<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="声音"><a href="#声音" class="headerlink" title="声音"></a>声音</h3><p>声音三要素：音调、响度、音色。<br>-　音调：声音的高低，由频率决定，频率越高音调越高。<br>-　响度：又称音量、音强，由振幅和距离声源的距离决定。<br>-　音色：又称音品，由发声物体本身材料、结构决定。</p>
<p>分贝用于度量声音强度，单位是dB。</p>
<p><img src="/images/media/audio/dB.png" alt="分贝"></p>
<h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>采样率（sample rate）表示单位时间内对声音信号的采样次数，单位Hz。在当今的主流采集卡上，采样频率一般共分为 22.05KHz、44.1KHz、48KHz三个等级，对于高于48KHz的采样频率人耳已无法辨别出来了。</p>
<p><img src="/images/media/audio/sample_rate.png" alt="采样率"></p>
<h3 id="位深度"><a href="#位深度" class="headerlink" title="位深度"></a>位深度</h3><p>位深度也叫采样位数就是采样值用多少位0和1来表示，也叫采样精度，代表取样中对声音强度记录的精细程度。音频的位深度决定动态范围。采样声波时，为每个采样指定最接近原始声波振幅的振幅值。较高的位深度可提供更多可能的振幅值，产生更大的动态范围、更低的噪声基准和更高的保真度。</p>
<p><img src="/images/media/audio/bit_deep.png" alt="位深"></p>
<h3 id="声道"><a href="#声道" class="headerlink" title="声道"></a>声道</h3><p>声道（channel）分为单声道mono；立体声stereo；还可以是多声道，叫环绕立体声。如果是单声道的文件，采样数据按时间的先后顺序依次存入。如果是双声道的文件，采样数据按时间先后顺序交叉的存入。</p>
<p><img src="/images/media/audio/pcm.png" alt="PCM格式"></p>
<h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><p>比特率（bitrate）也叫码率，表示压缩编码后每秒的音频数据量大小。比特率 = 采样率 x 采样精度 x 声道数（单位kbps，这里的k为1000）</p>
<h3 id="音频帧"><a href="#音频帧" class="headerlink" title="音频帧"></a>音频帧</h3><p>音频数据是流式的，本身没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的。</p>
<h3 id="码率模式"><a href="#码率模式" class="headerlink" title="码率模式"></a>码率模式</h3><p>VBR（VariableBitrate）动态比特率。也就是没有固定的比特率，压缩软件在压缩时根据音频数据即时确定使用什么比特率。这是新发展的算法，他们将一首歌的复杂部分用高Bitrate编码，简单部分用低Bitrate编码。主意虽然不错，可惜新编码器的VBR算法很差，音质与CBR相去甚远。幸运的是， Lame完美地优化了VBR算法，使之成为MP3的最佳编码模式。这是以质量为前提兼顾文件大小的方式时推荐的编码模式。</p>
<p>ABR（Average Bitrate）平均比特率，是VBR的一种插值参数。Lame针对CBR不佳的文件体积比和VBR生成文件大小不定的特点独创了这种编码模式。ABR也被称为“Safe VBR”，它是在指定的平均Bitrate内，以每50帧（30帧约1秒）为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量。举例来说，当指定用192kbps ABR对一段wav文件进行编码时，Lame会将该文件的85%用192kbps固定编码，然后对剩余15%进行动态优化：复杂部分用高于192kbps 来编码、简单部分用低于192kbps来编码。与192kbps CBR相比，192kbps ABR在文件大小上相差不多，音质却提高不少。ABR编码在速度上是VBR编码的2到3倍，在128-256kbps范围内质量要好于CBR。可以做为 VBR和CBR的一种折衷选择。</p>
<p>CBR（ConstantBitrate），常数比特率，指文件从头到尾都是一种位速率。相对于VBR和ABR来讲，它压缩出来的文件体积很大，但音质却不会有明显的提高。</p>
<h2 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h2><p>根据编码方式的不同，音频编码技术分为三种：波形编码、参数编码和混合编码。波形编码的话音质量高，但编码速率也很高；参数编码的编码速率很低，产生的合成语音的音质不高；混合编码使用参数编码技术和波形编码技术，编码速率和音质介于它们之间。</p>
<p> PCM 即脉冲编码调制(Pulse Code Modulation)。 在PCM 过程中，将输入的模拟信号进行采样、量化和编码，用二进制进行编码的数来代表模拟信号的幅度；接收端再将这些编码还原为原来的模拟信号。</p>
<h3 id="音频数据格式"><a href="#音频数据格式" class="headerlink" title="音频数据格式"></a>音频数据格式</h3><p>PCM数据是最原始的音频数据完全无损，所以PCM数据虽然音质优秀但体积庞大，为了解决这个问题先后诞生了一系列的音频格式，这些音频格式运用不同的方法对音频数据进行压缩，其中有无损压缩（WAV，PCM，ALS，TAK，WavPack　ALAC、APE、FLAC）和有损压缩（MP3、AAC、OGG、WMA）两种。</p>
<h4 id="WAV"><a href="#WAV" class="headerlink" title="WAV"></a>WAV</h4><p>WAV是WaveFom的简写，也称为波形文件，可直接存储声音波形。WAV格式支持MSADPCM、CCITT A律、CCITT μ律和其他压缩算法，支持多种音频位数、采样频率和声道；但其文件尺寸较大，多用于存储简短的声音片段</p>
<h4 id="MIDI"><a href="#MIDI" class="headerlink" title="MIDI"></a>MIDI</h4><p>MIDI是Musical InstrumentDigital Interface的缩写，又称作乐器数字接口，是数字音乐/电子合成乐器的统一国际标准。它定义了计算机音乐程序、数字合成器及其它电子设备交换音乐信号的方式，规定了不同厂家的电子乐器与计算机连接的电缆和硬件及设备间数据传输的协议，可以模拟多种乐器的声音。MIDI文件就是MIDI格式的文件，在MIDI文件中存储的是一些指令。把这些指令发送给声卡，由声卡按照指令将声音合成出来。</p>
<h4 id="WMA"><a href="#WMA" class="headerlink" title="WMA"></a>WMA</h4><p>Windows Media Audio是微软公司开发的一种声音文件格式，也叫波形声音文件，压缩率低。 所需频宽 320～112kbps（压缩10～12倍），当Bitrate小于128K时，WMA最为出色且编码后得到的音频文件很小 ，当Bitrate大于128K时，WMA音质损失过大。WMA标准不开放。</p>
<h4 id="MP1"><a href="#MP1" class="headerlink" title="MP1"></a>MP1</h4><p>MPEG-1 audio layer 1声音压缩编码是国际上第一个高保真声音数据压缩的国际标准，编码简单，用于数字盒式录音磁带，2声道，VCD中使用的音频压缩方案就是MPEG-1层Ⅰ。所需频宽：384kbps（压缩4倍）。压缩方式相对时域压缩技术而言要复杂得多，同时编码效率、声音质量也大幅提高，编码延时相应增加。可以达到“完全透明”的声音质量（EBU音质标准）。</p>
<h4 id="MUSICAM"><a href="#MUSICAM" class="headerlink" title="MUSICAM"></a>MUSICAM</h4><p>MPEG-1 audio layer 2（MP2），所需频宽：256～192kbps（压缩6～8倍），算法复杂度中等，用于数字音频广播(DAB)和VCD等，2声道，而MUSICAM由于其适当的复杂程度和优秀的声音质量，在数字演播室、DAB、DVB等数字节目的制作、交换、存储、传送中得到广泛应用。</p>
<h4 id="MP3"><a href="#MP3" class="headerlink" title="MP3"></a>MP3</h4><p>MP3全称是动态影像专家压缩标准音频层面3（Moving Picture Experts Group Audio Layer III）。是一种有损压缩的音频格式，设计这种格式的目的就是为了大幅度的减小音频的数据量，它舍弃PCM音频数据中人类听觉不敏感的部分。所需频宽：128～112kbps（压缩10～12倍），编码复杂，用于互联网上的高质量声音的传输，如MP3音乐压缩10倍，2声道。MP3是在综合MUSICAM和ASPEC的优点的基础上提出的混合压缩技术，在当时的技术条件下，MP3的复杂度显得相对较高，编码不利于实时，但由于MP3在低码率条件下高水准的声音质量，使得它成为软解压及网络广播的宠儿。优点：压缩比高，适合用于互联网上的传播，缺点：MP3在128KBitrate及以下时，会出现明显的高频丢失。</p>
<p>所谓的MP3也就是指的是MPEG标准中的音频部分，也就是MPEG音频层。根据压缩质量和编码处理的不同分为3层，分别对应mp1/mp2/mp3这3种声音文件。需要提醒大家注意的地方是：MPEG音频文件的压缩是一种有损压缩，MPEG3音频编码具有10：1~12：1的高压缩率，同时基本保持低音频部分不失真，但是牺牲了声音文件中12KHz到16KHz高音频这部分的质量来换取文件的尺寸，相同长度的音乐文件，用*.mp3格式来储存，一般只有*.wav文件的1/10，而音质要次于CD格式或WAV格式的声音文件。由于其文件尺寸小，音质好;所以在它问世之初还没有什么别的音频格式可以与之匹敌，因而为*.mp3格式的发展提供了良好的条件。</p>
<p>MP3格式中的数据通常由两部分组成，一部分为ID3用来存储歌名、演唱者、专辑、音轨数等信息，另一部分为音频数据。音频数据部分以帧(frame)为单位存储，每个音频都有自己的帧头，如图所示就是一个MP3文件帧结构图（图片同样来自互联网）。MP3中的每一个帧都有自己的帧头，其中存储了采样率等解码必须的信息，所以每一个帧都可以独立于文件存在和播放，这个特性加上高压缩比使得MP3文件成为了音频流播放的主流格式。帧头之后存储着音频数据，这些音频数据是若干个PCM数据帧经过压缩算法压缩得到的，对CBR的MP3数据来说每个帧中包含的PCM数据帧是固定的，而VBR是可变的。</p>
<p><img src="/images/media/audio/mp3_format.webp" alt="mp3文件格式"></p>
<h4 id="AAC"><a href="#AAC" class="headerlink" title="AAC"></a>AAC</h4><p>AAC实际上是高级音频编码(Advanced Audio Coding–AAC)的缩写。AAC是由Fraunhofer IIS-A、杜比和AT&amp;T共同开发的一种音频格式，它是MPEG-2规范的一部分。成为继MPEG-2音频标准（ISO/IEC13818-3）之后的新一代音频压缩标准。制定者：MPEG，所需频宽：96-128 kbps。</p>
<p>AAC所采用的运算法则与MP3的运算法则有所不同，AAC通过结合其他的功能来提高编码效率。AAC的音频算法在压缩能力上远远超过了以前的一些压缩算法。它还同时支持多达48个音轨、15个低频音轨、更多种采样率和比特率、多种语言的兼容能力、更高的解码效率。总之，AAC可以在比MP3文件缩小30%的前提下提供更好的音质。</p>
<p>AAC支持多声道，可提供1到48路之间任意数目的音频声道组合、包括15路低频效果声道、配音/多语音声道，以及15路数据。它可同时传送16套节目，每套节目的音频及数据结构可任意规定。最高支持96KHz的采样频率。</p>
<p>AAC主要可能的应用范围集中在因特网网络传播、数字音频广播，包括卫星直播和数字AM、以及数字电视及影院系统等方面。AAC使用了一种非常灵活的熵编码核心去传输编码频谱数据。具有48个主要音频通道，16 个低频增强通道，16 个集成数据流, 16 个配音，16 种编排。</p>
<h4 id="GSM-AMR"><a href="#GSM-AMR" class="headerlink" title="GSM-AMR"></a>GSM-AMR</h4><p>GSM-ASM(Adaptive Multi-Rate)是一种广泛使用在GPRS和W-CDMA网络上的音频标准。在规范ETSI GSM06.90中对GSM-AMR进行了定义。AMR语音编码是GSM 2+和WCDMA的默认编码标准，是第三代无线通讯系统的语音编码标准。GSM-AMR标准基于ACELP（代数激励线性预测）编码。它能在广泛的传输条件下提供高品质的语音效果。制定者：飞利浦，所需频宽：8Kbps(4.75 Kbps~12.2 Kbps)，可以对语音进行替换和消音，平滑噪音，支持间断式传输，对语音进行动态侦查。能在各种网络条件下提供优质的语音效果。</p>
<h4 id="EVRC"><a href="#EVRC" class="headerlink" title="EVRC"></a>EVRC</h4><p>Enhanced Variable Rate Coder，增强型可变速率编码器广泛使用于CDMA网络。EVRC标准遵循规范TIA IS-127的内容。EVRC编码基于RCELP（松弛码激励线性预测）标准。该编码可以以Rate 1（171bits/packet），Rate 1/2（80bits/packet）或是Rate 1/8（16bits/packet）的容量进行操作。在要求下，它也能产生空包（0bits/packet）。制定者：Qualcomm，所需频宽：8Kbps或13Kbps，支持三种码率（9.6 Kbps, 4.8 Kbps 和 1.2 Kbps），噪声抑制，邮件过滤。能在各种网络条件下提供优质的语音效果。</p>
<h4 id="ADPCM"><a href="#ADPCM" class="headerlink" title="ADPCM"></a>ADPCM</h4><p>ADPCM(adaptive difference pulse code modulation，　自适应差分PCM)综合了APCM的自适应特性和DPCM系统的差分特性，是一种性能比较好的波形编码。它的核心想法是利用自适应的思想改变量化阶的大小，即使用小的量化阶(step-size)去编码小的差值，使用大的量化阶去编码大的差值；使用过去的样本值估算下一个输入样本的预测值，使实际样本值和预测值之间的差值总是最小。针对 16bit (或者更高) 声音波形数据的一种有损压缩算法, 它将声音流中每次采样的 16bit 数据以 4bit 存储, 所以压缩比 1:4. 而压缩/解压缩算法非常的简单, 所以是一种低空间消耗,高质量声音获得的好途径。制定者：ITU-T，所需频宽：32Kbps，优点：算法复杂度低，压缩比小（CD音质&gt;400kbps），编解码延时最短。，缺点：声音质量一般</p>
<h4 id="MP3Pro"><a href="#MP3Pro" class="headerlink" title="MP3Pro"></a>MP3Pro</h4><p>MP3Pro是由瑞典Coding科技公司开发的，其中包含了两大技术：一是来自于Coding科技公司所特有的解码技术，二是由MP3的专利持有者法国汤姆森多媒体公司和德国Fraunhofer集成电路协会共同研究的一项译码技术。MP3Pro可以在基本不改变文件大小的情况下改善原先的MP3音乐音质。它能够在用较低的比特率压缩音频文件的情况下，最大程度地保持压缩前的音质。</p>
<h4 id="RealAudio"><a href="#RealAudio" class="headerlink" title="RealAudio"></a>RealAudio</h4><p>RealAudio是由Real Networks公司推出的一种文件格式，最大的特点就是可以实时传输音频信息，尤其是在网速较慢的情况下，仍然可以较为流畅地传送数据，因此RealAudio主要适用于网络上的在线播放。现在的RealAudio文件格式主要有RA(RealAudio)、RM（RealMedia，RealAudio G2）、RMX(RealAudio Secured)等三种，这些文件的共同性在于随着网络带宽的不同而改变声音的质量，在保证大多数人听到流畅声音的前提下，令带宽较宽敞的听众获得较好的音质。</p>
<p>RA采用的是有损压缩技术，由于它的压缩比相当高，因此音质相对较差，但是文件也是最小的，因此在高压缩比条件下表现好，但若在中、低压缩比条件下时，表现却反而不及其他同类型档案格式了。此外RA可以随网络带宽的不同而改变声音质量，以使用户在得到流畅声音的前提下，尽可能高地提高声音质量。由于RA格式的这些特点，因此特别适合在网络传输速度较低的互联网上使用，互联网上许多的网络电台、音乐网站的歌曲试听都在使用这种音频格式。</p>
<h4 id="Ogg-Vorbis"><a href="#Ogg-Vorbis" class="headerlink" title="Ogg Vorbis"></a>Ogg Vorbis</h4><p>Ogg Vorbis 是一种新的音频压缩格式，类似于MP3等现有的音乐格式。但有一点不同的是，它是完全免费、开放和没有专利限制的。Vorbis 是这种音频压缩机制的名字，而Ogg则是一个计划的名字，该计划意图设计一个完全开放性的多媒体系统。VORBIS也是有损压缩，但通过使用更加先进的声学模型去减少损失，因此，同样位速率(Bit Rate)编码的OGG与MP3相比听起来更好一些。</p>
<h4 id="APE"><a href="#APE" class="headerlink" title="APE"></a>APE</h4><p>APE是Monkey’s Audio提供的一种无损压缩格式,是一种无损压缩音频格式,在音质不降低的前提下，大小压缩到传统无损格式 WAV 文件的一半,而且可以无须解压而直接播放。APE的采样率最高可达1400kbps，接近于音乐CD格式。</p>
<h4 id="FLAC"><a href="#FLAC" class="headerlink" title="FLAC"></a>FLAC</h4><p>FLAC即是Free Lossless AudioCodec的缩写，是一套著名的自由音频无损压缩编码，其特点是无损压缩。</p>
<h2 id="音频处理"><a href="#音频处理" class="headerlink" title="音频处理"></a>音频处理</h2><p>音频处理是指对PCM数据进行处理，从而达到想要的效果。对音频编码前的PCM数据进行处理叫音频前处理，主要用于语音中，来去除各种干扰，使声音更清晰，主要有回声消除、噪声抑制、增益控制等。对音频解码后的PCM数据进行处理叫音频后处理，主要用于音乐中，来产生各种音效，使音乐更动听，主要有均衡器、混响等。</p>
<h3 id="重采样"><a href="#重采样" class="headerlink" title="重采样"></a>重采样</h3><p>音频输入和音频输出模块支持对音频数据实施重采样。如果启用 AI 重采样功能，内部将会先执行重采样处理，再返回处理后的数据。如果启用了 AO 重采样功能，则音频数据在发送给 AO 之前，内部先执行重采样处理，处理完成后再发送给 AO 通道进行播放。重采样仅支持处理单声道。</p>
<h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><p>ANR 为语音降噪（ Audio Noise Reduction ）模块，主要工作在需要去除外界噪声，保<br>留语音输入的场景下。与 RNR 算法比起来， ANR 更讲究噪声处理的干净程度。 ANR 会滤除一些环境声音，主要保留语音数据，并会带来一定的细节丢失。所以 ANR 算法更适用于 NVR 和 IPC<br>场景。在这两个场景下，我们更希望能够着重保留人声，滤除其他噪声。</p>
<h3 id="RNR"><a href="#RNR" class="headerlink" title="RNR"></a>RNR</h3><p>RNR 为录音噪声消除（ Record Noise Reduction ）模块，主要工作在需要去除环境噪声，但保留小信号输入的场景下。与 ANR 算法比起来， RNR 更讲究细节输入（小信号）的保留度， RNR 会在降噪的同时保留小信号的输入，所以降噪力度会低一点，但能更多的保留现场声音，真实还原场景，适用于运动 DV 场景。</p>
<h3 id="AEC"><a href="#AEC" class="headerlink" title="AEC"></a>AEC</h3><p>AEC 为回声抵消（ Acoustic Echo Cancellation ）模块，主要工作在需要进行去除回声的<br>场景下：如 IPC 对讲，远端语音数据在 AO 设备上播放，此时在本地通过 MIC 采集语<br>音数据，它支持消除录制的语音数据中的 AO 设备播放的声音（回声）。</p>
<h3 id="AGC"><a href="#AGC" class="headerlink" title="AGC"></a>AGC</h3><p>AGC 为自动增益控制（ Auto Gain Control ）模块，主要负责增益控制输出电平，在声音输入音量有大小变化时，能将输出音量控制在比较一致的范围内，主要工作在需要保证声音不至于过大或过小的场景下。AGC 更多起到的作用是放大输入源的声音，以保证音源过小时，经过算法处理后的声音依然很大。</p>
<h3 id="DRC"><a href="#DRC" class="headerlink" title="DRC"></a>DRC</h3><p>DRC 为动态压缩控制（ Dynamic Range Control ）模块，负责控制输出电平，将输出增益控制在一个范围，主要工作在需要保证声音不至于过大或过小的场景下。DRC 与 AGC 作用相似，但算法实现及调节力度不同。其配合 RNR 使用在运动 DV 场景，与 AEC/ANR 互斥。</p>
<h3 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h3><p>HDR 为高动态范围（ High Dynamic Range ）模块，主要用于 Codec 输入音量控制，通过动态调节 Codec 增益控制 Codec 音量在合理范围内，保证声音不至于过大或过小。</p>
<h3 id="HPF"><a href="#HPF" class="headerlink" title="HPF"></a>HPF</h3><p>HPF 为高通滤波（ high-pass filte ）模块，主要负责去除低频噪声。</p>
<h3 id="PEQ"><a href="#PEQ" class="headerlink" title="PEQ"></a>PEQ</h3><p>PEQ 为参量均衡器（ Parameter Equalizer ）模块，主要对音频数据进行均衡处理，以调节音频数据中各频段声音的增益。PEQ 与 EQ 均为均衡处理器，但是 PEQ 调节方式更灵活，适用于运动 DV 场景。</p>
<h3 id="EQ"><a href="#EQ" class="headerlink" title="EQ"></a>EQ</h3><p>EQ 模块为均衡处理器（ Equalizer ）模块，主要对音频数据进行均衡处理，以调节音频数据中各频段声音的增益。</p>
<p>均衡器的调整方法：</p>
<ul>
<li>超低音： 20Hz-40Hz，适当时声音强而有力。能控制雷声、低音鼓、管风琴和贝司的声音。过度提升会使音乐变得混浊不清</li>
<li>低音： 40Hz-150Hz，是声音的基础部份，其能量占整个音频能量的70%，是表现音乐风格的重要成份。适当时，低音张弛得宜，声音丰满柔和，不足时声音单薄，150Hz，过度提升时会使声音发闷，明亮度下降，鼻音增强</li>
<li>中低音： 150Hz-500Hz，是声音的结构部分，人声位于这个位置，不足时，演唱声会被音乐淹没，声音软而无力，适当提升时会感到浑厚有力，提高声音的力度和响度。提升过度时会使低音变得生硬，300Hz处过度提升3-6dB，如再加上混响，则会严重影响声音的清晰度</li>
<li>中音： 500Hz-2KHz，包含大多数乐器的低次谐波和泛音，是小军鼓和打击乐器的特征音。适当时声音透彻明亮，不足时声音朦胧。过度提升时会产生类似电话的声音</li>
<li>中高音： 2KHz-5KHz，是弦乐的特征音（拉弦乐的弓与弦的摩搡声，弹拔乐的手指触弦的声音某）。不足时声音的穿透力下降，过强时会掩蔽语言音节的识别</li>
<li>高音： 7KHz-8KHz，是影响声音层次感的频率。过度提升会使短笛、长笛声音突出，语言的齿音加重和音色发毛</li>
<li>极高音： 8KHz-10KHz 合适时，三角铁和立*的金属感通透率高，沙钟的节奏清晰可辨。过度提升会使声音不自然，易烧毁高频单元。</li>
</ul>
<h2 id="耳机插头"><a href="#耳机插头" class="headerlink" title="耳机插头"></a>耳机插头</h2><p><img src="/images/media/audio/hp1.png" alt="耳机插头"></p>
<p><img src="/images/media/audio/hp2.png" alt="耳机插头"></p>
]]></content>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>video</title>
    <url>/2022/06/07/media/video/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="码流"><a href="#码流" class="headerlink" title="码流"></a>码流</h3><p>码流是指视频文件在单位时间内使用的数据流量，也叫码率或码流率，通俗一点的理解就是取样率,是视频编码中画面质量控制中最重要的部分，一般我们用的单位是kb/s或者Mb/s。一般来说同样分辨率下，视频文件的码流越大，压缩比就越小，画面质量就越高。码流越大，说明单位时间内取样率越大，数据流，精度就越高，处理出来的文件就越接近原始文件，图像质量越好，画质越清晰，要求播放设备的解码能力也越高。</p>
<h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>采样率（也称为采样速度或者采样频率）定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。采样率是指将模拟信号转换成数字信号时的采样频率，也就是单位时间内采样多少点。</p>
<h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><p>比特率是指每秒传送的bit数。单位为bps(Bit Per Second)，表示经过编码后的音视频数据每秒钟需要用多少个bit来表示。</p>
<h3 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h3><p>码率就是数据传输时单位时间传送的数据位数,一般我们用的单位是kbps即千位每秒。也就是取样率（并不等同与采样率，采样率的单位是Hz，表示每秒采样的次数），单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件。</p>
<p>$码率 = 采样率 x 位深度 x 声道$</p>
<p>$文件大小 = 码率（KBit） / 8  x  时长$  （用bits/s码流计算容量记得要除8）</p>
<h3 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h3><p>帧率fps(Frames Per Second)就是在1秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。每秒显示的图片数影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。由于人类眼睛的特殊生理结构，如果所看画面之帧率高于16的时候，就会认为是连贯的，此现象称之为视觉暂留。并且当帧速达到一定数值后，再增长的话，人眼也不容易察觉到有明显的流畅度提升了。</p>
<p>帧率影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。如果码率为变量，则帧率也会影响体积，帧率越高，每秒钟经过的画面越多，需要的码率也越高，体积也越大。</p>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>分辨率就是帧大小或尺寸，影响图像大小，与图像大小成正比：分辨率越高，图像越大；分辨率越低，图像越小。</p>
<p>标清(standard definition)，是物理分辨率在720p以下的一种视频格式，一般是480p。</p>
<p>高清(high definition)，有720p、1080i与1080p三种标准形式，1080p又叫全高清(超清)。1080p是逐行扫描(Progressive scan)，1080i是隔行扫描(Interlaced scan)。720p格式，分辨率为1280×720p/60Hz，行频为45kHz。</p>
<p>4K分辨率是1080p的4倍 3840×2160 = 1920×2×1080×2，8K分辨率是4K的4倍 7680×4320 = 3840×2×2160×2</p>
<p><img src="/images/media/video/res.png" alt="res"></p>
<table>
<thead>
<tr>
<th align="center">格式</th>
<th>分辨率</th>
<th>PAL</th>
<th>NTSC</th>
<th align="center">码率</th>
<th align="center">视频高宽比</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8K</td>
<td>3310万像素</td>
<td>7680x4320</td>
<td>7680x4320</td>
<td align="center">40-60Mbps</td>
<td align="center">16:9</td>
</tr>
<tr>
<td align="center">5K</td>
<td>1470万像素</td>
<td>5120x2880</td>
<td>5120x2880</td>
<td align="center">25-35Mbps</td>
<td align="center">16:9</td>
</tr>
<tr>
<td align="center">4K</td>
<td>880万像素</td>
<td>4096x2160</td>
<td>4096x2160</td>
<td align="center">20-30Mbps</td>
<td align="center">256:135</td>
</tr>
<tr>
<td align="center">5MP</td>
<td>500万像素</td>
<td>2592x1944</td>
<td>2592x1944</td>
<td align="center">8Mbps</td>
<td align="center">4:3</td>
</tr>
<tr>
<td align="center">2K</td>
<td>310万像素</td>
<td>2048x1080</td>
<td>2048x1080</td>
<td align="center">10-15Mbps</td>
<td align="center">256:135</td>
</tr>
<tr>
<td align="center">3MP</td>
<td>300万像素</td>
<td>2047x1536</td>
<td>2047x1536</td>
<td align="center">6Mbps</td>
<td align="center">4:3</td>
</tr>
<tr>
<td align="center">1080p</td>
<td>130万像素</td>
<td>1920x1080</td>
<td>1920x1080</td>
<td align="center">2Mbps</td>
<td align="center">16:9</td>
</tr>
<tr>
<td align="center">2MP</td>
<td>200万像素</td>
<td>1600x1200</td>
<td>1600x1200</td>
<td align="center">4Mbps</td>
<td align="center">4:3</td>
</tr>
<tr>
<td align="center">1.3MP</td>
<td>130万像素</td>
<td>1280x1024</td>
<td>1280x1024</td>
<td align="center">2Mbps</td>
<td align="center">5:4</td>
</tr>
<tr>
<td align="center">960p</td>
<td>130万像素</td>
<td>1280x960</td>
<td>1280x960</td>
<td align="center">2Mbps</td>
<td align="center">4:3</td>
</tr>
<tr>
<td align="center">720p</td>
<td>100万像素</td>
<td>1280x720</td>
<td>1280x720</td>
<td align="center">2Mbps</td>
<td align="center">16:9</td>
</tr>
<tr>
<td align="center">960H</td>
<td>50万像素</td>
<td>960x480</td>
<td>960x480</td>
<td align="center">1Mbps</td>
<td align="center">2:1</td>
</tr>
<tr>
<td align="center">D1(4CIF)</td>
<td>40万像素</td>
<td>704x576</td>
<td>704x480</td>
<td align="center">&gt;1Mbps</td>
<td align="center">22:15</td>
</tr>
<tr>
<td align="center">VGA</td>
<td>30万像素</td>
<td>640x480</td>
<td>640x480</td>
<td align="center">&gt;1Mbps</td>
<td align="center">4:3</td>
</tr>
<tr>
<td align="center">Half D1</td>
<td>20万像素</td>
<td>352x576</td>
<td>352x480</td>
<td align="center">&gt;1Mbps</td>
<td align="center">11:15</td>
</tr>
<tr>
<td align="center">2CIF</td>
<td>20万像素</td>
<td>704x288</td>
<td>704x240</td>
<td align="center">&gt;0.5Mbps</td>
<td align="center">4:3</td>
</tr>
<tr>
<td align="center">BCIF</td>
<td>20万像素</td>
<td>528x288</td>
<td>528x240</td>
<td align="center">&gt;0.5Mbps</td>
<td align="center">22:9</td>
</tr>
<tr>
<td align="center">QVGA</td>
<td>10万像素</td>
<td>320x240</td>
<td>320x240</td>
<td align="center">&gt;0.5Mbps</td>
<td align="center">4:3</td>
</tr>
<tr>
<td align="center">CIF</td>
<td>10万像素</td>
<td>352x288</td>
<td>352x240</td>
<td align="center">&gt;0.5Mbps</td>
<td align="center">11:9</td>
</tr>
<tr>
<td align="center">QCIF</td>
<td>10万像素</td>
<td>176x144</td>
<td>176x144</td>
<td align="center">&gt;0.5Mbps</td>
<td align="center">11:9</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Idx</th>
<th>Name</th>
<th>W</th>
<th>H</th>
<th>Pxs</th>
<th>gcd</th>
<th>Per</th>
<th>C</th>
<th>P</th>
<th>T</th>
<th>V</th>
<th>Memo</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td></td>
<td>8</td>
<td>8</td>
<td>64</td>
<td>8</td>
<td>p1_1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Macro Block</td>
</tr>
<tr>
<td>1</td>
<td>SQCIF</td>
<td>128</td>
<td>96</td>
<td>12,288</td>
<td>32</td>
<td>p4_3</td>
<td></td>
<td>Y</td>
<td></td>
<td>Y</td>
<td>Sub Quarter CIF</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>128</td>
<td>128</td>
<td>16,384</td>
<td>128</td>
<td>p1_1</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>160</td>
<td>100</td>
<td>16,000</td>
<td>20</td>
<td>p8_5</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>QQVGA</td>
<td>160</td>
<td>120</td>
<td>19,200</td>
<td>40</td>
<td>p4_3</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>Quarter-QVGA</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>160</td>
<td>128</td>
<td>20,480</td>
<td>32</td>
<td>p5_4</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>QCIF</td>
<td>176</td>
<td>144</td>
<td>25,344</td>
<td>16</td>
<td>p11_9</td>
<td></td>
<td>Y</td>
<td></td>
<td>Y</td>
<td>Quarter CIF</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>208</td>
<td>176</td>
<td>36,608</td>
<td>16</td>
<td>p7_5</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>. Nokia</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>220</td>
<td>176</td>
<td>38,720</td>
<td>44</td>
<td>p5_4</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>HQVGA</td>
<td>240</td>
<td>160</td>
<td>38,400</td>
<td>80</td>
<td>p3_2</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>Half-QVGA</td>
</tr>
<tr>
<td>10</td>
<td>SCIF</td>
<td>256</td>
<td>192</td>
<td>49,152</td>
<td>64</td>
<td>p4_3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>CGA</td>
<td>320</td>
<td>200</td>
<td>64,000</td>
<td>40</td>
<td>p8_5</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>QVGA</td>
<td>320</td>
<td>240</td>
<td>76,800</td>
<td>80</td>
<td>p4_3</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td>Quarter Video Graphics Array</td>
</tr>
<tr>
<td>13</td>
<td></td>
<td>350</td>
<td>240</td>
<td>84,000</td>
<td>10</td>
<td>p13_9</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>. Video CD</td>
</tr>
<tr>
<td>14</td>
<td>SIF(525)</td>
<td>352</td>
<td>240</td>
<td>84,480</td>
<td>16</td>
<td>p13_9</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>Source Input Format(NTSC). VCD(MPEG1)</td>
</tr>
<tr>
<td>15</td>
<td>CIF</td>
<td>352</td>
<td>288</td>
<td>101,376</td>
<td>32</td>
<td>p11_9</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>Common Intermediate Format. SIF(625)(PAL). VDC(MPEG1)</td>
</tr>
<tr>
<td>16</td>
<td>WQVGA</td>
<td>376</td>
<td>240</td>
<td>90,240</td>
<td>8</td>
<td>p11_7</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>wide-QVGA. Apple iPod nano</td>
</tr>
<tr>
<td>17</td>
<td>WQVGA</td>
<td>384</td>
<td>240</td>
<td>92,160</td>
<td>48</td>
<td>p8_5</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>wide-QVGA</td>
</tr>
<tr>
<td>18</td>
<td></td>
<td>384</td>
<td>288</td>
<td>110,592</td>
<td>96</td>
<td>p4_3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>. Display for SIF</td>
</tr>
<tr>
<td>19</td>
<td>WQVGA</td>
<td>400</td>
<td>240</td>
<td>96,000</td>
<td>80</td>
<td>p5_3</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>wide-QVGA</td>
</tr>
<tr>
<td>20</td>
<td>WQVGA</td>
<td>432</td>
<td>240</td>
<td>103,680</td>
<td>48</td>
<td>p9_5</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>wide-QVGA</td>
</tr>
<tr>
<td>21</td>
<td>HVGA</td>
<td>480</td>
<td>272</td>
<td>130,560</td>
<td>16</td>
<td>p16_9</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>Half-size VGA</td>
</tr>
<tr>
<td>22</td>
<td></td>
<td>480</td>
<td>300</td>
<td>144,000</td>
<td>60</td>
<td>p8_5</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>. Umatic, Betamax, VHS, Video8</td>
</tr>
<tr>
<td>23</td>
<td>HVGA</td>
<td>480</td>
<td>320</td>
<td>153,600</td>
<td>160</td>
<td>p3_2</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>Half-size VGA</td>
</tr>
<tr>
<td>24</td>
<td></td>
<td>480</td>
<td>350</td>
<td>168,000</td>
<td>10</td>
<td>p11_8</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>. Super Betamax, Betacam (pro)</td>
</tr>
<tr>
<td>25</td>
<td>HVGA</td>
<td>480</td>
<td>360</td>
<td>172,800</td>
<td>120</td>
<td>p4_3</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td>Half-size VGA</td>
</tr>
<tr>
<td>26</td>
<td></td>
<td>480</td>
<td>420</td>
<td>201,600</td>
<td>60</td>
<td>p8_7</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>. LaserDisc, Super VHS, Hi8</td>
</tr>
<tr>
<td>27</td>
<td></td>
<td>500</td>
<td>480</td>
<td>240,000</td>
<td>20</td>
<td>p1_1</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>. Analog broadcast</td>
</tr>
<tr>
<td>28</td>
<td>DCIF</td>
<td>528</td>
<td>384</td>
<td>202,752</td>
<td>48</td>
<td>p11_8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Double CIF</td>
</tr>
<tr>
<td>29</td>
<td>HVGA</td>
<td>640</td>
<td>240</td>
<td>153,600</td>
<td>80</td>
<td>p8_3</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>Half-size VGA</td>
</tr>
<tr>
<td>30</td>
<td>EGA</td>
<td>640</td>
<td>350</td>
<td>224,000</td>
<td>10</td>
<td>p11_6</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>31</td>
<td></td>
<td>640</td>
<td>352</td>
<td>225,280</td>
<td>32</td>
<td>p11_6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>. nHD for Video(32x32 macroblocks)</td>
</tr>
<tr>
<td>32</td>
<td>nHD</td>
<td>640</td>
<td>360</td>
<td>230,400</td>
<td>40</td>
<td>p16_9</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>one ninth of a full HD 1080p frame</td>
</tr>
<tr>
<td>33</td>
<td></td>
<td>640</td>
<td>368</td>
<td>235,520</td>
<td>16</td>
<td>p7_4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>. nHD for Video(16x16 macroblocks)</td>
</tr>
<tr>
<td>34</td>
<td>VGA</td>
<td>640</td>
<td>480</td>
<td>307,200</td>
<td>160</td>
<td>p4_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Video Graphics Array</td>
</tr>
<tr>
<td>35</td>
<td></td>
<td>670</td>
<td>480</td>
<td>321,600</td>
<td>10</td>
<td>p7_5</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>. Enhanced Definition Betamax</td>
</tr>
<tr>
<td>36</td>
<td>HALF D1</td>
<td>704</td>
<td>288</td>
<td>202,752</td>
<td>32</td>
<td>p22_9</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>HALF D1 = 2× CIF</td>
</tr>
<tr>
<td>37</td>
<td>4SIF(525)</td>
<td>704</td>
<td>480</td>
<td>337,920</td>
<td>32</td>
<td>p13_9</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>4× SIF(525)</td>
</tr>
<tr>
<td>38</td>
<td>4CIF</td>
<td>704</td>
<td>576</td>
<td>405,504</td>
<td>64</td>
<td>p11_9</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>4× CIF, D1, 4× SIF(625)</td>
</tr>
<tr>
<td>39</td>
<td></td>
<td>720</td>
<td>348</td>
<td>250,560</td>
<td>12</td>
<td>p60_29</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Hercules</td>
</tr>
<tr>
<td>40</td>
<td>NTSC</td>
<td>720</td>
<td>480</td>
<td>345,600</td>
<td>240</td>
<td>p3_2</td>
<td></td>
<td></td>
<td>Y</td>
<td></td>
<td>National Television System Committee</td>
</tr>
<tr>
<td>41</td>
<td>EDTV</td>
<td>720</td>
<td>576</td>
<td>414,720</td>
<td>144</td>
<td>p5_4</td>
<td></td>
<td></td>
<td>Y</td>
<td></td>
<td>Enhanced-definition television</td>
</tr>
<tr>
<td>42</td>
<td>PAL</td>
<td>768</td>
<td>576</td>
<td>442,368</td>
<td>192</td>
<td>p4_3</td>
<td></td>
<td></td>
<td>Y</td>
<td></td>
<td>Phase Alternating Line</td>
</tr>
<tr>
<td>43</td>
<td>WVGA</td>
<td>800</td>
<td>480</td>
<td>384,000</td>
<td>160</td>
<td>p5_3</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>wide-VGA</td>
</tr>
<tr>
<td>44</td>
<td>SVGA</td>
<td>800</td>
<td>600</td>
<td>480,000</td>
<td>200</td>
<td>p4_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Super Video Graphics Array</td>
</tr>
<tr>
<td>45</td>
<td>WVGA</td>
<td>848</td>
<td>480</td>
<td>407,040</td>
<td>16</td>
<td>p16_9</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>wide-VGA</td>
</tr>
<tr>
<td>46</td>
<td>WVGA</td>
<td>852</td>
<td>480</td>
<td>408,960</td>
<td>12</td>
<td>p16_9</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>wide-VGA</td>
</tr>
<tr>
<td>47</td>
<td>FWVGA</td>
<td>854</td>
<td>480</td>
<td>409,920</td>
<td>2</td>
<td>p16_9</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>Full Wide VGA</td>
</tr>
<tr>
<td>48</td>
<td>qHD</td>
<td>960</td>
<td>540</td>
<td>518,400</td>
<td>60</td>
<td>p16_9</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td>one quarter of a full HD 1080p frame</td>
</tr>
<tr>
<td>49</td>
<td>WSVGA</td>
<td>1024</td>
<td>576</td>
<td>589,824</td>
<td>64</td>
<td>p16_9</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td>wide-SVGA</td>
</tr>
<tr>
<td>50</td>
<td>WSVGA</td>
<td>1024</td>
<td>600</td>
<td>614,400</td>
<td>8</td>
<td>p12_7</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td>wide-SVGA</td>
</tr>
<tr>
<td>51</td>
<td></td>
<td>1024</td>
<td>640</td>
<td>655,360</td>
<td>128</td>
<td>p8_5</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>52</td>
<td>XGA</td>
<td>1024</td>
<td>768</td>
<td>786,432</td>
<td>256</td>
<td>p4_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>eXtended Graphics Array</td>
</tr>
<tr>
<td>53</td>
<td></td>
<td>1152</td>
<td>720</td>
<td>829,440</td>
<td>144</td>
<td>p8_5</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>54</td>
<td>XGA+</td>
<td>1152</td>
<td>768</td>
<td>884,736</td>
<td>384</td>
<td>p3_2</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>eXtended Graphics Array Plus</td>
</tr>
<tr>
<td>55</td>
<td>XGA+</td>
<td>1152</td>
<td>864</td>
<td>995,328</td>
<td>288</td>
<td>p4_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>eXtended Graphics Array Plus</td>
</tr>
<tr>
<td>56</td>
<td>HD720</td>
<td>1280</td>
<td>720</td>
<td>921,600</td>
<td>80</td>
<td>p16_9</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>High-definition television 720p</td>
</tr>
<tr>
<td>57</td>
<td>WXGA</td>
<td>1280</td>
<td>768</td>
<td>983,040</td>
<td>256</td>
<td>p5_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>wide-XGA</td>
</tr>
<tr>
<td>58</td>
<td>WXGA</td>
<td>1280</td>
<td>800</td>
<td>1,024,000</td>
<td>160</td>
<td>p8_5</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>wide-XGA</td>
</tr>
<tr>
<td>59</td>
<td></td>
<td>1280</td>
<td>854</td>
<td>1,093,120</td>
<td>2</td>
<td>p3_2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>60</td>
<td>SXGA-</td>
<td>1280</td>
<td>960</td>
<td>1,228,800</td>
<td>320</td>
<td>p4_3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>61</td>
<td>SXGA</td>
<td>1280</td>
<td>1024</td>
<td>1,310,720</td>
<td>256</td>
<td>p5_4</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Super eXtended Graphics Array</td>
</tr>
<tr>
<td>62</td>
<td>HD</td>
<td>1360</td>
<td>768</td>
<td>1,044,480</td>
<td>16</td>
<td>p16_9</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td></td>
<td>HD, wide-XGA</td>
</tr>
<tr>
<td>63</td>
<td>HD</td>
<td>1365</td>
<td>768</td>
<td>1,048,320</td>
<td>3</td>
<td>p16_9</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>HD, wide-XGA</td>
</tr>
<tr>
<td>64</td>
<td>HD</td>
<td>1366</td>
<td>768</td>
<td>1,049,088</td>
<td>2</td>
<td>p16_9</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td></td>
<td>HD, wide-XGA</td>
</tr>
<tr>
<td>65</td>
<td>SXGA+</td>
<td>1400</td>
<td>1050</td>
<td>1,470,000</td>
<td>350</td>
<td>p4_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Super eXtended Graphics Array Plus</td>
</tr>
<tr>
<td>66</td>
<td>16SIF(525)</td>
<td>1408</td>
<td>960</td>
<td>1,351,680</td>
<td>64</td>
<td>p13_9</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>16× SIF(525)</td>
</tr>
<tr>
<td>67</td>
<td>16CIF</td>
<td>1408</td>
<td>1152</td>
<td>1,622,016</td>
<td>128</td>
<td>p11_9</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>16× CIF, 16× SIF(625)</td>
</tr>
<tr>
<td>68</td>
<td>WXGA+</td>
<td>1440</td>
<td>900</td>
<td>1,296,000</td>
<td>180</td>
<td>p8_5</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Wide eXtended Graphics Array Plus</td>
</tr>
<tr>
<td>69</td>
<td></td>
<td>1440</td>
<td>960</td>
<td>1,382,400</td>
<td>480</td>
<td>p3_2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>70</td>
<td></td>
<td>1440</td>
<td>1080</td>
<td>1,555,200</td>
<td>360</td>
<td>p4_3</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>. HDV (miniDV)</td>
</tr>
<tr>
<td>71</td>
<td>UWXGA</td>
<td>1600</td>
<td>768</td>
<td>1,228,800</td>
<td>64</td>
<td>p25_12</td>
<td></td>
<td></td>
<td></td>
<td>ultra-wide-XGA</td>
<td></td>
</tr>
<tr>
<td>72</td>
<td>HD+</td>
<td>1600</td>
<td>900</td>
<td>1,440,000</td>
<td>100</td>
<td>p16_9</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>73</td>
<td>UGA</td>
<td>1600</td>
<td>1200</td>
<td>1,920,000</td>
<td>400</td>
<td>p4_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Ultra eXtended Graphics Array</td>
</tr>
<tr>
<td>74</td>
<td>WSXGA+</td>
<td>1680</td>
<td>1050</td>
<td>1,764,000</td>
<td>210</td>
<td>p8_5</td>
<td>Y</td>
<td></td>
<td></td>
<td>Y</td>
<td>Widescreen Super eXtended Graphics Array Plus</td>
</tr>
<tr>
<td>75</td>
<td>HD1080</td>
<td>1920</td>
<td>1080</td>
<td>2,073,600</td>
<td>120</td>
<td>p16_9</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td>Y</td>
<td>High-definition television 1080p</td>
</tr>
<tr>
<td>76</td>
<td>WUXGA</td>
<td>1920</td>
<td>1200</td>
<td>2,304,000</td>
<td>240</td>
<td>p8_5</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Widescreen Ultra eXtended Graphics Array</td>
</tr>
<tr>
<td>77</td>
<td>2K</td>
<td>2048</td>
<td>1080</td>
<td>2,211,840</td>
<td>8</td>
<td>p17_9</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>2K Digital Cinema</td>
</tr>
<tr>
<td>78</td>
<td>QWXGA</td>
<td>2048</td>
<td>1152</td>
<td>2,359,296</td>
<td>128</td>
<td>p16_9</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Quad Wide eXtended Graphics Array</td>
</tr>
<tr>
<td>79</td>
<td>QXGA</td>
<td>2048</td>
<td>1536</td>
<td>3,145,728</td>
<td>512</td>
<td>p4_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Quad eXtended Graphics Array</td>
</tr>
<tr>
<td>80</td>
<td></td>
<td>2304</td>
<td>1440</td>
<td>3,317,760</td>
<td>288</td>
<td>p8_5</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>. GDM-FW900 &amp; A7217A</td>
</tr>
<tr>
<td>81</td>
<td>WQHD</td>
<td>2560</td>
<td>1440</td>
<td>3,686,400</td>
<td>160</td>
<td>p16_9</td>
<td>Y</td>
<td></td>
<td></td>
<td>Y</td>
<td>Wide Quad High Definition</td>
</tr>
<tr>
<td>82</td>
<td>WQXGA</td>
<td>2560</td>
<td>1600</td>
<td>4,096,000</td>
<td>320</td>
<td>p8_5</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Wide Quad eXtended Graphics Array</td>
</tr>
<tr>
<td>83</td>
<td></td>
<td>2560</td>
<td>1920</td>
<td>4,915,200</td>
<td>640</td>
<td>p4_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>. Viewsonic P225f</td>
</tr>
<tr>
<td>84</td>
<td>QSXGA</td>
<td>2560</td>
<td>2048</td>
<td>5,242,880</td>
<td>512</td>
<td>p5_4</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Quad Super eXtended Graphics Array</td>
</tr>
<tr>
<td>85</td>
<td>WQSXGA</td>
<td>3200</td>
<td>2048</td>
<td>6,553,600</td>
<td>128</td>
<td>p14_9</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Wide Quad Super eXtended Graphics Array</td>
</tr>
<tr>
<td>86</td>
<td>QUXGA</td>
<td>3200</td>
<td>2400</td>
<td>7,680,000</td>
<td>800</td>
<td>p4_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Quad Ultra Extended Graphics Array</td>
</tr>
<tr>
<td>87</td>
<td>WQSXGA</td>
<td>3280</td>
<td>2048</td>
<td>6,717,440</td>
<td>16</td>
<td>p8_5</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>WQSXGA. Coronis Fusion 6MP DL</td>
</tr>
<tr>
<td>88</td>
<td></td>
<td>3840</td>
<td>2048</td>
<td>7,864,320</td>
<td>256</td>
<td>p15_8</td>
<td></td>
<td></td>
<td>Y</td>
<td></td>
<td>. UHDTV</td>
</tr>
<tr>
<td>89</td>
<td>QFHD</td>
<td>3840</td>
<td>2160</td>
<td>8,294,400</td>
<td>240</td>
<td>p16_9</td>
<td></td>
<td></td>
<td>Y</td>
<td>Y</td>
<td>Quad Full High Definition</td>
</tr>
<tr>
<td>90</td>
<td>WQUXGA</td>
<td>3840</td>
<td>2400</td>
<td>9,216,000</td>
<td>480</td>
<td>p8_5</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Wide Quad Ultra eXtended Graphics Array</td>
</tr>
<tr>
<td>91</td>
<td>4K-</td>
<td>4096</td>
<td>1716</td>
<td>7,028,736</td>
<td>4</td>
<td>p19_8</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>92</td>
<td>4K</td>
<td>4096</td>
<td>2160</td>
<td>8,847,360</td>
<td>16</td>
<td>p17_9</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>4K Digital Cinema</td>
</tr>
<tr>
<td>93</td>
<td></td>
<td>4096</td>
<td>2304</td>
<td>9,437,184</td>
<td>256</td>
<td>p16_9</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>. YouTube</td>
</tr>
<tr>
<td>94</td>
<td>HXGA</td>
<td>4096</td>
<td>3072</td>
<td>12,582,912</td>
<td>1024</td>
<td>p4_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Hex[adecatuple] Extended Graphics Array</td>
</tr>
<tr>
<td>95</td>
<td></td>
<td>5120</td>
<td>3072</td>
<td>15,728,640</td>
<td>1024</td>
<td>p5_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>. WHXGA-</td>
</tr>
<tr>
<td>96</td>
<td>WHXGA</td>
<td>5120</td>
<td>3200</td>
<td>16,384,000</td>
<td>640</td>
<td>p8_5</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Wide Hex[adecatuple] Extended Graphics Array</td>
</tr>
<tr>
<td>97</td>
<td>HSXGA</td>
<td>5120</td>
<td>4096</td>
<td>20,971,520</td>
<td>1024</td>
<td>p5_4</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Hex[adecatuple] Super Extended Graphics Array</td>
</tr>
<tr>
<td>98</td>
<td>WHSXGA</td>
<td>6400</td>
<td>4096</td>
<td>26,214,400</td>
<td>256</td>
<td>p14_9</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Wide Hex[adecatuple] Super Extended Graphics Array</td>
</tr>
<tr>
<td>99</td>
<td>HUXGA</td>
<td>6400</td>
<td>4800</td>
<td>30,720,000</td>
<td>1600</td>
<td>p4_3</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Hex[adecatuple] Ultra Extended Graphics Array</td>
</tr>
<tr>
<td>100</td>
<td>UHDTV</td>
<td>7680</td>
<td>4320</td>
<td>33,177,600</td>
<td>480</td>
<td>p16_9</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td></td>
<td>Ultra High Definition Television</td>
</tr>
<tr>
<td>101</td>
<td>WHUXGA</td>
<td>7680</td>
<td>4800</td>
<td>36,864,000</td>
<td>960</td>
<td>p8_5</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Wide Hex[adecatuple] Ultra Extended Graphics Array</td>
</tr>
</tbody></table>
<p><em>Idx：顺序。Name：命名了的分辨率。W：宽度。H：高度。Pxs：总像素。gcd：宽度、高度的最大公约数。Per：比例。p16_9表示16:9。C：是否电脑屏幕分辨率；P：是否手机屏幕分辨率；T：是否电视屏幕分辨率；V：是否视频设备分辨率。</em></p>
<h3 id="码率模式"><a href="#码率模式" class="headerlink" title="码率模式"></a>码率模式</h3><p>-　VBR（Variable Bitrate）动态比特率也就是没有固定的比特率，用的是动态编码的方式，压缩软件在压缩时根据音频数据即时确定使用什么比特率，把较高的采样率用于复杂的动态画面，而把较低的采样率用于静态画面，合理利用资源，达到画质与体积可兼得的效果。</p>
<p>-　ABR（Average Bitrate）平均比特率是VBR的一种插值参数。LAME针对CBR不佳的文件体积比和VBR生成文件大小不定的特点独创了这种编码模式。ABR在指定的文件大小内，以每50帧（30帧约1秒）为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量，可以做为VBR和CBR的一种折衷选择。</p>
<p>-　CBR（Constant Bitrate）常数比特率指文件从头到尾都是一种位速率。相对于VBR和ABR来讲，它压缩出来的文件体积很大，而且音质相对于VBR和ABR不会有明显的提高。</p>
<h3 id="QP"><a href="#QP" class="headerlink" title="QP"></a>QP</h3><p>Quantizer Parameter，量化参数，反映了空间细节压缩情况。值越小，量化越精细，图像质量越高，产生的码流也越长。如QP小，大部分的细节都会被保留；QP增大，一些细节丢失，码率降低，但图像失真加强和质量下降。</p>
<h3 id="profile-level"><a href="#profile-level" class="headerlink" title="profile level"></a>profile level</h3><ul>
<li><p>BP-Baseline Profile：基本画质。支持I/P 帧，只支持无交错（Progressive）和CAVLC；</p>
</li>
<li><p>EP-Extended profile：进阶画质。支持I/P/B/SP/SI 帧，只支持无交错（Progressive）和CAVLC；</p>
</li>
<li><p>MP-Main profile：主流画质。提供I/P/B 帧，支持无交错（Progressive）和交错（Interlaced），也支持CAVLC 和CABAC 的支持；</p>
</li>
<li><p>HP-High profile：高级画质。在main Profile 的基础上增加了8x8内部预测、自定义量化、无损视频编码和更多的YUV 格式。</p>
</li>
</ul>
<h2 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h2><p>视频是由不同的帧画面连续播放形成的。这些帧，主要分为三类，分别是I帧，B帧，P帧。</p>
<ul>
<li><p>I帧，是自带全部信息的独立帧，是最完整的画面，无需参考其它图像便可独立进行解码。视频序列中的第一个帧，始终都是I帧。</p>
</li>
<li><p>P帧，帧间预测编码帧，需要参考前面的I帧和/或P帧的不同部分，才能进行编码。P帧对前面的P和I参考帧有依赖性。但是，P帧压缩率比较高，占用的空间较小。</p>
</li>
</ul>
<p><img src="/images/media/video/Pframe.jpg" alt="P帧"></p>
<p>*　B帧，双向预测编码帧，以前帧和后作为参考帧。不仅参考前面，还参考后面的帧，所以，它的压缩率最高，可以达到200:1。不过，因为依赖后面的帧，所以不适合实时传输。</p>
<p><img src="/images/media/video/Bframe.jpg" alt="B帧"></p>
<p><img src="/images/media/video/venc.jpg" alt="venc"></p>
<h3 id="IDR"><a href="#IDR" class="headerlink" title="IDR"></a>IDR</h3><p>Instantaneous Decoding Refresh，即时解码刷新。为将首个I帧和其他I帧区别开，定义首个I帧为IDR帧。</p>
<h3 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h3><p>Group of picture，关键帧的周期，也就是两个IDR帧之间的距离，一个帧组的最大帧数，一般而言，每一秒视频至少需要使用 1 个关键帧。增加关键帧个数可改善质量，但是同时增加带宽和网络负载。<br>需要说明的是，通过提高GOP值来提高图像质量是有限度的，在遇到场景切换的情况时，H.264编码器会自动强制插入一个I帧，此时实际的GOP值被缩短了。另一方面，在一个GOP中，P、B帧是由I帧预测得到的，当I帧的图像质量比较差时，会影响到一个GOP中后续P、B帧的图像质量，直到下一个GOP开始才有可能得以恢复，所以GOP值也不宜设置过大。</p>
<p>同时，由于P、B帧的复杂度大于I帧，所以过多的P、B帧会影响编码效率，使编码效率降低。另外，过长的GOP还会影响Seek操作的响应速度，由于P、B帧是由前面的I或P帧预测得到的，所以Seek操作需要直接定位，解码某一个P或B帧时，需要先解码得到本GOP内的I帧及之前的N个预测帧才可以，GOP值越长，需要解码的预测帧就越多，seek响应的时间也越长。</p>
<p><img src="/images/media/video/gop.png" alt="gop"></p>
<p>-　H.265和H.264的区别</p>
<p>　　1．H.265是新的编码协议，也即是H.264的升级版。H.265标准保留H.264原来的某些技术，同时对一些相关的技术加以改进。新技术使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。</p>
<p>　　2．H.265相比H.264最主要的改变是采用了块的四叉树划分结构，采用了从64×64～8×8像素的自适应块划分，并基于这种块划分结构采用一系列自适应的预测和变换等编码技术。</p>
<p>　　3．H.264由于算法优化，可以低于1Mbps的速度实现标清数字图像传送；H.265则可以实现利用1~2Mbps的传输速度传送720P（分辨率1280×720）普通高清音视频传送。</p>
<p>　　4．同样的画质和同样的码率，H.265比H2.64 占用的存储空间要少理论50%。</p>
<p>　　5．比起H.264/AVC，H.265/HEVC提供了更多不同的工具来降低码率，以编码单位来说，H.264中每个宏块（macroblock/MB）大小都是固定的16×16像素，而H.265的编码单位可以选择从最小的8×8到最大的64×64。</p>
<p>　　6．在相同的图象质量下，相比于H.264，通过H.265编码的视频大小将减少大约39～44%。</p>
<p>-　H.265的优势</p>
<p>　　1．H.265/HEVC的编码架构大致上和H.264/AVC的架构相似，主要也包含，帧内预测（intra prediction）、帧间预测（inter prediction）、转换（transform）、量化（quantization）、去区块滤波器（deblocking filter）、熵编码（entropy coding）等模块。</p>
<p>　　但在HEVC编码架构中，整体被分为了三个基本单位，分别是编码单位（coding unit, CU）、预测单位（predict unit, PU）和转换单位（transform unit, TU）。</p>
<p>　　2．比起H.264/AVC，H.265/HEVC提供了更多不同的工具来降低码率，以编码单位来说，H.264中每个宏块（macroblock/MB）大小都是固定的16x16像素，而H.265的编码单位可以选择从最小的8×8到最大的64×64。</p>
<p>　　3．H.265的帧内预测模式支持33种方向（H.264只支持8种），并且提供了更好的运动补偿处理和矢量预测方法。</p>
<p>　　4．反复的质量比较测试已经表明，在相同的图象质量下，相比于H.264，通过H.265编码的视频大小将减少大约39～44%。由于质量控制的测定方法不同，这个数据也会有相应的变化。</p>
<p>　　5．通过主观视觉测试得出的数据显示，在码率减少51～74%的情况下，H.265编码视频的质量还能与H.264编码视频近似甚至更好，其本质上说是比预期的信噪比（PSNR）要好。</p>
]]></content>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>linux async</title>
    <url>/2022/06/07/kernel/async/</url>
    <content><![CDATA[<h2 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h2><p>异步通知是应用程序不需要一直查询设备状态，一旦设备就绪，则主动通知应用程序。为了使设备支持异步通知机制，驱动程序中涉及 3 项工作：</p>
<ul>
<li><p>支持 F_SETOWN 命令，能在这个控制命令处理中设置 filp-&gt;f_owner 为对应进程 ID。不<br>过此项工作已由内核完成，设备驱动无需处理。</p>
</li>
<li><p>支持 F_SETFL 命令的处理，当应用改变 FASYNC 标志时，驱动程序中的fasync()函数将得以执行。</p>
</li>
<li><p>在设备资源可获得时，激发相应的信号。</p>
</li>
</ul>
<p><img src="/images/kernel/async/async.png" alt="async"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理 FASYNC 标志变更 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fasync_helper</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> mode, <span class="keyword">struct</span> fasync_struct **fa)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kill_fasync</span><span class="params">(<span class="keyword">struct</span> fasync_struct **fp, <span class="type">int</span> sig, <span class="type">int</span> band)</span></span><br></pre></td></tr></table></figure>

<p>驱动中要实现fasync()函数，当应用改变 FASYNC 标志时，驱动程序中的fasync()函数将得以执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxx_object</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">return</span> fasync_helper(fd, filp, mode, &amp;dev-&gt;async_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设备资源可以获得时，应该调用 kill_fasync()释放 SIGIO 信号，可读时band参数设置为 <code>POLL_IN</code>，可写时设置为 <code>POLL_OUT</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 产生异步读信号 */</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;async_queue)</span><br><span class="line">&#123;</span><br><span class="line">    kill_fasync(&amp;dev-&gt;async_queue, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在设备驱动的 release()函数中，应调用设备驱动的 fasync()函数将文件从异步通知的列表中删除。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    xxx_fasync(<span class="number">-1</span>, file, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2>]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>block device</title>
    <url>/2022/09/04/kernel/block/</url>
    <content><![CDATA[<p>块设备是一种具有一定结构的随机存取设备，读写数据的基本单位为块，使用缓冲区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者从设备一次性读到缓冲区。</p>
<ul>
<li>**页(page)**：Linux内存页，一般是4096字节，用作磁盘缓存。通过<code>getconf PAGE_SIZE</code>查看。</li>
<li>**段(Segments)**：由若干个块组成。是Linux内存管理机制中一个内存页或者内存页的一部分。</li>
<li><strong>块  (Blocks)</strong> ：  Linux虚拟文件系统I/O操作的最小单位，通常为扇区的2的幂次方倍。通过<code>tune2fs -l /dev/vdb1|grep Block</code>查看块大小。</li>
<li>**扇区(Sectors)**：块设备的基本单位。通常在512字节到32768字节之间，默认512字节。可以通过<code>fdisk -l</code>命令查看每个磁盘sector的大小</li>
</ul>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>Linux使用虚拟文件系统屏蔽不同I/O设备的差别，Linux内核通过映射层、通用块层、I/O调度层屏蔽不同块设备的差别。</p>
<p><img src="/images/kernel/block/block-arch.jpg" alt="块设备框架"></p>
<p><img src="/images/kernel/block/block-arch2.jpg" alt="块设备框架"></p>
<p><img src="/images/kernel/block/block.png" alt="块设备框架"></p>
<h2 id="块设备层"><a href="#块设备层" class="headerlink" title="块设备层"></a>块设备层</h2><h3 id="gendisk"><a href="#gendisk" class="headerlink" title="gendisk"></a>gendisk</h3><p>linux内核用 gendisk 结构体表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> major;   <span class="comment">/* major number of driver */</span></span><br><span class="line">    <span class="type">int</span> first_minor;</span><br><span class="line">    <span class="type">int</span> minors;                     <span class="comment">/* maximum number of minors, =1 for</span></span><br><span class="line"><span class="comment">                                         * disks that can&#x27;t be partitioned. */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> disk_name[DISK_NAME_LEN]; <span class="comment">/* name of major driver */</span></span><br><span class="line">    <span class="type">char</span> *(*devnode)(<span class="keyword">struct</span> gendisk *gd, <span class="type">mode_t</span> *mode);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> events;  <span class="comment">/* supported events */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> async_events; <span class="comment">/* async events, subset of all */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">disk_part_tbl</span> __<span class="title">rcu</span> *<span class="title">part_tbl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> <span class="title">part0</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">    <span class="type">void</span> *private_data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">driverfs_dev</span>;</span>  <span class="comment">// <span class="doctag">FIXME:</span> remove</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">slave_dir</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_rand_state</span> *<span class="title">random</span>;</span></span><br><span class="line">    <span class="type">atomic_t</span> sync_io;  <span class="comment">/* RAID */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">disk_events</span> *<span class="title">ev</span>;</span></span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gendisk 是一个动态分配的结构体，需要内核来初始化，不能自己分配 */</span></span><br><span class="line"><span class="keyword">struct</span> gendisk *<span class="title function_">alloc_disk</span><span class="params">(<span class="type">int</span> minors)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册磁盘设备 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_disk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 gendisk */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_gendisk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/kernel/block/add_disk.png" alt="块设备注册过程"></p>
<h3 id="block-device-operations"><a href="#block-device-operations" class="headerlink" title="block_device_operations"></a>block_device_operations</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> gendisk *, <span class="type">fmode_t</span>);</span><br><span class="line">    <span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*compat_ioctl) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*direct_access) (<span class="keyword">struct</span> block_device *, <span class="type">sector_t</span>,</span><br><span class="line">                        <span class="type">void</span> **, <span class="type">unsigned</span> <span class="type">long</span> *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*check_events)</span> <span class="params">(<span class="keyword">struct</span> gendisk *disk,</span></span><br><span class="line"><span class="params">                      <span class="type">unsigned</span> <span class="type">int</span> clearing)</span>;</span><br><span class="line">    <span class="comment">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span></span><br><span class="line">    <span class="type">int</span> (*media_changed) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line">    <span class="type">void</span> (*unlock_native_capacity) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line">    <span class="type">int</span> (*revalidate_disk) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line">    <span class="type">int</span> (*getgeo)(<span class="keyword">struct</span> block_device *, <span class="keyword">struct</span> hd_geometry *);</span><br><span class="line">    <span class="comment">/* this callback is with swap_lock and sometimes page table lock held */</span></span><br><span class="line">    <span class="type">void</span> (*swap_slot_free_notify) (<span class="keyword">struct</span> block_device *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>media_changed()检查可移动介质的驱动器中的介质是否已经改变，如果是返回一个非 0 值，否则返回 0。</p>
</li>
<li><p>revalidate_disk()函数被调用来响应一个介质改变，使介质做好工作准备。</p>
</li>
<li><p>getgeo()函数获得驱动器信息，根据驱动器的几何信息填充一个 hd_geometry 结构体，hd_geometry 结构体包含磁头、<br>扇区、柱面等信息，其定义于 include/linux/hdreg.h 头文件。</p>
</li>
<li><p>owner是指向拥有这个结构体的模块的指针，通常被初始化为<code>THIS_MODULE</code>。</p>
</li>
</ul>
<h2 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h2><p>通用块层 (Generic Block Layer) 负责维持一个 I/O 请求在上层文件系统与底层物理磁盘之间的关系。</p>
<h3 id="bio"><a href="#bio" class="headerlink" title="bio"></a>bio</h3><p>bio 结构体用来对应一个 I/O 请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">    <span class="type">sector_t</span>  bi_sector; <span class="comment">/* device address in 512 byte</span></span><br><span class="line"><span class="comment">                           sectors */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span>  *<span class="title">bi_next</span>;</span> <span class="comment">/* request queue link */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bi_bdev</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bi_flags; <span class="comment">/* status, command, etc */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bi_rw;  <span class="comment">/* bottom bits READ/WRITE,</span></span><br><span class="line"><span class="comment">                         * top bits priority</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  bi_vcnt; <span class="comment">/* how many bio_vec&#x27;s */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  bi_idx;  <span class="comment">/* current index into bvl_vec */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of segments in this BIO after</span></span><br><span class="line"><span class="comment">     * physical address coalescing is performed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_phys_segments;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_size; <span class="comment">/* residual I/O count */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * To keep track of the max segment size, we account for the</span></span><br><span class="line"><span class="comment">     * sizes of the first and last mergeable segments in this bio.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_seg_front_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_seg_back_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_max_vecs; <span class="comment">/* max bvl_vecs we can hold */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_comp_cpu; <span class="comment">/* completion CPU */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_t</span>  bi_cnt;  <span class="comment">/* pin count */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>  *<span class="title">bi_io_vec</span>;</span> <span class="comment">/* the actual vec list */</span></span><br><span class="line">    <span class="type">bio_end_io_t</span>  *bi_end_io;</span><br><span class="line">    <span class="type">void</span>   *bi_private;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_integrity_payload</span> *<span class="title">bi_integrity</span>;</span>  <span class="comment">/* data integrity */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">bio_destructor_t</span> *bi_destructor; <span class="comment">/* destructor */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We can inline a number of vecs at the end of the bio, to avoid</span></span><br><span class="line"><span class="comment">     * double allocations for a small number of bio_vecs. This member</span></span><br><span class="line"><span class="comment">     * MUST obviously be kept at the very end of the bio.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>  <span class="title">bi_inline_vecs</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bio 描述了内存中连续几页的数据，每一页的数据由一个段 bio_vec 表示。多个页会被封装成多个段，这些段被组成一个数组，用 bio_io_vec 表示，bi_vcnt 是数组中元素的个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">bv_page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bv_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bv_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 遍历一个bio中的bi_io_vec 数组 */</span></span><br><span class="line"><span class="type">int</span> iter</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>  *<span class="title">bvec</span>;</span></span><br><span class="line">bio_for_each_segment(bvec, bio, iter)   </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回I/O操作的数据方向 */</span></span><br><span class="line">bio_rw(bio)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结束I/O请求 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bio_endio</span><span class="params">(<span class="keyword">struct</span> bio *bio, <span class="type">int</span> error)</span></span><br></pre></td></tr></table></figure>

<h2 id="I-O-调度层"><a href="#I-O-调度层" class="headerlink" title="I/O 调度层"></a>I/O 调度层</h2><p>I/O 调度层负责管理块设备的请求队列，对块设备提交的请求进行合并和排序预操作，以提高访问的效率。I/O调度算法可将连续的bio合并成一个请求，因此，一个请求可以包含多个bio，请求是bio经由I/O调度进行调整后的结果。</p>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>在 Linux 中，驱动对块设备的输入或输出 (I/O) 操作，都会向块设备发出一个请求，在驱动中用 request 结构体描述。但对于一些磁盘设备而言请求的速度很慢，这时候内核就提供一种队列的机制把这些 I/O 请求添加到队列中（即请求队列），在驱动中用 request_queue 结构体描述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queuelist</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">call_single_data</span> <span class="title">csd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cmd_flags;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">rq_cmd_type_bits</span> <span class="title">cmd_type</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">atomic_flags</span>;</span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the following two fields are internal, NEVER access directly */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> __data_len; <span class="comment">/* total data len */</span></span><br><span class="line">    <span class="type">sector_t</span> __sector;  <span class="comment">/* sector cursor */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bio</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">biotail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hash</span>;</span> <span class="comment">/* merge hash */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The rb_node is only used inside the io scheduler, requests</span></span><br><span class="line"><span class="comment">     * are pruned when moved to the dispatch queue. So let the</span></span><br><span class="line"><span class="comment">     * completion_data share space with the rb_node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span> <span class="comment">/* sort/lookup */</span></span><br><span class="line">        <span class="type">void</span> *completion_data;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Three pointers are available for the IO schedulers, if they need</span></span><br><span class="line"><span class="comment">     * more they have to dynamically allocate it.  Flush requests are</span></span><br><span class="line"><span class="comment">     * never put on the IO scheduler. So let the flush fields share</span></span><br><span class="line"><span class="comment">     * space with the three elevator_private pointers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *elevator_private[<span class="number">3</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span>  seq;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">        &#125; flush;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">rq_disk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> *<span class="title">part</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_time;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start_time_ns;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> io_start_time_ns;    <span class="comment">/* when passed to hardware */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Number of scatter-gather DMA addr+len pairs after</span></span><br><span class="line"><span class="comment">     * physical address coalescing is performed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> nr_phys_segments;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> nr_integrity_segments;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ioprio;</span><br><span class="line">    <span class="type">int</span> ref_count;</span><br><span class="line">    <span class="type">void</span> *special;  <span class="comment">/* opaque pointer available for LLD use */</span></span><br><span class="line">    <span class="type">char</span> *buffer;  <span class="comment">/* kaddr of the current segment if available */</span></span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">    <span class="type">int</span> errors;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * when request is used as a packet command carrier</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> __cmd[BLK_MAX_CDB];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *cmd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cmd_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra_len; <span class="comment">/* length of alignment and padding */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sense_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> resid_len; <span class="comment">/* residual count */</span></span><br><span class="line">    <span class="type">void</span> *sense;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> deadline;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">timeout_list</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> timeout;</span><br><span class="line">    <span class="type">int</span> retries;</span><br><span class="line">    rq_end_io_fn *end_io;</span><br><span class="line">    <span class="type">void</span> *end_io_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">next_rq</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化请求队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(request_fn_proc)</span> <span class="params">(<span class="keyword">struct</span> request_queue *q)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> request_queue *<span class="title function_">blk_init_queue</span><span class="params">(request_fn_proc *rfn, <span class="type">spinlock_t</span> *lock)</span></span><br></pre></td></tr></table></figure>

<p>rfn是请求处理函数的指针，lock是控制访问队列权限的自旋锁</p>
<ul>
<li>清除请求队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_cleanup_queue</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分配请求队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> request_queue *<span class="title function_">blk_alloc_queue</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span></span><br></pre></td></tr></table></figure>

<p>对于 Flash、RAM 盘等完全随机访问的非机械设备，并不需要进行复杂的 I/O 调度，这个时候，应该使用上述函数分配一个请求队列，并使用如下函数来绑定请求队列和制造请求函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(make_request_fn)</span> <span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> bio *bio)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_queue_make_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q, make_request_fn *mfn)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>队列操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 从请求队列里面获得一个请求 */</span></span><br><span class="line"><span class="keyword">struct</span> request *<span class="title function_">blk_fetch_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否是队列尾部 */</span></span><br><span class="line"><span class="type">bool</span> __<span class="title function_">blk_end_request_cur</span><span class="params">(<span class="keyword">struct</span> request *rq, <span class="type">int</span> error)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得请求数据传送方向，0 返回值表示从设备中读，非 0 表示向设备写 */</span></span><br><span class="line"><span class="title function_">rq_data_dir</span><span class="params">(<span class="keyword">struct</span> request *req)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="request-queue"><a href="#request-queue" class="headerlink" title="request_queue"></a>request_queue</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Together with queue_head for cacheline sharing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span>  *<span class="title">last_merge</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span> *<span class="title">elevator</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * the queue request freelist, one for reads and one for writes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_list</span> <span class="title">rq</span>;</span></span><br><span class="line">    </span><br><span class="line">    request_fn_proc  *request_fn;</span><br><span class="line">    make_request_fn  *make_request_fn;</span><br><span class="line">    prep_rq_fn  *prep_rq_fn;</span><br><span class="line">    unprep_rq_fn  *unprep_rq_fn;</span><br><span class="line">    merge_bvec_fn  *merge_bvec_fn;</span><br><span class="line">    softirq_done_fn  *softirq_done_fn;</span><br><span class="line">    rq_timed_out_fn  *rq_timed_out_fn;</span><br><span class="line">    dma_drain_needed_fn *dma_drain_needed;</span><br><span class="line">    lld_busy_fn  *lld_busy_fn;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Dispatch queue sorting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">sector_t</span>  end_sector;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span>  *<span class="title">boundary_rq</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Delayed queue handling</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">delay_work</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> <span class="title">backing_dev_info</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The queue owner gets to use this for whatever they like.</span></span><br><span class="line"><span class="comment">     * ll_rw_blk doesn&#x27;t touch it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span>   *queuedata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queue needs bounce pages for pages above this limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">gfp_t</span>   bounce_gfp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * various queue flags, see QUEUE_* below</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  queue_flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * protects queue structures from reentrancy. -&gt;__queue_lock should</span></span><br><span class="line"><span class="comment">     * _never_ be used directly, it is queue private. always use</span></span><br><span class="line"><span class="comment">     * -&gt;queue_lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">spinlock_t</span>  __queue_lock;</span><br><span class="line">    <span class="type">spinlock_t</span>  *queue_lock;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queue kobject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queue settings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  nr_requests; <span class="comment">/* Max # of requests */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  nr_congestion_on;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  nr_congestion_off;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  nr_batching;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span>   *dma_drain_buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  dma_drain_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  dma_pad_mask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  dma_alignment;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_queue_tag</span> *<span class="title">queue_tags</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tag_busy_list</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  nr_sorted;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  in_flight[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  rq_timeout;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">timeout_list</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue_limits</span> <span class="title">limits</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sg stuff</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  sg_timeout;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  sg_reserved_size;</span><br><span class="line">    <span class="type">int</span>   node;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_trace</span> *<span class="title">blk_trace</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * for flush operations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  flush_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  flush_not_queueable:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  flush_queue_delayed:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  flush_pending_idx:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  flush_running_idx:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  flush_pending_since;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flush_queue</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flush_data_in_flight</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span>  <span class="title">flush_rq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>  <span class="title">sysfs_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BLK_DEV_BSG)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bsg_class_device</span> <span class="title">bsg_dev</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_THROTTLING</span></span><br><span class="line">    <span class="comment">/* Throttle data */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">throtl_data</span> *<span class="title">td</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>devfs</title>
    <url>/2022/06/07/kernel/devfs/</url>
    <content><![CDATA[<p>devfs(设备文件系统)是由Linux 2.4 内核引入。</p>
<ul>
<li>可以通过程序在设备初始化时在/dev 目录下创建设备文件，卸载设备时将它删除。</li>
<li>设备驱动程序可以指定设备名、所有者和权限位，用户空间程序仍可以修改所有者和权限位。</li>
<li>不再需要为设备驱动程序分配主设备号以及处理次设备号，给register_chrdev()传递0，以获得可用的主设备号，并在devfs_register()中指定次设备号。</li>
</ul>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>kernel debug</title>
    <url>/2022/06/07/kernel/debug/</url>
    <content><![CDATA[<h2 id="WARN-ON"><a href="#WARN-ON" class="headerlink" title="WARN_ON"></a>WARN_ON</h2><p>内核要开启General setup-&gt;Configure standard kernel features-&gt;BUG() support</p>
<p>BUG_ON会引发oops，导致栈的回溯和错误信息的打印</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUG_ON(condition) do &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely((condition)!=<span class="number">0</span>)) </span><br><span class="line">           BUG(); </span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>WARN_ON则是调用dump_stack，打印堆栈信息，不会OOPS</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WARN_ON(condition) do &#123; </span></span><br><span class="line">      <span class="keyword">if</span> (unlikely((condition)!=<span class="number">0</span>)) &#123; </span><br><span class="line">         printk(<span class="string">&quot;Badness in %s at %s:%d/n&quot;</span>, __FUNCTION__, __FILE__,__LINE__); </span><br><span class="line">         dump_stack(); </span><br><span class="line">        &#125; </span><br><span class="line"> &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="printk"><a href="#printk" class="headerlink" title="printk"></a>printk</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG     <span class="string">&quot;&lt;0&gt;&quot;</span> <span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ALERT     <span class="string">&quot;&lt;1&gt;&quot;</span> <span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CRIT      <span class="string">&quot;&lt;2&gt;&quot;</span> <span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ERR       <span class="string">&quot;&lt;3&gt;&quot;</span> <span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_WARNING   <span class="string">&quot;&lt;4&gt;&quot;</span> <span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_NOTICE    <span class="string">&quot;&lt;5&gt;&quot;</span> <span class="comment">/* normal but significant condition */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_INFO      <span class="string">&quot;&lt;6&gt;&quot;</span> <span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEBUG     <span class="string">&quot;&lt;7&gt;&quot;</span> <span class="comment">/* debug-level messages */</span></span></span><br></pre></td></tr></table></figure>

<p>查看当前控制台的打印级别 <code>cat /proc/sys/kernel/printk</code></p>
<blockquote>
<p>4    4    1    7</p>
</blockquote>
<p>分别表示：</p>
<ul>
<li>控制台日志级别：优先级高于该值的消息将被打印至控制台;</li>
<li>默认的消息日志级别：将用该优先级来打印没有优先级的消息;</li>
<li>最低的控制台日志级别：控制台日志级别可被设置的最小值(最高优先级);</li>
<li>默认的控制台日志级别：控制台日志级别的缺省值;</li>
</ul>
<p>修改打印</p>
<blockquote>
<p>echo “新的打印级别  4    1    7” &gt;/proc/sys/kernel/printk</p>
</blockquote>
<p>打印级别不够的信息会被写到日志中，可通过<code>dmesg</code>命令来查看。</p>
<h2 id="Sparse"><a href="#Sparse" class="headerlink" title="Sparse"></a>Sparse</h2><p>Sparse通过 gcc 的扩展属性 <strong>attribute</strong> 以及自己定义的 <strong>context</strong> 来对代码进行静态检查。</p>
<table>
<thead>
<tr>
<th><strong>宏名称</strong></th>
<th><strong>宏定义</strong></th>
<th><strong>检查点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>__bitwise</td>
<td><strong>attribute</strong>((bitwise))</td>
<td>确保变量是相同的位方式(bit-endian, little-endiandeng)</td>
</tr>
<tr>
<td>__user</td>
<td><strong>attribute</strong>((noderef, address_space(1)))</td>
<td>指针地址必须在用户地址空间初始化，不能指向内核地址空间, 设备地址空间</td>
</tr>
<tr>
<td>__kernel</td>
<td><strong>attribute</strong>((noderef, address_space(0)))</td>
<td>指针地址必须在内核地址空间初始化</td>
</tr>
<tr>
<td>__iomem</td>
<td><strong>attribute</strong>((noderef, address_space(2)))</td>
<td>指针地址必须在设备地址空间初始化</td>
</tr>
<tr>
<td>__safe</td>
<td><strong>attribute</strong>((safe))</td>
<td>变量可以为空</td>
</tr>
<tr>
<td>__force</td>
<td><strong>attribute</strong>((force))</td>
<td>变量可以进行强制转换</td>
</tr>
<tr>
<td>__nocast</td>
<td><strong>attribute</strong>((nocast))</td>
<td>参数类型与实际参数类型必须一致</td>
</tr>
<tr>
<td>__acquires(x)</td>
<td><strong>attribute</strong>((context(x, 0, 1)))</td>
<td>参数x 在执行前引用计数必须是0，执行后，引用计数必须为1</td>
</tr>
<tr>
<td>__releases(x)</td>
<td><strong>attribute</strong>((context(x, 1, 0)))</td>
<td>与 __acquires(x) 相反</td>
</tr>
<tr>
<td>__acquire(x)</td>
<td><strong>context</strong>(x, 1)</td>
<td>参数x 的引用计数 + 1</td>
</tr>
<tr>
<td>__release(x)</td>
<td><strong>context</strong>(x, -1)</td>
<td>与 __acquire(x) 相反</td>
</tr>
<tr>
<td>__cond_lock(x,c)</td>
<td>((c) ? ({ __acquire(x); 1; }) : 0)</td>
<td>参数c 不为0时,引用计数 + 1, 并返回1</td>
</tr>
</tbody></table>
<p>其中 <code>__acquires(x)</code>  和<code>__releases(x)</code>，  <code>__acquire(x)</code>和  <code>__release(x)</code> 必须配对使用, 否则 Sparse 会给出警告。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>bus device driver</title>
    <url>/2022/06/07/kernel/bus/</url>
    <content><![CDATA[<p>Linux内核分别使用 bus_type、device_driver 和 device 来描述总线、驱动和设备，这三个结构体定义于 include/linux/device.h 头文件中。</p>
<h2 id="bus"><a href="#bus" class="headerlink" title="bus"></a>bus</h2><p>在linux设备模型中，总线用 bus_type 结构体表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsystem</span> <span class="title">subsys</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">drivers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span>    *<span class="title">bus_attrs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">dev_attrs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> *<span class="title">drv_attrs</span>;</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv);</span><br><span class="line">    <span class="type">int</span> (*hotplug) (<span class="keyword">struct</span> device *dev, <span class="type">char</span> **envp, </span><br><span class="line">                    <span class="type">int</span> num_envp, <span class="type">char</span> *buffer, <span class="type">int</span> buffer_size);</span><br><span class="line">    <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> device *dev, <span class="type">pm_message_t</span> state);</span><br><span class="line">    <span class="type">int</span> (*resume)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>match()成员函数将分开注册的设备和驱动捆绑在一起。</p>
<h3 id="bus-register"><a href="#bus-register" class="headerlink" title="bus_register()"></a>bus_register()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bus_register</span><span class="params">(<span class="keyword">struct</span> bus_type *bus)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> retval;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span> =</span> &amp;bus-&gt;lock_key;</span><br><span class="line"></span><br><span class="line">   priv = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> subsys_private), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">   priv-&gt;bus = bus;</span><br><span class="line">   bus-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">   BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">   retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, bus-&gt;name);</span><br><span class="line"></span><br><span class="line">   priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class="line">   priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">   priv-&gt;drivers_autoprobe = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line"></span><br><span class="line">   retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line"></span><br><span class="line">   priv-&gt;devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, <span class="literal">NULL</span>, &amp;priv-&gt;subsys.kobj);</span><br><span class="line">   priv-&gt;drivers_kset = kset_create_and_add(<span class="string">&quot;drivers&quot;</span>, <span class="literal">NULL</span>, &amp;priv-&gt;subsys.kobj);</span><br><span class="line"></span><br><span class="line">   INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">   __mutex_init(&amp;priv-&gt;mutex, <span class="string">&quot;subsys mutex&quot;</span>, key);</span><br><span class="line">   klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">   klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   retval = add_probe_files(bus);</span><br><span class="line"></span><br><span class="line">   retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bus-attribute"><a href="#bus-attribute" class="headerlink" title="bus_attribute"></a>bus_attribute</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>   <span class="title">attr</span>;</span></span><br><span class="line">   <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> bus_type *bus, <span class="type">char</span> *buf);</span><br><span class="line">   <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> bus_type *bus, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUS_ATTR(_name, _mode, _show, _store)   \</span></span><br><span class="line"><span class="meta">   struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bus_create_file</span><span class="params">(<span class="keyword">struct</span> bus_type *bus, <span class="keyword">struct</span> bus_attribute *attr)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bus_remove_file</span><span class="params">(<span class="keyword">struct</span> bus_type *bus, <span class="keyword">struct</span> bus_attribute *attr)</span></span><br></pre></td></tr></table></figure>

<p>可用BUS_ATTR宏来初始化一个 bus_attribute 结构体。调用 bus_create_file() 函数创建总线属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">show_bus_version</span><span class="params">(<span class="keyword">struct</span> bus_type *bus, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">snprintf</span>(buf, PAGE_SIZE, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;revision: 1.0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">BUS_ATTR</span><span class="params">(version, S_IRUGO, show_bus_version, <span class="literal">NULL</span>)</span>;</span><br><span class="line"></span><br><span class="line">bus_create_file(&amp;my_bus_type, &amp;bus_attr_version)</span><br></pre></td></tr></table></figure>

<h2 id="device"><a href="#device" class="headerlink" title="device"></a>device</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>  *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_private</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>  *init_name; <span class="comment">/* initial name of the device */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>  <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span>  <span class="comment">/* type of bus device is on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span> <span class="comment">/* which driver has allocated this device */</span></span><br><span class="line">    <span class="type">void</span>  *platform_data; <span class="comment">/* Platform specific data, device core doesn&#x27;t touch it */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_info</span> <span class="title">power</span>;</span></span><br><span class="line">    u64  *dma_mask;</span><br><span class="line">    u64  coherent_dma_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_dma_parameters</span> *<span class="title">dma_parms</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dma_pools</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dma_coherent_mem</span> *<span class="title">dma_mem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line">    <span class="type">dev_t</span>   devt; <span class="comment">/* dev_t, creates the sysfs &quot;dev&quot; */</span></span><br><span class="line">    <span class="type">spinlock_t</span>  devres_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">devres_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span>  *<span class="keyword">class</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span> <span class="comment">/* optional groups */</span></span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="device-register"><a href="#device-register" class="headerlink" title="device_register()"></a>device_register()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">device_register</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">   device_initialize(dev);</span><br><span class="line">   <span class="keyword">return</span> device_add(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">device_initialize</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">   dev-&gt;kobj.kset = devices_kset;</span><br><span class="line">   kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype);</span><br><span class="line">   INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);</span><br><span class="line">   mutex_init(&amp;dev-&gt;mutex);</span><br><span class="line">   lockdep_set_novalidate_class(&amp;dev-&gt;mutex);</span><br><span class="line">   spin_lock_init(&amp;dev-&gt;devres_lock);</span><br><span class="line">   INIT_LIST_HEAD(&amp;dev-&gt;devres_head);</span><br><span class="line">   device_pm_init(dev);</span><br><span class="line">   set_dev_node(dev, <span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">   INIT_LIST_HEAD(&amp;dev-&gt;msi_list);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   INIT_LIST_HEAD(&amp;dev-&gt;links.consumers);</span><br><span class="line">   INIT_LIST_HEAD(&amp;dev-&gt;links.suppliers);</span><br><span class="line">   dev-&gt;links.status = DL_DEV_NO_DRIVER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">device_add</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">class_interface</span> *<span class="title">class_intf</span>;</span></span><br><span class="line">   <span class="type">int</span> error = -EINVAL;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">glue_dir</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   dev = get_device(dev);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!dev-&gt;p) &#123;</span><br><span class="line">      error = device_private_init(dev);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (dev-&gt;init_name) &#123;</span><br><span class="line">      dev_set_name(dev, <span class="string">&quot;%s&quot;</span>, dev-&gt;init_name);</span><br><span class="line">      dev-&gt;init_name = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* subsystems can specify simple device enumeration */</span></span><br><span class="line">   <span class="keyword">if</span> (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)</span><br><span class="line">      dev_set_name(dev, <span class="string">&quot;%s%u&quot;</span>, dev-&gt;bus-&gt;dev_name, dev-&gt;id);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!dev_name(dev)) &#123;</span><br><span class="line">      error = -EINVAL;</span><br><span class="line">      <span class="keyword">goto</span> name_error;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   parent = get_device(dev-&gt;parent);</span><br><span class="line">   kobj = get_device_parent(dev, parent);</span><br><span class="line">   <span class="keyword">if</span> (kobj)</span><br><span class="line">      dev-&gt;kobj.parent = kobj;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* use parent numa_node */</span></span><br><span class="line">   <span class="keyword">if</span> (parent &amp;&amp; (dev_to_node(dev) == NUMA_NO_NODE))</span><br><span class="line">      set_dev_node(dev, dev_to_node(parent));</span><br><span class="line"></span><br><span class="line">   error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* notify platform of device entry */</span></span><br><span class="line">   error = device_platform_notify(dev, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">   error = device_create_file(dev, &amp;dev_attr_uevent);</span><br><span class="line"></span><br><span class="line">   error = device_add_class_symlinks(dev);</span><br><span class="line">   error = device_add_attrs(dev);</span><br><span class="line">   error = bus_add_device(dev);</span><br><span class="line">   error = dpm_sysfs_add(dev);</span><br><span class="line">   device_pm_add(dev);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (MAJOR(dev-&gt;devt)) &#123;</span><br><span class="line">      error = device_create_file(dev, &amp;dev_attr_dev);</span><br><span class="line"></span><br><span class="line">      error = device_create_sys_dev_entry(dev);</span><br><span class="line"></span><br><span class="line">      devtmpfs_create_node(dev);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">      blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                    BUS_NOTIFY_ADD_DEVICE, dev);</span><br><span class="line"></span><br><span class="line">   kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</span><br><span class="line">   bus_probe_device(dev);</span><br><span class="line">   <span class="keyword">if</span> (parent)</span><br><span class="line">      klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</span><br><span class="line">                &amp;parent-&gt;p-&gt;klist_children);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (dev-&gt;class) &#123;</span><br><span class="line">      mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">      <span class="comment">/* tie the class to the device */</span></span><br><span class="line">      klist_add_tail(&amp;dev-&gt;knode_class,</span><br><span class="line">                &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* notify any interfaces that the device is here */</span></span><br><span class="line">      list_for_each_entry(class_intf,</span><br><span class="line">                &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</span><br><span class="line">         <span class="keyword">if</span> (class_intf-&gt;add_dev)</span><br><span class="line">            class_intf-&gt;add_dev(dev, class_intf);</span><br><span class="line">      mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="device-attribute"><a href="#device-attribute" class="headerlink" title="device_attribute"></a>device_attribute</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>   <span class="title">attr</span>;</span></span><br><span class="line">   <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">         <span class="type">char</span> *buf);</span><br><span class="line">   <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">          <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_ATTR(_name, _mode, _show, _store) \</span></span><br><span class="line"><span class="meta">   struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *attr)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr)</span></span><br></pre></td></tr></table></figure>

<h2 id="device-driver"><a href="#device-driver" class="headerlink" title="device_driver"></a>device_driver</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 驱动程序的名称 */</span></span><br><span class="line">    <span class="type">char</span>   *name;</span><br><span class="line">    <span class="comment">/* 指向总线描述符的指针。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>  *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 禁止卸载设备驱动程序的信号量。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">unload_sem</span>;</span></span><br><span class="line">    <span class="comment">/* 内嵌kobject */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>  <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="comment">/* 驱动程序所支持的所有设备组成的链表的首部。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">devices</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 驱动程序所在模块（如果有的话） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>   *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 探测设备的方法 */</span></span><br><span class="line">    <span class="type">int</span> (*probe) (<span class="keyword">struct</span> device *dev);</span><br><span class="line">    <span class="comment">/* 移走设备的方法（检测设备驱动程序是否可以控制该设备） */</span></span><br><span class="line">    <span class="type">int</span>  (*remove) (<span class="keyword">struct</span> device *dev);</span><br><span class="line">    <span class="comment">/* 设备断电时调用的方法。 */</span></span><br><span class="line">    <span class="type">void</span> (*shutdown) (<span class="keyword">struct</span> device *dev);</span><br><span class="line">    <span class="comment">/* 设备置于低功率状态时所调用的方法 */</span></span><br><span class="line">    <span class="type">int</span> (*suspend) (<span class="keyword">struct</span> device *dev, u32 state, u32 level);</span><br><span class="line">    <span class="comment">/* 设备恢复正常状态时所调用的方法 */</span></span><br><span class="line">    <span class="type">int</span> (*resume) (<span class="keyword">struct</span> device *dev, u32 level);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="driver-register"><a href="#driver-register" class="headerlink" title="driver_register()"></a>driver_register()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">driver_register</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> ret;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">other</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||</span><br><span class="line">       (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||</span><br><span class="line">       (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))</span><br><span class="line">      printk(KERN_WARNING <span class="string">&quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span></span><br><span class="line">         <span class="string">&quot;bus_type methods\n&quot;</span>, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">   other = driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line"></span><br><span class="line">   ret = bus_add_driver(drv);</span><br><span class="line"></span><br><span class="line">   ret = driver_add_groups(drv, drv-&gt;groups);</span><br><span class="line"></span><br><span class="line">   kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="driver-attribute"><a href="#driver-attribute" class="headerlink" title="driver_attribute"></a>driver_attribute</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">   <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device_driver *driver, <span class="type">char</span> *buf);</span><br><span class="line">   <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device_driver *driver, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_ATTR(_name, _mode, _show, _store)   \</span></span><br><span class="line"><span class="meta">struct driver_attribute driver_attr_##_name =      \</span></span><br><span class="line"><span class="meta">   __ATTR(_name, _mode, _show, _store)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">driver_create_file</span><span class="params">(<span class="keyword">struct</span> device_driver *drv, <span class="type">const</span> <span class="keyword">struct</span> driver_attribute *attr)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">driver_remove_file</span><span class="params">(<span class="keyword">struct</span> device_driver *drv, <span class="keyword">struct</span> driver_attribute *attr)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>char device</title>
    <url>/2022/09/04/kernel/cdev/</url>
    <content><![CDATA[<p>字符设备是一个顺序的数据流设备，对设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。不具备缓冲区，所以对字符设备的读写是实时的。</p>
<p>创建一个字符设备的步骤：</p>
<ol>
<li>申请然后注册设备号。</li>
<li>实例一个cdev结构体。</li>
<li>实现字符设备的文件操作函数，然后用cdev_init()函数初始化cdev。</li>
<li>使用cdev_add()函数添加设备号。以上几步也可以直接用register_chrdev函数代替。</li>
<li>使用device_create()函数在/dev/下创建设备节点。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">register_chrdev_region(chardev-&gt;devno, <span class="number">1</span>, CHARDEV_DEV_NAME);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">alloc_chrdev_region(&amp;chardev-&gt;devno, <span class="number">0</span>, <span class="number">1</span>, CHARDEV_DEV_NAME);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">cdev_init(&amp;chardev-&gt;cdev, &amp;chardev_fops);</span><br><span class="line">chardev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_add(&amp;chardev-&gt;cdev, chardev-&gt;devno, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在/sys/class/目录下创建设备 */</span></span><br><span class="line">chardev-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, CHARDEV_DEV_NAME);</span><br><span class="line"></span><br><span class="line">device_create(chardev-&gt;class, <span class="literal">NULL</span>, chardev-&gt;devno, <span class="literal">NULL</span>, CHARDEV_DEV_NAME);</span><br></pre></td></tr></table></figure>

<p>卸载设备时，需要将之前创建的cdev、设备号、设备结点一并销毁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cdev_del(&amp;chardev-&gt;cdev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 销毁设备节点 */</span></span><br><span class="line">device_destroy(chardev-&gt;class, chardev-&gt;devno);</span><br><span class="line"></span><br><span class="line">class_destroy(chardev-&gt;class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注销设备号*/</span></span><br><span class="line">unregister_chrdev_region(chardev-&gt;devno, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">cdev</span>;</span></span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="type">int</span> err = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配请求的设备号范围。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cd = __register_chrdev_region(major, <span class="number">0</span>, <span class="number">256</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(cd))<span class="comment">/* 设备号冲突，返回。 */</span></span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(cd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为设备驱动程序分配一个新的cdev结构 */</span></span><br><span class="line">    cdev = cdev_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化cdev结构 */</span></span><br><span class="line">    cdev-&gt;owner = fops-&gt;owner;</span><br><span class="line">    cdev-&gt;ops = fops;</span><br><span class="line">    kobject_set_name(&amp;cdev-&gt;kobj, <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="keyword">for</span> (s = <span class="built_in">strchr</span>(kobject_name(&amp;cdev-&gt;kobj),<span class="string">&#x27;/&#x27;</span>); s; s = <span class="built_in">strchr</span>(s, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">        *s = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将设备添加到设备驱动模型中 */</span></span><br><span class="line">    cdev_add(cdev, MKDEV(cd-&gt;major, <span class="number">0</span>), <span class="number">256</span>);</span><br><span class="line">    cd-&gt;cdev = cdev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> major ? <span class="number">0</span> : cd-&gt;major;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unregister_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">    cd = __unregister_chrdev_region(major, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">if</span> (cd &amp;&amp; cd-&gt;cdev)</span><br><span class="line">        cdev_del(cd-&gt;cdev);</span><br><span class="line">    kfree(cd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h2><p>设备号分为主设备号和次设备号，主设备号用来标识设备类型，次设备号用来区分同类型的设备，分别为dev_t的高12位和低20位。inode 结构i_rdev 字段包含设备号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS   20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORMASK   ((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*分解出主设备号*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR(dev)    ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*分解出次设备号*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINOR(dev)    ((unsigned int) ((dev) &amp; MINORMASK))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*合成dev_t*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,mi)  (((ma) &lt;&lt; MINORBITS) | (mi))</span></span><br></pre></td></tr></table></figure>

<p>设备号可以是动态分配，也可以是静态注册，如果是静态注册，需要避免与系统现有的设备号不冲突，内核Documents 目录下的devices.txt 文件，里面描述了linux设备号的分配情况，可供参考。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 静态注册，设备号已知 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 动态注册，设备号未知 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注销设备号*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>可以通过读取/proc/devices文件获取字符设备和块设备的设备号信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Character devices:</span><br><span class="line">  4 tty</span><br><span class="line">  5 /dev/tty</span><br><span class="line">  5 /dev/console</span><br><span class="line"> 10 misc</span><br><span class="line"> 13 input</span><br><span class="line"> 89 i2c</span><br><span class="line">180 usb</span><br><span class="line">249 watchdog</span><br><span class="line">250 rtc</span><br><span class="line">254 gpiochip</span><br><span class="line"></span><br><span class="line">Block devices:</span><br><span class="line">259 blkext</span><br><span class="line">  7 loop</span><br><span class="line">  8 sd</span><br><span class="line">  9 md</span><br><span class="line"> 11 sr</span><br><span class="line"> 65 sd</span><br></pre></td></tr></table></figure>

<h2 id="cdev结构体"><a href="#cdev结构体" class="headerlink" title="cdev结构体"></a>cdev结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span> <span class="comment">/* 内嵌的 kobject 对象 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> <span class="comment">/*所属模块*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">/*文件操作结构体*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev; <span class="comment">/*设备号*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count; /引用计数*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/kernel/char/cdev-file_ops.png" alt="cdev-file_ops"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cdev *<span class="title function_">cdev_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span> =</span> kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cdev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        INIT_LIST_HEAD(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">        kobject_init(&amp;p-&gt;kobj, &amp;ktype_cdev_dynamic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">    INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">    kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">    cdev-&gt;ops = fops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    p-&gt;dev = dev;</span><br><span class="line">    p-&gt;count = count;</span><br><span class="line"></span><br><span class="line">    error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line">             exact_match, exact_lock, p);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    kobject_get(p-&gt;kobj.parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_unmap(p-&gt;dev, p-&gt;count);</span><br><span class="line">    kobject_put(&amp;p-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_put</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span> =</span> p-&gt;owner;</span><br><span class="line">        kobject_put(&amp;p-&gt;kobj);</span><br><span class="line">        module_put(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h2><p>class_create()在/sys/class/目录下创建设备类。再调用 device_create()函数来在/dev目录下创建相应的设备节点。当加载模块时，用户空间中的udev会自动去/sysfs下寻找对应的类从而创建设备节点。</p>
<p><code>udevadm info</code>命令可以查看/dev下的设备节点信息。可以通过<code>mknod</code>命令来手动创建设备节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mknod [选项] name &#123;bcp&#125; major minor</span><br><span class="line"></span><br><span class="line">选项： </span><br><span class="line">-Z：设置安全的上下文;</span><br><span class="line">-m：设置权限模式;</span><br><span class="line">-help：显示帮助信息;</span><br><span class="line">--version：显示版本信息;</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">b 创建块设备;</span><br><span class="line">c 创建字符设备;</span><br><span class="line">p 创建命名管道;</span><br></pre></td></tr></table></figure>

<h2 id="file结构体"><a href="#file结构体" class="headerlink" title="file结构体"></a>file结构体</h2><p>file 结构体代表一个打开的设备文件，每个打开的文件在内核空间都关联一个struct file，在打开文件时创建，在文件关闭后释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">f_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>  *<span class="title">f_dentry</span>;</span> <span class="comment">// 文件对应的目录项结构，可用filp-&gt;f_dentry-&gt;d_inode的方式来访问索引节点结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span>         *<span class="title">f_vfsmnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span> <span class="comment">// 文件相关的操作</span></span><br><span class="line">    <span class="type">atomic_t</span>  f_count; <span class="comment">// 文件对象的引用计数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>   f_flags; <span class="comment">// 文件标志，如O_RONLY、O_NONBLOCK和O_SYNC</span></span><br><span class="line">    <span class="type">mode_t</span>   f_mode; <span class="comment">// 文件模式，FMODE_READ和FMODE_WRITE分别表示读写权限</span></span><br><span class="line">    <span class="type">int</span>   f_error;</span><br><span class="line">    <span class="type">loff_t</span>   f_pos; <span class="comment">// 当前的读写位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span> <span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  f_uid, f_gid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> <span class="title">f_ra</span>;</span></span><br><span class="line">    <span class="type">size_t</span>   f_maxcount;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  f_version;</span><br><span class="line">    <span class="type">void</span>   *f_security;</span><br><span class="line">    <span class="type">void</span>   *private_data;  <span class="comment">// 文件私有数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">f_ep_links</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span>  f_ep_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h2><p>file_operations 是对设备操作的抽象结构体，应用程序和VFS之间的接口是系统调用，而VFS与磁盘文件系统以及普通设备之间的接口是file_operations 结构体成员函数。应用程序进行open、write、read、close等系统调用，最终都会引起file_operations 结构体对应函数的调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">    <span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="inode结构体"><a href="#inode结构体" class="headerlink" title="inode结构体"></a>inode结构体</h2><p>inode结构体用来记录文件的物理上的信息，包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等信息。一个文件可以对应多个file结构，但只有一个inode 结构。它是Linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">umode_t</span>         i_mode;  <span class="comment">/* inode 的权限 */</span></span><br><span class="line">    <span class="type">uid_t</span>           i_uid;   <span class="comment">/* inode 拥有者的 id */</span></span><br><span class="line">    <span class="type">gid_t</span>           i_gid;   <span class="comment">/* inode 所属的群组 id */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>   *<span class="title">i_op</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>  *<span class="title">i_sb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">spinlock_t</span>          i_lock; <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       i_state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">i_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       dirtied_when;   <span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>   <span class="title">i_hash</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_wb_list</span>;</span>  <span class="comment">/* backing dev IO list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_lru</span>;</span>      <span class="comment">/* inode LRU list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_dentry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">i_rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   i_ino;</span><br><span class="line">    <span class="type">atomic_t</span>        i_count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    i_nlink;</span><br><span class="line">    <span class="type">dev_t</span>           i_rdev;  <span class="comment">/* 若是设备文件,此字段将记录设备的设备号 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    i_blkbits;</span><br><span class="line">    u64             i_version;</span><br><span class="line">    <span class="type">loff_t</span>          i_size;  <span class="comment">/* inode 所代表的文件大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_atime</span>;</span> <span class="comment">/* inode 最近一次的存取时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_mtime</span>;</span> <span class="comment">/* inode 最近一次的修改时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_ctime</span>;</span> <span class="comment">/* inode 的产生时间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">blkcnt_t</span>        i_blocks;  <span class="comment">/* inode 所使用的 block 数,一个 block为512 byte */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  i_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">i_alloc_sem</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span> <span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_lock</span>    *<span class="title">i_flock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span>  <span class="comment">/*若是块设备,为其对应的 block_device 结构体指针*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>     *<span class="title">i_cdev</span>;</span>  <span class="comment">/*若是字符设备,为其对应的 cdev 结构体指针*/</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">void</span>            *i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>应用程序每打开一个设备文件，就会产生一个inode节点，通过结点的i_cdev字段找到cdev结构体，再通过cdev的ops指针，就能找到设备的操作函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">light_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 获得设备结构体指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">light_dev</span> *<span class="title">dev</span> =</span> container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> light_dev, cdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 让设备结构体作为设备的私有信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">light_object</span> *<span class="title">obj</span> =</span> kmalloc(<span class="keyword">sizeof</span> (<span class="keyword">struct</span> light_object), GFP_KERNEL);</span><br><span class="line">    filp-&gt;private_data = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">light_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">light_object</span> *<span class="title">obj</span> =</span> (<span class="keyword">struct</span> light_object *)file-&gt;private_data;</span><br><span class="line">    kfree(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">light_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, </span></span><br><span class="line"><span class="params">    <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chardev_object</span> *<span class="title">obj</span> =</span> file-&gt;private_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inode节点的i_devices 成员和cdev的 list 相关联，这样文件就和字符设备绑定了，操作文件就等同在操作设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode * inode, <span class="keyword">struct</span> file * filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_add(&amp;inode-&gt;i_devices, &amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">    cdev_put(new);</span><br><span class="line"></span><br><span class="line">    filp-&gt;f_op = fops_get(p-&gt;ops);</span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_op-&gt;open) &#123;</span><br><span class="line">        lock_kernel();</span><br><span class="line">        ret = filp-&gt;f_op-&gt;open(inode,filp);</span><br><span class="line">        unlock_kernel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">def_chr_fops</span> =</span> &#123;</span><br><span class="line">    .open = chrdev_open,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_special_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">umode_t</span> mode, <span class="type">dev_t</span> rdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    inode-&gt;i_mode = mode;</span><br><span class="line">    <span class="keyword">if</span> (S_ISCHR(mode)) &#123;</span><br><span class="line">        inode-&gt;i_fop = &amp;def_chr_fops;</span><br><span class="line">        inode-&gt;i_rdev = rdev;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">chardev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, </span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chardev_object</span> *<span class="title">dev</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> xxx:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            printk(KERN_WARNING <span class="string">&quot;cmd invalid\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> - EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ioctl() 函数的cmd参数是自定义的IO控制命令，用于设备驱动区别应用程序的请求内容，大小为32位，分为4个域：</p>
<ul>
<li><p><strong>bit[31:30]</strong>: 区别读写命令，值可能是 <code>_IOC_NONE</code> 表示无数据传输，<code>_IOC_READ</code> (读)， <code>_IOC_WRITE</code> (写) ， <code>_IOC_READ|_IOC_WRITE</code> (双向)。</p>
</li>
<li><p><strong>bit[29:15]</strong>: 数据大小，表示 ioctl() 中的 arg 变量传送的内存大小。</p>
</li>
<li><p><strong>bit[20:8]</strong>: 魔数，这个值用以与其它设备驱动程序的 ioctl 命令进行区别，魔数范围为 0~255 。通常用英文字符 “A” ~ “Z” 或者 “a” ~ “z” 来表示。</p>
</li>
<li><p><strong>bit[7:0]</strong>: 区别序号，是命令的顺序序号。</p>
</li>
</ul>
<p>Doucumention/ioctl-number.txt文件中罗列了内核所使用的幻数，自己选择的幻数要避免和内核冲突。内核定义了 <code>_IO()</code> , <code>_IOR()</code> , <code>IOW()</code> 和 <code>_IOWR()</code> 4 个宏用来来辅助生成上面的 cmd 。注意cmd不能为2。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序数（number）字段的字位宽度，8bits</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRBITS      8 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPEBITS    8 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZEBITS    14 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIRBITS     2 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         _IOC_NRMASK        ((1 &lt;&lt; _IOC_NRBITS)-1)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         _IOC_TYPEMASK   ((1 &lt;&lt; _IOC_TYPEBITS)-1) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         _IOC_SIZEMASK     ((1 &lt;&lt; _IOC_SIZEBITS)-1)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         _IOC_DIRMASK      ((1 &lt;&lt; _IOC_DIRBITS)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        _IOC_NRSHIFT       0  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        _IOC_TYPESHIFT   (_IOC_NRSHIFT+_IOC_NRBITS) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        _IOC_SIZESHIFT    (_IOC_TYPESHIFT+_IOC_TYPEBITS) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        _IOC_DIRSHIFT      (_IOC_SIZESHIFT+_IOC_SIZEBITS)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NONE     0U  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_WRITE   1U   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_READ     2U </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*_IOC 宏将dir，type，nr，size四个参数组合成一个cmd参数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC(dir,type,nr,size) \</span></span><br><span class="line"><span class="meta">       (((dir)  &lt;&lt; _IOC_DIRSHIFT) | \</span></span><br><span class="line"><span class="meta">        ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span></span><br><span class="line"><span class="meta">        ((nr)   &lt;&lt; _IOC_NRSHIFT) | \</span></span><br><span class="line"><span class="meta">        ((size) &lt;&lt; _IOC_SIZESHIFT))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造无参数的命令编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO(type,nr)          _IOC(_IOC_NONE,(type),(nr),0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造从驱动程序中读取数据的命令编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR(type,nr,size)    _IOC(_IOC_READ,(type),(nr),sizeof(size)) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于向驱动程序写入数据命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW(type,nr,size)    _IOC(_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于双向传输</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR(type,nr,size)   _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从命令参数中解析出数据方向，即写进还是读出</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr)    (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从命令参数中解析出幻数type</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr)   (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从命令参数中解析出序数number</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr)           (((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从命令参数中解析出用户数据大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr)     (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_IN            (_IOC_WRITE &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_OUT         (_IOC_READ &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_INOUT     ((_IOC_WRITE|_IOC_READ) &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_MASK      (_IOC_SIZEMASK &lt;&lt; _IOC_SIZESHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_SHIFT      (_IOC_SIZESHIFT)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>device tree</title>
    <url>/2022/09/04/kernel/dts/</url>
    <content><![CDATA[<p>设备树可以描述的信息包括CPU的数量和类别、内存基地址和大小、总线和桥、外设连接、中断控制器和中断使用情况、GPIO控制器和GPIO使用情况、Clock控制器和Clock使用情况。另外，设备树对于可热插拔的热备不进行具体描述，它只描述用于控制该热插拔设备的控制器。对于同一SOC的不同主板，只需更换设备树文件.dtb即可实现不同主板的无差异支持，而无需更换内核文件。</p>
<p>设备树中的设备树节点在文件系统中有与之对应的文件，位于/proc/device-tree目录。在这里子节点是一个文件夹，属性是一个文件。设备节点属性的设置方法可参考内核文档Documentation/devicetree。</p>
<p><a href="https://www.devicetree.org/">https://www.devicetree.org/</a></p>
<p>设备树包含DTC（device tree compiler），DTS（device tree source和DTB（device tree blob）。</p>
<h2 id="DTS"><a href="#DTS" class="headerlink" title="DTS"></a>DTS</h2><p>dts文件是一种ASCII文本对Device Tree的描述，放置在内核的/arch/arm/boot/dts目录。一般而言，一个dts文件对应一个ARM的板子。</p>
<p>由于一个SOC可能有多个不同的电路板，而每个电路板拥有一个dts文件。这些dts势必会存在许多共同部分，为了减少代码的冗余，设备树将这些共同部分提炼保存在dtsi文件中，供不同的dts共同使用，使用时需要包含dtsi文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exynos4.dtsi&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>device tree的基本单元是node。这些node被组织成树状结构，除了root node，每个node都只有一个parent。一个dts文件中只能有一个root node。</p>
<p>每一个“{}”都是一个设备树节点，“{}”中包含的内容是节点属性，属性的定义采用property ＝ value的形式，value有三种情况：</p>
<ul>
<li>字符串或字符串数组，用双引号表示。</li>
<li>u32整数，用尖括号表示。</li>
<li>二进制数，用方括号表示。</li>
</ul>
<p>设备树中的每个节点都按照以下节点基本格式：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">[label:] node-name[<span class="keyword">@unit</span>-address] &#123; </span><br><span class="line">   [properties definitions] </span><br><span class="line">   [child nodes] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>label定义一个标签，是可选的，在标签名前加“&amp;”符号就可引用该节点。</p>
</li>
<li><p>node-name 用于标识节点的名称，root node的节点名必须是“/”。</p>
</li>
<li><p><code>@unit-address</code> ，其中“@”符号是分割符，“unit-address”是单元地址， 它的值要和节点<code>reg</code>属性的第一个地址一致。如果节点没有<code>reg</code>属性，可以直接省略， 不过这时要求同级别的设备树下节点名唯一。同级别的子节点的节点名可以相同，但是要求地址不同，node-name@unit-address 的整体要求同级唯一。</p>
</li>
</ul>
<p>子节点前面加一个“&amp;”符号， 这表示该节点在向已经存在的子节点追加数据。</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h4 id="chosen"><a href="#chosen" class="headerlink" title="chosen"></a>chosen</h4><p>chosen 节点主要用来描述由系统firmware指定的runtime parameter。如果存在chosen node，其parent node必须是根节点。可以用作uboot向linux内核传递配置参数，如：<code>bootargs</code> ,<code>console</code>。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/mmcblk0p2 rw rootfstype=ext4 rootdelay=1 rootwait&quot;</span>;</span><br><span class="line">        stdout-path = <span class="string">&quot;serial2:115200n8&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h4 id="aliases"><a href="#aliases" class="headerlink" title="aliases"></a>aliases</h4><p>aliases 节点定义了一个别名。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">    spi0 = &amp;spi_0;</span><br><span class="line">    i2c0 = &amp;i2c_0;</span><br><span class="line">    serial0 = &amp;serial_0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h4><p>memory node是所有设备树文件的必备节点，它定义了系统物理内存的layout。对于memory node，其<code>device_type</code>属性必须等于<code>memory</code>。<code>reg</code>属性定义了memory的起始地址和长度。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">memory@<span class="number">40000000</span> &#123;</span><br><span class="line">    device_type = <span class="string">&quot;memory&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0</span>x40000000 <span class="number">0</span>x40000000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="interrupt-controller"><a href="#interrupt-controller" class="headerlink" title="interrupt-controller"></a>interrupt-controller</h4><figure class="highlight d"><table><tr><td class="code"><pre><span class="line">gic: interrupt-controller@<span class="number">10490000</span> &#123;</span><br><span class="line">    #interrupt-cells = &lt;<span class="number">3</span>&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">wakup_eint: wakeup-interrupt-controller &#123;</span><br><span class="line">    interrupt-parent = &lt;&amp;gic&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">32</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>interrupt-controller</code> 是一个空属性，用来声明这个node是一个中断控制器。</li>
<li><code>#interrupt-cells</code>标识这个控制器需要几个单位做中断描述符，描述子节点中<code>interrupts</code>属性使用了父节点中<code>interrupts</code>属性的具体的哪个值。如果父节点的属性値是3，则子节点<code>interrupts</code>属性中的3个值分别代表&lt;中断域 中断 触发方式&gt;；如果父节点的属性値是2，则是&lt;中断 触发方式&gt;。</li>
<li><code>interrupt-parent</code>标识此设备节点属于哪一个中断控制器，如果没有设置这个属性，会自动依附父节点的。</li>
<li><code>interrupts</code>标识一个中断。而具体每个cell的含义，由驱动的实现决定，也会在Device Tree的binding文档中说明。</li>
</ul>
<h4 id="gpio-controller"><a href="#gpio-controller" class="headerlink" title="gpio-controller"></a>gpio-controller</h4><figure class="highlight d"><table><tr><td class="code"><pre><span class="line">gpa0: gpa0 &#123;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    #gpio-cells = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gpio-controller</code>是一个空属性，用来说明该节点描述的是一个gpio控制器。</li>
<li><code>#gpio-cells</code>用来描述gpio使用节点的属性一个cell的内容，即 `属性 = &lt;&amp;引用gpio节点别名  gpio号  有效电平&gt;</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="compatible"><a href="#compatible" class="headerlink" title="compatible"></a>compatible</h4><figure class="highlight d"><table><tr><td class="code"><pre><span class="line">leds &#123;</span><br><span class="line">    compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line"></span><br><span class="line">    led2 &#123;</span><br><span class="line">        label = <span class="string">&quot;red:system&quot;</span>;</span><br><span class="line">        gpios = &lt;&amp;gpl2 <span class="number">0</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">        <span class="keyword">default</span>-state = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">        linux,<span class="keyword">default</span>-trigger = <span class="string">&quot;heartbeat&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    led3 &#123;</span><br><span class="line">        label = <span class="string">&quot;red:user&quot;</span>;</span><br><span class="line">        gpios = &lt;&amp;gpk1 <span class="number">1</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">        <span class="keyword">default</span>-state = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>compatible属性值由一个或多个字符串组成，有多个字符串时使用“,”分隔开。</p>
<p>设备树中的每个设备节点都有一个compatible属性，compatible属性用于驱动和设备的绑定。platform总线根据设备节点”compatible”属性和驱动程序中的of_match_table指针所指向的of_device_id结构里的compatible字段匹配的，只有dts里的compatible字段的名字和驱动程序中of_device_id里的compatible字段的名字一样，驱动程序才能进入probe函数。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> of_device_id of_gpio_leds_match[] = &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;gpio-leds&quot;</span>, &#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> platform_driver gpio_led_driver = &#123;</span><br><span class="line">    .probe      = gpio_led_probe,</span><br><span class="line">    .shutdown   = gpio_led_shutdown,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;leds-gpio&quot;</span>,</span><br><span class="line">        .of_match_table = of_gpio_leds_match,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="model"><a href="#model" class="headerlink" title="model"></a>model</h4><p>model属性用于指定设备的制造商和型号，格式自定义。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">model = <span class="string">&quot;TOPEET iTop 4412 Elite board based on Exynos4412&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="status"><a href="#status" class="headerlink" title="status"></a>status</h4><p>status属性用于指示设备的操作状态，可以禁止设备或者启用设备，默认情况下不设置status属性设备是使能的。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">status = <span class="string">&quot;disabled&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="ranges"><a href="#ranges" class="headerlink" title="ranges"></a>ranges</h4><p>ranges属性为地址转换表，表明了子节点地址空间和父地址空间的映射方法，常见格式是<code>ranges = &lt;子地址, 父地址, 转换长度&gt;</code>。 如果父地址空间和子地址空间相同则无需转换，只写<code>renges,</code>内容为空，或直接省略renges属性。</p>
<p>比如对于#address-cells和#size-cells都为1的话，以ranges=&lt;0x0 0x10 0x20&gt;为例，表示将子地址的从0x0<del>(0x0 + 0x20)的地址空间映射到父地址的0x10</del>(0x10 + 0x20)。</p>
<h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>name属性在旧的设备树中用于确定节点名， 现在已经弃用。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;name&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="device-type"><a href="#device-type" class="headerlink" title="device_type"></a>device_type</h4><p>对于device node，device_type属性定义了该node的设备类型，如<code>cpu</code>、<code>serial</code>等。对于memory node，其device_type属性必须等于<code>memory</code>。</p>
<h4 id="reg"><a href="#reg" class="headerlink" title="reg"></a>reg</h4><p>reg用于描述地址的offset和length。该属性的值被解析成任意长度的（address，length）组合，其中address和size的値是在其parent node中的<code>#address-cells</code>和<code>#size-cells</code>属性定义的。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">reg = &lt;<span class="number">0</span>x03830000 <span class="number">0</span>x100&gt;;</span><br></pre></td></tr></table></figure>

<p>如果一个device node中包含了有寻址需求的sub node，那么就必须要定义<code>#address-cells</code>和<code>#size-cells</code>这两个属性。“#”是number的意思，这两个属性是用来描述sub node中的reg属性的地址域特性的，也就是说需要用多少个u32的cell来描述该地址域。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    #address-cells = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">    #size-cells = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="获取节点信息"><a href="#获取节点信息" class="headerlink" title="获取节点信息"></a>获取节点信息</h2><p>内核提供了一组函数用于获取设备节点属性的函数，这些函数以of_开头，称为OF操作函数。</p>
<h3 id="device-node"><a href="#device-node" class="headerlink" title="device_node"></a>device_node</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;  <span class="comment">/* 节点中属性为name的值 */</span></span><br><span class="line">    phandle phandle;  <span class="comment">/* 节点中属性为device_type的值 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *full_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">property</span> *<span class="title">properties</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">property</span> *<span class="title">deadprops</span>;</span>    <span class="comment">/* removed properties */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">device_node</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">device_node</span> *<span class="title">sibling</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> _flags;</span><br><span class="line">    <span class="type">void</span>    *data;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> unique_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 根据节点路径寻找 */</span></span><br><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据节点名字寻找，from指定从哪个节点开始查找，它本身并不在查找行列中，只查找它后面的节点，如果设置为NULL表示从根节点开始查找。 */</span></span><br><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_name</span><span class="params">(<span class="keyword">struct</span> device_node *from,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据节点类型寻找 */</span></span><br><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_type</span><span class="params">(<span class="keyword">struct</span> device_node *from,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据节点类型和compatible属性寻找 */</span></span><br><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_compatible_node</span><span class="params">(<span class="keyword">struct</span> device_node *from,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *compat)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 寻找父节点 */</span></span><br><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_parent</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 寻找子节点，寻找的是prev节点之后的节点。这是一个迭代寻找过程，例如寻找第二个子节点，这里就要填第一个子节点。参数为NULL 表示寻找第一个子节点。 */</span></span><br><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_child</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node,</span></span><br><span class="line"><span class="params">                         <span class="keyword">struct</span> device_node *prev)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>    *name;  属性名</span><br><span class="line">    <span class="type">int</span> length;  属性长度</span><br><span class="line">    <span class="type">void</span>    *value;  属性值</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">next</span>;</span>  下一个属性</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> _flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_PROMTREE)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> unique_id;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> <span class="title">attr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="提取属性值"><a href="#提取属性值" class="headerlink" title="提取属性值"></a>提取属性值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取节点属性 */</span></span><br><span class="line"><span class="keyword">struct</span> property *<span class="title function_">of_find_property</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> *lenp)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u32</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">char</span> *propname, u32 *out_value)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u8</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, </span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> *propname, u8 *out_value)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u16</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, </span></span><br><span class="line"><span class="params">                         <span class="type">const</span> <span class="type">char</span> *propname, u16 *out_value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查节点中某个属性是否存在 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">of_property_read_bool</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> <span class="type">char</span> *propname)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_string</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, </span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="type">char</span> *propname, <span class="type">const</span> <span class="type">char</span> **out_string)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u32_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">                         <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">                         u32 *out_values, <span class="type">size_t</span> sz)</span></span><br></pre></td></tr></table></figure>

<h3 id="gpio的获取"><a href="#gpio的获取" class="headerlink" title="gpio的获取"></a>gpio的获取</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据gpio属性的名字获取 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_get_named_gpio</span><span class="params">(<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">char</span> *propname, <span class="type">int</span> index)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_get_gpio</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>

<h3 id="地址的获取"><a href="#地址的获取" class="headerlink" title="地址的获取"></a>地址的获取</h3><p>在设备树的设备节点中大多会包含一些内存相关的属性，比如常用的reg属性。通常情况下，得到寄存器地址之后我们还要通过ioremap函数将物理地址转化为虚拟地址。现在内核提供了of函数，自动完成物理地址到虚拟地址的转换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="type">resource_size_t</span> start;</span><br><span class="line">    <span class="type">resource_size_t</span> end;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> desc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> resource *r)</span></span><br></pre></td></tr></table></figure>

<h3 id="中断的获取"><a href="#中断的获取" class="headerlink" title="中断的获取"></a>中断的获取</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="DTC"><a href="#DTC" class="headerlink" title="DTC"></a>DTC</h2><p>DTC（Device Tree Compiler）为编译工具，它可以将.dts文件编译成.dtb文件。DTC的源码位于内核的scripts/dtc目录，内核选中CONFIG_OF，编译内核的时候，主机可执行程序DTC就会被编译出来。 即scripts/dtc/Makefile中。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">hostprogs-y := dtc</span><br><span class="line"></span><br><span class="line">always := $(hostprogs-y) </span><br></pre></td></tr></table></figure>

<p>在内核的arch/arm/boot/dts/Makefile中，若选中某种SOC，则与其对应相关的所有dtb文件都将编译出来。<code>make dtbs</code>可单独编译dtb。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">ifeq ($(CONFIG_OF),y)</span><br><span class="line"></span><br><span class="line">dtb-$(CONFIG_ARCH_EXYNOS4) += \</span><br><span class="line">    exynos4412-origen.dtb \</span><br><span class="line">    exynos4412-smdk4412.dtb \</span><br><span class="line">    exynos4412-tiny4412.dtb \</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>DTC在编译时，会对node进行合并操作，最终生成的dtb只有一个root node。</p>
<h2 id="DTB"><a href="#DTB" class="headerlink" title="DTB"></a>DTB</h2><p>dtb文件由头（Header）、结构块（device-tree structure）、字符串块（string block）三部分组成。</p>
<p><img src="/images/kernel/device-tree/dtb_struct.png" alt="dtb文件结构"></p>
<h3 id="fdt-header"><a href="#fdt-header" class="headerlink" title="fdt_header"></a>fdt_header</h3><p>设备树文件头信息，存储在dtb文件的开头部分，使用fdt_header结构体描述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_MAGIC   0xd00dfeed  <span class="comment">/* 4: version, 4: total size */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_header</span> &#123;</span></span><br><span class="line">        <span class="type">fdt32_t</span> magic;                   <span class="comment">/* magic word FDT_MAGIC */</span></span><br><span class="line">        <span class="type">fdt32_t</span> totalsize;               <span class="comment">/* total size of DT block */</span></span><br><span class="line">        <span class="type">fdt32_t</span> off_dt_struct;           <span class="comment">/* offset to structure */</span></span><br><span class="line">        <span class="type">fdt32_t</span> off_dt_strings;          <span class="comment">/* offset to strings */</span></span><br><span class="line">        <span class="type">fdt32_t</span> off_mem_rsvmap;          <span class="comment">/* offset to memory reserve map */</span></span><br><span class="line">        <span class="type">fdt32_t</span> version;                 <span class="comment">/* format version */</span></span><br><span class="line">        <span class="type">fdt32_t</span> last_comp_version;       <span class="comment">/* last compatible version */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* version 2 fields below */</span></span><br><span class="line">        <span class="type">fdt32_t</span> boot_cpuid_phys;         <span class="comment">/* Which physical CPU id we&#x27;re</span></span><br><span class="line"><span class="comment">                                            booting on */</span></span><br><span class="line">        <span class="comment">/* version 3 fields below */</span></span><br><span class="line">        <span class="type">fdt32_t</span> size_dt_strings;         <span class="comment">/* size of the strings block */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* version 17 fields below */</span></span><br><span class="line">        <span class="type">fdt32_t</span> size_dt_struct;          <span class="comment">/* size of the structure block */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所有成员都是32位整型，并以大端模式存储；从头部可获知memory reservation block、structure block和strings block部分的起始地址和大小。</p>
<p>使用<code>fdtdump</code>工具对dtb文件进行分析，通过查看fdtdump输出信息以及dtb二进制文件信息。</p>
<p><img src="/images/kernel/device-tree/dtb_dump.png" alt="fdt_header和文件结构之间的关系"></p>
<p>dtb文件结构分为header、fill_area、dt_struct及dt_string四个区域。header为头信息，其中fill_area为填充区域，填充数字0，dt_struct存储节点数值及名称相关信息，dt_string存储属性名。</p>
<h3 id="memory-reservation-block"><a href="#memory-reservation-block" class="headerlink" title="memory reservation block"></a>memory reservation block</h3><p>预留内存区域，用于存放并保护一些重要的数据，与特定平台的实现相关。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_reserve_entry</span> &#123;</span></span><br><span class="line">        <span class="type">fdt64_t</span> address;</span><br><span class="line">        <span class="type">fdt64_t</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="structure-block"><a href="#structure-block" class="headerlink" title="structure block"></a>structure block</h3><p>structure block区域描述了设备树本身的结构和内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_node_header</span>  &#123;</span></span><br><span class="line">    <span class="type">fdt32_t</span>  tag; </span><br><span class="line">    <span class="comment">/* node名称，以&#x27;\0&#x27;结尾的字符串形式，32-bits对齐，不够用0x0补齐 */</span></span><br><span class="line">    <span class="type">char</span>  name[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>fdt_node_header结构体描述节点信息，tag是标识node的起始结束等信息的标志位，name指向node名称的首地址。tag的取值如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_BEGIN_NODE   0x1    <span class="comment">/*  标识一个node的开始 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_END_NODE  0x2    <span class="comment">/*  标识一个node的结束 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PROP   0x3    <span class="comment">/* 标识node节点下面的属性起始符 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_NOP    0x4    <span class="comment">/* 所有的设备树解析程序都会忽略该令牌，一般用于覆盖树中的属性或者节点，以将其从树中删除 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_END    0x9  <span class="comment">/* 标识structure block区域的结 */</span>束</span></span><br></pre></td></tr></table></figure>

<p>对于每个node节点的tag标识符一般为FDT_BEGIN_NODE，对于每个node节点下面的属性的tag标识符一般是FDT_PROP。</p>
<h3 id="strings-block"><a href="#strings-block" class="headerlink" title="strings block"></a>strings block</h3><p>strings block包含了设备树中所有属性的名称。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">fdt_property</span>  &#123;</span></span><br><span class="line">    <span class="type">fdt32_t</span>  tag;</span><br><span class="line">    <span class="comment">/* 表示property value的长度 */</span></span><br><span class="line">    <span class="type">fdt32_t</span>  len;</span><br><span class="line">    <span class="comment">/* property的名称在string block的偏移 */</span></span><br><span class="line">    <span class="type">fdt32_t</span>  nameoff;</span><br><span class="line">    <span class="comment">/* property值，以&#x27;\0&#x27;结尾的字符串形式，32-bits对齐，用0x0补齐 */</span></span><br><span class="line">    <span class="type">char</span>  data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>属性用fdt_property结构体描述，tag标识是属性，取值为FDT_PROP；len为属性值的长度（包括‘\0’，单位字节）；nameoff为属性名称存储位置相对于off_dt_strings的偏移地址。</p>
<p>由于设备树node节点的名称和property value值的长度是不固定的，所以fdt_node_header和fdt_property结构体都使用零长数组的方式进行实现动态长度。</p>
<p><img src="/images/kernel/device-tree/dtb_block.png" alt="dt_struct结构图"></p>
<h3 id="kernel解析设备树"><a href="#kernel解析设备树" class="headerlink" title="kernel解析设备树"></a>kernel解析设备树</h3><p>bootloader在引导内核时，会预先读取dtb文件到内存，然后将地址通过bootm或bootz命令传给内核，<code>bootm [kernel_addr] [initrd_address] [dtb_address]</code>。</p>
<p>kernel会根据Device Tree的结构解析出能够使用的 property结构体。并根据Device Tree中的属性解析出数据来填充 property结构体，并将同一个node节点下面的所有属性通过property.next指针进行链接，形成一个单链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span>  &#123;</span></span><br><span class="line">    <span class="type">char</span>  *name;                          <span class="comment">/* property full name */</span></span><br><span class="line">    <span class="type">int</span>  length;                          <span class="comment">/* property  value length */</span></span><br><span class="line">    <span class="type">void</span>  *value;                         <span class="comment">/* property  value */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">property</span> *<span class="title">next</span>;</span>   <span class="comment">/* next property  under the same node */</span></span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">long</span> _flags;</span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">int</span> unique_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">bin_attribute</span> <span class="title">attr</span>;</span>        <span class="comment">/*属性文件，与sysfs文件系统挂接 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>kernel启动的入口函数为stext，其中会将bootloader传来的dtb地址（物理地址，保存在x21寄存器中）赋值给__fdt_pointer变量。此后执行的start_kernell()函数对dtb文件进行物理地址映射，并进行数据解析。</p>
<p>start_kernel()函数，在early_init_dt_scan_nodes()中会做以下三件事：</p>
<ol>
<li><p>扫描/chosen或者/chose@0节点下面的bootargs属性值到boot_command_line，此外，还处理initrd相关的property，并保存在initrd_start和initrd_end这两个全局变量中；</p>
</li>
<li><p>扫描根节点下面，获取{size,address}-cells信息，并保存在dt_root_size_cells和dt_root_addr_cells全局变量中；</p>
</li>
<li><p>扫描具有device_type = “memory”属性的/memory或者/memory@0节点下面的reg属性值，并把相关信息保存在meminfo中，全局变量meminfo保存了系统内存相关的信息。</p>
</li>
</ol>
<p>Device Tree中的每一个node节点经过kernel处理都会生成一个device_node的结构体，device_node最终会被挂接到具体的device结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>  &#123;</span></span><br><span class="line">    <span class="type">const</span>  <span class="type">char</span> *name;              <span class="comment">/* node的名称，取最后一次“/”和“@”之间子串 */</span></span><br><span class="line">    <span class="type">const</span>  <span class="type">char</span> *type;              <span class="comment">/* device_type的属性名称，没有为&lt;NULL&gt; */</span></span><br><span class="line">    phandle  phandle;               <span class="comment">/* phandle属性值 */</span></span><br><span class="line">    <span class="type">const</span>  <span class="type">char</span> *full_name;   <span class="comment">/*指向该结构体结束的位置，存放node的路径全名，例如：/chosen */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">properties</span>;</span>  <span class="comment">/*指向该节点下的第一个属性，其他属性与该属性链表相接 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">deadprops</span>;</span>   <span class="comment">/* removed properties */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span>   <span class="comment">/*父节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span>    <span class="comment">/*子节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span>  <span class="comment">/*姊妹节点，与自己同等级的node */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>          <span class="comment">/* sysfs文件系统目录体现 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">long</span> _flags;        <span class="comment">/*当前node状态标志位 */</span></span><br><span class="line">    <span class="type">void</span>   *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OF_DYNAMIC        1 <span class="comment">/* node and properties were  allocated via kmalloc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OF_DETACHED       2  <span class="comment">/* node has been detached from the device tree*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OF_POPULATED      3  <span class="comment">/* device already created for the node */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OF_POPULATED_BUS  4 <span class="comment">/* of_platform_populate recursed to children of this node */</span></span></span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://zhuanlan.zhihu.com/p/141623370">https://zhuanlan.zhihu.com/p/141623370</a></p>
<p><a href="https://www.zhihu.com/column/c_1221056483527483392">https://www.zhihu.com/column/c_1221056483527483392</a></p>
<p><a href="http://www.wowotech.net/device_model/dt-code-analysis.html">http://www.wowotech.net/device_model/dt-code-analysis.html</a></p>
]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>gpio driver</title>
    <url>/2022/06/07/kernel/gpiolib/</url>
    <content><![CDATA[<h2 id="gpiolib"><a href="#gpiolib" class="headerlink" title="gpiolib"></a>gpiolib</h2><p>gpiolib的作用是对所有的gpio实行统一管理，因为驱动在工作的时候，会出现好几个驱动共同使用同一个gpio的情况，这会造成混乱，所以内核提供了一些方法来管理gpio资源。代码实现在gpio/gpiolib.c中。</p>
<h3 id="gpio-desc"><a href="#gpio-desc" class="headerlink" title="gpio_desc"></a>gpio_desc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line"><span class="comment">/* flag symbols are bit numbers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_REQUESTED  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_IS_OUT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_RESERVED   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_EXPORT 3   <span class="comment">/* protected by sysfs_lock */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_SYSFS  4   <span class="comment">/* exported via /sys/class/gpio/control */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_TRIG_FALL  5   <span class="comment">/* trigger on falling edge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_TRIG_RISE  6   <span class="comment">/* trigger on rising edge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_ACTIVE_LOW 7   <span class="comment">/* sysfs value has active low */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_SHIFT    16  <span class="comment">/* add new flags before this one */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_FLAGS_MASK     ((1 &lt;&lt; ID_SHIFT) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_TRIGGER_MASK   (BIT(FLAG_TRIG_FALL) | BIT(FLAG_TRIG_RISE))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *label;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> <span class="title">gpio_desc</span>[<span class="title">ARCH_NR_GPIOS</span>];</span></span><br></pre></td></tr></table></figure>

<p>定义了一个gpio_desc结构体数组。</p>
<h3 id="gpio-chip"><a href="#gpio-chip" class="headerlink" title="gpio_chip"></a>gpio_chip</h3><p>gpio_chip 结构体包含了对gpio的各种操作方法，比如设置gpio的输入输出，设置gpio的输出值或者获取值等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *label;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>       *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>       *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         (*request)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="type">void</span>            (*<span class="built_in">free</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         (*direction_input)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="type">int</span>         (*get)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="type">int</span>         (*direction_output)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset, <span class="type">int</span> value);</span><br><span class="line">    <span class="type">int</span>         (*set_debounce)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset, <span class="type">unsigned</span> debounce);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>            (*<span class="built_in">set</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset, <span class="type">int</span> value);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         (*to_irq)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>            (*dbg_show)(<span class="keyword">struct</span> seq_file *s,</span><br><span class="line">                        <span class="keyword">struct</span> gpio_chip *chip);</span><br><span class="line">    <span class="type">int</span>         base;</span><br><span class="line">    u16         ngpio;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *<span class="type">const</span> *names;</span><br><span class="line">    <span class="type">unsigned</span>        can_sleep:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>        exported:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_GPIO)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If CONFIG_OF is enabled, then all GPIO controllers described in the</span></span><br><span class="line"><span class="comment">     * device tree automatically may have an OF translation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line">    <span class="type">int</span> of_gpio_n_cells;</span><br><span class="line">    <span class="type">int</span> (*of_xlate)(<span class="keyword">struct</span> gpio_chip *gc, <span class="keyword">struct</span> device_node *np,</span><br><span class="line">                <span class="type">const</span> <span class="type">void</span> *gpio_spec, u32 *flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="gpiochip-add"><a href="#gpiochip-add" class="headerlink" title="gpiochip_add()"></a>gpiochip_add()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiochip_add</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   flags;</span><br><span class="line">    <span class="type">int</span>     status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span>    id;</span><br><span class="line">    <span class="type">int</span>     base = chip-&gt;base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((!gpio_is_valid(base) || !gpio_is_valid(base + chip-&gt;ngpio - <span class="number">1</span>))</span><br><span class="line">            &amp;&amp; base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        status = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        base = gpiochip_find_base(chip-&gt;ngpio);</span><br><span class="line">        <span class="keyword">if</span> (base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            status = base;</span><br><span class="line">            <span class="keyword">goto</span> unlock;</span><br><span class="line">        &#125;</span><br><span class="line">        chip-&gt;base = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* these GPIO numbers must not be managed by another gpio_chip */</span></span><br><span class="line">    <span class="keyword">for</span> (id = base; id &lt; base + chip-&gt;ngpio; id++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gpio_desc[id].chip != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            status = -EBUSY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (id = base; id &lt; base + chip-&gt;ngpio; id++) &#123;</span><br><span class="line">            gpio_desc[id].chip = chip;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* REVISIT:  most hardware initializes GPIOs as</span></span><br><span class="line"><span class="comment">             * inputs (often with pullups enabled) so power</span></span><br><span class="line"><span class="comment">             * usage is minimized.  Linux code should set the</span></span><br><span class="line"><span class="comment">             * gpio direction first thing; but until it does,</span></span><br><span class="line"><span class="comment">             * we may expose the wrong direction in sysfs.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            gpio_desc[id].flags = !chip-&gt;direction_input</span><br><span class="line">                ? (<span class="number">1</span> &lt;&lt; FLAG_IS_OUT)</span><br><span class="line">                : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    of_gpiochip_add(chip);</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    status = gpiochip_export(chip);</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-request"><a href="#gpio-request" class="headerlink" title="gpio_request()"></a>gpio_request()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span> *label)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">int</span>         status = -EINVAL;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    desc = &amp;gpio_desc[gpio];</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (chip == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!try_module_get(chip-&gt;owner))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span>  gpio_request() can be called in early boot,</span></span><br><span class="line"><span class="comment">     * before IRQs are enabled, for non-sleeping (SOC) GPIOs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (test_and_set_bit(FLAG_REQUESTED, &amp;desc-&gt;flags) == <span class="number">0</span>) &#123;</span><br><span class="line">        desc_set_label(desc, label ? : <span class="string">&quot;?&quot;</span>);</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = -EBUSY;</span><br><span class="line">        module_put(chip-&gt;owner);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chip-&gt;request) &#123;</span><br><span class="line">        <span class="comment">/* chip-&gt;request may sleep */</span></span><br><span class="line">        spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">        status = chip-&gt;request(chip, gpio - chip-&gt;base);</span><br><span class="line">        spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            desc_set_label(desc, <span class="literal">NULL</span>);</span><br><span class="line">            module_put(chip-&gt;owner);</span><br><span class="line">            clear_bit(FLAG_REQUESTED, &amp;desc-&gt;flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        pr_debug(<span class="string">&quot;gpio_request: gpio-%d (%s) status %d\n&quot;</span>,</span><br><span class="line">            gpio, label ? : <span class="string">&quot;?&quot;</span>, status);</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-free"><a href="#gpio-free" class="headerlink" title="gpio_free()"></a>gpio_free()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_free</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio)) &#123;</span><br><span class="line">        WARN_ON(extra_checks);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gpio_unexport(gpio);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    desc = &amp;gpio_desc[gpio];</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (chip &amp;&amp; test_bit(FLAG_REQUESTED, &amp;desc-&gt;flags)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chip-&gt;<span class="built_in">free</span>) &#123;</span><br><span class="line">            spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">            might_sleep_if(chip-&gt;can_sleep);</span><br><span class="line">            chip-&gt;<span class="built_in">free</span>(chip, gpio - chip-&gt;base);</span><br><span class="line">            spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        desc_set_label(desc, <span class="literal">NULL</span>);</span><br><span class="line">        module_put(desc-&gt;chip-&gt;owner);</span><br><span class="line">        clear_bit(FLAG_ACTIVE_LOW, &amp;desc-&gt;flags);</span><br><span class="line">        clear_bit(FLAG_REQUESTED, &amp;desc-&gt;flags);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        WARN_ON(extra_checks);</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-direction-input"><a href="#gpio-direction-input" class="headerlink" title="gpio_direction_input()"></a>gpio_direction_input()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_direction_input</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span> =</span> &amp;gpio_desc[gpio];</span><br><span class="line">    <span class="type">int</span>         status = -EINVAL;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio))</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (!chip || !chip-&gt;get || !chip-&gt;direction_input)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    gpio -= chip-&gt;base;</span><br><span class="line">    <span class="keyword">if</span> (gpio &gt;= chip-&gt;ngpio)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    status = gpio_ensure_requested(desc, gpio);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now we know the gpio is valid and chip won&#x27;t vanish */</span></span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    might_sleep_if(chip-&gt;can_sleep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        status = chip-&gt;request(chip, gpio);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;GPIO-%d: chip request fail, %d\n&quot;</span>,</span><br><span class="line">                chip-&gt;base + gpio, status);</span><br><span class="line">            <span class="comment">/* and it&#x27;s not available to anyone else ...</span></span><br><span class="line"><span class="comment">             * gpio_request() is the fully clean solution.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">goto</span> lose;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = chip-&gt;direction_input(chip, gpio);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">        clear_bit(FLAG_IS_OUT, &amp;desc-&gt;flags);</span><br><span class="line"></span><br><span class="line">    trace_gpio_direction(chip-&gt;base + gpio, <span class="number">1</span>, status);</span><br><span class="line">lose:</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">fail:</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: gpio-%d status %d\n&quot;</span>,</span><br><span class="line">            __func__, gpio, status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-direction-output"><a href="#gpio-direction-output" class="headerlink" title="gpio_direction_output()"></a>gpio_direction_output()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span> =</span> &amp;gpio_desc[gpio];</span><br><span class="line">    <span class="type">int</span>         status = -EINVAL;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio))</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (!chip || !chip-&gt;<span class="built_in">set</span> || !chip-&gt;direction_output)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    gpio -= chip-&gt;base;</span><br><span class="line">    <span class="keyword">if</span> (gpio &gt;= chip-&gt;ngpio)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    status = gpio_ensure_requested(desc, gpio);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now we know the gpio is valid and chip won&#x27;t vanish */</span></span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    might_sleep_if(chip-&gt;can_sleep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        status = chip-&gt;request(chip, gpio);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;GPIO-%d: chip request fail, %d\n&quot;</span>,</span><br><span class="line">                chip-&gt;base + gpio, status);</span><br><span class="line">            <span class="comment">/* and it&#x27;s not available to anyone else ...</span></span><br><span class="line"><span class="comment">             * gpio_request() is the fully clean solution.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">goto</span> lose;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = chip-&gt;direction_output(chip, gpio, value);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">        set_bit(FLAG_IS_OUT, &amp;desc-&gt;flags);</span><br><span class="line">    trace_gpio_value(chip-&gt;base + gpio, <span class="number">0</span>, value);</span><br><span class="line">    trace_gpio_direction(chip-&gt;base + gpio, <span class="number">0</span>, status);</span><br><span class="line">lose:</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">fail:</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: gpio-%d status %d\n&quot;</span>,</span><br><span class="line">            __func__, gpio, status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-get-value"><a href="#gpio-get-value" class="headerlink" title="gpio_get_value()"></a>gpio_get_value()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_get_value</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    chip = gpio_to_chip(gpio);</span><br><span class="line">    WARN_ON(chip-&gt;can_sleep);</span><br><span class="line">    value = chip-&gt;get ? chip-&gt;get(chip, gpio - chip-&gt;base) : <span class="number">0</span>;</span><br><span class="line">    trace_gpio_value(gpio, <span class="number">1</span>, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-set-value"><a href="#gpio-set-value" class="headerlink" title="gpio_set_value()"></a>gpio_set_value()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_set_value</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line"></span><br><span class="line">    chip = gpio_to_chip(gpio);</span><br><span class="line">    WARN_ON(chip-&gt;can_sleep);</span><br><span class="line">    trace_gpio_value(gpio, <span class="number">0</span>, value);</span><br><span class="line">    chip-&gt;<span class="built_in">set</span>(chip, gpio - chip-&gt;base, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpio注册"><a href="#gpio注册" class="headerlink" title="gpio注册"></a>gpio注册</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c_gpio_chip</span> <span class="title">exynos4_gpio_common_4bit</span>[] =</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        .base   = S5P_VA_GPIO1,</span><br><span class="line">        .eint_offset = <span class="number">0x0</span>,</span><br><span class="line">        .group  = <span class="number">0</span>,</span><br><span class="line">        .chip   = &#123;</span><br><span class="line">            .base   = EXYNOS4_GPA0(<span class="number">0</span>),</span><br><span class="line">            .ngpio  = EXYNOS4_GPIO_A0_NR,</span><br><span class="line">            .label  = <span class="string">&quot;GPA0&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        .base   = (S5P_VA_GPIO1 + <span class="number">0x20</span>),</span><br><span class="line">        .eint_offset = <span class="number">0x4</span>,</span><br><span class="line">        .group  = <span class="number">1</span>,</span><br><span class="line">        .chip   = &#123;</span><br><span class="line">            .base   = EXYNOS4_GPA1(<span class="number">0</span>),</span><br><span class="line">            .ngpio  = EXYNOS4_GPIO_A1_NR,</span><br><span class="line">            .label  = <span class="string">&quot;GPA1&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">exynos4_gpiolib_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c_gpio_chip</span> *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> nr_chips;</span><br><span class="line"></span><br><span class="line">    chip = exynos4_gpio_common_4bit;</span><br><span class="line">    nr_chips = ARRAY_SIZE(exynos4_gpio_common_4bit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_chips; i++, chip++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chip-&gt;config == <span class="literal">NULL</span>)</span><br><span class="line">            chip-&gt;config = &amp;gpio_cfg;</span><br><span class="line">        <span class="keyword">if</span> (chip-&gt;base == <span class="literal">NULL</span>)</span><br><span class="line">            pr_err(<span class="string">&quot;No allocation of base address for [common gpio]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    samsung_gpiolib_add_4bit_chips(exynos4_gpio_common_4bit, nr_chips);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">core_initcall(exynos4_gpiolib_init);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">samsung_gpiolib_add_4bit2_chips</span><span class="params">(<span class="keyword">struct</span> s3c_gpio_chip *chip,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> nr_chips)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (; nr_chips &gt; <span class="number">0</span>; nr_chips--, chip++) &#123;</span><br><span class="line">        samsung_gpiolib_add_4bit2(chip);</span><br><span class="line">        s3c_gpiolib_add(chip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__init <span class="type">void</span> <span class="title function_">s3c_gpiolib_add</span><span class="params">(<span class="keyword">struct</span> s3c_gpio_chip *chip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> &amp;chip-&gt;chip;</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;chip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;direction_input)</span><br><span class="line">        gc-&gt;direction_input = s3c_gpiolib_input;</span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;direction_output)</span><br><span class="line">        gc-&gt;direction_output = s3c_gpiolib_output;</span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;<span class="built_in">set</span>)</span><br><span class="line">        gc-&gt;<span class="built_in">set</span> = s3c_gpiolib_set;</span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;get)</span><br><span class="line">        gc-&gt;get = s3c_gpiolib_get;</span><br><span class="line"></span><br><span class="line">    gpiochip_add(gc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充gpio_chip结构体，再用<a href="#gpiochip_add">gpiochip_add()</a>函数注册到内核。需要确定每组gpio的虚拟地址，其中物理地址和虚拟地址的映射平台已经做好了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S5P_VA_GPIO1        S3C_ADDR(0x02200000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S5P_VA_GPIO2        S3C_ADDR(0x02240000)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">map_desc</span> <span class="title">exynos4_iodesc</span>[] __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .virtual    = (<span class="type">unsigned</span> <span class="type">long</span>)S5P_VA_GPIO1,</span><br><span class="line">        .pfn        = __phys_to_pfn(EXYNOS4_PA_GPIO1),</span><br><span class="line">        .length     = SZ_4K,</span><br><span class="line">        .type       = MT_DEVICE,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        .virtual    = (<span class="type">unsigned</span> <span class="type">long</span>)S5P_VA_GPIO2,</span><br><span class="line">        .pfn        = __phys_to_pfn(EXYNOS4_PA_GPIO2),</span><br><span class="line">        .length     = SZ_4K,</span><br><span class="line">        .type       = MT_DEVICE,</span><br><span class="line">    &#125;, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">exynos4_map_io</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    iotable_init(exynos4_iodesc, ARRAY_SIZE(exynos4_iodesc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pinctrl"><a href="#pinctrl" class="headerlink" title="pinctrl"></a>pinctrl</h2>]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>i2c 设备驱动</title>
    <url>/2022/09/04/kernel/i2c_device/</url>
    <content><![CDATA[<p>I2C设备层由i2c设备和对应的设备驱动组成，分别用i2c_client和i2c_driver表示。</p>
<h2 id="i2c-driver"><a href="#i2c-driver" class="headerlink" title="i2c_driver"></a>i2c_driver</h2><p>i2c_driver 对应一套驱动方法，实现设备与总线的挂接。i2c_driver与i2c_client的关系是一对多，一个i2c_driver上可以支持多个同等类型的i2c_client。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notifies the driver that a new bus has appeared or is about to be</span></span><br><span class="line"><span class="comment">     * removed. You should avoid using this if you can, it will probably</span></span><br><span class="line"><span class="comment">     * be removed in a near future.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line">    <span class="type">int</span> (*detach_adapter)(<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">    <span class="type">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *);</span><br><span class="line">    <span class="type">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line">    <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> i2c_client *, <span class="type">pm_message_t</span> mesg);</span><br><span class="line">    <span class="type">int</span> (*resume)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">     * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">     * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">     * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="type">unsigned</span> <span class="type">int</span> data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">     * with the device.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *arg);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">    <span class="type">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *);</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_i2c_driver(d) container_of(d, struct i2c_driver, driver)</span></span><br></pre></td></tr></table></figure>

<h3 id="注册i2c设备驱动"><a href="#注册i2c设备驱动" class="headerlink" title="注册i2c设备驱动"></a>注册i2c设备驱动</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">eeprom_detect</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">struct</span> i2c_board_info *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span> =</span> client-&gt;adapter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EDID EEPROMs are often 24C00 EEPROMs, which answer to all</span></span><br><span class="line"><span class="comment">       addresses 0x50-0x57, but we only care about 0x50. So decline</span></span><br><span class="line"><span class="comment">       attaching to addresses &gt;= 0x51 on DDC buses */</span></span><br><span class="line">    <span class="keyword">if</span> (!(adapter-&gt;class &amp; I2C_CLASS_SPD) &amp;&amp; client-&gt;addr &gt;= <span class="number">0x51</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There are four ways we can read the EEPROM data:</span></span><br><span class="line"><span class="comment">       (1) I2C block reads (faster, but unsupported by most adapters)</span></span><br><span class="line"><span class="comment">       (2) Word reads (128% overhead)</span></span><br><span class="line"><span class="comment">       (3) Consecutive byte reads (88% overhead, unsafe)</span></span><br><span class="line"><span class="comment">       (4) Regular byte data reads (265% overhead)</span></span><br><span class="line"><span class="comment">       The third and fourth methods are not implemented by this driver</span></span><br><span class="line"><span class="comment">       because all known adapters support one of the first two. */</span></span><br><span class="line">    <span class="keyword">if</span> (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_WORD_DATA)</span><br><span class="line">     &amp;&amp; !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_I2C_BLOCK))</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    strlcpy(info-&gt;type, <span class="string">&quot;eeprom&quot;</span>, I2C_NAME_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">eeprom_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span> =</span> client-&gt;adapter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eeprom_data</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    data = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> eeprom_data), GFP_KERNEL);</span><br><span class="line">    <span class="built_in">memset</span>(data-&gt;data, <span class="number">0xff</span>, EEPROM_SIZE);</span><br><span class="line">    i2c_set_clientdata(client, data);</span><br><span class="line">    mutex_init(&amp;data-&gt;update_lock);</span><br><span class="line">    data-&gt;nature = UNKNOWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect the Vaio nature of EEPROMs.</span></span><br><span class="line"><span class="comment">       We use the &quot;PCG-&quot; or &quot;VGN-&quot; prefix as the signature. */</span></span><br><span class="line">    <span class="keyword">if</span> (client-&gt;addr == <span class="number">0x57</span> &amp;&amp; i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_BYTE_DATA)) &#123;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">4</span>];</span><br><span class="line">        name[<span class="number">0</span>] = i2c_smbus_read_byte_data(client, <span class="number">0x80</span>);</span><br><span class="line">        name[<span class="number">1</span>] = i2c_smbus_read_byte_data(client, <span class="number">0x81</span>);</span><br><span class="line">        name[<span class="number">2</span>] = i2c_smbus_read_byte_data(client, <span class="number">0x82</span>);</span><br><span class="line">        name[<span class="number">3</span>] = i2c_smbus_read_byte_data(client, <span class="number">0x83</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(name, <span class="string">&quot;PCG-&quot;</span>, <span class="number">4</span>) || !<span class="built_in">memcmp</span>(name, <span class="string">&quot;VGN-&quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">            dev_info(&amp;client-&gt;dev, <span class="string">&quot;Vaio EEPROM detected, enabling privacy protection\n&quot;</span>);</span><br><span class="line">            data-&gt;nature = VAIO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the sysfs eeprom file */</span></span><br><span class="line">    err = sysfs_create_bin_file(&amp;client-&gt;dev.kobj, &amp;eeprom_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">eeprom_id</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;eeprom&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">eeprom_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;eeprom&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe      = eeprom_probe,</span><br><span class="line">    .remove     = eeprom_remove,</span><br><span class="line">    .id_table   = eeprom_id,</span><br><span class="line">    .class      = I2C_CLASS_DDC | I2C_CLASS_SPD,</span><br><span class="line">    .detect     = eeprom_detect,</span><br><span class="line">    .address_list   = normal_i2c,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">eeprom_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i2c_add_driver(&amp;eeprom_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例一个 i2c_driver，然后通过 i2c_add_driver() 函数注册i2c设备驱动。id_table数组元素中的名称指明了支持的I2C设备。</p>
<h3 id="i2c-add-driver"><a href="#i2c-add-driver" class="headerlink" title="i2c_add_driver()"></a>i2c_add_driver()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">i2c_add_driver</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i2c_register_driver(THIS_MODULE, driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_register_driver</span><span class="params">(<span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Can&#x27;t register until after driver model init */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(WARN_ON(!i2c_bus_type.p)))</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add the driver to the list of i2c drivers in the driver core */</span></span><br><span class="line">    driver-&gt;driver.owner = owner;</span><br><span class="line">    driver-&gt;driver.bus = &amp;i2c_bus_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When registration returns, the driver core</span></span><br><span class="line"><span class="comment">     * will have called probe() for all matching-but-unbound devices.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    res = driver_register(&amp;driver-&gt;driver);</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class="line">    <span class="comment">/* Walk the adapters that are already present */</span></span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    bus_for_each_dev(&amp;i2c_bus_type, <span class="literal">NULL</span>, driver, __process_new_driver);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __process_new_driver(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;type != &amp;i2c_adapter_type)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> i2c_do_add_adapter(data, to_i2c_adapter(dev));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_do_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver, <span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Detect supported devices on that bus, and instantiate them */</span></span><br><span class="line">    i2c_detect(adap, driver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let legacy drivers scan this bus for matching devices */</span></span><br><span class="line">    <span class="keyword">if</span> (driver-&gt;attach_adapter) &#123;</span><br><span class="line">        <span class="comment">/* We ignore the return code; if it fails, too bad */</span></span><br><span class="line">        driver-&gt;attach_adapter(adap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定总线类型为 i2c_bus_type。遍历总线的设备，调用__process_new_driver()函数，拿到设备对应的适配器，调用驱动的detect()函数，探测其设备地址，若设备名匹配，则将这个设备注册到内核。</p>
<h2 id="i2c-client"><a href="#i2c-client" class="headerlink" title="i2c_client"></a>i2c_client</h2><p>i2c_client 对应真实的i2c物理设备，描述了i2c设备的硬件信息，设备挂接在i2c适配器上，通过i2c适配器与CPU交换数据。所有的i2c设备都在/sys/bus/i2c/目录中显示，以适配器地址和芯片地址的形式列出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> flags;       <span class="comment">/* div., see below      */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> addr;        <span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit    */</span></span><br><span class="line">                    <span class="comment">/* addresses are stored in the  */</span></span><br><span class="line">                    <span class="comment">/* _LOWER_ 7 bits       */</span></span><br><span class="line">    <span class="type">char</span> name[I2C_NAME_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>    <span class="comment">/* the adapter we sit on    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>      <span class="comment">/* the device structure     */</span></span><br><span class="line">    <span class="type">int</span> init_irq;           <span class="comment">/* irq set at initialization    */</span></span><br><span class="line">    <span class="type">int</span> irq;            <span class="comment">/* irq issued by device     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="注册i2c设备"><a href="#注册i2c设备" class="headerlink" title="注册i2c设备"></a>注册i2c设备</h3><p><strong>在板文件注册</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>        type[I2C_NAME_SIZE];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  addr;</span><br><span class="line">    <span class="type">void</span>        *platform_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> *<span class="title">archdata</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span>     irq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c_client 信息通常在BSP板文件中通过 i2c_board_info 结构体来填充。注册I2C设备时，先获取相应总线号上的适配器，然后通过 i2c_new_device() 函数生成一个i2c_client。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span>  <span class="title">my_i2c_dev_info</span> =</span> &#123;</span><br><span class="line">    I2C_BOARD_INFO(<span class="string">&quot;my_i2c_dev&quot;</span>, <span class="number">0x20</span>),  <span class="comment">//名字，设备地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">adapter = i2c_get_adapter(bus);</span><br><span class="line"></span><br><span class="line">client = i2c_new_device(adapter, my_i2c_dev_info);</span><br></pre></td></tr></table></figure>

<p>也可以通过 i2c_register_board_info() 函数来注册。</p>
<p><strong>在用户空间注册</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注册设备</span></span><br><span class="line">echo my_i2c_dev 0x55 &gt; sys/devices/platform/s3c2440-i2c.0/i2c-0/new_device</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注销设备</span></span><br><span class="line">echo 0x55 &gt; sys/devices/platform/s3c2440-i2c.0/i2c-0/delete_device</span><br></pre></td></tr></table></figure>

<h3 id="i2c-register-board-info"><a href="#i2c-register-board-info" class="headerlink" title="i2c_register_board_info()"></a>i2c_register_board_info()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LIST_HEAD(__i2c_board_list);</span><br><span class="line">EXPORT_SYMBOL_GPL(__i2c_board_list);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">i2c_register_board_info</span><span class="params">(<span class="type">int</span> busnum, </span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> i2c_board_info <span class="type">const</span> *info, <span class="type">unsigned</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    down_write(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dynamic bus numbers will be assigned after the last static one */</span></span><br><span class="line">    <span class="keyword">if</span> (busnum &gt;= __i2c_first_dynamic_bus_num)</span><br><span class="line">        __i2c_first_dynamic_bus_num = busnum + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (status = <span class="number">0</span>; len; len--, info++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">i2c_devinfo</span>  *<span class="title">devinfo</span> =</span> kzalloc(<span class="keyword">sizeof</span>(*devinfo), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">        devinfo-&gt;busnum = busnum;</span><br><span class="line">        devinfo-&gt;board_info = *info;</span><br><span class="line">        list_add_tail(&amp;devinfo-&gt;<span class="built_in">list</span>, &amp;__i2c_board_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    up_write(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">i2c_scan_static_board_info</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_devinfo</span>  *<span class="title">devinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    down_read(&amp;__i2c_board_lock);</span><br><span class="line">    list_for_each_entry(devinfo, &amp;__i2c_board_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (devinfo-&gt;busnum == adapter-&gt;nr</span><br><span class="line">                &amp;&amp; !i2c_new_device(adapter, &amp;devinfo-&gt;board_info))</span><br><span class="line">            dev_err(&amp;adapter-&gt;dev,</span><br><span class="line">                <span class="string">&quot;Can&#x27;t create device at 0x%02x\n&quot;</span>, devinfo-&gt;board_info.addr);</span><br><span class="line">    &#125;</span><br><span class="line">    up_read(&amp;__i2c_board_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_register_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* create pre-declared device nodes */</span></span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">        i2c_scan_static_board_info(adap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过板文件静态注册的i2c设备，会先添加加到一个设备链表中，内核在注册i2c适配器时，会遍历这个设备链表，把总线号匹配的设备注册到内核，所以通过板文件注册设备要在注册适配器之前。</p>
<h3 id="i2c-new-device"><a href="#i2c-new-device" class="headerlink" title="i2c_new_device()"></a>i2c_new_device()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_client *<span class="title function_">i2c_new_device</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_board_info <span class="type">const</span> *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>   *<span class="title">client</span>;</span></span><br><span class="line">    <span class="type">int</span>         status;</span><br><span class="line"></span><br><span class="line">    client = kzalloc(<span class="keyword">sizeof</span> *client, GFP_KERNEL);</span><br><span class="line">    client-&gt;adapter = adap;</span><br><span class="line">    client-&gt;dev.platform_data = info-&gt;platform_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;archdata)</span><br><span class="line">        client-&gt;dev.archdata = *info-&gt;archdata;</span><br><span class="line"></span><br><span class="line">    client-&gt;flags = info-&gt;flags;</span><br><span class="line">    client-&gt;addr = info-&gt;addr;</span><br><span class="line">    client-&gt;irq = info-&gt;irq;</span><br><span class="line">    strlcpy(client-&gt;name, info-&gt;type, <span class="keyword">sizeof</span>(client-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for address validity */</span></span><br><span class="line">    status = i2c_check_client_addr_validity(client);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for address business */</span></span><br><span class="line">    status = i2c_check_addr_busy(adap, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">    client-&gt;dev.parent = &amp;client-&gt;adapter-&gt;dev;</span><br><span class="line">    client-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">    client-&gt;dev.type = &amp;i2c_client_type;</span><br><span class="line"></span><br><span class="line">    dev_set_name(&amp;client-&gt;dev, <span class="string">&quot;%d-%04x&quot;</span>, i2c_adapter_id(adap),</span><br><span class="line">             client-&gt;addr);</span><br><span class="line">    status = device_register(&amp;client-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>device</category>
      </categories>
      <tags>
        <tag>i2c</tag>
        <tag>device</tag>
      </tags>
  </entry>
  <entry>
    <title>i2c 适配器</title>
    <url>/2022/09/04/kernel/i2c_adapter/</url>
    <content><![CDATA[<h2 id="i2c-框架"><a href="#i2c-框架" class="headerlink" title="i2c 框架"></a>i2c 框架</h2><p><img src="/images/kernel/i2c/i2c-arch.png" alt="i2c体系结构"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── algos           实现了一些i2c总线适配器的算法</span><br><span class="line">│   ├── i2c-algo-bit.c</span><br><span class="line">│   ├── i2c-algo-pca.c</span><br><span class="line">│   ├── i2c-algo-pcf.c</span><br><span class="line">│   ├── i2c-algo-pcf.h</span><br><span class="line">├── busses          包含了一些处理器的i2c控制器驱动</span><br><span class="line">│   ├── i2c-at91.c</span><br><span class="line">│   ├── i2c-exynos5.c</span><br><span class="line">│   ├── i2c-gpio.c</span><br><span class="line">│   ├── i2c-s3c2410.c</span><br><span class="line">│   ├── i2c-stm32.c</span><br><span class="line">├── chips            包含了一些特定的i2c设备驱动</span><br><span class="line">├── i2c-boardinfo.c</span><br><span class="line">├── i2c-core.c       实现了i2c核心的功能以及/proc/bus/i2c*接口</span><br><span class="line">├── i2c-dev.c        实现了i2c适配器设备文件的功能</span><br><span class="line">├── i2c-mux.c</span><br><span class="line">└── muxes</span><br><span class="line">    ├── i2c-arb-gpio-challenge.c</span><br><span class="line">    ├── i2c-demux-pinctrl.c</span><br><span class="line">    ├── i2c-mux-gpio.c</span><br><span class="line">    ├── i2c-mux-gpmux.c</span><br><span class="line">    ├── i2c-mux-ltc4306.c</span><br><span class="line">    ├── i2c-mux-mlxcpld.c</span><br><span class="line">    ├── i2c-mux-pca9541.c</span><br><span class="line">    ├── i2c-mux-pinctrl.c</span><br><span class="line">    ├── i2c-mux-reg.c</span><br></pre></td></tr></table></figure>

<h2 id="i2c总线"><a href="#i2c总线" class="headerlink" title="i2c总线"></a>i2c总线</h2><p>I2C核心维护了i2c_bus结构体，提供了I2C总线驱动和设备驱动的注册、注销方法，维护了I2C总线的驱动、设备链表，实现了设备、驱动的匹配探测。代码实现在i2c-core.c中。</p>
<p>i2c总线用于管理I2C设备和I2C驱动，维护一个设备链表和驱动链表，定义了设备和驱动的匹配规则和匹配成功后的行为。</p>
<p><strong>注册i2c总线</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">i2c_bus_type</span> =</span> &#123;</span><br><span class="line">    .name       = <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">    .match      = i2c_device_match,</span><br><span class="line">    .probe      = i2c_device_probe,</span><br><span class="line">    .remove     = i2c_device_remove,</span><br><span class="line">    .shutdown   = i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ret = bus_register(&amp;i2c_bus_type);</span><br></pre></td></tr></table></figure>

<p>i2c_device_match()中，会调用 i2c_match_id()函数匹配板文件中定义的ID和i2c_driver 所支持的ID表。</p>
<p>I2C总线由I2C适配器和适配器的通信方法组成。</p>
<h2 id="i2c-adapter"><a href="#i2c-adapter" class="headerlink" title="i2c_adapter"></a>i2c_adapter</h2><p>i2c_adapter 对应与物理上的一个适配器，适配器就是cpu内部的i2c控制器，用来产生总线操作信号，此部分代码由具体的芯片厂商提供。<br>一个适配器上可以连接多个i2c设备，i2c_client都会依附于适配器上的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id; <span class="comment">/* == is algo-&gt;id | hwdep.struct-&gt;id/</span></span><br><span class="line"><span class="comment">    unsigned int class;</span></span><br><span class="line"><span class="comment">    struct i2c_algorithm *algo; /* the algorithm to access the bus */</span></span><br><span class="line">    <span class="type">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*client_register)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line">    <span class="type">int</span> (*client_unregister)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data fields that are valid for all devices */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">clist_lock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> timeout;</span><br><span class="line">    <span class="type">int</span> retries;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>  <span class="comment">/* the adapter device */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class_device</span> <span class="title">class_dev</span>;</span> <span class="comment">/* the class device */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nr;  <span class="comment">// 总线号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span>  <span class="comment">//连接的i2c设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">char</span> name[I2C_NAME_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">class_dev_released</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注册适配器</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">i2c_imx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span>;</span></span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (irq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t get irq number\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pdata = pdev-&gt;dev.platform_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup i2c_imx driver structure */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(i2c_imx-&gt;adapter.name, pdev-&gt;name);</span><br><span class="line">    i2c_imx-&gt;adapter.owner      = THIS_MODULE;</span><br><span class="line">    i2c_imx-&gt;adapter.algo       = &amp;i2c_imx_algo;</span><br><span class="line">    i2c_imx-&gt;adapter.dev.parent = &amp;pdev-&gt;dev;</span><br><span class="line">    i2c_imx-&gt;adapter.nr         = pdev-&gt;id;</span><br><span class="line">    i2c_imx-&gt;irq    = irq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get I2C clock */</span></span><br><span class="line">    i2c_imx-&gt;clk = clk_get(&amp;pdev-&gt;dev, <span class="string">&quot;i2c_clk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Request IRQ */</span></span><br><span class="line">    ret = request_irq(i2c_imx-&gt;irq, i2c_imx_isr, <span class="number">0</span>, pdev-&gt;name, i2c_imx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init queue */</span></span><br><span class="line">    init_waitqueue_head(&amp;i2c_imx-&gt;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up adapter data */</span></span><br><span class="line">    i2c_set_adapdata(&amp;i2c_imx-&gt;adapter, i2c_imx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up clock divider */</span></span><br><span class="line">    <span class="keyword">if</span> (pdata &amp;&amp; pdata-&gt;bitrate)</span><br><span class="line">        i2c_imx_set_clk(i2c_imx, pdata-&gt;bitrate);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i2c_imx_set_clk(i2c_imx, IMX_I2C_BIT_RATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up chip registers to defaults */</span></span><br><span class="line">    writeb(<span class="number">0</span>, i2c_imx-&gt;base + IMX_I2C_I2CR);</span><br><span class="line">    writeb(<span class="number">0</span>, i2c_imx-&gt;base + IMX_I2C_I2SR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add I2C adapter */</span></span><br><span class="line">    ret = i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先初始化i2c控制器的I/O地址、中断号等硬件资源，实例一个i2c_adapter对象，实现适配器的数据传输方法，如果总线号（nr成员）已经指定，则调用 i2c_add_numbered_adapter() 函数完成适配器的构建，否则使用i2c_add_adapter()动态生成总线号。</p>
<h2 id="i2c-algorithm"><a href="#i2c-algorithm" class="headerlink" title="i2c_algorithm"></a>i2c_algorithm</h2><p>i2c_algorithm 对应i2c总线的数据通信算法，i2c适配器需要 i2c_algorithm 中提供的通信函数来实现对I2C总线上数据的发送和接收等操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 作为主设备时的发送函数 */</span></span><br><span class="line">    <span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">               <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 作为从设备时的发送函数 */</span></span><br><span class="line">    <span class="type">int</span> (*smbus_xfer) (<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">               <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">               u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    u32 (*functionality) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c_algorithm 中的master_xfer()函数通过操作寄存器来完成i2c_msg数据的传输。functionality()函数返回支持的通信协议掩码，用来确定适配器支持那些传输协议。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span> </span><br><span class="line">    __u16 addr; <span class="comment">/* slave address */</span></span><br><span class="line">    __u16 flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RD        0x0001  <span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line">                    <span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_TEN       0x0010  <span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_DMA_SAFE      0x0200  <span class="comment">/* the buffer of this message is DMA safe */</span></span></span><br><span class="line">                    <span class="comment">/* makes only sense in kernelspace */</span></span><br><span class="line">                    <span class="comment">/* userspace buffers are copied anyway */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RECV_LEN      0x0400  <span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NO_RD_ACK     0x0800  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_IGNORE_NAK    0x1000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_REV_DIR_ADDR  0x2000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NOSTART       0x4000  <span class="comment">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_STOP      0x8000  <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">    __u16 len;      <span class="comment">/* msg length */</span></span><br><span class="line">    __u8 *buf;      <span class="comment">/* pointer to msg data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, temp;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start I2C transfer */</span></span><br><span class="line">    result = i2c_imx_start(i2c_imx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read/write data */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) &#123;</span><br><span class="line">            temp = readb(i2c_imx-&gt;base + IMX_I2C_I2CR);</span><br><span class="line">            temp |= I2CR_RSTA;</span><br><span class="line">            writeb(temp, i2c_imx-&gt;base + IMX_I2C_I2CR);</span><br><span class="line">            result =  i2c_imx_bus_busy(i2c_imx, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* write/read data */</span></span><br><span class="line">        <span class="keyword">if</span> (msgs[i].flags &amp; I2C_M_RD)</span><br><span class="line">            result = i2c_imx_read(i2c_imx, &amp;msgs[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = i2c_imx_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stop I2C transfer */</span></span><br><span class="line">    i2c_imx_stop(i2c_imx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (result &lt; <span class="number">0</span>) ? result : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32 <span class="title function_">i2c_imx_func</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">i2c_imx_algo</span> =</span> &#123;</span><br><span class="line">    .master_xfer   = i2c_imx_xfer,</span><br><span class="line">    .functionality = i2c_imx_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="i2c-core-c"><a href="#i2c-core-c" class="headerlink" title="i2c-core.c"></a>i2c-core.c</h2><h3 id="i2c-add-adapter"><a href="#i2c-add-adapter" class="headerlink" title="i2c_add_adapter()"></a>i2c_add_adapter()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;adapter-&gt;dev;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    id = idr_alloc(&amp;i2c_adapter_idr, adapter,</span><br><span class="line">               __i2c_first_dynamic_bus_num, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line">    adapter-&gt;nr = id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i2c_register_adapter(adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">i2c_bus_type</span> =</span> &#123;</span><br><span class="line">    .name       = <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">    .match      = i2c_device_match,</span><br><span class="line">    .probe      = i2c_device_probe,</span><br><span class="line">    .remove     = i2c_device_remove,</span><br><span class="line">    .shutdown   = i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> <span class="title">i2c_adapter_type</span> =</span> &#123;</span><br><span class="line">    .groups     = i2c_adapter_groups,</span><br><span class="line">    .release    = i2c_adapter_dev_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_register_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_mutex_init(&amp;adap-&gt;bus_lock);</span><br><span class="line">    rt_mutex_init(&amp;adap-&gt;mux_lock);</span><br><span class="line">    mutex_init(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;adap-&gt;userspace_clients);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set default timeout to 1 second if not already set */</span></span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;timeout == <span class="number">0</span>)</span><br><span class="line">        adap-&gt;timeout = HZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register soft irqs for Host Notify */</span></span><br><span class="line">    res = i2c_setup_host_notify_irq_domain(adap);</span><br><span class="line"></span><br><span class="line">    dev_set_name(&amp;adap-&gt;dev, <span class="string">&quot;i2c-%d&quot;</span>, adap-&gt;nr);</span><br><span class="line">    adap-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">    adap-&gt;dev.type = &amp;i2c_adapter_type;</span><br><span class="line">    res = device_register(&amp;adap-&gt;dev);  <span class="comment">//创建设备结节</span></span><br><span class="line"></span><br><span class="line">    i2c_init_recovery(adap);</span><br><span class="line"></span><br><span class="line">    of_i2c_register_devices(adap);</span><br><span class="line">    i2c_acpi_register_devices(adap);</span><br><span class="line">    i2c_acpi_install_space_handler(adap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">        i2c_scan_static_board_info(adap);</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;core_lock);</span><br><span class="line">    bus_for_each_drv(&amp;i2c_bus_type, <span class="literal">NULL</span>, adap, __process_new_adapter);</span><br><span class="line">    mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __process_new_adapter(<span class="keyword">struct</span> device_driver *d, <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i2c_do_add_adapter(to_i2c_driver(d), data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_do_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver, <span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Detect supported devices on that bus, and instantiate them */</span></span><br><span class="line">    i2c_detect(adap, driver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let legacy drivers scan this bus for matching devices */</span></span><br><span class="line">    <span class="keyword">if</span> (driver-&gt;attach_adapter) &#123;</span><br><span class="line">        <span class="comment">/* We ignore the return code; if it fails, too bad */</span></span><br><span class="line">        driver-&gt;attach_adapter(adap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册适配器时，会扫描并注册当前已经静态添加的i2c设备，同时遍历所有的i2c设备驱动，将匹配的驱动与自己附属的设备进行绑定。</p>
<h3 id="i2c-detect"><a href="#i2c-detect" class="headerlink" title="i2c_detect()"></a>i2c_detect()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_detect</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter, <span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">temp_client</span>;</span></span><br><span class="line">    <span class="type">int</span> i, err = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> adap_id = i2c_adapter_id(adapter);</span><br><span class="line"></span><br><span class="line">    address_list = driver-&gt;address_list;</span><br><span class="line">    <span class="keyword">if</span> (!driver-&gt;detect || !address_list)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up a temporary client to help detect callback */</span></span><br><span class="line">    temp_client = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> i2c_client), GFP_KERNEL);</span><br><span class="line">    temp_client-&gt;adapter = adapter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stop here if the classes do not match */</span></span><br><span class="line">    <span class="keyword">if</span> (!(adapter-&gt;class &amp; driver-&gt;class))</span><br><span class="line">        <span class="keyword">goto</span> exit_free;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stop here if the bus doesn&#x27;t support probing */</span></span><br><span class="line">    <span class="keyword">if</span> (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_BYTE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (address_list[<span class="number">0</span>] == I2C_CLIENT_END)</span><br><span class="line">            <span class="keyword">goto</span> exit_free;</span><br><span class="line"></span><br><span class="line">        err = -EOPNOTSUPP;</span><br><span class="line">        <span class="keyword">goto</span> exit_free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; address_list[i] != I2C_CLIENT_END; i += <span class="number">1</span>) &#123;</span><br><span class="line">        dev_dbg(&amp;adapter-&gt;dev, <span class="string">&quot;found normal entry for adapter %d, &quot;</span></span><br><span class="line">            <span class="string">&quot;addr 0x%02x\n&quot;</span>, adap_id, address_list[i]);</span><br><span class="line">        temp_client-&gt;addr = address_list[i];</span><br><span class="line">        i2c_detect_address(temp_client, driver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> exit_free:</span><br><span class="line">    kfree(temp_client);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造一个临时的i2c设备，然后调用驱动的探测函数detect()，检查其设备地址，若设备名匹配，则将这个设备注册到内核。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_detect_address</span><span class="params">(<span class="keyword">struct</span> i2c_client *temp_client, <span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span> =</span> temp_client-&gt;adapter;</span><br><span class="line">    <span class="type">int</span> addr = temp_client-&gt;addr;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the address is valid */</span></span><br><span class="line">    err = i2c_check_addr_validity(addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip if already in use */</span></span><br><span class="line">    <span class="keyword">if</span> (i2c_check_addr_busy(adapter, addr))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure there is something at this address */</span></span><br><span class="line">    <span class="keyword">if</span> (!i2c_default_probe(adapter, addr))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally call the custom detection function */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> i2c_board_info));</span><br><span class="line">    info.addr = addr;</span><br><span class="line">    err = driver-&gt;detect(temp_client, &amp;info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Consistency check */</span></span><br><span class="line">    <span class="keyword">if</span> (info.type[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        dev_err(&amp;adapter-&gt;dev, <span class="string">&quot;%s detection function provided &quot;</span></span><br><span class="line">            <span class="string">&quot;no name for 0x%x\n&quot;</span>, driver-&gt;driver.name, addr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> i2c_client *client;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Detection succeeded, instantiate the device */</span></span><br><span class="line">        dev_dbg(&amp;adapter-&gt;dev, <span class="string">&quot;Creating %s at 0x%02x\n&quot;</span>, info.type, info.addr);</span><br><span class="line">        client = i2c_new_device(adapter, &amp;info);</span><br><span class="line">        <span class="keyword">if</span> (client)</span><br><span class="line">            list_add_tail(&amp;client-&gt;detected, &amp;driver-&gt;clients);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dev_err(&amp;adapter-&gt;dev, <span class="string">&quot;Failed creating %s at 0x%02x\n&quot;</span>, info.type, info.addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="i2c-transfer"><a href="#i2c-transfer" class="headerlink" title="i2c_transfer()"></a>i2c_transfer()</h3><p>i2c_transfer()函数用于进行i2c适配器和i2c设备之间的消息交互，i2c_master_send()函数和i2c_master_recv()函数内部会调用i2c_transfer()函数分别完成一条写消息和一条读消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!adap-&gt;algo-&gt;master_xfer) &#123;</span><br><span class="line">        dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;I2C level transfers not supported\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adap-&gt;algo-&gt;master_xfer(adap, msgs, num); <span class="comment">//调用适配器的算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i2c_transfer()函数通过i2c_adapter对应的i2c_algorithm中的master_xfer()函数来传输I2C数据。</p>
<h2 id="i2c-dev-c"><a href="#i2c-dev-c" class="headerlink" title="i2c-dev.c"></a>i2c-dev.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2cdev_attach_adapter</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *dummy)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_dev</span> *<span class="title">i2c_dev</span>;</span></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    adap = to_i2c_adapter(dev);</span><br><span class="line">    i2c_dev = get_free_i2c_dev(adap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register this i2c device with the driver core */</span></span><br><span class="line">    i2c_dev-&gt;dev = device_create(i2c_dev_class, &amp;adap-&gt;dev,</span><br><span class="line">                     MKDEV(I2C_MAJOR, adap-&gt;nr), <span class="literal">NULL</span>,</span><br><span class="line">                     <span class="string">&quot;i2c-%d&quot;</span>, adap-&gt;nr);</span><br><span class="line"></span><br><span class="line">    res = device_create_file(i2c_dev-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">i2cdev_fops</span> =</span> &#123;</span><br><span class="line">    .owner  = THIS_MODULE,</span><br><span class="line">    .llseek = no_llseek,</span><br><span class="line">    .read   = i2cdev_read,</span><br><span class="line">    .write  = i2cdev_write,</span><br><span class="line">    .unlocked_ioctl = i2cdev_ioctl,</span><br><span class="line">    .open   = i2cdev_open,</span><br><span class="line">    .release    = i2cdev_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">i2c_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    res = register_chrdev(I2C_MAJOR, <span class="string">&quot;i2c&quot;</span>, &amp;i2cdev_fops);</span><br><span class="line"></span><br><span class="line">    i2c_dev_class = class_create(THIS_MODULE, <span class="string">&quot;i2c-dev&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep track of adapters which will be added or removed later */</span></span><br><span class="line">    res = bus_register_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bind to already existing adapters right away */</span></span><br><span class="line">    i2c_for_each_dev(<span class="literal">NULL</span>, i2cdev_attach_adapter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现了i2c适配器设备文件的功能，每一个i2c适配器都被分配一个设备。通过适配器访问设备时的主设备号都为 89，次设备号为 0～255。应用程序通过“i2c-%d”设备结点并使用文件操作接口 open()、write()、read()、ioctl()和 close()等来访问这个设备。</p>
]]></content>
      <categories>
        <category>device</category>
      </categories>
      <tags>
        <tag>i2c</tag>
        <tag>device</tag>
      </tags>
  </entry>
  <entry>
    <title>i2c-tools 使用</title>
    <url>/2022/09/04/kernel/i2c_tools/</url>
    <content><![CDATA[<p>下载地址：<a href="https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/">https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/</a></p>
]]></content>
      <categories>
        <category>device</category>
      </categories>
      <tags>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>imx280内核编译</title>
    <url>/2022/06/07/kernel/imx280_kerenl/</url>
    <content><![CDATA[<h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>原厂提供的是v2.6.35.3版本的内核，在编译之前要先准备好交叉编译和mkimage打包镜像工具。</p>
<p>将内核压缩包解压到宿主机上，cd到内核根目录，先是配置内核的.config文件，首次编译先使用默认的即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-fsl-linux-gnueabi- EasyARM-iMX280A_defconfig</span><br></pre></td></tr></table></figure>

<p>接着是开始编译内核镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-fsl-linux-gnueabi- zImage -j16</span><br></pre></td></tr></table></figure>

<p>这里可能会出现编译错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Can&#x27;t use &#x27;defined(@array)&#x27; (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373.</span><br><span class="line">make[1]: *** [kernel/timeconst.h] Error 255</span><br><span class="line">make: *** [kernel] Error 2</span><br></pre></td></tr></table></figure>

<p>这是因为主机上的perl版本与pl脚本语法不匹配的原因，修改pl脚本即可</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">        @val = @&#123;$canned_values&#123;$hz&#125;&#125;;</span><br><span class="line"><span class="deletion">-       if (!defined(@val)) &#123;</span></span><br><span class="line"><span class="addition">+       if (!@val) &#123;</span></span><br><span class="line">                @val = compute_values($hz);</span><br><span class="line">        &#125;</span><br><span class="line">        output($hz, @val);</span><br></pre></td></tr></table></figure>

<p>修改之后，继续编译，最终在arch/arm/boot/目录生成zImage镜像。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>imx280</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel Architecture</title>
    <url>/2022/06/07/kernel/kernel_arch/</url>
    <content><![CDATA[<p>Linux的内核是一种宏内核，主要有以下特征：</p>
<ul>
<li>支持动态加载内核模块</li>
<li>支持对称多处理（SMP）</li>
<li>支持抢占，允许内核运行的任务有优先执行的能力</li>
<li>不区分线程和进程</li>
</ul>
<h2 id="linux系统结构"><a href="#linux系统结构" class="headerlink" title="linux系统结构"></a>linux系统结构</h2><img src="/images/kernel/kernel/linux_arch.jpeg" alt="Unix/Linux系统分层结构" style="zoom: 33%;" />

<p><img src="/images/kernel/kernel/linux-arch.webp" alt="Linux系统层次结构"></p>
<p>最上面是用户空间，这是用户应用程序执行的地方。用户空间之下是内核空间，GNU C Library （glibc）也位于这里，它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。</p>
<p>Linux 内核可以进一步划分成三层，最上面是系统调用接口，之下是内核代码，是与处理器体系结构无关的通用代码，最下面是依赖于特定处理器体系结构的代码，称为 BSP（Board Support Package）。</p>
<h2 id="内核架构"><a href="#内核架构" class="headerlink" title="内核架构"></a>内核架构</h2><p><img src="/images/kernel/kernel/kernel_struct.webp" alt="linux内核架构"></p>
<p>Linux内核的主要组件有：系统调用接口、进程调度、内存管理、虚拟文件系统、网络协议栈、进程间通信、设备驱动程序和硬件架构的相关代码。</p>
<p>LXR (Linux Cross Reference)是一个内核的源代码浏览工具，<a href="http://lxr.linux.no/%E3%80%82">http://lxr.linux.no/。</a></p>
<p><img src="/images/kernel/kernel/linux_kernel_map.svg" alt="Linux kernel map"></p>
<p><a href="https://makelinux.github.io/kernel/map/">https://makelinux.github.io/kernel/map/</a></p>
<h3 id="目录详解"><a href="#目录详解" class="headerlink" title="目录详解"></a>目录详解</h3><table>
<thead>
<tr>
<th align="left">目录 / 文件名</th>
<th align="left">源码功能简介</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>特定体系结构的代码</td>
</tr>
<tr>
<td>block</td>
<td>块设备I/O层</td>
</tr>
<tr>
<td>crypo</td>
<td>加密API</td>
</tr>
<tr>
<td>certs</td>
<td>与证书相关。</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核源码文档</td>
</tr>
<tr>
<td>drivers</td>
<td>设备驱动程序</td>
</tr>
<tr>
<td>firmware</td>
<td>使用某些驱动程序而需要的设备固件</td>
</tr>
<tr>
<td>fs</td>
<td>VFS和各种文件系统</td>
</tr>
<tr>
<td>include</td>
<td>内核头文件</td>
</tr>
<tr>
<td>init</td>
<td>内核引导和初始化</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>核心子系统，如调度程序</td>
</tr>
<tr>
<td>lib</td>
<td>同样内核函数</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理子系统和VM</td>
</tr>
<tr>
<td>net</td>
<td>网络子系统</td>
</tr>
<tr>
<td>samples</td>
<td>示例，示范代码</td>
</tr>
<tr>
<td>scripts</td>
<td>编译内核所用的脚本</td>
</tr>
<tr>
<td>security</td>
<td>Linux 安全模块</td>
</tr>
<tr>
<td>sound</td>
<td>语音子系统</td>
</tr>
<tr>
<td>usr</td>
<td>早期用户空间代码（所谓的initramfs）</td>
</tr>
<tr>
<td>tools</td>
<td>在Linux开发中有用的工具</td>
</tr>
<tr>
<td>virt</td>
<td>虚拟化基础结构</td>
</tr>
<tr>
<td>COPYING</td>
<td>许可和授权信息。</td>
</tr>
<tr>
<td>CREDITS</td>
<td>贡献者列表。</td>
</tr>
</tbody></table>
<h2 id="drivers目录"><a href="#drivers目录" class="headerlink" title="drivers目录"></a>drivers目录</h2><p><strong>accessibility</strong>  这些驱动提供支持一些辅助设备。在Linux 3.9.4中，这个文件夹中只有一个驱动就是盲文设备驱动。</p>
<p><strong>acpi</strong>  高级配置和电源接口（ACPI : Advanced Configuration and Power Interface）驱动用来管理电源使用。</p>
<p><strong>amba</strong>  高级微控制器总线架构（AMBA : Advanced Microcontroller Bus Architecture）是与片上系统（SoC）的管理和互连的协议。SoC是一块包含许多或所有必要的计算机组件的芯片。这里的AMBA驱动让内核能够运行在这上面。</p>
<p><strong>ata</strong>  该目录包含PATA和SATA设备的驱动程序。串行ATA（SATA）是一种连接主机总线适配器到像硬盘那样的存储器的计算机总线接口。并行ATA（PATA）用于连接存储设备，如硬盘驱动器，软盘驱动器，光盘驱动器的标准。PATA就是我们所说的IDE。</p>
<p><strong>atm</strong>  异步通信模式(ATM : Asynchronous Transfer Mode)是一种通信标准。这里有各种接到PCI桥的驱动(他们连接到PCI总线)和以太网控制器(控制以太网通信的集成电路芯片)。</p>
<p><strong>auxdisplay</strong>  这个文件夹提供了三个驱动。LCD 帧缓存（framebuffer）驱动、LCD控制器驱动和一个LCD驱动。这些驱动用于管理液晶显示器 —— 液晶显示器会在按压时显示波纹。注意:按压会损害屏幕,所以请不要用力戳LCD显示屏。</p>
<p><strong>base</strong>  这是个重要的目录包含了固件、系统总线、虚拟化能力等基本的驱动。</p>
<p><strong>bcma</strong>  这些驱动用于使用基于AMBA协议的总线。AMBA是由博通公司开发。</p>
<p><strong>block</strong>  这些驱动提供对块设备的支持，像软驱、SCSI磁带、TCP网络块设备等等。</p>
<p><strong>bluetooth</strong>  蓝牙是一种安全的无线个人区域网络标准(PANs)。蓝牙驱动就在这个文件夹，它允许系统使用各种蓝牙设备。例如，一个蓝牙鼠标不用电缆，并且计算机有一个电子狗(小型USB接收器)。Linux系统必须能够知道进入电子狗的信号，否则蓝牙设备无法工作。</p>
<p><strong>bus</strong>  这个目录包含了三个驱动。一个转换ocp接口协议到scp协议。一个是设备间的互联驱动，第三个是用于处理互联中的错误处理。</p>
<p><strong>cdrom</strong>  这个目录包含两个驱动。一个是cd-rom，包括DVD和CD的读写。第二个是gd-rom(只读GB光盘)，GD光盘是1.2GB容量的光盘，这像一个更大的CD或者更小的DVD。GD通常用于世嘉游戏机中。</p>
<p><strong>char</strong>  字符设备驱动就在这里。字符设备每次传输数据传输一个字符。这个文件夹里的驱动包括打印机、PS3闪存驱动、东芝SMM驱动和随机数发生器驱动等。</p>
<p><strong>clk</strong>  这些驱动用于系统时钟。</p>
<p><strong>clocksource</strong>  这些驱动用于作为定时器的时钟。</p>
<p><strong>connector</strong>  这些驱动使内核知道当进程fork并使用proc连接器更改UID(用户ID)、GID(组ID)和SID(会话ID)。内核需要知道什么时候进程fork(CPU中运行多个任务)并执行。否则,内核可能会低效管理资源。</p>
<p><strong>cpufreq</strong>  这些驱动改变CPU的电源能耗。</p>
<p><strong>cpuidle</strong>  这些驱动用来管理空闲的CPU。一些系统使用多个CPU，其中一个驱动可以让这些CPU负载相当。</p>
<p><strong>crypto</strong>  这些驱动提供加密功能。</p>
<p><strong>dca</strong>  直接缓存访问（DCA ： Direct Cache Access）驱动允许内核访问CPU缓存。CPU缓存就像CPU内置的RAM。CPU缓存的速度比RAM更快。然而,CPU缓存的容量比RAM小得多。CPU在这个缓存系统上存储了最重要的和执行的代码。</p>
<p><strong>devfreq</strong>  这个驱动程序提供了一个通用的动态电压和频率调整(DVFS ： Generic Dynamic Voltage and Frequency Scaling)框架，可以根据需要改变CPU频率来节约能源。这就是所谓的CPU节能。</p>
<p><strong>dio</strong>  数字输入/输出（DIO ：Digital Input/Output）总线驱动允许内核可以使用DIO总线。</p>
<p><strong>dma</strong>  直接内存访问(DMA)驱动允许设备无需CPU直接访问内存。这减少了CPU的负载。</p>
<p><strong>edac</strong>  错误检测和校正（ Error Detection And Correction）驱动帮助减少和纠正错误。</p>
<p><strong>eisa</strong>  扩展工业标准结构总线（Extended Industry Standard Architecture）驱动提供内核对EISA总线的支持。</p>
<p><strong>extcon</strong>  外部连接器（EXTernal CONnectors）驱动用于检测设备插入时的变化。例如，extcon会检测用户是否插入了USB驱动器。</p>
<p><strong>firewire</strong>  这些驱动用于控制苹果制造的类似于USB的火线设备。</p>
<p><strong>firmware</strong>  这些驱动用于和像BIOS(计算机的基本输入输出系统固件)这样的设备的固件通信。BIOS用于启动操作系统和控制硬件与设备的固件。一些BIOS允许用户超频CPU。超频是使CPU运行在一个更快的速度。CPU速度以MHz(百万赫兹)或GHz衡量。一个3.7 GHz的CPU的的速度明显快于一个700Mhz的处理器。</p>
<p><strong>gpio</strong>  通用输入/输出(GPIO ：General Purpose Input/Output)是可由用户控制行为的芯片的管脚。这里的驱动就是控制GPIO。</p>
<p><strong>gpu</strong>  这些驱动控制VGA、GPU和直接渲染管理(DRM ：Direct Rendering Manager )。VGA是640*480的模拟计算机显示器或是简化的分辨率标准。GPU是图形处理器。DRM是一个Unix渲染系统。</p>
<p><strong>hid</strong>  这驱动用于对USB人机界面设备的支持。</p>
<p><strong>hsi</strong>  这个驱动用于内核访问像Nokia N900这样的蜂窝式调制解调器。</p>
<p><strong>hv</strong>  这个驱动用于提供Linux中的键值对(KVP ：Key Value Pair)功能。</p>
<p><strong>hwmon</strong>  硬件监控驱动用于内核读取硬件传感器上的信息。比如，CPU上有个温度传感器。那么内核就可以追踪温度的变化并相应地调节风扇的速度。</p>
<p><strong>hwspinlock</strong>  硬件转锁驱动允许系统同时使用两个或者更多的处理器，或使用一个处理器上的两个或更多的核心。</p>
<p><strong>i2c</strong>  I2C驱动可以使计算机用I2C协议处理主板上的低速外设。系统管理总线(SMBus ：System Management Bus)驱动管理SMBus,这是一种用于轻量级通信的two-wire总线。</p>
<p><strong>ide</strong>  这些驱动用来处理像CDROM和硬盘这些PATA/IDE设备。</p>
<p><strong>idle</strong>  这个驱动用来管理Intel处理器的空闲功能。</p>
<p><strong>iio</strong>  工业I/O核心驱动程序用来处理数模转换器或模数转换器。</p>
<p><strong>infiniband</strong>  Infiniband是在企业数据中心和一些超级计算机中使用的一种高性能的端口。这个目录中的驱动用来支持Infiniband硬件。</p>
<p><strong>input</strong>  这里包含了很多驱动，这些驱动都用于输入处理，包括游戏杆、鼠标、键盘、游戏端口（旧式的游戏杆接口）、遥控器、触控、耳麦按钮和许多其他的驱动。如今的操纵杆使用USB端口，但是在上世纪80、90年代，操纵杆是插在游戏端口的。</p>
<p><strong>iommu</strong>  输入/输出内存管理单元(IOMMU ：Input/Output Memory Management Unit)驱动用来管理内存管理单元中的IOMMU。IOMMU连接DMA IO总线到内存上。IOMMU是设备在没有CPU帮助下直接访问内存的桥梁。这有助于减少处理器的负载。</p>
<p><strong>ipack</strong>  Ipack代表的是IndustryPack。 这个驱动是一个虚拟总线,允许在载体和夹板之间操作。</p>
<p><strong>irqchip</strong>  这些驱动程序允许硬件的中断请求(IRQ)发送到处理器，暂时挂起一个正在运行的程序而去运行一个特殊的程序（称为一个中断处理程序）。</p>
<p><strong>isdn</strong>  这些驱动用于支持综合业务数字网(ISDN)，这是用于同步数字传输语音、视频、数据和其他网络服务使用传统电话网络的电路的通信标准。</p>
<p><strong>leds</strong>  用于LED的驱动。</p>
<p><strong>lguest</strong>  lguest用于管理客户机系统的中断。中断是CPU被重要任务打断的硬件或软件信号。CPU接着给硬件或软件一些处理资源。</p>
<p><strong>macintosh</strong>  苹果设备的驱动在这个文件夹里。</p>
<p><strong>mailbox</strong>  这个文件夹(pl320-pci)中的驱动用于管理邮箱系统的连接。</p>
<p><strong>md</strong>  多设备驱动用于支持磁盘阵列，一种多块硬盘间共享或复制数据的系统。</p>
<p><strong>media</strong>  媒体驱动提供了对收音机、调谐器、视频捕捉卡、DVB标准的数字电视等等的支持。驱动还提供了对不同通过USB或火线端口插入的多媒体设备的支持。</p>
<p><strong>memory</strong>  支持内存的重要驱动。</p>
<p><strong>memstick</strong>  这个驱动用于支持Sony记忆棒。</p>
<p><strong>message</strong>  这些驱动用于运行LSI Fusion MPT(一种消息传递技术)固件的LSI PCI芯片/适配器。LSI大规模集成，这代表每片芯片上集成了几万晶体管、</p>
<p><strong>mfd</strong>  多用途设备(MFD)驱动提供了对可以提供诸如电子邮件、传真、复印机、扫描仪、打印机功能的多用途设备的支持。这里的驱动还给MFD设备提供了一个通用多媒体通信端口(MCP)层。</p>
<p><strong>misc</strong>  这个目录包含了不适合在其他目录的各种驱动。就像光线传感器驱动。</p>
<p><strong>mmc</strong>  MMC卡驱动用于处理用于MMC标准的闪存卡。</p>
<p><strong>mtd</strong>  内存技术设备(MTD ：Memory technology devices)驱动程序用于Linux和闪存的交互，这就就像一层闪存转换层。其他块设备和字符设备的驱动程序不会以闪存设备的操作方式来做映射。尽管USB记忆卡和SD卡是闪存设备，但它们不使用这个驱动，因为他们隐藏在系统的块设备接口后。这个驱动用于新型闪存设备的通用闪存驱动器驱动。</p>
<p><strong>net</strong>  网络驱动提供像AppleTalk、TCP和其他的网络协议。这些驱动也提供对调制解调器、USB 2.0的网络设备、和射频设备的支持。</p>
<p><strong>nfc</strong>  这个驱动是德州仪器的共享传输层之间的接口和NCI核心。</p>
<p><strong>ntb</strong>  不透明的桥接驱动提供了在PCIe系统的不透明桥接。PCIe是一种高速扩展总线标准。</p>
<p><strong>nubus</strong>  NuBus是一种32位并行计算总线。用于支持苹果设备。</p>
<p><strong>of</strong>  此驱动程序提供设备树中创建、访问和解释程序的OF助手。</p>
<p><strong>oprofile</strong>  这个驱动用于从驱动到用户空间进程(运行在用户态下的应用)评测整个系统。这帮助开发人员找到性能问题—-性能分析机制-是用于 Linux 的若干种评测和性能监控工具中的一种</p>
<p><strong>parisc</strong>  这些驱动用于HP生产的PA-RISC架构设备。PA-RISC是一种特殊指令集的处理器。</p>
<p><strong>parport</strong>  并口驱动提供了Linux下的并口支持。</p>
<p><strong>pci</strong>  这些驱动提供了PCI总线服务。</p>
<p><strong>pcmcia</strong>  这些是笔记本的pc卡驱动</p>
<p><strong>pinctrl</strong>  这些驱动用来处理引脚控制设备。引脚控制器可以禁用或启用I/O设备。</p>
<p><strong>platform</strong> 这个文件夹包含了不同的计算机平台的驱动像Acer、Dell、Toshiba、IBM、Intel、Chrombooks等等。</p>
<p><strong>pnp</strong>  即插即用驱动允许用户在插入一个像USB的设备后可以立即使用而不必手动配置设备。</p>
<p><strong>power</strong>  电源驱动使内核可以测量电池电量，检测充电器和进行电源管理。</p>
<p><strong>pps</strong>  Pulse-Per-Second驱动用来控制电流脉冲速率。这用于计时。</p>
<p><strong>ps3</strong>  这是Sony的游戏控制台驱动- PlayStation3。</p>
<p><strong>ptp</strong>  图片传输协议(PTP)驱动支持一种从数码相机中传输图片的协议。</p>
<p><strong>pwm</strong>  脉宽调制(PWM)驱动用于控制设备的电流脉冲。主要用于控制像CPU风扇。</p>
<p><strong>rapidio</strong>  RapidIO驱动用于管理RapidIO架构，它是一种高性能分组交换，用于电路板上交互芯片的交互技术，也用于互相使用底板的电路板。</p>
<p><strong>regulator</strong>  校准驱动用于校准电流、温度、或其他可能系统存在的校准硬件。—-用于控制系统中某些设备的电压电流供应</p>
<p><strong>remoteproc</strong>  这些驱动用来管理远程处理器。</p>
<p><strong>rpmsg</strong>  这个驱动用来控制支持大量驱动的远程处理器通讯总线(rpmsg)。这些总线提供消息传递设施,促进客户端驱动程序编写自己的连接协议消息。—-该基础架构允许主处理器上的 Linux 操作系统管理远程处理器上远程软件环境的生命周期和通信-用于在 AMP 环境中的操作系统之间实现 IPC 的 rpmsg 组件和 API</p>
<p><strong>rtc</strong>  实时时钟(RTC)驱动使内核可以读取时钟。</p>
<p><strong>s390</strong>  用于31/32位的大型机架构的驱动。</p>
<p><strong>sbus</strong>  用于管理基于SPARC的总线驱动。</p>
<p><strong>scsi</strong>  允许内核使用SCSI标准外围设备。例如,Linux将在与SCSI硬件传输数据时使用SCSI驱动。</p>
<p><strong>sfi</strong> 简单固件接口(SFI)驱动允许固件发送信息表给操作系统。这些表的数据称为SFI表。</p>
<p><strong>sh</strong>  该驱动用于支持SuperHway总线。</p>
<p><strong>sn</strong>  该驱动用于支持IOC3串口。</p>
<p><strong>spi</strong>  这些驱动处理串行设备接口总线(SPI)，它是一个在在全双工下运行的同步串行数据链路标准,。全双工是指两个设备可以同一时间同时发送和接收信息。双工指的是双向通信。设备在主/从模式下通信(取决于设备配置)。</p>
<p><strong>ssb</strong>  ssb(Sonics Silicon Backplane)驱动提供对在不同芯片和嵌入式设备上使用的迷你总线的支持。</p>
<p><strong>staging</strong>  该目录含有许多子目录。这里所有的驱动还需要在加入主内核前经过更多的开发工作。</p>
<p><strong>target</strong>  SCSI设备驱动</p>
<p><strong>tc</strong>  这些驱动用于TURBOchannel，TURBOchannel是数字设备公司开发的32位开放总线。这主要用于DEC工作站。</p>
<p><strong>thermal</strong>  thermal驱动使CPU保持较低温度。—Linux温控框架</p>
<p><strong>tty</strong>  tty驱动用于管理物理终端连接。</p>
<p><strong>uio</strong>  该驱动允许用户编译运行在用户空间而不是内核空间的驱动。这使用户驱动不会导致内核崩溃。—–运行在用户空间的IO技术</p>
<p><strong>usb</strong>  USB设备允许内核使用USB端口。闪存驱动和记忆卡已经包含了固件和控制器,所以这些驱动程序允许内核使用USB接口和与USB设备。</p>
<p><strong>uwb</strong>  Ultra-WideBand驱动用来管理短距离，高带宽通信的超低功耗的射频设备</p>
<p><strong>vfio</strong>  允许设备访问用户空间的VFIO驱动。用户态驱动框架。</p>
<p><strong>vhost</strong>  这是用于宿主内核中的virtio服务器驱动。用于虚拟化中。</p>
<p><strong>video</strong>  这是用来管理显卡和监视器的视频驱动。</p>
<p><strong>virt</strong>  这些驱动用来虚拟化。</p>
<p><strong>virtio</strong>  这个驱动用来在虚拟PCI设备上使用virtio设备。用于虚拟化中。</p>
<p><strong>vlynq</strong>  这个驱动控制着由德州仪器开发的专有接口。这些都是宽带产品，像WLAN和调制解调器，VOIP处理器，音频和数字媒体信号处理芯片。</p>
<p><strong>vme</strong>  WMEbus最初是为摩托罗拉68000系列处理器开发的总线标准</p>
<p><strong>w1</strong>  这些驱动用来控制one-wire总线。</p>
<p><strong>watchdog</strong>  该驱动管理看门狗定时器，这是一个可以用来检测和恢复异常的定时器。</p>
<p><strong>xen</strong>  该驱动是Xen管理程序系统。这是个允许用户运行多个操作系统在一台计算机的软件或硬件。这意味着xen的代码将允许用户在同一时间的一台计算机上运行两个或更多的Linux系统。用户也可以在Linux上运行Windows、Solaris、FreeBSD、或其他操作系统。</p>
<p><strong>zorro</strong>  该驱动提供Zorro Amiga总线支持。</p>
<p>Documentation/CodingStyle 文件描 述 了 Linux 内 核 对 编 码 风 格 的 要 求，内 核 下 的scripts/checkpatch.pl 脚本可以检查代码风格。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>kernel make and menuconfig</title>
    <url>/2022/09/04/kernel/kernel_make/</url>
    <content><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>指定交叉工具和平台。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- ARCH=arm defconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- ARCH=arm menuconfig</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul>
<li>屏蔽编译信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make &gt; /dev/null</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>make -j&lt;n&gt;</code>参数加速编译</p>
</li>
<li><p>指定编译某些模块</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make M=drivers/i2c/ modules</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 verbose 模式，将每一步执行的命令都打印出来，并重定向到一个文件中去，这样以后可以方便地查找模块之间的依赖关系。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make V=1 &gt; ~/bak.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 ccache 提高编译速度，使用 ccache时，需要更改源码树根目录下面的 Makefile 文件，在 CC 和 HOSTCC 变量的定义前添加 ccache。<a href="http://ccache.samba.org/">ccache主页</a>。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = ccache <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">HOSTCC = ccache gcc</span><br></pre></td></tr></table></figure>

<h2 id="编译文档"><a href="#编译文档" class="headerlink" title="编译文档"></a>编译文档</h2><p>使用下面的一些命令可以在 Documentation/DocBook/目录下，生成一些文档。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make htmldocs //生成 HTML 文件</span><br><span class="line">make pdfdocs  //生成 PDF 文件</span><br><span class="line">make psdocs   //生成 Postscript 文件</span><br><span class="line">make mandocs  //生成 Kernel API 手册</span><br><span class="line">make installmandocs //将 Kernel API 手册页安装到 man 程序能够找到的目录中</span><br></pre></td></tr></table></figure>

<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>1.缺少libncurses5-dev</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make menuconfig requires the ncurses libraries.</span><br></pre></td></tr></table></figure>

<p>2.没有安装u-boot-tools</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkimage command not found – U-Boot images will not be built</span><br></pre></td></tr></table></figure>

<p>3.源文件编译生成的.o文件和模块目标文件xxx.o重名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module license &#x27;unspecified&#x27; taints kernel.</span><br><span class="line">Disabling lock debugging due to kernel taint</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>kernel irq</title>
    <url>/2022/06/07/kernel/irq/</url>
    <content><![CDATA[<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>根据中断入口跳转方法的不同，分为向量中断和非向量中断。采用向量中断的 CPU 通常为不同的中断分配不同的中断号，当检测到某中断号的中断到来后，就自动跳转到与该中断号对应的地址执行。不同中断号的中断有不同的入口地址。非向量中断的多个中断共享一个入口地址，进入该入口地址后再通过软件判断中断标志来识别具体是哪个中断。</p>
<p>中断处理程序是在中断上下文中运行的，它受到某些限制:</p>
<ol>
<li>不能向用户空间发送或接受数据</li>
<li>不能使用可能引起阻塞的函数</li>
<li>不能使用可能引起调度的函数</li>
</ol>
<p><img src="/images/kernel/irq/irq.png" alt="irq"></p>
<p>Linux 将中断处理程序分为顶半部(top half)和底半部(bottom half)。顶半部完成尽可能少的比较紧急的功能，往只是简单地读取寄存器中的中断状态并清除中断标志，这样才能服务更多的中断请求。底半部处理比较耗时的事情，而且可以被新的中断打断。Linux 实现底半部的机制主要有 tasklet、工作队列和软中断。</p>
<p>tasklet和内核定时器都是依靠软中断实现。软中断和tasklet 运行于软中断上下文，仍然属于原子上下文的一种，而工作队列则运行于进<br>程上下文。因此，软中断和 tasklet 处理函数中不能睡眠，而工作队列处理函数中允许睡眠。</p>
<p><code>/proc/interrupts</code>文件可以获得系统中中断的统计信息，第1列是中断号，第2列是向对应CPU产后的中断的次数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">irqreturn_t</span> <span class="params">(*<span class="type">irq_handler_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure>

<p>irq 是要申请的硬件中断号。handler 是向系统登记的中断处理函数，是一个回调函数，中断发生时，系统调用这个函数，dev_id 可在共享中断中作为参数传入中断处理函数，也可以为 NULL。</p>
<p>flags 是中断处理的属性，可以指定中断的触发方式以及处理方式。</p>
<ul>
<li>IRQF_TRIGGER_RISING</li>
<li>IRQF_TRIGGER_FALLING</li>
<li>IRQF_TRIGGER_HIGH</li>
<li>IRQF_TRIGGER_LOW</li>
<li>IRQF_ISABLED  表明中断处理程序是快速处理程序，快速处理程序被调用时屏蔽所有中断，慢速处理程序则不会屏蔽其他设备的驱动。</li>
<li>IRQF_SHARED  表示多个设备共享中断，主要是为PCI设备服务。</li>
</ul>
<p>request_irq()返回 0 表示成功；返回-EINVAL 表示中断号无效或处理函数指针为 NULL；返回-EBUSY 表示中断已经被占用且不能共享。</p>
<p>request_irq()相对应的释放中断的函数为 free_irq()。</p>
<p>共享中断到来时，会遍历执行共享此中断的所有中断处理程序，直到某一个函数返回 IRQ_HANDLED。在中断处理程序顶半部中，应对照传入的 dev_id 参数判断是否是本设备的中断，若不是返回 IRQ_NONE。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br></pre></td></tr></table></figure>

<p>这些函数用于使能和屏蔽一个中断源，disable_irq_nosync()立即返回，而disable_rq()会等待指定的中断被处理完，因此如果在顶半部调用，会引起系统的死锁。</p>
<h2 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h2><p>tasklet不能休眠，同一个tasklet不能在两个CPU上同时运行。定义 tasklet 及其中断底半部处理函数并将两者关联，在中断顶半部中调度task执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化tasklet，指定其处理函数及其传递的参数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t,</span></span><br><span class="line"><span class="params">          <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调度task执行*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁tasklet*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_kill</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>定义一个工作队列和一个底半部执行函数，并将其绑定，在中断顶半部调度工作队列执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="type">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        flags;      <span class="comment">/* I: WQ_* flags */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> __<span class="title">percpu</span>    *<span class="title">pcpu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span>     *<span class="title">single</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>               v;</span><br><span class="line">    &#125; cpu_wq;               <span class="comment">/* I: cwq&#x27;s */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">list</span>;</span>       <span class="comment">/* W: list of all workqueues */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">flush_mutex</span>;</span>    <span class="comment">/* protects wq flushing */</span></span><br><span class="line">    <span class="type">int</span>         work_color; <span class="comment">/* F: current work color */</span></span><br><span class="line">    <span class="type">int</span>         flush_color;    <span class="comment">/* F: current flush color */</span></span><br><span class="line">    <span class="type">atomic_t</span>        nr_cwqs_to_flush; <span class="comment">/* flush in progress */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span>   *<span class="title">first_flusher</span>;</span> <span class="comment">/* F: first flusher */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">flusher_queue</span>;</span>  <span class="comment">/* F: flush waiters */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">flusher_overflow</span>;</span> <span class="comment">/* F: flush overflow list */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">mayday_mask_t</span>       mayday_mask;    <span class="comment">/* cpus requesting rescue */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker</span>       *<span class="title">rescuer</span>;</span>   <span class="comment">/* I: rescue worker */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         saved_max_active; <span class="comment">/* W: saved cwq max_active */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *name;      <span class="comment">/* I: workqueue name */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>  <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">work_func_t</span>)</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化工作并将其与处理函数绑定*/</span></span><br><span class="line">INIT_WORK(<span class="keyword">struct</span> work_struct *work, <span class="type">work_func_t</span> func)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调度工作执行*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">flush_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">flush_work_sync</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cancel_work_sync</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> create_workqueue(name)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> create_freezable_workqueue(name)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> create_singlethread_workqueue(name)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flush_workqueue</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁工作队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_workqueue</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="delayed-work"><a href="#delayed-work" class="headerlink" title="delayed_work"></a>delayed_work</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="type">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">work_func_t</span>)</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"></span><br><span class="line">INIT_DELAYED_WORK(<span class="keyword">struct</span> delayed_work *dwork, <span class="type">work_func_t</span> func)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调度delayed_work 在指定延时后执行*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">schedule_delayed_work</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork, <span class="type">unsigned</span> <span class="type">long</span> delay)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">flush_delayed_work</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">flush_delayed_work_sync</span><span class="params">(<span class="keyword">struct</span> delayed_work *work)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cancel_delayed_work</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cancel_delayed_work_sync</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork)</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>input 子系统</title>
    <url>/2022/09/04/kernel/input/</url>
    <content><![CDATA[<p>Linux 输入子系统由三部分组成：</p>
<ul>
<li><p>设备驱动层主要实现对硬件设备的读写访问，中断设置，并把硬件产生的事件通过核心层定义的的 API 上报给事件处理层。代码实现在 input.c。</p>
</li>
<li><p>核心层为事件处理层和设备驱动层提供接口 API，通知事件处理层对事件进行处理。具体实现代码在 drivers/input/input.c。input 核心层维护一个 input_device 链表和 input_handler 链表，还有一个 input_handler 数组。</p>
</li>
<li><p>事件处理层提供用户编程的接口（设备节点），并处理驱动层上报的数据处理。不同类型的输入设备都有相应的实现文件，如 evdev.c、mousedev.c、joydev.c。</p>
</li>
</ul>
<p><img src="/images/kernel/input/input-arch.jpg" alt="img"></p>
<h2 id="input-dev"><a href="#input-dev" class="headerlink" title="input_dev"></a>input_dev</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//设备名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *phys;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *uniq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span>  <span class="comment">//与 handler 匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输入设备支持事件的位图*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)];   <span class="comment">// 所有事件</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; <span class="comment">// 按键事件</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; <span class="comment">// 相对位移事件</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; <span class="comment">// 记录支持的绝对坐标的位图</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hint_events_per_packet;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> keycodemax;   <span class="comment">//支持的按键值的个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> keycodesize;  <span class="comment">//每个键值的字节数</span></span><br><span class="line">    <span class="type">void</span> *keycode;  <span class="comment">//存储按键值的数组首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*setkeycode)(<span class="keyword">struct</span> input_dev *dev, <span class="type">int</span> scancode, <span class="type">int</span> keycode);</span><br><span class="line">    <span class="type">int</span> (*getkeycode)(<span class="keyword">struct</span> input_dev *dev, <span class="type">int</span> scancode, <span class="type">int</span> *keycode);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ff_device</span> *<span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> repeat_key;   <span class="comment">//最近一次按键值，用于连击</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span>   <span class="comment">//自动连击计时器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="built_in">abs</span>[ABS_MAX + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> rep[REP_MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_mt_slot</span> *<span class="title">mt</span>;</span></span><br><span class="line">    <span class="type">int</span> mtsize;</span><br><span class="line">    <span class="type">int</span> slot;</span><br><span class="line">    <span class="type">int</span> trkid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> *<span class="title">absinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> key[BITS_TO_LONGS(KEY_CNT)];  <span class="comment">//反映当前按键状态的位图</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> led[BITS_TO_LONGS(LED_CNT)];  <span class="comment">//反映当前 led 状态的位图</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> snd[BITS_TO_LONGS(SND_CNT)];  <span class="comment">//反映当前 beep 状态的位图</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sw[BITS_TO_LONGS(SW_CNT)];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> absmax[ABS_MAX + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> absmin[ABS_MAX + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> absfuzz[ABS_MAX + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> absflat[ABS_MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> input_dev *dev);   <span class="comment">//打开函数</span></span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> input_dev *dev); <span class="comment">//关闭函数</span></span><br><span class="line">    <span class="type">int</span> (*flush)(<span class="keyword">struct</span> input_dev *dev, <span class="keyword">struct</span> file *file);  <span class="comment">//断开连接时刷新数据</span></span><br><span class="line">    <span class="type">int</span> (*event)(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value); </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span> <span class="comment">//当前占用该设备的 input_handle</span></span><br><span class="line"></span><br><span class="line">    <span class="type">spinlock_t</span> event_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> users;</span><br><span class="line">    <span class="type">int</span> going_away;</span><br><span class="line">    <span class="type">bool</span> sync;   <span class="comment">//最后一次同步后没有新的事件置 1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">h_list</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> &#123;</span></span><br><span class="line">    __u16 bustype;  <span class="comment">/*总线类型*/</span></span><br><span class="line">    __u16 vendor;   <span class="comment">/*生产商编号*/</span></span><br><span class="line">    __u16 product;  <span class="comment">/*产品编号*/</span></span><br><span class="line">    __u16 version;  <span class="comment">/* 版本号 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>input_dev 结构体代表一个具体的硬件设备。node 是 input_dev 链表，包含所有注册了的 input_dev 设备。h_list 是 handle 链表，包含该设备相匹配的 input_handler 设备处理方法。input_dev 通过设置位图来标记设备具有什么功能。</p>
<h3 id="注册-input-dev"><a href="#注册-input-dev" class="headerlink" title="注册 input_dev"></a>注册 input_dev</h3><ol>
<li><p>实例化一个 input_dev 对象，创建一个硬件设备</p>
</li>
<li><p>配置 evbit 成员，设置支持的事件类型，<code>EV_SYN</code>表示支持所有的事件类型。可以使用 input_set_capability() 函数，input.h 里有事件 code 的定义</p>
</li>
<li><p>相关硬件初始化，中断初始化，定义中断处理程序</p>
</li>
<li><p>使用 input_register_device() 函数注册 input_dev</p>
</li>
<li><p>当有事件发生时，在处理函数里调用 input_report_key() 函数上报事件，然后使用 input_sync() 函数将收集的事件发给用户空间。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span> =</span> input_allocate_device();</span><br><span class="line"></span><br><span class="line">input-&gt;name = pdev-&gt;name;</span><br><span class="line">input-&gt;phys = <span class="string">&quot;gpio-keys/input0&quot;</span>;</span><br><span class="line">input-&gt;dev.parent = &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">input-&gt;id.bustype = BUS_HOST;</span><br><span class="line">input-&gt;id.vendor = <span class="number">0x0001</span>;</span><br><span class="line">input-&gt;id.product = <span class="number">0x0001</span>;</span><br><span class="line">input-&gt;id.version = <span class="number">0x0100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable auto repeat feature of Linux input subsystem */</span></span><br><span class="line"><span class="keyword">if</span> (pdata-&gt;rep)</span><br><span class="line">    __set_bit(EV_REP, input-&gt;evbit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pdata-&gt;nbuttons; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_keys_button</span> *<span class="title">button</span> =</span> &amp;pdata-&gt;buttons[i];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> type = button-&gt;type ?: EV_KEY;</span><br><span class="line"></span><br><span class="line">    input_set_capability(input, type, button-&gt;code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = input_register_device(input);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get current state of buttons */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pdata-&gt;nbuttons; i++)</span><br><span class="line">    gpio_keys_report_event(&amp;ddata-&gt;data[i]);</span><br><span class="line">input_sync(input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="input-register-device"><a href="#input-register-device" class="headerlink" title="input_register_device()"></a>input_register_device()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Every input device generates EV_SYN/SYN_REPORT events. */</span></span><br><span class="line">    __set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KEY_RESERVED is not supposed to be transmitted to userspace. */</span></span><br><span class="line">    __clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */</span></span><br><span class="line">    input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD])</span><br><span class="line">        input_enable_softrepeat(dev, <span class="number">250</span>, <span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;getkeycode)</span><br><span class="line">        dev-&gt;getkeycode = input_default_getkeycode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;setkeycode)</span><br><span class="line">        dev-&gt;setkeycode = input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册输入设备，把输入设备挂到输入设备链表 input_dev_list 中，遍历 input_handler_list 链表，如果找到 input_id 匹配的事件处理器，则调用其 connect() 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">input_attach_handler</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="keyword">struct</span> input_handler *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    id = input_match_device(handler, dev);</span><br><span class="line">    <span class="keyword">if</span> (!id)</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handler-&gt;connect(handler, dev, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="input-event"><a href="#input-event" class="headerlink" title="input_event()"></a>input_event()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">input_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    input_event(dev, EV_SYN, SYN_REPORT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">input_report_key</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line">        spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">        add_input_randomness(type, code, value);</span><br><span class="line">        input_handle_event(dev, type, code, value);</span><br><span class="line">        spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">input_handle_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">                   <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> disposition = INPUT_IGNORE_EVENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EV_KEY:</span><br><span class="line">            <span class="keyword">if</span> (is_event_supported(code, dev-&gt;keybit, KEY_MAX) &amp;&amp;</span><br><span class="line">                !!test_bit(code, dev-&gt;key) != value) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (value != <span class="number">2</span>) &#123;</span><br><span class="line">                    __change_bit(code, dev-&gt;key);</span><br><span class="line">                    <span class="keyword">if</span> (value)</span><br><span class="line">                        input_start_autorepeat(dev, code);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        input_stop_autorepeat(dev);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (disposition != INPUT_IGNORE_EVENT &amp;&amp; type != EV_SYN)</span><br><span class="line">        dev-&gt;sync = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((disposition &amp; INPUT_PASS_TO_DEVICE) &amp;&amp; dev-&gt;event)</span><br><span class="line">        dev-&gt;event(dev, type, code, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (disposition &amp; INPUT_PASS_TO_HANDLERS)</span><br><span class="line">        input_pass_event(dev, type, code, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">input_pass_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>;</span></span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line"></span><br><span class="line">    handle = rcu_dereference(dev-&gt;grab);</span><br><span class="line">    <span class="keyword">if</span> (handle)</span><br><span class="line">        handle-&gt;handler-&gt;event(handle, type, code, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">bool</span> filtered = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!handle-&gt;open)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            handler = handle-&gt;handler;</span><br><span class="line">            <span class="keyword">if</span> (!handler-&gt;filter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (filtered)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                handler-&gt;event(handle, type, code, value);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler-&gt;filter(handle, type, code, value))</span><br><span class="line">                filtered = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="input-set-capability"><a href="#input-set-capability" class="headerlink" title="input_set_capability()"></a>input_set_capability()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_set_capability</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EV_KEY:</span><br><span class="line">        __set_bit(code, dev-&gt;keybit);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        printk(KERN_ERR</span><br><span class="line">            <span class="string">&quot;input_set_capability: unknown type %u (code %u)\n&quot;</span>,</span><br><span class="line">            type, code);</span><br><span class="line">        dump_stack();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __set_bit(type, dev-&gt;evbit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="input-init"><a href="#input-init" class="headerlink" title="input_init()"></a>input_init()</h3><p>input_init() 完成设备的初始化。创建 proc 接口，<code>/proc/bus/input/devices</code>文件显示已经注册的输入设备；<code>/proc/bus/input/handlers</code>文件显示已注册事件处理函数。在/sys/class 下创建 input 类。创建字符设备，主设备号是 13，次设备号分布如下：</p>
<ul>
<li>joystick 游戏杆：0~16</li>
<li>mouse 鼠标： 32~62</li>
<li>mice 鼠标： 63</li>
<li>事件设备： 64~95</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">input_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = class_register(&amp;input_class);</span><br><span class="line"></span><br><span class="line">    err = input_proc_init();</span><br><span class="line"></span><br><span class="line">    err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>), INPUT_MAX_CHAR_DEVICES, <span class="string">&quot;input&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="input-handler"><a href="#input-handler" class="headerlink" title="input_handler"></a>input_handler</h2><p>input_handler 结构体代表一种事件处理器，通过设置 input_device_id 中的位图来标记匹配的设备至少要满足什么功能。实现代码在evdev.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span>                     </span><br><span class="line">    <span class="type">void</span> *private;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*处理设备驱动报告的事件*/</span></span><br><span class="line">    <span class="type">void</span> (*event)(<span class="keyword">struct</span> input_handle *handle, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);</span><br><span class="line">    <span class="type">bool</span> (*filter)(<span class="keyword">struct</span> input_handle *handle, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);</span><br><span class="line">    <span class="type">bool</span> (*match)(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev);</span><br><span class="line">    <span class="type">int</span> (*connect)(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev, </span><br><span class="line">        <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id);</span><br><span class="line">    <span class="type">void</span> (*disconnect)(<span class="keyword">struct</span> input_handle *handle);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> input_handle *handle);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    <span class="type">int</span> minor;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span> <span class="comment">//存放该 handler 所支持的设备 id 的表</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">h_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">kernel_ulong_t</span> flags;</span><br><span class="line"></span><br><span class="line">    __u16 bustype;</span><br><span class="line">    __u16 vendor;</span><br><span class="line">    __u16 product;</span><br><span class="line">    __u16 version;</span><br><span class="line"></span><br><span class="line">    <span class="type">kernel_ulong_t</span> evbit[INPUT_DEVICE_ID_EV_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="type">kernel_ulong_t</span> keybit[INPUT_DEVICE_ID_KEY_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="type">kernel_ulong_t</span> relbit[INPUT_DEVICE_ID_REL_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="type">kernel_ulong_t</span> absbit[INPUT_DEVICE_ID_ABS_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="type">kernel_ulong_t</span> mscbit[INPUT_DEVICE_ID_MSC_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="type">kernel_ulong_t</span> ledbit[INPUT_DEVICE_ID_LED_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="type">kernel_ulong_t</span> sndbit[INPUT_DEVICE_ID_SND_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="type">kernel_ulong_t</span> ffbit[INPUT_DEVICE_ID_FF_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="type">kernel_ulong_t</span> swbit[INPUT_DEVICE_ID_SW_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line">    <span class="type">kernel_ulong_t</span> propbit[INPUT_DEVICE_ID_PROP_MAX / BITS_PER_LONG + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">kernel_ulong_t</span> driver_info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注册 handler</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">evdev_ids</span>[] =</span> &#123;</span><br><span class="line">    &#123; .driver_info = <span class="number">1</span> &#125;,   <span class="comment">/* Matches all devices */</span></span><br><span class="line">    &#123; &#125;,            <span class="comment">/* Terminating zero entry */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> =</span> &#123;</span><br><span class="line">    .event      = evdev_event,</span><br><span class="line">    .connect    = evdev_connect,</span><br><span class="line">    .disconnect = evdev_disconnect,</span><br><span class="line">    .fops       = &amp;evdev_fops,</span><br><span class="line">    .minor      = EVDEV_MINOR_BASE,</span><br><span class="line">    .name       = <span class="string">&quot;evdev&quot;</span>,</span><br><span class="line">    .id_table   = evdev_ids,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">evdev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="input-register-handler"><a href="#input-register-handler" class="headerlink" title="input_register_handler()"></a>input_register_handler()</h3><p>注册事件处理器。把 handler 挂到 input_handler_list 链表中，并遍历 input_dev_list 链表，关联匹配的输入设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_handler</span><span class="params">(<span class="keyword">struct</span> input_handler *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配 input_dev 和 input_handler ，如果匹配成功，则调用 handler-&gt;connnect() 将 input_dev 和 input_handler 连接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">input_attach_handler</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="keyword">struct</span> input_handler *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    id = input_match_device(handler, dev);</span><br><span class="line">    <span class="keyword">if</span> (!id)</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; error != -ENODEV)</span><br><span class="line">        pr_err(<span class="string">&quot;failed to attach handler %s to device %s, error: %d\n&quot;</span>,</span><br><span class="line">               handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="input-match-device"><a href="#input-match-device" class="headerlink" title="input_match_device()"></a>input_match_device()</h3><p>input_match_device() 匹配 input_dev 和 input_handler 的 id 成员。如果 id-&gt;driver_info 设置了说明它匹配所有的 id，evdev 就是这样的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> input_device_id *<span class="title function_">input_match_device</span><span class="params">(<span class="keyword">struct</span> input_handler *handler,</span></span><br><span class="line"><span class="params">                            <span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!handler-&gt;match || handler-&gt;match(handler, dev)) &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="input-handle"><a href="#input-handle" class="headerlink" title="input_handle"></a>input_handle</h2><p>input_handle 结构体代表一个成功配对的 input_dev 和 input_handler。input_hande 没有一个全局的链表，它注册的时候将自己分别挂在了 input_device 和 input_handler 的 h_list 上了；同时，input_handle 结构体成员 dev 关联到 input_dev 结构，handler 关联到 input_handler 结构。</p>
<p>当注册一个 input_device 的时候，会遍历 input_hanlder 链表，查看是否匹配，如果匹配，就会创建一个 input_hanle 连接器，然后分别存放到对应的 input_dev 和 input_handler 中的 input_handle 链表中，注册 input_handler 的时候也是同理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> &#123;</span>                                                                                             </span><br><span class="line">    <span class="type">void</span> *private;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> open;  <span class="comment">//设备打开次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">d_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">h_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="input-register-handle"><a href="#input-register-handle" class="headerlink" title="input_register_handle()"></a>input_register_handle()</h3><p>将自己添加到 input_dev.h_list 链表和 input_handler.h_list 链表中，如果事件处理器定义了 start 函数，则调用它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_handle</span><span class="params">(<span class="keyword">struct</span> input_handle *handle)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> =</span> handle-&gt;handler;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> =</span> handle-&gt;dev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;filter)</span><br><span class="line">        list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;start)</span><br><span class="line">        handler-&gt;start(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p>每个 input_handler 都会实现相应的 connect 方法。里面会调用 input_register_handle() 注册一个 input_handle，并生成设备节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_connect</span><span class="params">(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="type">int</span> minor;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    evdev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> evdev), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;evdev-&gt;client_list);</span><br><span class="line">    spin_lock_init(&amp;evdev-&gt;client_lock);</span><br><span class="line">    mutex_init(&amp;evdev-&gt;mutex);</span><br><span class="line">    init_waitqueue_head(&amp;evdev-&gt;wait);</span><br><span class="line"></span><br><span class="line">    dev_set_name(&amp;evdev-&gt;dev, <span class="string">&quot;event%d&quot;</span>, minor);</span><br><span class="line">    evdev-&gt;exist = <span class="number">1</span>;</span><br><span class="line">    evdev-&gt;minor = minor;</span><br><span class="line"></span><br><span class="line">    evdev-&gt;handle.dev = input_get_device(dev);</span><br><span class="line">    evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);</span><br><span class="line">    evdev-&gt;handle.handler = handler;</span><br><span class="line">    evdev-&gt;handle.private = evdev;</span><br><span class="line"></span><br><span class="line">    evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor);</span><br><span class="line">    evdev-&gt;dev.class = &amp;input_class;</span><br><span class="line">    evdev-&gt;dev.parent = &amp;dev-&gt;dev;</span><br><span class="line">    evdev-&gt;dev.release = evdev_free;</span><br><span class="line">    device_initialize(&amp;evdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">    error = input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line"></span><br><span class="line">    error = evdev_install_chrdev(evdev);</span><br><span class="line">    error = device_add(&amp;evdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><p>当应用层调用 read 函数时，将调用到事件处理器的 evdev_read() 函数，若当前无事件发生就会进入了休眠状态。当驱动层上报事件时，调用 input_event() 函数，最终会引起事件处理器的 evdev_event() 函数调用，唤醒休眠，将事件信息读出到应用层。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">evdev_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">              <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client-&gt;head == client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp;</span><br><span class="line">        (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">    retval = wait_event_interruptible(evdev-&gt;wait,</span><br><span class="line">        client-&gt;head != client-&gt;tail || !evdev-&gt;exist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (retval + input_event_size() &lt;= count &amp;&amp;</span><br><span class="line">           evdev_fetch_next_event(client, &amp;event)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input_event_to_user(buffer + retval, &amp;event))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        retval += input_event_size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="input-event-1"><a href="#input-event-1" class="headerlink" title="input_event"></a>input_event</h2><p>input 产生的事件用 struct input_event 表示，应用层只要调 read() 函数读/dev/input/下相应设备节点，从而获取到 input_event 信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span> <span class="comment">//事件发生的时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> type; <span class="comment">//事件的类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> code; <span class="comment">//事件的代码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> value;  <span class="comment">//事件的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>device</category>
      </categories>
      <tags>
        <tag>device</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title>linux kernel list</title>
    <url>/2022/06/07/kernel/list/</url>
    <content><![CDATA[<p>Linux内核中使用了大量的链表结构来组织数据，代码实现在include/linux/list.h中。</p>
<h2 id="list-head"><a href="#list-head" class="headerlink" title="list_head"></a>list_head</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>list_head本身没有任何数据内容，只有两个方向指针prev和next，而自定义的数据结点结构体只要包含list_head指针，就可以使用 list提供的所有接口函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span>    data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*声明一个链表头，它的next、prev指针都初始化为指向自己*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化已经定义过的链表*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">INIT_LIST_HEAD</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-add"><a href="#list-add" class="headerlink" title="list_add"></a>list_add</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add(<span class="keyword">struct</span> list_head *new_entry,</span><br><span class="line">       <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">       <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = new_entry;</span><br><span class="line">    new_entry-&gt;next = next;</span><br><span class="line">    new_entry-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = new_entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *new_entry, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_add(new_entry, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add_tail</span><span class="params">(<span class="keyword">struct</span> list_head *new_entry, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_add(new_entry, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-del"><a href="#list-del" class="headerlink" title="list_del"></a>list_del</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del(<span class="keyword">struct</span> list_head * prev, <span class="keyword">struct</span> list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_POISON1  ((void *) 0x00100100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_POISON2  ((void *) 0x00200200)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_del</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">    entry-&gt;next = (<span class="keyword">struct</span> list_head *)LIST_POISON1;</span><br><span class="line">    entry-&gt;prev = (<span class="keyword">struct</span> list_head *)LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-replace"><a href="#list-replace" class="headerlink" title="list_replace"></a>list_replace</h2><p>新节点替换老节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_replace</span><span class="params">(<span class="keyword">struct</span> list_head *old,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> list_head *new_entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    new_entry-&gt;next = old-&gt;next;</span><br><span class="line">    new_entry-&gt;next-&gt;prev = new_entry;</span><br><span class="line">    new_entry-&gt;prev = old-&gt;prev;</span><br><span class="line">    new_entry-&gt;prev-&gt;next = new_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-move"><a href="#list-move" class="headerlink" title="list_move"></a>list_move</h2><p>移动节点到另一个链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_move</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_del_entry(<span class="built_in">list</span>);</span><br><span class="line">    list_add(<span class="built_in">list</span>, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_move_tail</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_del_entry(<span class="built_in">list</span>);</span><br><span class="line">    list_add_tail(<span class="built_in">list</span>, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-empty"><a href="#list-empty" class="headerlink" title="list_empty"></a>list_empty</h2><p>判断这个链表的头指针 head的next是否指向它自己，如果是，则说明为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">list_empty</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-entry"><a href="#list-entry" class="headerlink" title="list_entry"></a>list_entry</h2><p>获取链表中某个节点的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset_of(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;\</span></span><br><span class="line"><span class="meta">    const __typeof__( ((type *)0)-&gt;member ) *__mptr = (ptr); \</span></span><br><span class="line"><span class="meta">    (type *)( (char *)__mptr - offset_of(type,member) ); &#125;)</span></span><br></pre></td></tr></table></figure>

<p>获取链表中第一个节点的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_first_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    list_entry((ptr)-&gt;next, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_last_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    list_entry((ptr)-&gt;prev, type, member)</span></span><br></pre></td></tr></table></figure>

<h2 id="list-for-each"><a href="#list-for-each" class="headerlink" title="list_for_each"></a>list_for_each</h2><p>遍历整个链表，pos只是一个临时的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_prev(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev; pos != (head); pos = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>

<h2 id="list-for-each-safe"><a href="#list-for-each-safe" class="headerlink" title="list_for_each_safe"></a>list_for_each_safe</h2><p>遍历链表，如果在遍历的过程中涉及到节点的删除操作，则需要使用这个函数，这个函数中有个中间节点 n 作为临时存储区，更加安全。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_prev_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev, n = pos-&gt;prev; \</span></span><br><span class="line"><span class="meta">         pos != (head); \</span></span><br><span class="line"><span class="meta">         pos = n, n = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>

<h2 id="list-for-each-entry"><a href="#list-for-each-entry" class="headerlink" title="list_for_each_entry"></a>list_for_each_entry</h2><p>节点结构遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry(head, __typeof__(*pos), member); \</span></span><br><span class="line"><span class="meta">         &amp;pos-&gt;member != (head);                    \</span></span><br><span class="line"><span class="meta">         pos = list_next_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry_reverse(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_last_entry(head, __typeof__(*pos), member); \</span></span><br><span class="line"><span class="meta">         &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">         pos = list_prev_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry_safe(pos, n, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry(head, __typeof__(*pos), member), \</span></span><br><span class="line"><span class="meta">            n = list_next_entry(pos, member); \</span></span><br><span class="line"><span class="meta">         &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">         pos = n, n = list_next_entry(n, member))</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>atomic mutex_lock semaphore</title>
    <url>/2022/06/07/kernel/lock/</url>
    <content><![CDATA[<h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p>原子操作是一种不可以被打断的操作，需要硬件的支持。</p>
<p><strong>原子整形操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> counter;</span><br><span class="line">&#125; <span class="type">atomic_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义原子变量, 并初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_set</span><span class="params">(<span class="type">atomic_t</span> *v, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">atomic_t</span> v = ATOMIC_INIT(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">atomic_read</span>(<span class="type">atomic_t</span> *v);  <span class="comment">// 获取原子变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*原子变量进行加减操作,并返回新的值*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_add_return</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_sub_return</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*原子变量自增/自减*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_inc(v)     (void) atomic_add_return(1, v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_dec(v)     (void) atomic_sub_return(1, v)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 原子变量增加减少 i */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_add(i, v)  (void) atomic_add_return(i, v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_sub(i, v)  (void) atomic_sub_return(i, v)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*原子变量执行自增、自减和减操作，测试其是否为0，为0返回true，否则返回 false*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_inc_and_test(v)  (atomic_add_return(1, v) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_dec_and_test(v)  (atomic_sub_return(1, v) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*原子变量自增自减操作,并返回新的值*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_inc_return(v)    (atomic_add_return(1, v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_dec_return(v)    (atomic_sub_return(1, v))</span></span><br></pre></td></tr></table></figure>

<p><strong>原子位操作</strong></p>
<p>原子位操作，可对数据的每一位进行操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*设置addr地址的第nr位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除addr地址的第nr位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*对addr地址的第nr位进行反置*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回addr地址的第nr位*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*先返回addr地址的第nr位，再执行相应bit操作*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_set_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_clear_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_change_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁(spin lock)是一种对临界资源进行互斥访问的手段。自旋锁主要针对SMP或单CPU但内核可抢占的情况，可以保证临界区不受别的CPU和本CPU 内的抢占进程打扰，但受到中断和底半部的影响。</p>
<p>自旋锁是一种<strong>忙等待</strong>，如果得不到锁，则会自旋在那里，不会引起调用者睡眠，因此只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。自旋锁锁定期间不能调用可能引起进程调度的函数，也不能递归使用，只允许一个持有者。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化自旋锁*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_init</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获得自旋锁*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尝试获得自旋锁，如果能立即获得锁，它获得锁并返回真；否则立即返回假，不再自旋*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">spin_trylock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*释放自旋锁*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上锁并关中断*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_irq</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解锁并开中断*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock_irq</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上锁并关底半部*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_bh</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解锁并开底半部*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock_bh</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure>

<p>自旋锁一般这样被使用:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义一个自旋锁，然后初始化*/</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line">spin_lock_init(&amp;lock);</span><br><span class="line"></span><br><span class="line">spin_lock (&amp;lock); </span><br><span class="line">    <span class="comment">/* 临界区*/</span></span><br><span class="line">spin_unlock (&amp;lock); </span><br></pre></td></tr></table></figure>

<h3 id="读写自旋锁"><a href="#读写自旋锁" class="headerlink" title="读写自旋锁"></a>读写自旋锁</h3><p>读写自旋锁(rwlock)只能有1个写操作，但允许并发读。</p>
<h3 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h3><p>顺序锁(seqlock)是对读写锁的一种优化，读执行单元不必等待写执行单元完成写操作，写执行单元也不需要等待所有读执行单元完成读操作，写执行单元与写执行单元之间仍然是互斥的。如果读执行单元在读操作期间，写执行单元已经发生了写操作，那么读执行单元必须重新读取数据，以便确保得到的数据是完整的。</p>
<p>顺序锁要求被保护的共享资源不含有指针，因为写执行单元可能使得指针失效，但读执行单元如果正要访问该指针，将导致oops。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量(semaphore)是一种用于保护临界区的方法，只有得到信号量的进程才能执行临界区代码。当获取不到信号量时，进程会将自身加入一个等待队列中去<strong>睡眠</strong>，当信号量释放后才被唤醒。</p>
<p>信号量的实现依赖于自旋锁和等待队列，为了保证信号量结构存取的原子性，在多CPU中需要自旋锁来互斥。</p>
<p>信号量是进程级的，会导致进程睡眠，睡眠需要进程上下文切换，开销也很大，因此只有当进程占用资源时间较长时，用信号量比较好。在中断或软中断情况下，因为不能被睡眠，所以不能用信号量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span>      lock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化信号量，一般为1*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获得信号量，它会导致睡眠,因此不能在中断上下文使用*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*能被信号打断，信号会导致该函数返回非0*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_interruptible</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尝试获得信号量，如果能够立刻获得，它就获得该信号量并返回0,否则返回非0值。它不会导致调用者睡眠，可以在中断上下文使用*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_trylock</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*释放信号量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br></pre></td></tr></table></figure>

<p>信号量根据count的値，设定可以允许有多少个进程持有这个信号量，一个持有者的信号量叫互斥信号量，多个持有者的信号量叫计数信号量。</p>
<p>使用down_interruptible()获取信号量时，要对返回值进行检查，如果非0要立即返回-ERESTARTSYS。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (down_interruptible(&amp;sem)) </span><br><span class="line">    <span class="keyword">return</span> -ERESTARTSYS;</span><br></pre></td></tr></table></figure>

<h3 id="读写信号量"><a href="#读写信号量" class="headerlink" title="读写信号量"></a>读写信号量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> &#123;</span></span><br><span class="line">    __s32           activity;</span><br><span class="line">    <span class="type">spinlock_t</span>      wait_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化读写信号量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_rwsem</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读信号量获取*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down_read</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">down_read_trylock</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读信号量释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_read</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写信号量获取*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down_write</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">down_write_trylock</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写信号量释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_write</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="完成量"><a href="#完成量" class="headerlink" title="完成量"></a>完成量</h2><p>完成量用于内核线程间的同步。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> done;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化完成量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_completion</span><span class="params">(<span class="keyword">struct</span> completion *x)</span>;</span><br><span class="line">DECLARE_COMPLETION(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*等待完成量被唤醒*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait_for_completion</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*唤醒完成量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">complete</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">complete_all</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>        count; <span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line">    <span class="type">spinlock_t</span>      wait_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_SMP)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *name;</span><br><span class="line">    <span class="type">void</span>            *magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>  <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*互斥体并初始化*/</span></span><br><span class="line">mutex_init(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取互斥体*/</span></span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_lock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span>;</span><br><span class="line"><span class="type">int</span> __sched <span class="title function_">mutex_lock_interruptible</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span>;</span><br><span class="line"><span class="type">int</span> __sched <span class="title function_">mutex_trylock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*释放互斥体*/</span></span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_unlock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>kernel module</title>
    <url>/2022/06/07/kernel/module/</url>
    <content><![CDATA[<p>模块是可以随时装载入内核的代码，这样就可以定制内核的功能了。</p>
<p><code>insmod</code> 命令加载模块， <code>dmesg | tail</code> 命令可以查看打印信息。</p>
<p><code>rmmod</code> 命令卸载模块。</p>
<p><code>modprobe</code> 命令加载模块及其依赖模块。</p>
<p><code>lsmod</code> 命令可以获得系统中加载了的所有模块以及模块间的依赖关系，实际上读取并分析<code>/proc/modules</code> 文件。内核中已加载模块的信息也存在于<code>/sys/module</code> 目录下。</p>
<p><code>modinfo</code> 命令可以获得模块的信息，包括模块作者、模块的说明、模块所支持的参数以及 vermagic。</p>
<p><img src="/images/kernel/module/inmod.bmp" alt="inmod"></p>
<h2 id="模块加载-卸载"><a href="#模块加载-卸载" class="headerlink" title="模块加载/卸载"></a>模块加载/卸载</h2><h3 id="init"><a href="#init" class="headerlink" title="__init"></a>__init</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __section(S) __attribute__ ((__section__(#S)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __init      __section(.init.text)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __initdata  __section(.init.data)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __exit      __section(.exit.text)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __exitdata  __section(.exit.data)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __exit_call __used __section(.exitcall.exit)</span></span><br></pre></td></tr></table></figure>

<p><code>__init</code> 标识的函数在连接的时候都放在.init.text 这个区段内，此外在区段 .initcall.init  中还保存了一份函数指针，在初始化时内核会通过这些函数指针调用这些<code>__init</code>函数，并在初始化完成后，释放 init 区段。</p>
<p><code>__exit</code> 使函数结束后自动回收内存。</p>
<p>需要注意的是驱动模块名字不能为” block”，驱动文件名字也不能是block.ko，不然会有以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">block: module is already loaded.</span><br><span class="line">insmod: can&#x27;t insert &#x27;block.ko&#x27;: invalid parameter</span><br></pre></td></tr></table></figure>

<h3 id="module-init"><a href="#module-init" class="headerlink" title="module_init()"></a>module_init()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pure_initcall(fn)   __define_initcall(<span class="string">&quot;0&quot;</span>,fn,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall(fn)   __define_initcall(<span class="string">&quot;1&quot;</span>,fn,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall_sync(fn)    __define_initcall(<span class="string">&quot;1s&quot;</span>,fn,1s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall(fn)   __define_initcall(<span class="string">&quot;2&quot;</span>,fn,2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall_sync(fn)  __define_initcall(<span class="string">&quot;2s&quot;</span>,fn,2s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall(fn)   __define_initcall(<span class="string">&quot;3&quot;</span>,fn,3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall_sync(fn)    __define_initcall(<span class="string">&quot;3s&quot;</span>,fn,3s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall(fn)   __define_initcall(<span class="string">&quot;4&quot;</span>,fn,4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall_sync(fn)  __define_initcall(<span class="string">&quot;4s&quot;</span>,fn,4s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall(fn)     __define_initcall(<span class="string">&quot;5&quot;</span>,fn,5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall_sync(fn)    __define_initcall(<span class="string">&quot;5s&quot;</span>,fn,5s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rootfs_initcall(fn)   __define_initcall(<span class="string">&quot;rootfs&quot;</span>,fn,rootfs)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall(fn)   __define_initcall(<span class="string">&quot;6&quot;</span>,fn,6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall_sync(fn)  __define_initcall(<span class="string">&quot;6s&quot;</span>,fn,6s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall(fn)   __define_initcall(<span class="string">&quot;7&quot;</span>,fn,7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall_sync(fn)    __define_initcall(<span class="string">&quot;7s&quot;</span>,fn,7s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __initcall(fn) device_initcall(fn)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_init(x)  __initcall(x);                                                                </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_exit(x)  __exitcall(x);</span></span><br></pre></td></tr></table></figure>

<p>module_init对应的驱动加载优先级为6。</p>
<p>内核编译完之后，会在根目录生成system.map文件，里面记录了驱动加载的顺序。</p>
<h2 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">module_param(参数名, 参数类型, 参数读写权限)</span><br><span class="line"></span><br><span class="line">module_param_array(数组名, 数组类型, 数组长度指针, 参数读写权限)</span><br></pre></td></tr></table></figure>

<p>参数类型可以 byte、short、ushort、int、uint、long、ulong、charp(字符指针)、bool 或invbool(布尔的反)。当参数读/写权限不为0时，<code>/sys/module/模块名/parameters</code>目录下会有参数名文件，内容为参数的値，可以用echo命令修改。</p>
<p>可用<code>MODULE_PARM_DESC(参数变量, 描述字符串);</code>宏对参数进行注释，通过<code>modinfo -p</code>命令可以查看模块参数及其描述。</p>
<p>模块也可以拥有参数数组，用逗号分隔输入的数组元素，使用如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod  module.ko arg=3 array=1,2,3,4,5</span><br></pre></td></tr></table></figure>

<h2 id="导出符号"><a href="#导出符号" class="headerlink" title="导出符号"></a>导出符号</h2><p>将函数符号导出，以便让别的驱动模块引用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL(sym)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL_GPL(sym)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL_GPL_FUTURE(sym)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_UNUSED_SYMBOL(sym)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_UNUSED_SYMBOL_GPL(sym)</span></span><br></pre></td></tr></table></figure>

<p>模块可以使用如下宏导出符号到内核符号表，EXPORT_SYMBOL_GPL()只适用于包含GPL许可权的模块。<code>/proc/kallsyms</code>文件对应着内核符号表，它记录了符号以及符号所在的内存地址。</p>
<h2 id="模块声明与描述"><a href="#模块声明与描述" class="headerlink" title="模块声明与描述"></a>模块声明与描述</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(author);</span><br><span class="line">MODULE_DESCRIPTION(description);</span><br><span class="line">MODULE_VERSION(version_string);</span><br><span class="line">MODULE_DEVICE_TABLE(table_info);</span><br><span class="line">MODULE_ALIAS(alternate_name);</span><br></pre></td></tr></table></figure>

<p>其中<code>MODULE_LICENSE</code>许可声明是必须要有的，不然内核不让加载。</p>
<h2 id="模块使用计数"><a href="#模块使用计数" class="headerlink" title="模块使用计数"></a>模块使用计数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">try_module_get</span><span class="params">(<span class="keyword">struct</span> module *module)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">module_put</span><span class="params">(<span class="keyword">struct</span> module *module)</span></span><br></pre></td></tr></table></figure>

<p>当开始使用某个设备时，内核使用 <code>try_module_get(dev-&gt;owner)</code> 去增加管理此设备的 owner 模块的使用计数;当不再使用此设备时，内核使用 <code>module_put(dev-&gt;owner)</code>减少对管理此设备的 owner 模块的使用计数。正因如此，使得设备还在使用时，管理此设备的模块将不能被卸载，只有当设备不再被使用时，模块才允许被卸载。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>make module</title>
    <url>/2022/06/07/kernel/module_make/</url>
    <content><![CDATA[<p>编译一个模块需要内核源码（已经编译过的）和当前模块的Makefile文件。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(info KERNELRELEASE: <span class="variable">$(KERNELRELEASE)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">KERNEL_DIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	obj-m += hello.o</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@find ./ \</span><br><span class="line">		\( -name &#x27;*.[oas]&#x27; -o -name &#x27;.*.cmd&#x27; -o -name &#x27;*.symvers&#x27;\</span><br><span class="line">		-o -name &#x27;.*.d&#x27; -o -name &#x27;.*.tmp&#x27; -o -name &#x27;*.mod.c&#x27; \</span><br><span class="line">		-o -name &#x27;*.symtypes&#x27; -o -name &#x27;modules.order&#x27; \</span><br><span class="line">		-o -name modules.builtin -o -name &#x27;.tmp_*.o.*&#x27; \</span><br><span class="line">		-o -name &#x27;*.gcno&#x27; -o -name tags -o -name &#x27;.tags*&#x27; \</span><br><span class="line">		 \) -type f -print | xargs rm -f</span><br><span class="line"></span><br><span class="line">	@find ./ \</span><br><span class="line">		\( -name .tmp_versions \) -type d -print | xargs rm -rf</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean all</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>先判断<code>KERNELRELEASE</code>环境变量是否为空，该变量的値在进入内核源码目录后，会设置为内核版本号。</li>
<li>执行<code>-C $(KERNEL_DIR)</code>选项，进入内核源码目录。</li>
<li>根据选项<code>M=$(PWD)</code>，编译器会回到模块当前目录，再次执行Makefile文件，此时<code>KERNELRELEASE</code>环境变量已经有値了，生成hello.o中间文件。</li>
<li>运行MODPOST程序，生成hello.mod.c文件。</li>
<li>最后链接生成hello.ko。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">KERNELRELEASE: </span><br><span class="line">make -C /lib/modules/4.10.0-38-generic/build M=/home/luo_u/CodeHub/dev/test modules</span><br><span class="line">make[1]: Entering directory &#x27;/usr/src/linux-headers-4.10.0-38-generic&#x27;</span><br><span class="line">KERNELRELEASE: 4.10.0-38-generic</span><br><span class="line">  CC [M]  /home/luo_u/CodeHub/dev/test/hello.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">KERNELRELEASE: 4.10.0-38-generic</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /home/luo_u/CodeHub/dev/test/hello.mod.o</span><br><span class="line">  LD [M]  /home/luo_u/CodeHub/dev/test/hello.ko</span><br><span class="line">make[1]: Leaving directory &#x27;/usr/src/linux-headers-4.10.0-38-generic&#x27;</span><br></pre></td></tr></table></figure>

<p>加载模块，后在/sys/module/hello/目录和/proc/modules文件就可以看到模块信息了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsmod | grep hello</span></span><br><span class="line">hello                  16384  0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/modules | grep hello</span></span><br><span class="line">hello 16384 0 - Live 0x0000000000000000 (OE)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /sys/module/hello/</span></span><br><span class="line">coresize  holders  initsize  initstate  notes  refcnt  sections  srcversion  taint  uevent</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>platform bus</title>
    <url>/2022/06/07/kernel/platform/</url>
    <content><![CDATA[<p>platform 是一种虚拟的总线，负责绑定设备和驱动，在系统每注册一个设备的时候，会寻找与之匹配的驱动；相反的，在系统每注册一个驱动的时候，会寻找与之匹配的设备，而匹配由总线完成。</p>
<p>platform 使设备被挂接在一个总线上，在 BSP 中定义 platform 设备和设备使用的资源、设备的具体配置信息，而在驱动中只需要通过 API 去获取资源和数据，做到了板级代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。</p>
<h2 id="platform-device"><a href="#platform-device" class="headerlink" title="platform_device"></a>platform_device</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;  </span><br><span class="line">    <span class="type">int</span>  id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">    u32  num_resources;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般在bsp板文件中定义了平台资源的对应的全部platform_device， 并包含在一个数组中，然后通过 platform_add_devices()函数统一注册。当然也可以自己单独实现:</p>
<ol>
<li>实例一个 platform_device 结构体。</li>
<li>初始化设备名、id等成员。</li>
<li>创建一个资源数组，并赋值给 platform_device 对象。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">hello_device</span>=</span></span><br><span class="line">&#123;</span><br><span class="line">    .name = <span class="string">&quot;hello_platform&quot;</span>,</span><br><span class="line">    .id = <span class="number">-1</span>,</span><br><span class="line">    .resource = hello_resource,</span><br><span class="line">    .num_resources = ARRAY_SIZE(hello_resource),</span><br><span class="line">    .dev = </span><br><span class="line">    &#123;</span><br><span class="line">        .platform_data = &amp;plat_data,</span><br><span class="line">        .release = hello_release,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_device_register(&amp;hello_device);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_device_unregister(&amp;hello_device);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>platform_device 结构体的 platform_data 成员用来存放设备自定义的私有数据，驱动中可通过设备指针来获取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxx_plat_data</span> *<span class="title">pdata</span> =</span> pdev-&gt;dev.platform_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册platform-device"><a href="#注册platform-device" class="headerlink" title="注册platform_device"></a>注册platform_device</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">platform_device_register</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    device_initialize(&amp;pdev-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> platform_device_add(pdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">platform_device_add</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pdev-&gt;dev.parent)</span><br><span class="line">        pdev-&gt;dev.parent = &amp;platform_bus;</span><br><span class="line"></span><br><span class="line">    pdev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pdev-&gt;num_resources; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">p</span>, *<span class="title">r</span> =</span> &amp;pdev-&gt;resource[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;name == <span class="literal">NULL</span>)</span><br><span class="line">            r-&gt;name = dev_name(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">        p = r-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resource_type(r) == IORESOURCE_MEM)</span><br><span class="line">                p = &amp;iomem_resource;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (resource_type(r) == IORESOURCE_IO)</span><br><span class="line">                p = &amp;ioport_resource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device_add(&amp;pdev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">device_add</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    dev = get_device(dev);</span><br><span class="line">    bus_add_device(dev);</span><br><span class="line">    bus_probe_device(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bus_probe_device</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bus &amp;&amp; bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">        ret = device_attach(dev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">device_attach</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;driver) &#123;</span><br><span class="line">        klist_node_attached(&amp;dev-&gt;p-&gt;knode_driver);</span><br><span class="line"></span><br><span class="line">        ret = device_bind_driver(dev);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = bus_for_each_drv(dev-&gt;bus, <span class="literal">NULL</span>, dev, __device_attach);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __device_attach(<span class="keyword">struct</span> device_driver *drv, <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!driver_match_device(drv, dev))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver_probe_device(drv, dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">driver_match_device</span><span class="params">(<span class="keyword">struct</span> device_driver *drv,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册 platform_device 后，会遍历 platform_bus 中的 platform_driver，根据 platform_bus 的 match() 函数规则来匹配相应的平台驱动。</p>
<h2 id="platform-driver"><a href="#platform-driver" class="headerlink" title="platform_driver"></a>platform_driver</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);</span><br><span class="line">    <span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>probe() 在总线匹配成功后调用</li>
<li>remove() 在移除驱动或设备时调用</li>
</ul>
<h2 id="注册platform-driver"><a href="#注册platform-driver" class="headerlink" title="注册platform_driver"></a>注册platform_driver</h2><p>先实例一个 platform_driver 结构体，然后实现其成员函数，最后通过 platform_driver_register() 函数注册到platform总线。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">platform_driver_register</span><span class="params">(<span class="keyword">struct</span> platform_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;driver.bus = &amp;platform_bus_type;</span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;probe)</span><br><span class="line">        drv-&gt;driver.probe = platform_drv_probe;</span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;remove)</span><br><span class="line">        drv-&gt;driver.remove = platform_drv_remove;</span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;shutdown)</span><br><span class="line">        drv-&gt;driver.shutdown = platform_drv_shutdown;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">driver_register</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">other</span>;</span></span><br><span class="line"></span><br><span class="line">    other = driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line">    <span class="keyword">if</span> (other) &#123;</span><br><span class="line">        put_driver(other);</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span></span><br><span class="line">            <span class="string">&quot;aborting...\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bus_add_driver(drv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bus_add_driver</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">        error = driver_attach(drv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">driver_attach</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> bus_for_each_dev(drv-&gt;bus, <span class="literal">NULL</span>, drv, __driver_attach);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __driver_attach(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">drv</span> =</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!driver_match_device(drv, dev))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">driver_match_device</span><span class="params">(<span class="keyword">struct</span> device_driver *drv,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册 platform_driver 后，会遍历 platform_bus 中的 platform_device ，根据 platform_bus 的 match() 函数规则来匹配相应的平台设备。</p>
<h2 id="platform-总线"><a href="#platform-总线" class="headerlink" title="platform 总线"></a>platform 总线</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">platform_bus_type</span> =</span> &#123;</span><br><span class="line">    .name  = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">    .dev_attrs = platform_dev_attrs,</span><br><span class="line">    .match  = platform_match,</span><br><span class="line">    .uevent  = platform_uevent,</span><br><span class="line">    .pm  = &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">kernel_ulong_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[PLATFORM_NAME_SIZE];</span><br><span class="line">    <span class="type">kernel_ulong_t</span> driver_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>match()成员函数确定了 platform_device 和 platform_driver 之间的匹配规则，有4种匹配规则：</p>
<ul>
<li>设备树匹配</li>
<li>ACPI风格的匹配</li>
<li>匹配ID表，即platform_device设备名是否出现在platform_driver的ID表内</li>
<li>比较设备名和驱动名</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">platform_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line">    <span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then try ACPI style match */</span></span><br><span class="line">    <span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then try to match against the id table */</span></span><br><span class="line">    <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">        <span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="platform-设备资源"><a href="#platform-设备资源" class="headerlink" title="platform 设备资源"></a>platform 设备资源</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="type">resource_size_t</span> start;  <span class="comment">/* 资源的起始物理地址 */</span></span><br><span class="line">    <span class="type">resource_size_t</span> end;    <span class="comment">/* 资源的结束物理地址 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;    <span class="comment">/* 资源的类型 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> num)</span></span><br></pre></td></tr></table></figure>

<p>资源类型flags取値：</p>
<ul>
<li>IORESOURCE_IO</li>
<li>IORESOURCE_MEM  platform_device 占据的内存</li>
<li>IORESOURCE_IRQ  platform_device 使用的中断号</li>
<li>IORESOURCE_DMA</li>
</ul>
<p>当 flags 为 IORESOURCE_MEM 时，start、end 分别表示该 platform_device 占据的内存的开始地址和结束地址;<br>当 flags 为 IORESOURCE_IRQ 时，start、end 分别表示该 platform_device 使用的中断号的开始值和结束值，如果只使用了 1 个中断号，开始和结束值相同。</p>
<p>在驱动中通过 platform_get_resource()函数获取设备资源，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">dm9000_resource</span>[] =</span> &#123;</span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .start = <span class="number">0x18000000</span>,</span><br><span class="line">        .end = <span class="number">0x18000000</span> + <span class="number">3</span>,</span><br><span class="line">        .flags = IORESOURCE_MEM</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .start = <span class="number">0x18000000</span> + <span class="number">0x4</span>,</span><br><span class="line">        .end = <span class="number">0x18000000</span> + <span class="number">0x7</span>,</span><br><span class="line">        .flags = IORESOURCE_MEM</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    [<span class="number">2</span>] = &#123;</span><br><span class="line">        .start = IRQ_EINT(<span class="number">7</span>),</span><br><span class="line">        .end = IRQ_EINT(<span class="number">7</span>),</span><br><span class="line">        .flags = IORESOURCE_IRQ,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db-&gt;addr_res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">db-&gt;data_res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">1</span>);</span><br><span class="line">db-&gt;irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>power manage</title>
    <url>/2022/06/07/kernel/pm/</url>
    <content><![CDATA[<h2 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h2><p>电源管理就是当系统的某些设备不需要工作时，暂时以最低电耗的方式挂起设备，以节省系统的电能。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>kernel process manage</title>
    <url>/2022/06/07/kernel/sched/</url>
    <content><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程管理负责控制进程对 CPU 的访问，如任务的创建、调度和终止等。</p>
<p>进程是操作系统进行资源管理的最小单位，进程需要管理打开的文件、挂起的信号、内核内部数据、处理器状态等。线程是操作系统进行调度的最小单位。进程的可能状态有:</p>
<ul>
<li><p>运行态，已经获得了资源，并且进程正在被 CPU 执行。进程既可运行在内核态，也可运行在用户态。</p>
</li>
<li><p>内核态，内核和驱动所运行时的状态，程序处于特权阶级，能够访问系统的任何资源。</p>
</li>
<li><p>用户态，用户程序运行的状态，处于非特权阶级，不能随意访问系统资源，必须通过驱动程序方可访问，用户态程序可通过系统调用进入内核态。</p>
</li>
<li><p>就绪态，当系统资源已经可用，但由于前一个进程还没有执行完释放 CPU，准备进入运行状态。</p>
</li>
<li><p>可中断睡眠状态，当进程处于可中断等待状态时，系统不会调度该程序执行。当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，都可以被唤醒进入就绪状态或者运行态。</p>
</li>
<li><p>不可中断睡眠状态，处于中断等待状态，但是该进程只能被使用 wake_up()函数明确唤醒的时候才可进入就绪状态。</p>
</li>
<li><p>暂停状态，当进程收到 SIGSTOP、SIGSTP、SIGTTIN 或者 SIGTTOU 就会进入暂停状态，收到 SIGCONT 信号即可进入运行态。</p>
</li>
<li><p>僵死态，进程已经停止运行，但是其父进程还没有询问其状态。</p>
</li>
</ul>
<p>每个进程都有两个栈，用户栈和内核栈，在用户态运行时CPU堆栈指针寄存器指向用户栈地址。进程在内核态运行时，CPU堆栈指针寄存器指向内核栈地址。内核栈使用的空间很小，通常为8KB。</p>
<p><img src="/images/kernel/kernel/task_struct.png" alt="内核栈"></p>
<h2 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h2><p>在linux中线程和进程都使用 struct task_struct 结构体表示，通过唯一的进程标识值pid来标识每个进程，用全局指针current指向当前正在运行的进程的 task_struct。task_struct的state域存储了进程当前的状态，总共有7种状态：</p>
<ul>
<li><p><strong>TASK_RUNNING</strong> 一般指就绪状态，进程正在运行。</p>
</li>
<li><p><strong>TASK_INTERRUPTIBLE</strong> 进程暂停，直到它获得满足它继续运行的条件，比如进程获得了需要的资源、接收到硬件终端、或者收到某些signal等。</p>
</li>
<li><p><strong>TASK_UNINTERRUPTIBLE</strong> 进程暂停，不会被signal唤醒，只能等待某些事件(资源、硬件终端等)。</p>
</li>
<li><p><strong>TASK_STOPPED</strong> 进程中止运行，进程在接收到SIGSTOP, SIGTSTP, SIGTTIN或者SIGTTOU 信号时会进入这个状态。 接收到SIGCONT信号后，重新回到进行状态。</p>
</li>
<li><p><strong>TASK_TRACED</strong> 进程处于被调试，例如通过ptrace()对程序进行调试。</p>
</li>
<li><p><strong>EXIT_ZOMBIE</strong> 进程将要结束，等待父进程调用wait4()或者waitpid()来回收该进程。</p>
</li>
<li><p><strong>EXIT_DEAD</strong> 进程退出，这个状态主要用于避免多个进程同时对该进程调用类似wait()的函数或者系统调用。</p>
</li>
</ul>
<p><img src="/images/kernel/kernel/proc-sched.png" alt="proc"></p>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>任务调度由 Linux 内核调度器来完成。Linux 内核调度器根据进程的优先级选择运行进程。linux内核支持抢占，更高优先级的进程可以抢占低优先级进程。但在中断处理函数中，中断上下文的底半部，进程持有自旋锁的情况下不允许内核抢占。</p>
<p>当请求的资源不能得到满足时，内核会调度其他进程执行，并使本进程进入睡眠状态，直到它请求的资源被释放，才会被唤醒而进入就绪态。睡眠分成可被打断的睡眠和不可被打断的睡眠，区别在于可被打断的睡眠在收到信号的时候唤醒。</p>
<p>内核可以使用schedule()函数主动调度进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">current-&gt;state=TASK_INTERRUPTIBLE;</span><br><span class="line">schedule(); </span><br></pre></td></tr></table></figure>

<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>设备驱动中，如果需要几个并发执行的任务，可以启动内核线程，函数为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>spi 设备驱动</title>
    <url>/2022/09/04/kernel/spi_device/</url>
    <content><![CDATA[<h2 id="spi-device"><a href="#spi-device" class="headerlink" title="spi_device"></a>spi_device</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>   <span class="title">dev</span>;</span>    <span class="comment">//设备文件 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_master</span>   *<span class="title">master</span>;</span>    <span class="comment">//spi主机 </span></span><br><span class="line">    u32 max_speed_hz;   <span class="comment">//最大速率 </span></span><br><span class="line">    u8  chip_select;    <span class="comment">//片选 </span></span><br><span class="line">    u8  mode;   <span class="comment">//模式 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CPHA    0x01            <span class="comment">/* clock phase */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CPOL    0x02            <span class="comment">/* clock polarity */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MODE_0  (0|0)           <span class="comment">/* (original MicroWire) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MODE_1  (0|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MODE_2  (SPI_CPOL|0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MODE_3  (SPI_CPOL|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CS_HIGH 0x04            <span class="comment">/* chipselect active high? */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_LSB_FIRST   0x08            <span class="comment">/* per-word bits-on-wire */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_3WIRE   0x10            <span class="comment">/* SI/SO signals shared */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_LOOP    0x20            <span class="comment">/* loopback mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_NO_CS   0x40            <span class="comment">/* 1 dev/bus, no chipselect */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_READY   0x80            <span class="comment">/* slave pulls low to pause */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_TX_DUAL 0x100           <span class="comment">/* transmit with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_TX_QUAD 0x200           <span class="comment">/* transmit with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_RX_DUAL 0x400           <span class="comment">/* receive with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_RX_QUAD 0x800           <span class="comment">/* receive with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CS_WORD 0x1000          <span class="comment">/* toggle cs after each word */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_TX_OCTAL    0x2000          <span class="comment">/* transmit with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_RX_OCTAL    0x4000          <span class="comment">/* receive with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_3WIRE_HIZ   0x8000          <span class="comment">/* high impedance turnaround */</span></span></span><br><span class="line">    u8  bits_per_word;  <span class="comment">//一个字有多少位 </span></span><br><span class="line">    <span class="type">int</span> irq;    <span class="comment">//中断号 </span></span><br><span class="line">    <span class="type">void</span>    *controller_state;  <span class="comment">//控制器状态 </span></span><br><span class="line">    <span class="type">void</span>    *controller_data;   <span class="comment">//控制器数据 </span></span><br><span class="line">    <span class="type">char</span>    modalias[SPI_NAME_SIZE]; <span class="comment">//名字 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="spi-board-info"><a href="#spi-board-info" class="headerlink" title="spi_board_info"></a>spi_board_info</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_board_info</span> &#123;</span> </span><br><span class="line">    <span class="type">char</span>    modalias[SPI_NAME_SIZE];    <span class="comment">//名字 </span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>  *platform_data; <span class="comment">//平台数据 </span></span><br><span class="line">    <span class="type">void</span>    *controller_data;   <span class="comment">//控制器数据 </span></span><br><span class="line">    <span class="type">int</span> irq;            <span class="comment">//中断号 </span></span><br><span class="line">    u32 max_speed_hz;   <span class="comment">//最大速率 </span></span><br><span class="line">    u16 bus_num;        <span class="comment">//spi总线编号 </span></span><br><span class="line">    u16 chip_select;    <span class="comment">//片选 </span></span><br><span class="line">    u8  mode;           <span class="comment">//模式 </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="spi-device注册"><a href="#spi-device注册" class="headerlink" title="spi_device注册"></a>spi_device注册</h3><p>spi_device的注册一般在板文件中实现，先填充 spi_board_info 结构体，再使用 spi_register_board_info() 函数添加。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_board_info</span> <span class="title">spi_board_info</span>[] __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .modalias   = <span class="string">&quot;lms501kf03&quot;</span>,</span><br><span class="line">        .platform_data  = <span class="literal">NULL</span>,</span><br><span class="line">        .max_speed_hz   = <span class="number">1200000</span>,</span><br><span class="line">        .bus_num    = LCD_BUS_NUM,</span><br><span class="line">        .chip_select    = <span class="number">0</span>,</span><br><span class="line">        .mode       = SPI_MODE_3,</span><br><span class="line">        .controller_data = (<span class="type">void</span> *)DISPLAY_CS,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));</span><br></pre></td></tr></table></figure>

<h3 id="spi-register-board-info"><a href="#spi-register-board-info" class="headerlink" title="spi_register_board_info()"></a>spi_register_board_info()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">boardinfo</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">unsigned</span>        n_board_info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_board_info</span>   <span class="title">board_info</span>[0];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(board_list)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spi_register_board_info</span><span class="params">(<span class="keyword">struct</span> spi_board_info <span class="type">const</span> *info, <span class="type">unsigned</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">boardinfo</span>    *<span class="title">bi</span>;</span></span><br><span class="line"></span><br><span class="line">    bi = kmalloc(<span class="keyword">sizeof</span>(*bi) + n * <span class="keyword">sizeof</span> *info, GFP_KERNEL);</span><br><span class="line">    bi-&gt;n_board_info = n;</span><br><span class="line">    <span class="built_in">memcpy</span>(bi-&gt;board_info, info, n * <span class="keyword">sizeof</span> *info);</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;board_lock);</span><br><span class="line">    list_add_tail(&amp;bi-&gt;<span class="built_in">list</span>, &amp;board_list);</span><br><span class="line">    mutex_unlock(&amp;board_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加到全局链表 board_list 中，注册SPI主机驱动时链表，如果匹配到控制器，则调用 spi_new_device() 函数添加一个spi设备。</p>
<h2 id="spi-driver"><a href="#spi-driver" class="headerlink" title="spi_driver"></a>spi_driver</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">    <span class="type">int</span>  (*probe)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">    <span class="type">int</span>  (*remove)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">    <span class="type">int</span>  (*suspend)(<span class="keyword">struct</span> spi_device *spi, <span class="type">pm_message_t</span> mesg);</span><br><span class="line">    <span class="type">int</span>  (*resume)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="spi-driver-注册"><a href="#spi-driver-注册" class="headerlink" title="spi_driver 注册"></a>spi_driver 注册</h3><p>spi设备驱动根据功能分开在各个地方，如spi flash的一般就在/drivers/mtd/device/下，siwtch的spi接口就放在/drivers/net/ethernet/下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">ak_spiflash_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;ak-spiflash&quot;</span>,</span><br><span class="line">        .bus    = &amp;spi_bus_type,</span><br><span class="line">        .owner  = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe  = ak_spiflash_probe,</span><br><span class="line">    .remove = __devexit_p(ak_spiflash_remove),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ak_spiflash_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> spi_register_driver(&amp;ak_spiflash_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="spi-register-driver"><a href="#spi-register-driver" class="headerlink" title="spi_register_driver()"></a>spi_register_driver()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_register_driver</span><span class="params">(<span class="keyword">struct</span> spi_driver *sdrv)</span></span><br><span class="line">&#123;</span><br><span class="line">    sdrv-&gt;driver.bus = &amp;spi_bus_type;</span><br><span class="line">    <span class="keyword">if</span> (sdrv-&gt;probe)</span><br><span class="line">        sdrv-&gt;driver.probe = spi_drv_probe;</span><br><span class="line">    <span class="keyword">if</span> (sdrv-&gt;remove)</span><br><span class="line">        sdrv-&gt;driver.remove = spi_drv_remove;</span><br><span class="line">    <span class="keyword">if</span> (sdrv-&gt;shutdown)</span><br><span class="line">        sdrv-&gt;driver.shutdown = spi_drv_shutdown;</span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;sdrv-&gt;driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>device</category>
      </categories>
      <tags>
        <tag>spi</tag>
        <tag>device</tag>
      </tags>
  </entry>
  <entry>
    <title>RTC device</title>
    <url>/2022/09/04/kernel/rtc/</url>
    <content><![CDATA[<p>RTC(实时时钟)借助电池供电，在系统掉电的情况下时间依然可以正常走动，通常还具有产生周期性中断以及产生闹钟(alarm)中断的能力。</p>
<p><img src="/images/kernel/rtc/rtc-arch.png" alt="rtc"></p>
<ul>
<li>rtc-dev.c   rtc设备用户接口;</li>
<li>class.c     管理rtc sys class;</li>
<li>interface.c 间接rtc驱动接口;</li>
<li>rtc-lib.c   rtc辅助函数,主要用于rtc时间转换、计算;</li>
<li>rtc-proc    rtc proc fs用户接口;</li>
<li>rtc-sysfs   rtc sys fs用户接口;</li>
<li>hctosys.c   用于在系统启动时从rtc读取时间，并设置为系统时间;</li>
<li>rtc-xxx.c   rtc硬件芯片驱动，如rtc-wm8350.c、rtc-s3c.c等。</li>
<li>include/linux/rtc.h  rtc接口声明，定义ioctl命令宏。</li>
</ul>
<p>RTC框架大致可以分为三部分：芯片底层驱动，核心层API以及应用层接口，它们依次向上抽象注册。同时又对下面底层的函数进行回调。</p>
<h2 id="rtc-xxx-c"><a href="#rtc-xxx-c" class="headerlink" title="rtc-xxx.c"></a>rtc-xxx.c</h2><p>不同的芯片对应不同的.c文件，每种芯片的实现方式都不一样，由芯片硬件自身决定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> device *);</span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> device *);</span><br><span class="line">    <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*read_time)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_time *);</span><br><span class="line">    <span class="type">int</span> (*set_time)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_time *);</span><br><span class="line">    <span class="type">int</span> (*read_alarm)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_wkalrm *);</span><br><span class="line">    <span class="type">int</span> (*set_alarm)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_wkalrm *);</span><br><span class="line">    <span class="type">int</span> (*proc)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> seq_file *);</span><br><span class="line">    <span class="type">int</span> (*set_mmss)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">long</span> secs);</span><br><span class="line">    <span class="type">int</span> (*read_callback)(<span class="keyword">struct</span> device *, <span class="type">int</span> data);</span><br><span class="line">    <span class="type">int</span> (*alarm_irq_enable)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">int</span> enabled);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> <span class="title">s3c_rtcops</span> =</span> &#123;</span><br><span class="line">    .read_time  = s3c_rtc_gettime,</span><br><span class="line">    .set_time   = s3c_rtc_settime,</span><br><span class="line">    .read_alarm = s3c_rtc_getalarm,</span><br><span class="line">    .set_alarm  = s3c_rtc_setalarm,</span><br><span class="line">    .alarm_irq_enable = s3c_rtc_setaie,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span>;</span></span><br><span class="line">rtc = rtc_device_register(<span class="string">&quot;s3c&quot;</span>, &amp;pdev-&gt;dev, &amp;s3c_rtcops, THIS_MODULE);</span><br></pre></td></tr></table></figure>

<p>rtc芯片要实例化一个 rtc_class_ops 结构体，里面是一些rtc设备的操作函数，然后使用 <a href="#rtc_device_register">rtc_device_register()</a> 函数注册到rtc设备中。</p>
<h2 id="rtc-class-c"><a href="#rtc-class-c" class="headerlink" title="rtc-class.c"></a>rtc-class.c</h2><p>rtc-class.c 提供了一些rtc核心的API。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> id;                                              <span class="comment">//代表是那个rtc设备  </span></span><br><span class="line">    <span class="type">char</span> name[RTC_DEVICE_NAME_SIZE];                     <span class="comment">//代表rtc设备的名称  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> *<span class="title">ops</span>;</span>                     <span class="comment">//rtc操作函数集，需要驱动实现  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">ops_lock</span>;</span>                               <span class="comment">//操作函数集的互斥锁  </span></span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">char_dev</span>;</span>                                <span class="comment">//代表rtc字符设备，因为rtc就是个字符设备  </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;                                 <span class="comment">//rtc的状态标志，例如RTC_DEV_BUSY  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> irq_data;                              <span class="comment">//rtc中断数据  </span></span><br><span class="line">    <span class="type">spinlock_t</span> irq_lock;                                 <span class="comment">//访问数据是要互斥，需要spin_lock  </span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> irq_queue;                         <span class="comment">//数据查询中用到rtc队列  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span>                   <span class="comment">//异步队列  </span></span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_task</span> *<span class="title">irq_task</span>;</span>                           <span class="comment">//在中断中使用task传输数据  </span></span><br><span class="line">    <span class="type">spinlock_t</span> irq_task_lock;                            <span class="comment">//task传输互斥  </span></span><br><span class="line">    <span class="type">int</span> irq_freq;                                        <span class="comment">//rtc的中断频率  </span></span><br><span class="line">    <span class="type">int</span> max_user_freq;                                   <span class="comment">//rtc的最大中断频率  </span></span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerqueue_head</span> <span class="title">timerqueue</span>;</span>                   <span class="comment">//定时器队列                    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">aie_timer</span>;</span>                          <span class="comment">//aie(alaram interrupt enable)定时器  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">uie_rtctimer</span>;</span>                       <span class="comment">//uie(update interrupt enable)定时器  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">pie_timer</span>;</span> <span class="comment">/* sub second exp, so needs hrtimer */</span> <span class="comment">//pie(periodic interrupt enable)定时器  </span></span><br><span class="line">    <span class="type">int</span> pie_enabled;                                     <span class="comment">//pie使能标志  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">irqwork</span>;</span>                            </span><br><span class="line">    <span class="comment">/* Some hardware can&#x27;t support UIE mode */</span>  </span><br><span class="line">    <span class="type">int</span> uie_unsupported;                                 <span class="comment">//uie使能标志  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RTC_INTF_DEV_UIE_EMUL                      <span class="comment">//RTC UIE emulation on dev interface配置项，目前没有开启  </span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">uie_task</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">uie_timer</span>;</span>  </span><br><span class="line">    <span class="comment">/* Those fields are protected by rtc-&gt;irq_lock */</span>  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> oldsecs;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uie_irq_active:<span class="number">1</span>;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stop_uie_polling:<span class="number">1</span>;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uie_task_active:<span class="number">1</span>;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uie_timer_active:<span class="number">1</span>;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>

<h3 id="rtc-device-register"><a href="#rtc-device-register" class="headerlink" title="rtc_device_register"></a>rtc_device_register</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> rtc_device *<span class="title function_">rtc_device_register</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="keyword">struct</span> rtc_class_ops *ops,</span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> module *owner)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_wkalrm</span> <span class="title">alrm</span>;</span></span><br><span class="line">    <span class="type">int</span> id, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idr_pre_get(&amp;rtc_idr, GFP_KERNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        err = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;idr_lock);</span><br><span class="line">    err = idr_get_new(&amp;rtc_idr, <span class="literal">NULL</span>, &amp;id);</span><br><span class="line">    mutex_unlock(&amp;idr_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">    id = id &amp; MAX_ID_MASK;</span><br><span class="line"></span><br><span class="line">    rtc = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rtc_device), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (rtc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> exit_idr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rtc-&gt;id = id;</span><br><span class="line">    rtc-&gt;ops = ops;</span><br><span class="line">    rtc-&gt;owner = owner;</span><br><span class="line">    rtc-&gt;irq_freq = <span class="number">1</span>;</span><br><span class="line">    rtc-&gt;max_user_freq = <span class="number">64</span>;</span><br><span class="line">    rtc-&gt;dev.parent = dev;</span><br><span class="line">    rtc-&gt;dev.class = rtc_class;</span><br><span class="line">    rtc-&gt;dev.release = rtc_device_release;</span><br><span class="line"></span><br><span class="line">    mutex_init(&amp;rtc-&gt;ops_lock);</span><br><span class="line">    spin_lock_init(&amp;rtc-&gt;irq_lock);</span><br><span class="line">    spin_lock_init(&amp;rtc-&gt;irq_task_lock);</span><br><span class="line">    init_waitqueue_head(&amp;rtc-&gt;irq_queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init timerqueue */</span></span><br><span class="line">    timerqueue_init_head(&amp;rtc-&gt;timerqueue);</span><br><span class="line">    INIT_WORK(&amp;rtc-&gt;irqwork, rtc_timer_do_work);</span><br><span class="line">    <span class="comment">/* Init aie timer */</span></span><br><span class="line">    rtc_timer_init(&amp;rtc-&gt;aie_timer, rtc_aie_update_irq, (<span class="type">void</span> *)rtc);</span><br><span class="line">    <span class="comment">/* Init uie timer */</span></span><br><span class="line">    rtc_timer_init(&amp;rtc-&gt;uie_rtctimer, rtc_uie_update_irq, (<span class="type">void</span> *)rtc);</span><br><span class="line">    <span class="comment">/* Init pie timer */</span></span><br><span class="line">    hrtimer_init(&amp;rtc-&gt;pie_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span><br><span class="line">    rtc-&gt;pie_timer.function = rtc_pie_update_irq;</span><br><span class="line">    rtc-&gt;pie_enabled = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check to see if there is an ALARM already set in hw */</span></span><br><span class="line">    err = __rtc_read_alarm(rtc, &amp;alrm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err &amp;&amp; !rtc_valid_tm(&amp;alrm.time))</span><br><span class="line">        rtc_initialize_alarm(rtc, &amp;alrm);</span><br><span class="line"></span><br><span class="line">    strlcpy(rtc-&gt;name, name, RTC_DEVICE_NAME_SIZE);</span><br><span class="line">    dev_set_name(&amp;rtc-&gt;dev, <span class="string">&quot;rtc%d&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">    rtc_dev_prepare(rtc);</span><br><span class="line"></span><br><span class="line">    err = device_register(&amp;rtc-&gt;dev);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        put_device(&amp;rtc-&gt;dev);</span><br><span class="line">        <span class="keyword">goto</span> exit_kfree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rtc_dev_add_device(rtc);</span><br><span class="line">    rtc_sysfs_add_device(rtc);</span><br><span class="line">    rtc_proc_add_device(rtc);</span><br><span class="line"></span><br><span class="line">    dev_info(dev, <span class="string">&quot;rtc core: registered %s as %s\n&quot;</span>,</span><br><span class="line">            rtc-&gt;name, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rtc;</span><br><span class="line"></span><br><span class="line">exit_kfree:</span><br><span class="line">    kfree(rtc);</span><br><span class="line"></span><br><span class="line">exit_idr:</span><br><span class="line">    mutex_lock(&amp;idr_lock);</span><br><span class="line">    idr_remove(&amp;rtc_idr, id);</span><br><span class="line">    mutex_unlock(&amp;idr_lock);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    dev_err(dev, <span class="string">&quot;rtc core: unable to register %s, err = %d\n&quot;</span>,</span><br><span class="line">            name, err);</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(err);</span><br></pre></td></tr></table></figure>

<p>rtc_device_register()函数主要工作是创建一个rtc设备和实现proc、sysfs文件系统操作。</p>
<h2 id="rtc-dev-c"><a href="#rtc-dev-c" class="headerlink" title="rtc-dev.c"></a>rtc-dev.c</h2><p>rtc-dev.c 是硬件抽象层，为应用层提供了文件操作接口，如read, ioctl等。同时也为rtc-class.c 提供了API，rtc字符设备的创建的实现也在这里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_AIE_ON  _IO(<span class="string">&#x27;p&#x27;</span>, 0x01)  <span class="comment">/* Alarm int. enable on     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_AIE_OFF _IO(<span class="string">&#x27;p&#x27;</span>, 0x02)  <span class="comment">/* ... off          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_UIE_ON  _IO(<span class="string">&#x27;p&#x27;</span>, 0x03)  <span class="comment">/* Update int. enable on    */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_UIE_OFF _IO(<span class="string">&#x27;p&#x27;</span>, 0x04)  <span class="comment">/* ... off          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_PIE_ON  _IO(<span class="string">&#x27;p&#x27;</span>, 0x05)  <span class="comment">/* Periodic int. enable on  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_PIE_OFF _IO(<span class="string">&#x27;p&#x27;</span>, 0x06)  <span class="comment">/* ... off          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_WIE_ON  _IO(<span class="string">&#x27;p&#x27;</span>, 0x0f)  <span class="comment">/* Watchdog int. enable on  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_WIE_OFF _IO(<span class="string">&#x27;p&#x27;</span>, 0x10)  <span class="comment">/* ... off          */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_ALM_SET _IOW(<span class="string">&#x27;p&#x27;</span>, 0x07, struct rtc_time) <span class="comment">/* Set alarm time  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_ALM_READ    _IOR(<span class="string">&#x27;p&#x27;</span>, 0x08, struct rtc_time) <span class="comment">/* Read alarm time */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_RD_TIME _IOR(<span class="string">&#x27;p&#x27;</span>, 0x09, struct rtc_time) <span class="comment">/* Read RTC time   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_SET_TIME    _IOW(<span class="string">&#x27;p&#x27;</span>, 0x0a, struct rtc_time) <span class="comment">/* Set RTC time    */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_IRQP_READ   _IOR(<span class="string">&#x27;p&#x27;</span>, 0x0b, unsigned long)   <span class="comment">/* Read IRQ rate   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_IRQP_SET    _IOW(<span class="string">&#x27;p&#x27;</span>, 0x0c, unsigned long)   <span class="comment">/* Set IRQ rate    */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_EPOCH_READ  _IOR(<span class="string">&#x27;p&#x27;</span>, 0x0d, unsigned long)   <span class="comment">/* Read epoch      */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_EPOCH_SET   _IOW(<span class="string">&#x27;p&#x27;</span>, 0x0e, unsigned long)   <span class="comment">/* Set epoch       */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_WKALM_SET   _IOW(<span class="string">&#x27;p&#x27;</span>, 0x0f, struct rtc_wkalrm)<span class="comment">/* Set wakeup alarm*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_WKALM_RD    _IOR(<span class="string">&#x27;p&#x27;</span>, 0x10, struct rtc_wkalrm)<span class="comment">/* Get wakeup alarm*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_PLL_GET _IOR(<span class="string">&#x27;p&#x27;</span>, 0x11, struct rtc_pll_info)  <span class="comment">/* Get PLL correction */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_PLL_SET _IOW(<span class="string">&#x27;p&#x27;</span>, 0x12, struct rtc_pll_info)  <span class="comment">/* Set PLL correction */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">rtc_dev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> *<span class="title">ops</span> =</span> rtc-&gt;ops;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">tm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_wkalrm</span> <span class="title">alarm</span>;</span></span><br><span class="line">    <span class="type">void</span> __user *uarg = (<span class="type">void</span> __user *) arg;</span><br><span class="line"></span><br><span class="line">    err = mutex_lock_interruptible(&amp;rtc-&gt;ops_lock);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check that the calling task has appropriate permissions</span></span><br><span class="line"><span class="comment">     * for certain ioctls. doing this check here is useful</span></span><br><span class="line"><span class="comment">     * to avoid duplicate code in each driver.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> RTC_EPOCH_SET:</span><br><span class="line">    <span class="keyword">case</span> RTC_SET_TIME:</span><br><span class="line">        <span class="keyword">if</span> (!capable(CAP_SYS_TIME))</span><br><span class="line">            err = -EACCES;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_IRQP_SET:</span><br><span class="line">        <span class="keyword">if</span> (arg &gt; rtc-&gt;max_user_freq &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line">            err = -EACCES;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_PIE_ON:</span><br><span class="line">        <span class="keyword">if</span> (rtc-&gt;irq_freq &gt; rtc-&gt;max_user_freq &amp;&amp;</span><br><span class="line">                !capable(CAP_SYS_RESOURCE))</span><br><span class="line">            err = -EACCES;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Drivers *SHOULD NOT* provide ioctl implementations</span></span><br><span class="line"><span class="comment">     * for these requests.  Instead, provide methods to</span></span><br><span class="line"><span class="comment">     * support the following code, so that the RTC&#x27;s main</span></span><br><span class="line"><span class="comment">     * features are accessible without using ioctls.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * RTC and alarm times will be in UTC, by preference,</span></span><br><span class="line"><span class="comment">     * but dual-booting with MS-Windows implies RTCs must</span></span><br><span class="line"><span class="comment">     * use the local wall clock time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> RTC_ALM_READ:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"></span><br><span class="line">        err = rtc_read_alarm(rtc, &amp;alarm);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(uarg, &amp;alarm.time, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line">            err = -EFAULT;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_ALM_SET:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;alarm.time, uarg, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        alarm.enabled = <span class="number">0</span>;</span><br><span class="line">        alarm.pending = <span class="number">0</span>;</span><br><span class="line">        alarm.time.tm_wday = <span class="number">-1</span>;</span><br><span class="line">        alarm.time.tm_yday = <span class="number">-1</span>;</span><br><span class="line">        alarm.time.tm_isdst = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* RTC_ALM_SET alarms may be up to 24 hours in the future.</span></span><br><span class="line"><span class="comment">         * Rather than expecting every RTC to implement &quot;don&#x27;t care&quot;</span></span><br><span class="line"><span class="comment">         * for day/month/year fields, just force the alarm to have</span></span><br><span class="line"><span class="comment">         * the right values for those fields.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RTC_WKALM_SET should be used instead.  Not only does it</span></span><br><span class="line"><span class="comment">         * eliminate the need for a separate RTC_AIE_ON call, it</span></span><br><span class="line"><span class="comment">         * doesn&#x27;t have the &quot;alarm 23:59:59 in the future&quot; race.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span>  some legacy code may have used invalid fields as</span></span><br><span class="line"><span class="comment">         * wildcards, exposing hardware &quot;periodic alarm&quot; capabilities.</span></span><br><span class="line"><span class="comment">         * Not supported here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> now, then;</span><br><span class="line"></span><br><span class="line">            err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            rtc_tm_to_time(&amp;tm, &amp;now);</span><br><span class="line"></span><br><span class="line">            alarm.time.tm_mday = tm.tm_mday;</span><br><span class="line">            alarm.time.tm_mon = tm.tm_mon;</span><br><span class="line">            alarm.time.tm_year = tm.tm_year;</span><br><span class="line">            err  = rtc_valid_tm(&amp;alarm.time);</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            rtc_tm_to_time(&amp;alarm.time, &amp;then);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* alarm may need to wrap into tomorrow */</span></span><br><span class="line">            <span class="keyword">if</span> (then &lt; now) &#123;</span><br><span class="line">                rtc_time_to_tm(now + <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>, &amp;tm);</span><br><span class="line">                alarm.time.tm_mday = tm.tm_mday;</span><br><span class="line">                alarm.time.tm_mon = tm.tm_mon;</span><br><span class="line">                alarm.time.tm_year = tm.tm_year;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rtc_set_alarm(rtc, &amp;alarm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_RD_TIME:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"></span><br><span class="line">        err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(uarg, &amp;tm, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line">            err = -EFAULT;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_SET_TIME:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;tm, uarg, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rtc_set_time(rtc, &amp;tm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_PIE_ON:</span><br><span class="line">        err = rtc_irq_set_state(rtc, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_PIE_OFF:</span><br><span class="line">        err = rtc_irq_set_state(rtc, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_AIE_ON:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        <span class="keyword">return</span> rtc_alarm_irq_enable(rtc, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_AIE_OFF:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        <span class="keyword">return</span> rtc_alarm_irq_enable(rtc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_UIE_ON:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        <span class="keyword">return</span> rtc_update_irq_enable(rtc, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_UIE_OFF:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        <span class="keyword">return</span> rtc_update_irq_enable(rtc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_IRQP_SET:</span><br><span class="line">        err = rtc_irq_set_freq(rtc, <span class="literal">NULL</span>, arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_IRQP_READ:</span><br><span class="line">        err = put_user(rtc-&gt;irq_freq, (<span class="type">unsigned</span> <span class="type">long</span> __user *)uarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_WKALM_SET:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;alarm, uarg, <span class="keyword">sizeof</span>(alarm)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rtc_set_alarm(rtc, &amp;alarm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_WKALM_RD:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        err = rtc_read_alarm(rtc, &amp;alarm);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(uarg, &amp;alarm, <span class="keyword">sizeof</span>(alarm)))</span><br><span class="line">            err = -EFAULT;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* Finally try the driver&#x27;s ioctl interface */</span></span><br><span class="line">        <span class="keyword">if</span> (ops-&gt;ioctl) &#123;</span><br><span class="line">            err = ops-&gt;ioctl(rtc-&gt;dev.parent, cmd, arg);</span><br><span class="line">            <span class="keyword">if</span> (err == -ENOIOCTLCMD)</span><br><span class="line">                err = -ENOTTY;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            err = -ENOTTY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>poll</title>
    <url>/2022/06/07/kernel/poll/</url>
    <content><![CDATA[<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>使用非阻塞 I/O的应用程序通常会使用 select()和 poll()查询是否可对设备进行无阻塞的访问。应用层调用select()最终会引发设备驱动中的 poll()函数被执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN      0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLPRI     0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT     0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR     0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLHUP     0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL    0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDNORM  0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDBAND  0x0080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRNORM  0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRBAND  0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLMSG     0x0400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLREMOVE  0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDHUP       0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">poll_wait</span><span class="params">(<span class="keyword">struct</span> file * filp, <span class="type">wait_queue_head_t</span> * wait_address, poll_table *p)</span>;</span><br></pre></td></tr></table></figure>

<p>驱动要实现poll函数，主要工作为：对可能引起设备文件状态变化的等待队列调用 poll_wait()函数，将对应的等待队列头添加到 poll_table中，poll_wait()并不会引起阻塞。返回表示是否能对设备进行无阻塞读、写访问的掩码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">xxx_poll</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> poll_table_struct *wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxx_object</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    poll_wait(filp, &amp;dev-&gt;read_wait, wait);</span><br><span class="line">    poll_wait(filp, &amp;dev-&gt;write_wait, wait);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (...) <span class="comment">//可读 </span></span><br><span class="line">    &#123;</span><br><span class="line">        mask |= POLLIN | POLLRDNORM; <span class="comment">/*数据可获得*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (...) <span class="comment">//可写 </span></span><br><span class="line">    &#123;</span><br><span class="line">        mask |= POLLOUT | POLLWRNORM; <span class="comment">/*数据可写入*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除一个文件描述符集*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将一个文件描述符从文件描述符集中清除*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将一个文件描述符加入文件描述符集*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断文件描述符是否被置位*/</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">                  fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>readfds、writefds、exceptfds 分别是被 select()监视的读、写和异常处理的文件描述符集合，numfds 参数是要检查的最高的文件描述符加1，timeout 参数是超时时间。</p>
]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>spi 主机驱动</title>
    <url>/2022/09/04/kernel/spi_master/</url>
    <content><![CDATA[<h2 id="spi框架"><a href="#spi框架" class="headerlink" title="spi框架"></a>spi框架</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── spi-bitbang.c</span><br><span class="line">├── spi.c</span><br><span class="line">├── spidev.c</span><br><span class="line">├── spi-gpio.c</span><br><span class="line">├── spi-imx.c</span><br><span class="line">├── spi-mxs.c</span><br><span class="line">├── spi-rockchip.c</span><br><span class="line">├── spi-s3c24xx.c</span><br><span class="line">├── spi-stm32.c</span><br></pre></td></tr></table></figure>

<p>linux SPI驱动框架主要分为核心层，控制器驱动层以及设备驱动层。</p>
<p><img src="/images/kernel/spi/spi-arch.jpg" alt="SPI驱动框架"></p>
<p>SPI核心层代码位于 drivers/spi/spi.c，注册spi总线和spi_master设备类，同时提供spi设备驱动对spi总线操作的API。</p>
<h2 id="spi总线"><a href="#spi总线" class="headerlink" title="spi总线"></a>spi总线</h2><p><strong>注册SPI总线</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">spi_bus_type</span> =</span> &#123;</span><br><span class="line">    .name       = <span class="string">&quot;spi&quot;</span>,</span><br><span class="line">    .dev_groups = spi_dev_groups,</span><br><span class="line">    .match      = spi_match_device,</span><br><span class="line">    .uevent     = spi_uevent,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">spi_master_class</span> =</span> &#123;</span><br><span class="line">    .name       = <span class="string">&quot;spi_master&quot;</span>,</span><br><span class="line">    .owner      = THIS_MODULE,</span><br><span class="line">    .dev_release    = spi_controller_release,</span><br><span class="line">    .dev_groups = spi_master_groups,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPI_SLAVE</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">spi_slave_class</span> =</span> &#123;</span><br><span class="line">    .name       = <span class="string">&quot;spi_slave&quot;</span>,</span><br><span class="line">    .owner      = THIS_MODULE,</span><br><span class="line">    .dev_release    = spi_controller_release,</span><br><span class="line">    .dev_groups = spi_slave_groups,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">spi_slave_class</span>;</span>    <span class="comment">/* dummy */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">spi_init</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    buf = kmalloc(SPI_BUFSIZ, GFP_KERNEL);  <span class="comment">//分配数据收发缓冲区</span></span><br><span class="line"></span><br><span class="line">    status = bus_register(&amp;spi_bus_type);  <span class="comment">//注册spi总线 </span></span><br><span class="line"></span><br><span class="line">    status = class_register(&amp;spi_master_class);  <span class="comment">//注册spi主机类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ENABLED(CONFIG_SPI_SLAVE)) &#123;</span><br><span class="line">        status = class_register(&amp;spi_slave_class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册SPI总线，成功注册后，在/sys/bus下即可找到spi目录。注册设备类，成功注册后，在/sys/class目录下即可找到spi_master目录。</p>
<p><strong>总线匹配</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_match_device</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> to_spi_device(dev);</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> *<span class="title">sdrv</span> =</span> to_spi_driver(drv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check override first, and if set, only use the named driver */</span></span><br><span class="line">    <span class="keyword">if</span> (spi-&gt;driver_override)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(spi-&gt;driver_override, drv-&gt;name) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdrv-&gt;id_table)</span><br><span class="line">        <span class="keyword">return</span> !!spi_match_id(sdrv-&gt;id_table, spi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(spi-&gt;modalias, drv-&gt;name) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总线匹配规则：</p>
<ol>
<li>比较驱动中的of_match_table的compatible和device的of_node的compatible。</li>
<li>比较驱动中的acpi_match_table的compatible和device的of_node的compatible。</li>
<li>判断驱动中是否支持id数组，如果支持，查找匹配此id的spi_device。</li>
<li>比较设备的modalias的和驱动的名字是否相同。</li>
</ol>
<h2 id="spi-master"><a href="#spi-master" class="headerlink" title="spi_master"></a>spi_master</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_master</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>   <span class="title">dev</span>;</span>    <span class="comment">//spi主机设备文件</span></span><br><span class="line">    s16 bus_num;    <span class="comment">//spi总线号</span></span><br><span class="line">    u16 num_chipselect; <span class="comment">//片选号</span></span><br><span class="line">    u16 dma_alignment;  <span class="comment">//dma算法</span></span><br><span class="line">    u16 mode_bits;  <span class="comment">//模式位 </span></span><br><span class="line">    u16 flags;  <span class="comment">//传输类型标志 </span></span><br><span class="line">    <span class="type">int</span> (*setup)(<span class="keyword">struct</span> spi_device *spi);   <span class="comment">//setup方法</span></span><br><span class="line">    <span class="type">int</span> (*transfer)(<span class="keyword">struct</span> spi_device *spi,<span class="keyword">struct</span> spi_message *mesg);   <span class="comment">//传输方法</span></span><br><span class="line">    <span class="type">void</span>    (*cleanup)(<span class="keyword">struct</span> spi_device *spi); <span class="comment">//cleanup方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="注册-spi-master"><a href="#注册-spi-master" class="headerlink" title="注册 spi_master"></a>注册 spi_master</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">s3c64xx_spi_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">mem_res</span>, *<span class="title">dmatx_res</span>, *<span class="title">dmarx_res</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c64xx_spi_driver_data</span> *<span class="title">sdd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c64xx_spi_info</span> *<span class="title">sci</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_master</span> *<span class="title">master</span>;</span></span><br><span class="line"></span><br><span class="line">    master = spi_alloc_master(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> s3c64xx_spi_driver_data));</span><br><span class="line"></span><br><span class="line">    master-&gt;bus_num = pdev-&gt;id;</span><br><span class="line">    master-&gt;setup = s3c64xx_spi_setup;</span><br><span class="line">    master-&gt;transfer = s3c64xx_spi_transfer;</span><br><span class="line">    master-&gt;num_chipselect = sci-&gt;num_cs;</span><br><span class="line">    master-&gt;dma_alignment = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">/* the spi-&gt;mode bits understood by this driver: */</span></span><br><span class="line">    master-&gt;mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup Deufult Mode */</span></span><br><span class="line">    s3c64xx_spi_hwinit(sdd, pdev-&gt;id);</span><br><span class="line"></span><br><span class="line">    spi_register_master(master);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">s3c64xx_spi_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name  = <span class="string">&quot;s3c64xx-spi&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .remove = s3c64xx_spi_remove,</span><br><span class="line">    .suspend = s3c64xx_spi_suspend,</span><br><span class="line">    .resume = s3c64xx_spi_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">s3c64xx_spi_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_probe(&amp;s3c64xx_spi_driver, s3c64xx_spi_probe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 spi_alloc_master() 函数实例化一个spi控制器，初始化中断和时钟，实现 transfer_one() 函数，最后会使用 spi_register_master() 函数注册。注册成功后/sys/class/spi_master下会出现spi控制器。</p>
<h3 id="spi-register-master"><a href="#spi-register-master" class="headerlink" title="spi_register_master()"></a>spi_register_master()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_register_master</span><span class="params">(<span class="keyword">struct</span> spi_master *master)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">atomic_t</span>     dyn_bus_id = ATOMIC_INIT((<span class="number">1</span>&lt;&lt;<span class="number">15</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>       *<span class="title">dev</span> =</span> master-&gt;dev.parent;</span><br><span class="line">    <span class="type">int</span>         dynamic = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* even if it&#x27;s just one always-selected device, there must</span></span><br><span class="line"><span class="comment">     * be at least one chipselect</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;num_chipselect == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register the device, then userspace will see it.</span></span><br><span class="line"><span class="comment">     * registration fails if the bus ID is in use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dev_set_name(&amp;master-&gt;dev, <span class="string">&quot;spi%u&quot;</span>, master-&gt;bus_num);</span><br><span class="line">    status = device_add(&amp;master-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* populate children from any spi device tables */</span></span><br><span class="line">    scan_boardinfo(master);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scan_boardinfo</span><span class="params">(<span class="keyword">struct</span> spi_master *master)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">boardinfo</span> *<span class="title">bi</span>;</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;board_lock);</span><br><span class="line">    list_for_each_entry(bi, &amp;board_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">spi_board_info</span> *<span class="title">chip</span> =</span> bi-&gt;board_info;</span><br><span class="line">        <span class="type">unsigned</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (n = bi-&gt;n_board_info; n &gt; <span class="number">0</span>; n--, chip++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chip-&gt;bus_num != master-&gt;bus_num)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">/* <span class="doctag">NOTE:</span> this relies on spi_new_device to</span></span><br><span class="line"><span class="comment">             * issue diagnostics when given bogus inputs</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            (<span class="type">void</span>) spi_new_device(master, chip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;board_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将控制器添加到 spi_controller_list 链表，然后遍历 board_list 链表，如果匹配到 spi_board_info，则添加一个spi设备。</p>
<h3 id="spi-new-device"><a href="#spi-new-device" class="headerlink" title="spi_new_device()"></a>spi_new_device()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> spi_device *<span class="title function_">spi_new_device</span><span class="params">(<span class="keyword">struct</span> spi_master *master,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> spi_board_info *chip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">proxy</span>;</span></span><br><span class="line">    <span class="type">int</span>   status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span>  caller did any chip-&gt;bus_num checks necessary.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Also, unless we change the return value convention to use</span></span><br><span class="line"><span class="comment">     * error-or-pointer (not NULL-or-pointer), troubleshootability</span></span><br><span class="line"><span class="comment">     * suggests syslogged diagnostics are best here (ugh).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    proxy = spi_alloc_device(master);</span><br><span class="line"></span><br><span class="line">    WARN_ON(<span class="built_in">strlen</span>(chip-&gt;modalias) &gt;= <span class="keyword">sizeof</span>(proxy-&gt;modalias));</span><br><span class="line"></span><br><span class="line">    proxy-&gt;chip_select = chip-&gt;chip_select;</span><br><span class="line">    proxy-&gt;max_speed_hz = chip-&gt;max_speed_hz;</span><br><span class="line">    proxy-&gt;mode = chip-&gt;mode;</span><br><span class="line">    proxy-&gt;irq = chip-&gt;irq;</span><br><span class="line">    strlcpy(proxy-&gt;modalias, chip-&gt;modalias, <span class="keyword">sizeof</span>(proxy-&gt;modalias));</span><br><span class="line">    proxy-&gt;dev.platform_data = (<span class="type">void</span> *) chip-&gt;platform_data;</span><br><span class="line">    proxy-&gt;controller_data = chip-&gt;controller_data;</span><br><span class="line">    proxy-&gt;controller_state = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    status = spi_add_device(proxy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spi_add_device</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="title function_">DEFINE_MUTEX</span><span class="params">(spi_add_lock)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> spi-&gt;master-&gt;dev.parent;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">d</span>;</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Chipselects are numbered 0..max; validate. */</span></span><br><span class="line">    <span class="keyword">if</span> (spi-&gt;chip_select &gt;= spi-&gt;master-&gt;num_chipselect) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the bus ID string */</span></span><br><span class="line">    dev_set_name(&amp;spi-&gt;dev, <span class="string">&quot;%s.%u&quot;</span>, dev_name(&amp;spi-&gt;master-&gt;dev),</span><br><span class="line">            spi-&gt;chip_select);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to make sure there&#x27;s no other device with this</span></span><br><span class="line"><span class="comment">     * chipselect **BEFORE** we call setup(), else we&#x27;ll trash</span></span><br><span class="line"><span class="comment">     * its configuration.  Lock against concurrent add() calls.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mutex_lock(&amp;spi_add_lock);</span><br><span class="line"></span><br><span class="line">    d = bus_find_device_by_name(&amp;spi_bus_type, <span class="literal">NULL</span>, dev_name(&amp;spi-&gt;dev));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Drivers may modify this initial i/o setup, but will</span></span><br><span class="line"><span class="comment">     * normally rely on the device being setup.  Devices</span></span><br><span class="line"><span class="comment">     * using SPI_CS_HIGH can&#x27;t coexist well otherwise...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    status = spi_setup(spi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Device may be bound to an active driver when this returns */</span></span><br><span class="line">    status = device_add(&amp;spi-&gt;dev);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;spi_add_lock);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spi_setup</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> bad_bits;</span><br><span class="line">    <span class="type">int</span>  status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* help drivers fail *cleanly* when they need options</span></span><br><span class="line"><span class="comment">     * that aren&#x27;t supported with their current master</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bad_bits = spi-&gt;mode &amp; ~spi-&gt;master-&gt;mode_bits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!spi-&gt;bits_per_word)</span><br><span class="line">        spi-&gt;bits_per_word = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    status = spi-&gt;master-&gt;setup(spi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="spi-message"><a href="#spi-message" class="headerlink" title="spi_message"></a>spi_message</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">transfers</span>;</span>  <span class="comment">//spi传输事务链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>   *<span class="title">spi</span>;</span>   <span class="comment">//所属spi设备</span></span><br><span class="line">    <span class="type">unsigned</span>    is_dma_mapped:<span class="number">1</span>;</span><br><span class="line">    <span class="type">void</span>    (*complete)(<span class="type">void</span> *context);</span><br><span class="line">    <span class="type">void</span>    *context; </span><br><span class="line">    <span class="type">unsigned</span>    actual_length;</span><br><span class="line">    <span class="type">int</span>     status; <span class="comment">//传输状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">queue</span>;</span></span><br><span class="line">    <span class="type">void</span>    *state;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="spi-transfer"><a href="#spi-transfer" class="headerlink" title="spi_transfer"></a>spi_transfer</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> &#123;</span> </span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>  *tx_buf;    <span class="comment">//发送缓冲区指针 </span></span><br><span class="line">    <span class="type">void</span>        *rx_buf;    <span class="comment">//接收缓冲区指针 </span></span><br><span class="line">    <span class="type">unsigned</span>    len;    <span class="comment">//消息长度 </span></span><br><span class="line">    <span class="type">dma_addr_t</span>  tx_dma; <span class="comment">//DMA发送地址 </span></span><br><span class="line">    <span class="type">dma_addr_t</span>  rx_dma; <span class="comment">//DMA接收地址 </span></span><br><span class="line">    <span class="type">unsigned</span>    cs_change:<span class="number">1</span>;     </span><br><span class="line">    u8      bits_per_word;  <span class="comment">//一个字多少位 </span></span><br><span class="line">    u16     delay_usecs;    <span class="comment">//毫秒级延时 </span></span><br><span class="line">    u32     speed_hz;   <span class="comment">//速率 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">transfer_list</span>;</span> <span class="comment">//传输链表头 </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h2 id="spidev-c"><a href="#spidev-c" class="headerlink" title="spidev.c"></a>spidev.c</h2><p>注册SPI设备驱动代码位于/drivers/spi/spidev.c，同时创建spi字符设备文件，为应用层提供文件操作接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">spidev_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    <span class="comment">/* REVISIT switch to aio primitives, so that userspace</span></span><br><span class="line"><span class="comment">     * gets more complete API coverage.  It&#x27;ll simplify things</span></span><br><span class="line"><span class="comment">     * too, except for the locking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    .write = spidev_write,</span><br><span class="line">    .read =  spidev_read,</span><br><span class="line">    .unlocked_ioctl = spidev_ioctl,</span><br><span class="line">    .open =  spidev_open,</span><br><span class="line">    .release = spidev_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">spidev_spi_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name =  <span class="string">&quot;spidev&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = spidev_probe,</span><br><span class="line">    .remove = __devexit_p(spidev_remove),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">spidev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Claim our 256 reserved device numbers.  Then register a class</span></span><br><span class="line"><span class="comment">     * that will key udev/mdev to add/remove /dev nodes.  Last, register</span></span><br><span class="line"><span class="comment">     * the driver which manages those device numbers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BUILD_BUG_ON(N_SPI_MINORS &gt; <span class="number">256</span>);</span><br><span class="line">    status = register_chrdev(SPIDEV_MAJOR, <span class="string">&quot;spi&quot;</span>, &amp;spidev_fops);</span><br><span class="line"></span><br><span class="line">    spidev_class = class_create(THIS_MODULE, <span class="string">&quot;spidev&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(spidev_class)) &#123;</span><br><span class="line">        unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(spidev_class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = spi_register_driver(&amp;spidev_spi_driver);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line">module_init(spidev_init);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>device</category>
      </categories>
      <tags>
        <tag>spi</tag>
        <tag>device</tag>
      </tags>
  </entry>
  <entry>
    <title>sysfs</title>
    <url>/2022/06/07/kernel/sysfs/</url>
    <content><![CDATA[<h2 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h2><p>sysfs 是一个基于内存的虚拟文件系统，作用是将内核信息以文件的方式提供给用户程序使用。它把连接在系统上的设备和总线组织成为一个分级的文件，供用户空间存取；向用户空间导出内核数据结构以及它们的属性，以展示设备驱动模型中各组件的层次关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sys/</span><br><span class="line">├── block     包含系统中发现的块设备;</span><br><span class="line">├── bus       包含内核注册的总线;</span><br><span class="line">├── class     包含注册到内核的设备类;</span><br><span class="line">├── bus       按总线类型分类</span><br><span class="line">│   ├── i2c</span><br><span class="line">│   │   ├── drivers</span><br><span class="line">│   │   └── devices   包含总线下的所有设备</span><br><span class="line">│   │       ├──i2c-0 -&gt; ../../../devices/pci0000:00/0000:00:02.0/i2c-0/</span><br><span class="line">│   │       └──i2c-1 -&gt; ../../../devices/pci0000:00/0000:00:02.0/i2c-1/</span><br><span class="line">│   ├── pci</span><br><span class="line">│   ├── spi</span><br><span class="line">│   ├── usb</span><br><span class="line">├── class          按设备功能分类的设备模型</span><br><span class="line">│   ├── block</span><br><span class="line">│   ├── bluetooth</span><br><span class="line">│   ├── dma</span><br><span class="line">│   ├── gpio</span><br><span class="line">│   ├── i2c-adapter</span><br><span class="line">│   ├── i2c-dev</span><br><span class="line">│   ├── input</span><br><span class="line">│   ├── misc</span><br><span class="line">│   ├── phy</span><br><span class="line">│   ├── pwm</span><br><span class="line">│   ├── rtc</span><br><span class="line">│   ├── tty</span><br><span class="line">├── dev         按字符设备和块设备的major:minor指向真实设备(sys/devices)的链接</span><br><span class="line">│   ├── block</span><br><span class="line">│   └── char</span><br><span class="line">├── devices     含系统所有的设备，并根据设备挂接的总线类型组织成层次结构;</span><br><span class="line">├── firmware</span><br><span class="line">│   ├── acpi</span><br><span class="line">│   ├── dmi</span><br><span class="line">│   └── memmap</span><br><span class="line">├── fs</span><br><span class="line">├── hypervisor</span><br><span class="line">├── kernel      内核所有可调整参数位置</span><br><span class="line">├── module      所有驱动模块的模块参数等信息</span><br><span class="line">└── power       系统电源选项</span><br></pre></td></tr></table></figure>

<h2 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h2><p>总线、驱动和设备都对应sysfs 中的一个目录，实际上都算是kobject 的派生类，device 结构体直接包含了 kobject kobj 成员，而 bus_type和 device_driver 则透过 subsys_private、driver_private 间接包含了 kobject。每一个注册的kobject对象都对应 sysfs中的一个目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>      *name;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>   <span class="title">entry</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>      *<span class="title">parent</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>      *<span class="title">kset</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>   *<span class="title">ktype</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span>   *<span class="title">sd</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>      <span class="title">kref</span>;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>kobj_type 是/sys/下的属性文件，代表kobject 的属性，release()函数在 kobject 的引用计数为0时会被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">   <span class="type">void</span> (*release)(<span class="keyword">struct</span> kobject *kobj);</span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span>   <span class="comment">// 属性数组</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">   <span class="type">const</span> <span class="type">void</span> *(*namespace)(<span class="keyword">struct</span> kobject *kobj);</span><br><span class="line">   <span class="type">void</span> (*get_ownership)(<span class="keyword">struct</span> kobject *kobj, <span class="type">kuid_t</span> *uid, <span class="type">kgid_t</span> *gid);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sysfs_ops 包含对文件读写的函数指针，代表对属性文件的文件操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> &#123;</span></span><br><span class="line">   <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> kobject *, <span class="keyword">struct</span> attribute *, <span class="type">char</span> *);</span><br><span class="line">   <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> kobject *, <span class="keyword">struct</span> attribute *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="kset"><a href="#kset" class="headerlink" title="kset"></a>kset</h2><p>kset 是具有相同类型的 kobject 集合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">   <span class="type">spinlock_t</span> list_lock;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span>  <span class="comment">// 热插拔事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当驱动程序将 kobject 注册到设备驱动模型时，也就是调用 kobject_add()和 kobject_del()函数时，会产生热插拔事件，内核会根据 kobject 的 kset 指针找到所属的 kset 结构体，执行 uevent_ops 中的热插拔函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> &#123;</span></span><br><span class="line">   <span class="type">int</span> (* <span class="type">const</span> filter)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj);  <span class="comment">// 事件过滤，如果返回 0，将不传递事件到用户空间</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *(* <span class="type">const</span> name)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj);  <span class="comment">// 返回子系统的名字</span></span><br><span class="line">   <span class="type">int</span> (* <span class="type">const</span> uevent)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj,</span><br><span class="line">            <span class="keyword">struct</span> kobj_uevent_env *env);  <span class="comment">// 将用户空间需要的参数添加到环境变量中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>linux kernel timer</title>
    <url>/2022/06/07/kernel/timer/</url>
    <content><![CDATA[<h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>HZ 变量表示系统时钟频率，范围50-1200，默认1000。当时钟中断发生时，内核内部计数器的値就会加1，内部计数器由全局变量 jiffies 来表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span> <span class="comment">/*定时器列表*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires; <span class="comment">/*定时器到期时间*/</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">/* 定时器处理函数*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data; <span class="comment">/*作为参数被传入定时器处理函数*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_base_s</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="type">int</span> slack;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化定时器*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="keyword">struct</span> timer_list * timer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_INITIALIZER(_function, _expires, _data) &#123;     \</span></span><br><span class="line"><span class="meta">        .entry = &#123; .prev = TIMER_ENTRY_STATIC &#125;,    \</span></span><br><span class="line"><span class="meta">        .function = (_function),            \</span></span><br><span class="line"><span class="meta">        .expires = (_expires),              \</span></span><br><span class="line"><span class="meta">        .data = (_data),                \</span></span><br><span class="line"><span class="meta">        .base = &amp;boot_tvec_bases,           \</span></span><br><span class="line"><span class="meta">        .slack = -1,                    \</span></span><br><span class="line"><span class="meta">        __TIMER_LOCKDEP_MAP_INITIALIZER(        \</span></span><br><span class="line"><span class="meta">            __FILE__ <span class="string">&quot;:&quot;</span> __stringify(__LINE__)) \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TIMER(_name, _function, _expires, _data)     \</span></span><br><span class="line"><span class="meta">    struct timer_list _name =               \</span></span><br><span class="line"><span class="meta">        TIMER_INITIALIZER(_function, _expires, _data)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册内核定时器，将定时器加入到内核动态定时器链表中*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list * timer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除定时器*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(<span class="keyword">struct</span> timer_list * timer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重装载定时器*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mod_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer, <span class="type">unsigned</span> <span class="type">long</span> expires)</span>;</span><br></pre></td></tr></table></figure>

<p>内核定时器注册的处理函数只会执行一次，所以执行完后要重装载定时器，使其循环执行。</p>
<p>定时器的到期时间是在目前 jiffies 的基础是加一个时延，若为Hz，则表示延迟 1s。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">msecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">usecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> us)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">timespec_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timespec *value)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="内核延时"><a href="#内核延时" class="headerlink" title="内核延时"></a>内核延时</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ndelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nsecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">udelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>;</span><br></pre></td></tr></table></figure>

<p>这三种延时是根据CPU频率进行一定次数循环的忙等待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">msleep_interruptible</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ssleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<p>进程睡眠指定的时间，其中msleep()、ssleep()不能被打断。msleep_interruptible()可被打断。</p>
]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>udev</title>
    <url>/2022/06/07/kernel/udev/</url>
    <content><![CDATA[<h2 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h2><p>udev负责在用户空间，根据用户设置的规则，在监测到设备热插拔事件后，在/dev/下自动创建并命名设备文件节点，也可以自动设置设备属性。热插拔时，设备的详细信息会由内核输出到sysfs 文件系统。udev 的设备命名策略、权限控制和事件处理都是在用户态下完成的，它利用 sysfs 中的信息来进行创建设备文件节点等工作。</p>
<p>udev 根据系统中硬件设备的状态动态更新、创建和删除设备文件，进行设备文件的等，因此/dev 目录下只包含系统中真正存在的设备。linux在设备被发现的时候加载驱动模块。</p>
<p>udev主页 <a href="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html">http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html</a></p>
<p>udev包下载 <a href="http://www.us.kernel.org/pub/linux/utils/kernel/hotplug/">http://www.us.kernel.org/pub/linux/utils/kernel/hotplug/</a></p>
<p>udev 的设计目标如下：</p>
<ul>
<li>在用户空间中执行。</li>
<li>动态建立/删除设备文件。</li>
<li>允许每个人都不用关心主/次设备号。</li>
<li>提供 LSB 标准名称，如果需要，可提供固定的名称。</li>
</ul>
<p>udev 以 3 个分割的子计划发展：namedev、libsysfs 和 udev。namedev 为设备命名子系统；libsysfs 提供访问 sysfs 文件系统从中获取信息的标准接口；udev 提供/dev 设备节点文件的动态创建和删除策略，负责与 namedev 和 libsysfs 库交互的任务，当/sbin/hotplug程序被内核调用时，udev 将被运行。udev 的工作过程如下：</p>
<ol>
<li><p>当内核检测到在系统中出现了新设备后，内核会在 sysfs 文件系统中为该新设备生成新的记录并导出一些设备特定的信息及所发生的事件。</p>
</li>
<li><p>udev 获取内核导出的信息，它调用 namedev 决定应该给该设备指定的名称，如果是新插入设备，udev 将调用 libsysfs 决定应该为该设备的设备文件指定的主/次设备号，并用分析获得的设备名称和主/次设备号创建/dev 中的设备文件;如果是设备移除，则之前已经被创建的/dev 文件将被删除。</p>
</li>
</ol>
<p>namedev 中使用 5 步序列来决定指定设备的命名：</p>
<ol>
<li><p>标签(label)/序号(serial):这一步检查设备是否有惟一的识别记号，例如 USB 设备有惟一的 USB 序号，SCSI 有惟一的 UUID。如果 namedev 找到与这种惟一编号相对应的规则，它将使用该规则提供的名称。</p>
</li>
<li><p>设备总线号:这一步会检查总线设备编号，对于不可热插拔的环境，这一步足以辨别设备。例如，PCI 总线编号在系统的使用期间内很少变更。如果 namedev 找到相对应的规则，规则中的名称就会被使用。</p>
</li>
<li><p>总线上的拓扑:当设备在总线上的位置匹配用户指定的规则时，就会使用该规则指定的名称。</p>
</li>
<li><p>替换名称:当内核提供的名称匹配指定的替代字符串时，就会使用替代字符串指定的名称。</p>
</li>
<li><p>内核提供的名称:如果以前的几个步骤都没有被提供，默认的内核将被指定给该设备。</p>
</li>
</ol>
<h2 id="udev规则文件"><a href="#udev规则文件" class="headerlink" title="udev规则文件"></a>udev规则文件</h2><p><strong>配置文件</strong></p>
<p>udev的配置文件位于 /etc/udev/ 和 /lib/udev/。<br>udev 的主配置文件是 /etc/udev/udev.conf。 它包含一套变量，允许用户修改 udev 默认值。可以设置的变量如下：</p>
<ul>
<li>udev_root  设备目录，默认是/dev</li>
<li>udev_log   日志等级（表示严重程度），跟 syslog 一致，例如：err, info, debug。</li>
</ul>
<p><strong>规则文件</strong></p>
<p>udev的规则文件一般位于 /lib/udev/rules.d/，也可以位于 /etc/udev/rules.d/(优先)。规则文件以 .rules 作为扩展名。规则文件的每一行都是 key=value 格式，代表一个规则，key 分为匹配型和赋值型 key。</p>
<p>当所有匹配型 key 都匹配时，该规则即被采用，赋值型 key就会获得相应的值。也可以重命名网络接口，创建到设备节点的符号链或运行一个指定程序来处理该事件。</p>
<p>一条规则由多个 key=value 组成，以英文逗号隔开。 每个key 有一个操作，取决于操作符，有效的操作符如下：</p>
<ul>
<li>==    比较是否相等</li>
<li>!=    比较是否不相等</li>
<li>=     给一个key 赋值。表示一个列表的key会被重置，并且把这个唯一的值传给它</li>
<li>+=    将一个值增加到key中</li>
<li>:=    将一个值传给一个key，并且不允许再修改这个key。</li>
</ul>
<p><strong>匹配型KEY</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACTION     匹配事件的动作名</span><br><span class="line">DEVPATH    匹配事件的设备devpath</span><br><span class="line">KERNEL     匹配事件的设备名</span><br><span class="line">NAME       匹配网络接口或者设备节点的名字。NAME 只有在前面的规则赋值之后才可以使用。</span><br><span class="line">SYMLINK    匹配设备节点符号链的名字。SYMLINK 只有在前面的规则赋值之后才可以使用。可以有多个 symlinks，只需要匹配一个。</span><br><span class="line">SUBSYSTEM  匹配设备子系统名</span><br><span class="line">BUS        匹配总线类型</span><br><span class="line">SYSFS      匹配从 sysfs 得到的信息，比如 label、vendor、USB 序列号</span><br><span class="line">DRIVER               匹配设备的驱动名。只对绑定到一个驱动的设备有用。</span><br><span class="line">ATTR &#123; filename &#125;    匹配事件设备的sysfs 属性。</span><br><span class="line">KERNELS         向上搜索devpath，直到找到一个匹配的设备名</span><br><span class="line">SUBSYSTEMS      向上搜索devpath，直到找到一个匹配的子系统名</span><br><span class="line">DRIVERS         向上搜索devpath，直到找到一个匹配的驱动名</span><br><span class="line">ATTRS&#123; filename &#125;    向上搜索devpath，直到找到一个含匹配 sysfs 属性的设备</span><br><span class="line">ENV&#123; key &#125;</span><br><span class="line">TAG             设备的 tag</span><br><span class="line">TEST&#123;octal mode mask&#125;   测试一个文件是否存在，可以指定一个8进制的模式掩码。</span><br><span class="line">PROGRAM     执行一个程序。如果程序成功返回， key 为 true。设备的属性被放在被执行进程的环境变量中，该程序的输出为 stdout， 可以从 RESULT 这个 key 读取。</span><br><span class="line">RESULT      匹配最近一次PROGRAM 调用的返回字符串。它应该在 PROGRAM 之后使用</span><br></pre></td></tr></table></figure>

<p>支持一些通配符：</p>
<ul>
<li><ul>
<li>代表任意个字符</li>
</ul>
</li>
<li>? 代表一定有一个任意字符</li>
<li><input disabled="" type="checkbox"> 代表一定有一个在括号内的字符</li>
</ul>
<p><strong>匹配型KEY</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME     创建的设备文件名</span><br><span class="line">SYMLINK  符号创建链接名</span><br><span class="line">OWNER    设置设备的所有者</span><br><span class="line">GROUP    设置设备的组</span><br><span class="line">MODE</span><br><span class="line">ATTR &#123; key &#125;</span><br><span class="line">ENV &#123; key &#125;</span><br><span class="line">TAG</span><br><span class="line">RUN</span><br><span class="line">LABEL              GOTO 可以跳到的地方</span><br><span class="line">GOTO               跳到下一个带有匹配名字的 LABEL 处。</span><br><span class="line">IMPORT &#123; type &#125;    调用外部程序</span><br><span class="line">WAIT_FOR</span><br><span class="line">OPTIONS</span><br></pre></td></tr></table></figure>

<p>NAME,  SYMLINK,   PROGRAM,   OWNER,  GROUP、MODE 和 RUN 这些 field 支持一个简单的、类似于 printf 函数的格式字符串替换。可用的字符替换如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$kernel,  %k: 该设备的内核名字(%k 替换$kernel)</span><br><span class="line">$number,  %n：该设备的内核号码。例如 sda3 的内核号码是 <span class="number">3</span>。</span><br><span class="line">$devpath, %p：该设备的 devpath</span><br><span class="line">$id,   %b：当向上搜索devpath，寻找 SUBSYSTEMS， KERNELS， DRIVERS 和 ATTRS 时，被匹配的设备名字</span><br><span class="line">$driver：当向上搜索devpath，寻找 SUBSYSTEMS， KERNELS， DRIVERS 和 ATTRS 时，被匹配的驱动名字</span><br><span class="line">$attr &#123; file &#125;, %s &#123; file &#125;：一个被发现的设备的sysfs 属性的值。如果该设备没有该属性，且前面的 KERNELS,  SUBSYSTEMS,  DRIVERS或 ATTRS 测试选择的是一个父设备，那么就用父设备的属性。如果属性是一个符号链，符号链的最后一个元素作为返回值。</span><br><span class="line">$env &#123; key &#125;, %E &#123; key &#125;：一个设备属性值</span><br><span class="line">$major, %M：该设备的内核主号码</span><br><span class="line">$minor, %m：该设备的内核次号码</span><br><span class="line">$result, %c：由 PROGRAM 调用的外部程序返回的字符串。如果这个字符串包含空格，可以用 %c&#123;N&#125; 选中第N个字段。如果这个数字N，后面有一个 + 字符， 则表示选中从这个字段开始的所有后面的字符串 %c &#123; N + &#125;</span><br><span class="line">$parent, %p：父设备的节点名字</span><br><span class="line">$name：设备节点的名字，用一个空格作为分隔符。该值只有在前面的规则赋值之后才存在，或者是remove事件。</span><br><span class="line">$links：当前符号链的列表，用空格隔开。该值只有在前面的规则赋值之后才存在，或者是remove事件。</span><br><span class="line">$root, %r：udev_root 的值</span><br><span class="line">$sys, %S：sysfs 挂载点</span><br><span class="line">$tempnode, %N：在真正的设备节点创建之前，创建的一个临时的设备节点的名字，这个临时设备节点供外部程序使用。</span><br><span class="line">$$：<span class="string">&#x27;$&#x27;</span>字符自己</span><br><span class="line">%%：<span class="string">&#x27;%&#x27;</span> 字符自己</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, SYSFS&#123;address&#125;==&quot;00:0d:87:f6:59:f3&quot;, IMPORT=&quot;/sbin/rename_netiface %k eth0&quot;</span><br></pre></td></tr></table></figure>

<h2 id="udevadm"><a href="#udevadm" class="headerlink" title="udevadm"></a>udevadm</h2><p>udevadm可用于控制服务、 请求内核事件、管理事件队列、进行简单的调试。</p>
<ul>
<li><p><code>-d</code>, <code>--debug</code></p>
<p>在标准错误(STDERR)上显示调试信息。 <strong>udevadm test</strong> 与 <strong>udevadm test-builtin</strong> 命令隐含了此选项。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-info-options-devpath-file-unit…"><a href="#udevadm-info-options-devpath-file-unit…" class="headerlink" title="udevadm info [options] [devpath|file|unit…]"></a>udevadm info [<em>options</em>] [<em>devpath</em>|<em>file</em>|<em>unit</em>…]</h3><p>从udev数据库中提取设备信息。</p>
<p>位置参数用于指定一个或多个设备，它可以是 一个设备名(必须以 <code>/dev/</code> 开头)、 一个 sys 路径(必须以 <code>/sys/</code> 开头)、 一个设备单元(必须以 “<code>.device</code>“ 结尾)。详见 <a href="http://www.jinbuguo.com/systemd/systemd.device.html#">systemd.device(5)</a> 手册。</p>
<ul>
<li><p><code>-q</code>, <code>--query=*TYPE*</code></p>
<p>提取特定类型的设备信息。 <em>TYPE</em> 可以是下列值之一：<code>name</code>, <code>symlink</code>, <code>path</code>, <code>property</code>, <code>all</code>(默认值)</p>
</li>
<li><p><code>-p</code>, <code>--path=*DEVPATH*</code></p>
<p>该设备在 <code>/sys</code> 目录下的路径(例如 <code>[/sys]/class/block/sda</code>)。 因为此选项是位置参数以 <code>/sys/</code> 开头时的替代， 所以通常将 <strong>udevadm info –path=/class/block/sda</strong> 直接简写为 <strong>udevadm info /sys/class/block/sda</strong></p>
</li>
<li><p><code>-n</code>, <code>--name=*FILE*</code></p>
<p>设备节点或软连接的名称(例如 <code>[/dev]/sda</code>)。 因为此选项是位置参数以 <code>/dev/</code> 开头时的替代， 所以通常将 <strong>udevadm info –name=sda</strong> 直接简写为 <strong>udevadm info /dev/sda</strong></p>
</li>
<li><p><code>-r</code>, <code>--root</code></p>
<p>以绝对路径显示 <code>--query=name</code> 与 <code>--query=symlink</code> 的查询结果</p>
</li>
<li><p><code>-a</code>, <code>--attribute-walk</code></p>
<p>按照udev规则的格式，显示所有可用于匹配该设备的sysfs属性：从该设备自身开始，沿着设备树向上回溯(一直到树根)， 显示沿途每个设备的sysfs属性。</p>
</li>
<li><p><code>-x</code>, <code>--export</code></p>
<p>以 键=’值’ 的格式输出此设备的属性(注意，值两边有单引号界定)。 仅在指定了 <code>--query=property</code> 或 <code>--device-id-of-file=*FILE*</code> 的情况下才有效。</p>
</li>
<li><p><code>-P</code>, <code>--export-prefix=*NAME*</code></p>
<p>在输出的键名前添加一个前缀。 此选项隐含了 <code>--export</code></p>
</li>
<li><p><code>-d</code>, <code>--device-id-of-file=*FILE*</code></p>
<p>显示 <em>FILE</em> 文件所在底层设备的主/次设备号。 如果使用了此选项，那么将忽略所有位置参数。</p>
</li>
<li><p><code>-e</code>, <code>--export-db</code></p>
<p>导出udev数据库的全部内容</p>
</li>
<li><p><code>-c</code>, <code>--cleanup-db</code></p>
<p>清除udev数据库</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-trigger-options-devpath-file-unit"><a href="#udevadm-trigger-options-devpath-file-unit" class="headerlink" title="udevadm trigger [options] [devpath|file|unit]"></a>udevadm trigger [<em>options</em>] [<em>devpath</em>|<em>file</em>|<em>unit</em>]</h3><p>强制内核触发设备事件，主要用于重放内核初始化过程中的冷插(coldplug)设备事件。</p>
<p>接受一个用于指定设备的位置参数。参见前面对 <strong>info</strong> 的描述。</p>
<ul>
<li><p><code>-v</code>, <code>--verbose</code></p>
<p>显示被触发的设备列表</p>
</li>
<li><p><code>-n</code>, <code>--dry-run</code></p>
<p>并不真正触发设备事件</p>
</li>
<li><p><code>-t</code>, <code>--type=*TYPE*</code></p>
<p>仅触发特定类型的设备， TYPE 可以是下列值之一：<strong>devices</strong>(默认值), <strong>subsystems</strong></p>
</li>
<li><p><code>-c</code>, <code>--action=*ACTION*</code></p>
<p>指定触发哪种类型的设备事件，ACTION 可以是下列值之一：<strong>add</strong>, <strong>remove</strong>, <strong>change</strong>(默认值)</p>
</li>
<li><p><code>-s</code>, <code>--subsystem-match=*SUBSYSTEM*</code></p>
<p>仅触发属于 <em>SUBSYSTEM</em> 子系统的设备事件。 可以在 <em>SUBSYSTEM</em> 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，所有匹配的子系统中的设备都会被触发。</p>
</li>
<li><p><code>-S</code>, <code>--subsystem-nomatch=*SUBSYSTEM*</code></p>
<p>不触发属于 <em>SUBSYSTEM</em> 子系统的设备事件。 可以在 <em>SUBSYSTEM</em> 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则， 也就是说，只有不匹配所有指定子系统的设备才会被触发。</p>
</li>
<li><p><code>-a</code>, <code>--attr-match=*ATTRIBUTE*=*VALUE*</code></p>
<p>仅触发那些在设备的sysfs目录中存在 ATTRIBUTE 文件的设备事件。 如果同时还指定了”=VALUE”，那么表示仅触发那些 ATTRIBUTE 文件的内容匹配 VALUE 的设备事件。 注意，可以在 VALUE 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则， 也就是说，只有匹配所有指定属性的设备才会被触发。</p>
</li>
<li><p><code>-A</code>, <code>--attr-nomatch=*ATTRIBUTE*=*VALUE*</code></p>
<p>不触发那些在设备的sysfs目录中存在 ATTRIBUTE 文件的设备事件。 如果同时还指定了”=VALUE”，那么表示不触发那些 ATTRIBUTE 文件的内容匹配 VALUE 的设备事件。 注意，可以在 VALUE 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则， 也就是说，只有不匹配所有指定属性的设备才会被触发。</p>
</li>
<li><p><code>-p</code>, <code>--property-match=*PROPERTY*=*VALUE*</code></p>
<p>仅触发那些设备的 PROPERTY 属性值匹配 VALUE 的设备事件。注意，可以在 VALUE 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，匹配任意一个属性值的设备都会被触发。</p>
</li>
<li><p><code>-g</code>, <code>--tag-match=*PROPERTY*</code></p>
<p>仅触发匹配 PROPERTY 标签的设备事件。如果多次使用此选项， 那么表示以 AND 逻辑连接每个匹配规则，也就是说，只有匹配所有指定标签的设备才会被触发。</p>
</li>
<li><p><code>-y</code>, <code>--sysname-match=*SYSNAME*</code></p>
<p>仅触发设备sys名称(也就是该设备在 <code>/sys</code> 路径下最末端的文件名)匹配 <em>SYSNAME</em> 的设备事件。 注意，可以在 <em>SYSNAME</em> 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，匹配任意一个sys名称的设备都会被触发。</p>
</li>
<li><p><code>--name-match=*DEVPATH*</code></p>
<p>触发给定设备及其所有子设备的事件。<em>DEVPATH</em> 是该设备在 <code>/dev</code> 目录下的路径。 如果多次使用此选项，那么仅以最后一个为准。</p>
</li>
<li><p><code>-b</code>, <code>--parent-match=*SYSPATH*</code></p>
<p>触发给定设备及其所有子设备的事件。<em>SYSPATH</em> 是该设备在 <code>/sys</code> 目录下的路径。 如果多次使用此选项，那么仅以最后一个为准。</p>
</li>
<li><p><code>-w</code>, <code>--settle</code></p>
<p>除了触发设备事件之外，还要等待这些事件完成。 注意，此选项仅等待该命令自身触发的事件完成， 而 <strong>udevadm settle</strong> 则要一直等到 所有设备事件全部完成。</p>
</li>
<li><p><code>--wait-daemon[=*SECONDS*]</code></p>
<p>在触发设备事件之前，等待 systemd-udevd 守护进程完成初始化。 默认等待 5 秒之后超时(可以使用 <em>SECONDS</em> 参数修改)。 此选项等价于在 <strong>udevadm trigger</strong> 命令之前先使用 <strong>udevadm control –ping</strong> 命令。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<p>可以直接使用 以 <code>/sys</code> 或 <code>/dev</code> 开头的绝对路径来指定目标设备。</p>
<h3 id="udevadm-settle-options"><a href="#udevadm-settle-options" class="headerlink" title="udevadm settle [options]"></a>udevadm settle [<em>options</em>]</h3><p>监视udev事件队列，并且在所有事件全部处理完成之后退出。</p>
<ul>
<li><p><code>-t</code>, <code>--timeout=*SECONDS*</code></p>
<p>最多允许花多少秒等候事件队列清空。 默认值是120秒。 设为 0 表示仅检查事件队列是否为空， 并且立即返回。</p>
</li>
<li><p><code>-E</code>, <code>--exit-if-exists=*FILE*</code></p>
<p>如果 FILE 文件存在，则停止等待。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-control-option"><a href="#udevadm-control-option" class="headerlink" title="udevadm control option"></a>udevadm control <em>option</em></h3><p>控制udev守护进程(systemd-udevd)的内部状态。</p>
<ul>
<li><p><code>-e</code>, <code>--exit</code></p>
<p>向 systemd-udevd 发送”退出”信号并等待其退出。因为 <code>systemd-udevd.service</code> 中含有 <code>Restart=always</code> ，所以此选项实际是重启了 systemd-udevd 。 如果你想停止 <code>systemd-udevd.service</code> ，那么应该使用：<code>systemctl stop systemd-udevd-control.socket systemd-udevd-kernel.socket systemd-udevd.service</code></p>
</li>
<li><p><code>-l</code>, <code>--log-priority=*value*</code></p>
<p>设置 <a href="http://www.jinbuguo.com/systemd/systemd-udevd.service.html#">systemd-udevd.service(8)</a> 的内部日志等级。 可以用数字或文本表示：r<code>emerg</code>(0), <code>alert</code>(1), <code>crit</code>(2), <code>err</code>(3), <code>warning</code>(4), <code>notice</code>(5), <code>info</code>(6), <code>debug</code>(7)</p>
</li>
<li><p><code>-s</code>, <code>--stop-exec-queue</code></p>
<p>向 systemd-udevd 发送”禁止处理事件”信号， 这样所有新发生的事件都将进入等候队列。</p>
</li>
<li><p><code>-S</code>, <code>--start-exec-queue</code></p>
<p>向 systemd-udevd 发送”开始处理事件”信号，也就是开始处理事件队列中尚未处理的事件。</p>
</li>
<li><p><code>-R</code>, <code>--reload</code></p>
<p>向 systemd-udevd 发送”重新加载”信号，也就是重新加载udev规则与各种数据库(包括内核模块索引)。 注意，重新加载之后并不影响已经存在的设备， 但是新的配置将会应用于所有将来发生的新设备事件。</p>
</li>
<li><p><code>-p</code>, <code>--property=*KEY*=*value*</code></p>
<p>为所有将来发生的新设备事件统一设置一个全局的 KEY 属性，并将其值设为 value</p>
</li>
<li><p><code>-m</code>, <code>--children-max=</code><em>value</em></p>
<p>设置最多允许 systemd-udevd 同时处理多少个设备事件。</p>
</li>
<li><p><code>--ping</code></p>
<p>向 systemd-udevd 发送一个”ping”消息并等待应答。用于检查 systemd-udevd 守护进程是否仍在正常运行。</p>
</li>
<li><p><code>-t</code>, <code>--timeout=</code><em>seconds</em></p>
<p>等候 systemd-udevd 应答的最大秒数。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-monitor-options"><a href="#udevadm-monitor-options" class="headerlink" title="udevadm monitor [options]"></a>udevadm monitor [<em>options</em>]</h3><p>监视内核发出的设备事件(以”KERNEL”标记)， 以及udev在处理完udev规则之后发出的事件(以”UDEV”标记)，并在控制台上输出事件的设备路径(devpath)。 可用于分析udev处理设备事件所花的时间(比较”KERNEL”与”UDEV”的时间戳)。</p>
<ul>
<li><p><code>-k</code>, <code>--kernel</code></p>
<p>仅显示”KERNEL”事件</p>
</li>
<li><p><code>-u</code>, <code>--udev</code></p>
<p>仅显示”UDEV”事件</p>
</li>
<li><p><code>-p</code>, <code>--property</code></p>
<p>同时还显示事件的各属性</p>
</li>
<li><p><code>-s</code>, <code>--subsystem-match=*subsystem[/devtype]*</code></p>
<p>根据 subsystem[/devtype] 对事件(包括 kernel uevent 与 udev event)进行过滤，仅显示与”子系统[/设备类型]”匹配的”UDEV”事件。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，所有指定子系统中的设备都会被监视。</p>
</li>
<li><p><code>-t</code>, <code>--tag-match=*string*</code></p>
<p>根据设备标签对事件(仅 udev event)进行过滤，仅显示与”标签”匹配的”UDEV”事件。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，拥有任一指定标签的设备都会被监视。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-test-options-devpath"><a href="#udevadm-test-options-devpath" class="headerlink" title="udevadm test [options] [devpath]"></a>udevadm test [<em>options</em>] [<em>devpath</em>]</h3><p>模拟一个设备事件，并输出调试信息。</p>
<ul>
<li><p><code>-a</code>, <code>--action=*ACTION*</code></p>
<p>指定模拟哪种类型的设备事件，ACTION 可以是下列值之一：<strong>add</strong>(默认值), <strong>remove</strong>, <strong>change</strong></p>
</li>
<li><p><code>-N</code>, <code>--resolve-names=early|late|never</code></p>
<p>指定 udevadm 何时解析用户与组的名称：<code>early</code>(默认值) 表示在规则的解析阶段； <code>late</code> 表示在每个事件发生的时候； <code>never</code> 表示从不解析， 所有设备的属主与属组都是 root 。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-test-builtin-options-command-devpath"><a href="#udevadm-test-builtin-options-command-devpath" class="headerlink" title="udevadm test-builtin [options] [command] [devpath]"></a>udevadm test-builtin [<em>options</em>] [<em>command</em>] [<em>devpath</em>]</h3><p>针对 <em>DEVPATH</em>设备 运行一个内置的 <em>COMMAND</em> 命令， 并输出调试信息。</p>
<ul>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h2 id="mdev"><a href="#mdev" class="headerlink" title="mdev"></a>mdev</h2><p>mdev 是udev的轻量级版本，集成于 busybox中。为了使用mdev 功能，/etc/init.d/rcS 包含的如下内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/mount -t sysfs sysfs /sys</span><br><span class="line">/bin/mount -t tmpfs mdev /dev</span><br><span class="line">echo /bin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure>

<p><code>echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</code>的含义是当有热插拔事件产生时，内核会调用mdev。这时mdev扫描/sys 中所有的类设备目录，通过环境变量中的ACTION 和 DEVPATH，来确定此次热插拔事件的动作以及影响了/sys 中的那个目录。而<code>mdev -s</code>是自动扫描/sys 中所有的类设备目录。如果在目录中含有名为“dev”的文件，且文件中包含的是设备号，则mdev 就利用这些信息为该设备在/dev 下创建设备节点文件。</p>
<p>修改/etc/mdev.conf 文件可以修改mdev 的规则。</p>
<hr>
<p><a href="http://www.jinbuguo.com/systemd/udevadm.html">http://www.jinbuguo.com/systemd/udevadm.html</a></p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>tty 设备</title>
    <url>/2022/09/04/kernel/tty/</url>
    <content><![CDATA[<h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><p>终端是一种字符型设备，它有多种类型，通常使用 tty 来简称各种类型的终端设备。 tty 是 Teletype 的缩写， Teletype 是最早出现的一种终端设备，很像电传打字机，是由 Teletype公司生产的。Linux 中包含如下几类终端设备。</p>
<ul>
<li><strong>串行端口终端(/dev/ttySn)</strong></li>
</ul>
<p>串行端口终端(Serial Port Terminal)是使用计算机串行端口连接的终端设备。计算机把每个串行端口都看作是一个字符设备。这些串行端口所对应的设备名称是/dev/ttyS0(或/dev/tts/0)、/dev/ttyS1(或/dev/tts/1)等，设备号是4。在命令行上把标准输出重定向到端口对应的设备文件名上就可以通过该端口发送数据，例如，在命令行提示符下键入<code>echo test &gt; /dev/ttyS1</code>会把单词“test”发送到连接在 ttyS1 端口的设备上。</p>
<p>USB-串口转换器对应设备结点通常为/dev/ttyUSB0， /dev/ttyUSB1 等。</p>
<ul>
<li><strong>伪终端(/dev/pty/)</strong></li>
</ul>
<p>伪终端 pty(Pseudo Terminal)是成对的逻辑终端设备，并存在成对的设备文件。伪终端由pts(pseudo-terminal slave)和ptm(pseudo-terminal master)两部分组成。</p>
<p>pts伪造出一个标准的TTY设备，应用程序可以直接访问。应用程序向pts写入的数据，会直接反映到ptm上，同样，应用程序从pts读数据，则相当于直接从ptm读取。</p>
<p>而pym，根据具体情况具体实现。例如：要通过网络接口和终端设备交互，则pym需要打开对应的socket，将pts写来的数据，从socket送出，将从socket读取的数据，送回给pts。打开/dev/ptmx文件的时候，系统会自动在/dev/pts目录下创建一个新的设备文件。只要不关闭/dev/ptmx文件描述符，那么这个设备文件就会存在，一旦关闭，这个设备文件会自动消失。</p>
<p>在telnet，ssh等远程终端工具中会使用到伪终端，telnet通过网络协议与linux主机上的telnetd进程通讯，telnetd进程收到网络中的数据后，将数据写入/dev/ptmx，/dev/ptmx像管道一样将数据传递给/dev/pts/x，getty进程从pts/x读取数据传递给shell去执行。</p>
<ul>
<li><strong>控制终端(/dev/tty)</strong></li>
</ul>
<p>如果当前进程有控制终端(Controlling Terminal)的话，那么/dev/tty 就是当前进程的控制终端的设备特殊文件。可以使用命令<code>ps –ax</code>来查看进程与哪个控制终端相连，使用命令<code>tty</code>可以查看它具体对应哪个实际终端设备。</p>
<ul>
<li><strong>控制台终端(/dev/ttyn，/dev/console)</strong></li>
</ul>
<p>在 UNIX 系统中，计算机显示器通常被称为控制台终端(console)。当用户在控制台上登录时，使用的是 tty1。可以使用 Alt+[F1<del>F6]组合键切换到 tty2</del>tty6。tty1~tty6 等称为虚拟终端，tty0 则是当前所使用虚拟终端的一个别名，系统所产生的信息会发送到该终端上。用户登录不同的虚拟终端，就有多个不同的会话期存在。只有超级用户可以向/dev/tty0 进行写操作。</p>
<p>可以在系统启动命令行里指定kernel使用那个控制台终端，格式如下:</p>
<blockquote>
<p>console=device， options</p>
</blockquote>
<ul>
<li>device 指代的是终端设备，可以是 tty0(前台的虚拟终端)、ttyx(第x个虚拟终端)、ttySx(第x个串口)、lp0(第一个并口)等。</li>
<li>options 指代对 device 进行的设置，它取决于具体的设备驱动。对于串口设备，参数定义为:波特率、校验位(n/o/e)、位数，默认 options 是 9600n8。</li>
</ul>
<p>用户可以在内核命令行中同时设定多个console，这样输出将会在所有的console上显示，而当用户调用open()打开/dev/console时，打开的是最后一个console。</p>
<p>通过查看 /proc/tty/drivers 文件可以获知tty设备驱动的信息。</p>
<h2 id="tty框架"><a href="#tty框架" class="headerlink" title="tty框架"></a>tty框架</h2><p>tty可以分为如下几层：</p>
<ul>
<li><strong>核心层（tty core）</strong>: 是tty设备的抽象</li>
<li><strong>线路规程（tty line discipline）</strong>: 是对上层和底层之间数据传输的协议转换, 不同类型的终端设备数据转换协议不同</li>
<li><strong>驱动层（tty driver）</strong>: 面向底层硬件的设备驱动</li>
</ul>
<p><img src="/images/kernel/tty/tty-dev.bmp" alt="img"></p>
<p><img src="/images/kernel/tty/tty-ops.bmp" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── hvc</span><br><span class="line">├── ipwireless</span><br><span class="line">├── serdev</span><br><span class="line">├── vt</span><br><span class="line">├── serial</span><br><span class="line">│   ├── altera_uart.c</span><br><span class="line">│   ├── amba-pl010.c</span><br><span class="line">│   ├── atmel_serial.c</span><br><span class="line">│   ├── atmel_serial.h</span><br><span class="line">│   ├── rda-uart.c</span><br><span class="line">│   ├── samsung.c</span><br><span class="line">│   ├── samsung.h</span><br><span class="line">│   ├── serial_core.c</span><br><span class="line">│   ├── stm32-usart.c</span><br><span class="line">│   ├── stm32-usart.h</span><br><span class="line">├── tty_audit.c</span><br><span class="line">├── tty_baudrate.c</span><br><span class="line">├── tty_buffer.c</span><br><span class="line">├── tty_io.c        #ttty设备创建和相关文件操作API</span><br><span class="line">├── tty_ioctl.c</span><br><span class="line">├── tty_jobctrl.c</span><br><span class="line">├── tty_ldisc.c    #线路规程</span><br><span class="line">├── tty_ldsem.c</span><br><span class="line">├── tty_mutex.c</span><br><span class="line">├── tty_port.c</span><br><span class="line">├── n_tty.c</span><br><span class="line">├── n_gsm.c</span><br><span class="line">└── pty.c</span><br></pre></td></tr></table></figure>

<h2 id="tty核心层"><a href="#tty核心层" class="headerlink" title="tty核心层"></a>tty核心层</h2><h3 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> magic;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">  <span class="type">spinlock_t</span> ctrl_lock;</span><br><span class="line">  <span class="type">spinlock_t</span> flow_lock;</span><br><span class="line">  <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>  <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>   <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>   <span class="comment">/* winsize_mutex */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> stopped:<span class="number">1</span>,  <span class="comment">/* flow_lock */</span></span><br><span class="line">          flow_stopped:<span class="number">1</span>,</span><br><span class="line">          unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> hw_stopped;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ctrl_status:<span class="number">8</span>,  <span class="comment">/* ctrl_lock */</span></span><br><span class="line">          packet:<span class="number">1</span>,</span><br><span class="line">          unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">  <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">  <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">  <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">  <span class="type">void</span> *disc_data;</span><br><span class="line">  <span class="type">void</span> *driver_data;</span><br><span class="line">  <span class="type">spinlock_t</span> files_lock;    <span class="comment">/* protects tty_files list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> closing;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">  <span class="type">int</span> write_cnt;</span><br><span class="line">  <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tty-driver"><a href="#tty-driver" class="headerlink" title="tty_driver"></a>tty_driver</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span></span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line">  <span class="type">int</span> magic;    <span class="comment">/* magic number for this structure */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span> <span class="comment">/* Reference management */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> **<span class="title">cdevs</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>  *driver_name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>  *name;</span><br><span class="line">  <span class="type">int</span> name_base;  <span class="comment">/* offset of printed name */</span></span><br><span class="line">  <span class="type">int</span> major;    <span class="comment">/* major device number */</span></span><br><span class="line">  <span class="type">int</span> minor_start;  <span class="comment">/* start of minor device number */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  num;  <span class="comment">/* number of devices allocated */</span></span><br><span class="line">  <span class="type">short</span> type;   <span class="comment">/* type of tty driver */</span></span><br><span class="line">  <span class="type">short</span> subtype;  <span class="comment">/* subtype of tty driver */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">init_termios</span>;</span> <span class="comment">/* Initial termios */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags;    <span class="comment">/* tty driver flags */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_entry</span>;</span> <span class="comment">/* /proc fs entry */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">other</span>;</span> <span class="comment">/* only used for the PTY driver */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> **<span class="title">ttys</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> **<span class="title">ports</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> **<span class="title">termios</span>;</span></span><br><span class="line">  <span class="type">void</span> *driver_state;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_drivers</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tty-port"><a href="#tty-port" class="headerlink" title="tty_port"></a>tty_port</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_bufhead</span>  <span class="title">buf</span>;</span>        <span class="comment">/* Locked internally */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span>   *<span class="title">tty</span>;</span>       <span class="comment">/* Back pointer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span>   *<span class="title">itty</span>;</span>      <span class="comment">/* internal back ptr */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_port_operations</span> *<span class="title">ops</span>;</span>  <span class="comment">/* Port operations */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_port_client_operations</span> *<span class="title">client_ops</span>;</span> <span class="comment">/* Port client operations */</span></span><br><span class="line">    <span class="type">spinlock_t</span>      lock;       <span class="comment">/* Lock protecting tty field */</span></span><br><span class="line">    <span class="type">int</span>         blocked_open;   <span class="comment">/* Waiting to open */</span></span><br><span class="line">    <span class="type">int</span>         count;      <span class="comment">/* Usage count */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span>   open_wait;  <span class="comment">/* Open waiters */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span>   delta_msr_wait; <span class="comment">/* Modem status change */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;      <span class="comment">/* User TTY flags ASYNC_ */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       iflags;     <span class="comment">/* Internal flags TTY_PORT_ */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>       console:<span class="number">1</span>,  <span class="comment">/* port is a console */</span></span><br><span class="line">                low_latency:<span class="number">1</span>;  <span class="comment">/* optional: tune for latency */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">mutex</span>;</span>      <span class="comment">/* Locking */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">buf_mutex</span>;</span>  <span class="comment">/* Buffer alloc lock */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>       *xmit_buf;  <span class="comment">/* Optional buffer */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        close_delay;    <span class="comment">/* Close port delay */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        closing_wait;   <span class="comment">/* Delay for output */</span></span><br><span class="line">    <span class="type">int</span>         drain_delay;    <span class="comment">/* Set to zero if no pure time</span></span><br><span class="line"><span class="comment">                           based drain is needed else</span></span><br><span class="line"><span class="comment">                           set to size of fifo */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>     <span class="title">kref</span>;</span>       <span class="comment">/* Ref counter */</span></span><br><span class="line">    <span class="type">void</span>            *client_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tty-port-operations"><a href="#tty-port-operations" class="headerlink" title="tty_port_operations"></a>tty_port_operations</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_port_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*carrier_raised)(<span class="keyword">struct</span> tty_port *port);</span><br><span class="line">    <span class="type">void</span> (*dtr_rts)(<span class="keyword">struct</span> tty_port *port, <span class="type">int</span> raise);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_port *port);</span><br><span class="line">    <span class="type">int</span> (*activate)(<span class="keyword">struct</span> tty_port *port, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*destruct)(<span class="keyword">struct</span> tty_port *port);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tty-operations"><a href="#tty-operations" class="headerlink" title="tty_operations"></a>tty_operations</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">      <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">  <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">  <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">  <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">          <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">  <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">  <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">  <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">           <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">  <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">  <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">  <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">  <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">  <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">  <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">  <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">  <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">  <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line">  <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">        <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">  <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">  <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">  <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">  <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">  <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">  <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tty-register-driver"><a href="#tty-register-driver" class="headerlink" title="tty_register_driver()"></a>tty_register_driver()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_register_driver</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> error;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">dev_t</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">d</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册字符设备 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!driver-&gt;major) &#123;</span><br><span class="line">    error = alloc_chrdev_region(&amp;dev, driver-&gt;minor_start,</span><br><span class="line">            driver-&gt;num, driver-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">      driver-&gt;major = MAJOR(dev);</span><br><span class="line">      driver-&gt;minor_start = MINOR(dev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dev = MKDEV(driver-&gt;major, driver-&gt;minor_start);</span><br><span class="line">    error = register_chrdev_region(dev, driver-&gt;num, driver-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_ALLOC) &#123;</span><br><span class="line">    error = tty_cdev_add(driver, dev, <span class="number">0</span>, driver-&gt;num);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutex_lock(&amp;tty_mutex);</span><br><span class="line">  list_add(&amp;driver-&gt;tty_drivers, &amp;tty_drivers);  <span class="comment">//添加到全局链表 tty_drivers</span></span><br><span class="line">  mutex_unlock(&amp;tty_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_DEV)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; driver-&gt;num; i++) &#123;</span><br><span class="line">      d = tty_register_device(driver, i, <span class="literal">NULL</span>); <span class="comment">//注册tty设备</span></span><br><span class="line">      <span class="keyword">if</span> (IS_ERR(d)) &#123;</span><br><span class="line">        error = PTR_ERR(d);</span><br><span class="line">        <span class="keyword">goto</span> err_unreg_devs;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  proc_tty_register_driver(driver);  <span class="comment">//添加 proc 文件系统</span></span><br><span class="line">  driver-&gt;flags |= TTY_DRIVER_INSTALLED;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tty_cdev_add</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver, <span class="type">dev_t</span> dev,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  driver-&gt;cdevs[index] = cdev_alloc();</span><br><span class="line">  <span class="keyword">if</span> (!driver-&gt;cdevs[index])</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  driver-&gt;cdevs[index]-&gt;ops = &amp;tty_fops;  <span class="comment">//设置文件操作函数集 tty_fops</span></span><br><span class="line">  driver-&gt;cdevs[index]-&gt;owner = driver-&gt;owner;</span><br><span class="line">  err = cdev_add(driver-&gt;cdevs[index], dev, count);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    kobject_put(&amp;driver-&gt;cdevs[index]-&gt;kobj);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册字符设备，将该 tty_driver-&gt;tty_drivers 添加到全局链表 tty_drivers。添加 proc 文件系统。设置文件操作函数集 tty_fops。</p>
<h3 id="tty-open"><a href="#tty-open" class="headerlink" title="tty_open()"></a>tty_open()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tty_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">  <span class="type">int</span> noctty, retval;</span><br><span class="line">  <span class="type">dev_t</span> device = inode-&gt;i_rdev;</span><br><span class="line">  <span class="type">unsigned</span> saved_flags = filp-&gt;f_flags;</span><br><span class="line"></span><br><span class="line">  tty = tty_open_current_tty(device, filp); <span class="comment">/* 获取当前线程锁定的tty */</span></span><br><span class="line">  <span class="keyword">if</span> (!tty)</span><br><span class="line">    tty = tty_open_by_driver(device, inode, filp); <span class="comment">/* 通过查找tty驱动打开tty设备 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tty-&gt;ops-&gt;open)</span><br><span class="line">    retval = tty-&gt;ops-&gt;open(tty, filp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tty_struct *<span class="title function_">tty_open_current_tty</span><span class="params">(<span class="type">dev_t</span> device, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前设备是/dev/tty则尝试重新打开 */</span></span><br><span class="line">    <span class="keyword">if</span> (device != MKDEV(TTYAUX_MAJOR, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tty = get_current_tty();</span><br><span class="line">    retval = tty_reopen(tty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tty_reopen</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span> =</span> tty-&gt;driver;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ld</span>;</span></span><br><span class="line"></span><br><span class="line">    ld = tty_ldisc_ref_wait(tty);</span><br><span class="line">    <span class="keyword">if</span> (ld) &#123;</span><br><span class="line">        tty_ldisc_deref(ld);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        retval = tty_ldisc_lock(tty, <span class="number">5</span> * HZ);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!tty-&gt;ldisc)</span><br><span class="line">            retval = tty_ldisc_reinit(tty, tty-&gt;termios.c_line);  </span><br><span class="line">        tty_ldisc_unlock(tty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用线路规程的<a href="#tty_ldisc_reinit()">tty_ldisc_reinit()</a>函数重新初始化tty设备的线路规程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tty_struct *<span class="title function_">tty_open_by_driver</span><span class="params">(<span class="type">dev_t</span> device, <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从 tty_drivers 全局链表中获取注册的 tty_driver */</span></span><br><span class="line">    driver = tty_lookup_driver(device, filp, &amp;index);</span><br><span class="line"></span><br><span class="line">    通过 tty_drivers 查找 tty_struct</span><br><span class="line">    tty = tty_driver_lookup_tty(driver, filp, index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tty) &#123;</span><br><span class="line">        tty_reopen(tty);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        tty = tty_init_dev(driver, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tty_struct *<span class="title function_">tty_init_dev</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    tty = alloc_tty_struct(driver, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tty-&gt;port)</span><br><span class="line">        tty-&gt;port = driver-&gt;ports[idx];</span><br><span class="line"></span><br><span class="line">    tty_ldisc_lock(tty, <span class="number">5</span> * HZ);</span><br><span class="line">    tty-&gt;port-&gt;itty = tty;</span><br><span class="line"></span><br><span class="line">    tty_ldisc_setup(tty, tty-&gt;link);</span><br><span class="line">    <span class="keyword">return</span> tty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tty_struct *<span class="title function_">alloc_tty_struct</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line"></span><br><span class="line">    tty = kzalloc(<span class="keyword">sizeof</span>(*tty), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    kref_init(&amp;tty-&gt;kref);</span><br><span class="line">    tty-&gt;magic = TTY_MAGIC;</span><br><span class="line"></span><br><span class="line">    tty_ldisc_init(tty);</span><br><span class="line"></span><br><span class="line">    tty-&gt;session = <span class="literal">NULL</span>;</span><br><span class="line">    tty-&gt;pgrp = <span class="literal">NULL</span>;</span><br><span class="line">    mutex_init(&amp;tty-&gt;legacy_mutex);</span><br><span class="line">    mutex_init(&amp;tty-&gt;throttle_mutex);</span><br><span class="line">    init_rwsem(&amp;tty-&gt;termios_rwsem);</span><br><span class="line">    mutex_init(&amp;tty-&gt;winsize_mutex);</span><br><span class="line">    init_ldsem(&amp;tty-&gt;ldisc_sem);</span><br><span class="line">    init_waitqueue_head(&amp;tty-&gt;write_wait);</span><br><span class="line">    init_waitqueue_head(&amp;tty-&gt;read_wait);</span><br><span class="line">    INIT_WORK(&amp;tty-&gt;hangup_work, do_tty_hangup);</span><br><span class="line">    mutex_init(&amp;tty-&gt;atomic_write_lock);</span><br><span class="line">    spin_lock_init(&amp;tty-&gt;ctrl_lock);</span><br><span class="line">    spin_lock_init(&amp;tty-&gt;flow_lock);</span><br><span class="line">    spin_lock_init(&amp;tty-&gt;files_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;tty-&gt;tty_files);</span><br><span class="line">    INIT_WORK(&amp;tty-&gt;SAK_work, do_SAK_work);</span><br><span class="line"></span><br><span class="line">    tty-&gt;driver = driver;</span><br><span class="line">    tty-&gt;ops = driver-&gt;ops;  <span class="comment">/* 设置tty设备文件操作接口 */</span></span><br><span class="line">    tty-&gt;index = idx;</span><br><span class="line">    tty_line_name(driver, idx, tty-&gt;name);</span><br><span class="line">    tty-&gt;dev = tty_get_device(tty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_ldisc_setup</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> tty_struct *o_tty)</span></span><br><span class="line">&#123;</span><br><span class="line">    tty_ldisc_open(tty, tty-&gt;ldisc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化一个 tty_struct，调用<a href="#tty_ldisc_open()">tty_ldisc_open()</a>打开一个线路规程。最后调用 tty_struct-&gt;ops-&gt;open 函数，其实是tty_driver-&gt;ops-&gt;open，也就是uart_ops中的open函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_open</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> *<span class="title">drv</span> =</span> tty-&gt;driver-&gt;driver_state;</span><br><span class="line">    <span class="type">int</span> retval, line = tty-&gt;index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span> =</span> drv-&gt;state + line;</span><br><span class="line"></span><br><span class="line">    tty-&gt;driver_data = state;</span><br><span class="line"></span><br><span class="line">    retval = tty_port_open(&amp;state-&gt;port, tty, filp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_port_open</span><span class="params">(<span class="keyword">struct</span> tty_port *port, <span class="keyword">struct</span> tty_struct *tty,</span></span><br><span class="line"><span class="params">                            <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock_irq(&amp;port-&gt;lock);</span><br><span class="line">    ++port-&gt;count;</span><br><span class="line">    spin_unlock_irq(&amp;port-&gt;lock);</span><br><span class="line">    tty_port_tty_set(port, tty);</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;port-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tty_port_initialized(port)) &#123;</span><br><span class="line">        clear_bit(TTY_IO_ERROR, &amp;tty-&gt;flags);</span><br><span class="line">        <span class="keyword">if</span> (port-&gt;ops-&gt;activate) &#123;</span><br><span class="line">            <span class="type">int</span> retval = port-&gt;ops-&gt;activate(port, tty);</span><br><span class="line">        &#125;</span><br><span class="line">        tty_port_set_initialized(port, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;port-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> tty_port_block_til_ready(port, tty, filp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_port_activate</span><span class="params">(<span class="keyword">struct</span> tty_port *port, <span class="keyword">struct</span> tty_struct *tty)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span> =</span> container_of(port, <span class="keyword">struct</span> uart_state, port);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">uport</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uart_startup(tty, state, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_startup</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> uart_state *state,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> init_hw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span> =</span> &amp;state-&gt;port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uart_port_startup(tty, state, init_hw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_port_startup</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> uart_state *state,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> init_hw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">uport</span> =</span> uart_port_check(state);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> page;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uport-&gt;type == PORT_UNKNOWN)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    uart_change_pm(state, UART_PM_STATE_ON);</span><br><span class="line"></span><br><span class="line">    page = get_zeroed_page(GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    uart_port_lock(state, flags);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;xmit.buf) &#123;</span><br><span class="line">        state-&gt;xmit.buf = (<span class="type">unsigned</span> <span class="type">char</span> *) page;</span><br><span class="line">        uart_circ_clear(&amp;state-&gt;xmit);</span><br><span class="line">        uart_port_unlock(uport, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        uart_port_unlock(uport, flags);</span><br><span class="line">        free_page(page);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    retval = uport-&gt;ops-&gt;startup(uport);</span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uart_console(uport) &amp;&amp; uport-&gt;cons-&gt;cflag) &#123;</span><br><span class="line">            tty-&gt;termios.c_cflag = uport-&gt;cons-&gt;cflag;</span><br><span class="line">            uport-&gt;cons-&gt;cflag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uart_change_speed(tty, state, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (init_hw &amp;&amp; C_BAUD(tty))</span><br><span class="line">            uart_port_dtr_rts(uport, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用的是state-&gt;uart_port-&gt;ops-&gt;startup()函数。</p>
<h3 id="tty-write"><a href="#tty-write" class="headerlink" title="tty_write()"></a>tty_write()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">tty_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">                        <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ld</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span> =</span> file_tty(file);</span><br><span class="line">        </span><br><span class="line">    ld = tty-&gt;ldisc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ld)</span><br><span class="line">        <span class="keyword">return</span> hung_up_tty_write(file, buf, count, ppos);</span><br><span class="line">    <span class="keyword">if</span> (!ld-&gt;ops-&gt;write)</span><br><span class="line">        ret = -EIO;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count);</span><br><span class="line">    tty_ldisc_deref(ld);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">ssize_t</span> <span class="title function_">do_tty_write</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>),</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> tty_struct *tty,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> ret, written = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> chunk;</span><br><span class="line"></span><br><span class="line">    ret = tty_write_lock(tty, file-&gt;f_flags &amp; O_NDELAY);</span><br><span class="line"></span><br><span class="line">    chunk = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">if</span> (test_bit(TTY_NO_WRITE_SPLIT, &amp;tty-&gt;flags))</span><br><span class="line">        chunk = <span class="number">65536</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; chunk)</span><br><span class="line">        chunk = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tty-&gt;write_cnt &lt; chunk) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *buf_chunk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (chunk &lt; <span class="number">1024</span>)</span><br><span class="line">            chunk = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        buf_chunk = kmalloc(chunk, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!buf_chunk) &#123;</span><br><span class="line">            ret = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        kfree(tty-&gt;write_buf);</span><br><span class="line">        tty-&gt;write_cnt = chunk;</span><br><span class="line">        tty-&gt;write_buf = buf_chunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">size_t</span> size = count;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; chunk)</span><br><span class="line">            size = chunk;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(tty-&gt;write_buf, buf, size))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ret = write(tty, file, tty-&gt;write_buf, size);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        written += ret;</span><br><span class="line">        buf += ret;</span><br><span class="line">        count -= ret;</span><br><span class="line">        <span class="keyword">if</span> (!count)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ret = -ERESTARTSYS;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cond_resched();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (written) &#123;</span><br><span class="line">        tty_update_time(&amp;file_inode(file)-&gt;i_mtime);</span><br><span class="line">        ret = written;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    tty_write_unlock(tty);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="串口驱动层"><a href="#串口驱动层" class="headerlink" title="串口驱动层"></a>串口驱动层</h2><h3 id="uart-driver"><a href="#uart-driver" class="headerlink" title="uart_driver"></a>uart_driver</h3><p>uart_driver描述串口驱动，包含了串口设备名、串口驱动名、主次设备号、串口控制台等信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>   *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>    *driver_name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>    *dev_name;</span><br><span class="line">    <span class="type">int</span>      major;</span><br><span class="line">    <span class="type">int</span>      minor;</span><br><span class="line">    <span class="type">int</span>      nr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">console</span>    *<span class="title">cons</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">tty_driver</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span>     <span class="title">port</span>;</span></span><br><span class="line">    <span class="type">int</span>         pm_state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">circ_buf</span>     <span class="title">xmit</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span>    *<span class="title">uart_port</span>;</span> <span class="comment">//对应于一个串口设备</span></span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<h3 id="uart-port"><a href="#uart-port" class="headerlink" title="uart_port"></a>uart_port</h3><p>uart_port 用于描述一个UART端口的IO端口或IO内存地址、FIFO大小、端口类型等信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span>    lock;     <span class="comment">/* port lock */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   iobase;     <span class="comment">/* in/out[bwl] */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> __iomem *membase;   <span class="comment">/* read/write[bwl] */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span>    <span class="params">(*serial_in)</span><span class="params">(<span class="keyword">struct</span> uart_port *, <span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">void</span>      (*serial_out)(<span class="keyword">struct</span> uart_port *, <span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span>      (*set_termios)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">                        <span class="keyword">struct</span> ktermios *new,</span><br><span class="line">                        <span class="keyword">struct</span> ktermios *old);</span><br><span class="line">    <span class="type">void</span>      (*set_ldisc)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">                <span class="keyword">struct</span> ktermios *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span>    <span class="params">(*get_mctrl)</span><span class="params">(<span class="keyword">struct</span> uart_port *)</span>;</span><br><span class="line">    <span class="type">void</span>      (*set_mctrl)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span>    <span class="params">(*get_divisor)</span><span class="params">(<span class="keyword">struct</span> uart_port *,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">int</span> baud,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">int</span> *frac)</span>;</span><br><span class="line">    <span class="type">void</span>      (*set_divisor)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">int</span> baud,</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">int</span> quot,</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">int</span> quot_frac);</span><br><span class="line">    <span class="type">int</span>     (*startup)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">    <span class="type">void</span>      (*shutdown)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">    <span class="type">void</span>      (*throttle)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">    <span class="type">void</span>      (*unthrottle)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">    <span class="type">int</span>     (*handle_irq)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">    <span class="type">void</span>      (*pm)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span> state,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> old);</span><br><span class="line">    <span class="type">void</span>      (*handle_break)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">    <span class="type">int</span>     (*rs485_config)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">            <span class="keyword">struct</span> serial_rs485 *rs485);</span><br><span class="line">    <span class="type">int</span>     (*iso7816_config)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">                <span class="keyword">struct</span> serial_iso7816 *iso7816);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    irq;      <span class="comment">/* irq number */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   irqflags;   <span class="comment">/* irq flags  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    uartclk;    <span class="comment">/* base uart clock */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    fifosize;   <span class="comment">/* tx fifo size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   x_char;     <span class="comment">/* xon/xoff char */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   regshift;   <span class="comment">/* reg offset shift */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   iotype;     <span class="comment">/* io access style */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   quirks;     <span class="comment">/* internal quirks */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    read_status_mask; <span class="comment">/* driver specific */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    ignore_status_mask; <span class="comment">/* driver specific */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span>;</span>     <span class="comment">/* pointer to parent state */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_icount</span>  <span class="title">icount</span>;</span>     <span class="comment">/* statistics */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">console</span>    *<span class="title">cons</span>;</span>      <span class="comment">/* struct console, if any */</span></span><br><span class="line">    <span class="type">upf_t</span>     flags;</span><br><span class="line">    <span class="type">upstat_t</span>    status; </span><br><span class="line">    <span class="type">int</span>     hw_stopped;   <span class="comment">/* sw-assisted CTS flow state */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    mctrl;      <span class="comment">/* current modem ctrl settings */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    timeout;    <span class="comment">/* character-based timeout */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    type;     <span class="comment">/* port type */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    custom_divisor;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    line;     <span class="comment">/* port index */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    minor;</span><br><span class="line">    <span class="type">resource_size_t</span>   mapbase;    <span class="comment">/* for ioremap */</span></span><br><span class="line">    <span class="type">resource_size_t</span>   mapsize;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>   *<span class="title">dev</span>;</span>     <span class="comment">/* parent device */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   hub6;     <span class="comment">/* this should be in the 8250 driver */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   suspended;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   unused[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>    *name;      <span class="comment">/* port name */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>  *<span class="title">attr_group</span>;</span>    <span class="comment">/* port specific attributes */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">tty_groups</span>;</span>  <span class="comment">/* all attributes (serial core use only) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">serial_rs485</span>     <span class="title">rs485</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">serial_iso7816</span> <span class="title">iso7816</span>;</span>                                                         <span class="type">void</span>      *private_data;    <span class="comment">/* generic platform data pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>uart_port对应一个串口设备，用于描述串口端口的I/O端口或I/O内存地址、FIFO大小、端口类型、串口时钟等信息，需要实现串口相关操作方法的 uart_ops 结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> &#123;</span></span><br><span class="line">    unsignedint(*tx_empty)(<span class="keyword">struct</span> uart_port *); <span class="comment">/* 串口的Tx FIFO缓存是否为空 */</span></span><br><span class="line">    <span class="type">void</span>(*set_mctrl)(<span class="keyword">struct</span> uart_port *,unsignedint mctrl); <span class="comment">/* 设置串口modem控制 */</span></span><br><span class="line">    unsignedint(*get_mctrl)(<span class="keyword">struct</span> uart_port *);    <span class="comment">/* 获取串口modem控制 */</span></span><br><span class="line">    <span class="type">void</span>(*stop_tx)(<span class="keyword">struct</span> uart_port *); <span class="comment">/* 禁止串口发送数据 */</span></span><br><span class="line">    <span class="type">void</span>(*start_tx)(<span class="keyword">struct</span> uart_port *);    <span class="comment">/* 使能串口发送数据 */</span></span><br><span class="line">    <span class="type">void</span>(*send_xchar)(<span class="keyword">struct</span> uart_port *,<span class="type">char</span> ch);  <span class="comment">/* 发送xChar */</span></span><br><span class="line">    <span class="type">void</span>(*stop_rx)(<span class="keyword">struct</span> uart_port *); <span class="comment">/* 禁止串口接收数据 */</span></span><br><span class="line">    <span class="type">void</span>(*enable_ms)(<span class="keyword">struct</span> uart_port *);   <span class="comment">/* 使能modem的状态信号 */</span></span><br><span class="line">    <span class="type">void</span>(*break_ctl)(<span class="keyword">struct</span> uart_port *,<span class="type">int</span> ctl);   <span class="comment">/* 设置break信号 */</span></span><br><span class="line">    <span class="type">int</span>(*startup)(<span class="keyword">struct</span> uart_port *);  <span class="comment">/* 启动串口,应用程序打开串口设备文件时,该函数会被调用 */</span></span><br><span class="line">    <span class="type">void</span>(*shutdown)(<span class="keyword">struct</span> uart_port *);    <span class="comment">/* 关闭串口,应用程序关闭串口设备文件时,该函数会被调用 */</span></span><br><span class="line">    <span class="type">void</span>(*set_termios)(<span class="keyword">struct</span> uart_port *,<span class="keyword">struct</span> ktermios *new,<span class="keyword">struct</span> ktermios *old);   <span class="comment">/* 设置串口参数 */</span></span><br><span class="line">    <span class="type">void</span>(*pm)(<span class="keyword">struct</span> uart_port *,unsignedint state,</span><br><span class="line">    unsignedint oldstate);  <span class="comment">/* 串口电源管理 */</span></span><br><span class="line">    <span class="type">int</span>(*set_wake)(<span class="keyword">struct</span> uart_port *,unsignedint state);   <span class="comment">/* */</span></span><br><span class="line">    constchar*(*type)(<span class="keyword">struct</span> uart_port *);  <span class="comment">/* 返回一描述串口类型的字符串 */</span></span><br><span class="line">    <span class="type">void</span>(*release_port)(<span class="keyword">struct</span> uart_port *);    <span class="comment">/* 释放串口已申请的IO端口/IO内存资源,必要时还需iounmap */</span></span><br><span class="line">    <span class="type">int</span>(*request_port)(<span class="keyword">struct</span> uart_port *); <span class="comment">/* 申请必要的IO端口/IO内存资源,必要时还可以重新映射串口端口 */</span></span><br><span class="line">    <span class="type">void</span>(*config_port)(<span class="keyword">struct</span> uart_port *,<span class="type">int</span>); <span class="comment">/* 执行串口所需的自动配置 */</span></span><br><span class="line">    <span class="type">int</span>(*verify_port)(<span class="keyword">struct</span> uart_port *,<span class="keyword">struct</span> serial_struct *);   <span class="comment">/* 核实新串口的信息 */</span></span><br><span class="line">    <span class="type">int</span>(*ioctl)(<span class="keyword">struct</span> uart_port *,unsignedint,unsignedlong);   <span class="comment">/* IO控制 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="uart-driver注册"><a href="#uart-driver注册" class="headerlink" title="uart_driver注册"></a>uart_driver注册</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> <span class="title">s3c24xx_uart_drv</span> =</span> &#123;</span><br><span class="line">    .owner      = THIS_MODULE,</span><br><span class="line">    .driver_name    = <span class="string">&quot;s3c2410_serial&quot;</span>,</span><br><span class="line">    .nr     = CONFIG_SERIAL_SAMSUNG_UARTS,</span><br><span class="line">    .cons       = S3C24XX_SERIAL_CONSOLE,</span><br><span class="line">    .dev_name   = S3C24XX_SERIAL_NAME,</span><br><span class="line">    .major      = S3C24XX_SERIAL_MAJOR,</span><br><span class="line">    .minor      = S3C24XX_SERIAL_MINOR,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c24xx_uart_port</span></span></span><br><span class="line"><span class="class"><span class="title">s3c24xx_serial_ports</span>[<span class="title">CONFIG_SERIAL_SAMSUNG_UARTS</span>] =</span> &#123;</span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .port = &#123;</span><br><span class="line">            .lock       = __PORT_LOCK_UNLOCKED(<span class="number">0</span>),</span><br><span class="line">            .iotype     = UPIO_MEM,</span><br><span class="line">            .uartclk    = <span class="number">0</span>,</span><br><span class="line">            .fifosize   = <span class="number">16</span>,</span><br><span class="line">            .ops        = &amp;s3c24xx_serial_ops,</span><br><span class="line">            .flags      = UPF_BOOT_AUTOCONF,</span><br><span class="line">            .line       = <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .port = &#123;</span><br><span class="line">            .lock       = __PORT_LOCK_UNLOCKED(<span class="number">1</span>),</span><br><span class="line">            .iotype     = UPIO_MEM,</span><br><span class="line">            .uartclk    = <span class="number">0</span>,</span><br><span class="line">            .fifosize   = <span class="number">16</span>,</span><br><span class="line">            .ops        = &amp;s3c24xx_serial_ops,</span><br><span class="line">            .flags      = UPF_BOOT_AUTOCONF,</span><br><span class="line">            .line       = <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_serial_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c24xx_uart_port</span> *<span class="title">ourport</span>;</span></span><br><span class="line">    <span class="type">int</span> index = probe_index;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ourport = &amp;s3c24xx_serial_ports[index];</span><br><span class="line"></span><br><span class="line">    ourport-&gt;drv_data = s3c24xx_get_driver_data(pdev);</span><br><span class="line"></span><br><span class="line">    ourport-&gt;baudclk = ERR_PTR(-EINVAL);</span><br><span class="line">    ourport-&gt;info = ourport-&gt;drv_data-&gt;info;</span><br><span class="line">    ourport-&gt;cfg = (dev_get_platdata(&amp;pdev-&gt;dev)) ?</span><br><span class="line">            dev_get_platdata(&amp;pdev-&gt;dev) :</span><br><span class="line">            ourport-&gt;drv_data-&gt;def_cfg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ourport-&gt;drv_data-&gt;fifosize[index])</span><br><span class="line">        ourport-&gt;port.fifosize = ourport-&gt;drv_data-&gt;fifosize[index];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ourport-&gt;info-&gt;fifosize)</span><br><span class="line">        ourport-&gt;port.fifosize = ourport-&gt;info-&gt;fifosize;</span><br><span class="line"></span><br><span class="line">    ourport-&gt;min_dma_size = <span class="type">max_t</span>(<span class="type">int</span>, ourport-&gt;port.fifosize,</span><br><span class="line">                    dma_get_cache_alignment());</span><br><span class="line"></span><br><span class="line">    ret = s3c24xx_serial_init_port(ourport, pdev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s3c24xx_uart_drv.state) &#123;</span><br><span class="line">        ret = uart_register_driver(&amp;s3c24xx_uart_drv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将 uart_port 注册到 uart_driver */</span></span><br><span class="line">    uart_add_one_port(&amp;s3c24xx_uart_drv, &amp;ourport-&gt;port);</span><br><span class="line">    platform_set_drvdata(pdev, &amp;ourport-&gt;port);</span><br><span class="line"></span><br><span class="line">    clk_disable_unprepare(ourport-&gt;clk);</span><br><span class="line"></span><br><span class="line">    ret = s3c24xx_serial_cpufreq_register(ourport);</span><br><span class="line"></span><br><span class="line">    probe_index++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">samsung_serial_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = s3c24xx_serial_probe,</span><br><span class="line">    .remove     = s3c24xx_serial_remove,</span><br><span class="line">    .id_table   = s3c24xx_serial_driver_ids,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;samsung-uart&quot;</span>,</span><br><span class="line">        .pm = SERIAL_SAMSUNG_PM_OPS,</span><br><span class="line">        .of_match_table = of_match_ptr(s3c24xx_uart_dt_match),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_platform_driver(samsung_serial_driver);</span><br></pre></td></tr></table></figure>

<p>先实例化一个 uart_driver 结构体，再调用 <a href="#uart_register_driver()">uart_register_driver()</a>函数注册到内核。通过 <a href="#uart_add_one_port()">uart_add_one_port()</a>函数向该驱动添加uart_port。</p>
<h3 id="uart-register-driver"><a href="#uart-register-driver" class="headerlink" title="uart_register_driver()"></a>uart_register_driver()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_port_operations</span> <span class="title">uart_port_ops</span> =</span> &#123;</span><br><span class="line">    .carrier_raised = uart_carrier_raised,</span><br><span class="line">    .dtr_rts    = uart_dtr_rts,</span><br><span class="line">    .activate   = uart_port_activate,</span><br><span class="line">    .shutdown   = uart_tty_port_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_register_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">normal</span>;</span> </span><br><span class="line">    <span class="type">int</span> i, retval; </span><br><span class="line"></span><br><span class="line">    BUG_ON(drv-&gt;state); </span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Maybe we should be using a slab cache for this, especially if</span></span><br><span class="line"><span class="comment">    * we have a large number of ports to handle.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    drv-&gt;state = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> uart_state) * drv-&gt;nr, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!drv-&gt;state)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">        </span><br><span class="line">    normal = alloc_tty_driver(drv-&gt;nr);</span><br><span class="line">    <span class="keyword">if</span> (!normal)</span><br><span class="line">        <span class="keyword">goto</span> out_kfree;</span><br><span class="line">        </span><br><span class="line">    drv-&gt;tty_driver = normal;</span><br><span class="line">        </span><br><span class="line">    normal-&gt;driver_name = drv-&gt;driver_name;</span><br><span class="line">    normal-&gt;name    = drv-&gt;dev_name;</span><br><span class="line">    normal-&gt;major   = drv-&gt;major;</span><br><span class="line">    normal-&gt;minor_start = drv-&gt;minor;</span><br><span class="line">    normal-&gt;type    = TTY_DRIVER_TYPE_SERIAL;</span><br><span class="line">    normal-&gt;subtype   = SERIAL_TYPE_NORMAL;</span><br><span class="line">    normal-&gt;init_termios  = tty_std_termios;</span><br><span class="line">    normal-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;</span><br><span class="line">    normal-&gt;init_termios.c_ispeed = normal-&gt;init_termios.c_ospeed = <span class="number">9600</span>;</span><br><span class="line">    normal-&gt;flags   = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;</span><br><span class="line">    normal-&gt;driver_state    = drv;</span><br><span class="line">    tty_set_operations(normal, &amp;uart_ops);  <span class="comment">//将tty_driver的操作集设为uart_ops</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; drv-&gt;nr; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span> =</span> drv-&gt;state + i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span> =</span> &amp;state-&gt;port;</span><br><span class="line">        </span><br><span class="line">        tty_port_init(port);</span><br><span class="line">        port-&gt;ops = &amp;uart_port_ops;</span><br><span class="line">        port-&gt;close_delay     = HZ / <span class="number">2</span>; <span class="comment">/* .5 seconds */</span></span><br><span class="line">        port-&gt;closing_wait    = <span class="number">30</span> * HZ;<span class="comment">/* 30 seconds */</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    retval = tty_register_driver(normal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配一个 tty_driver，对 tty_driver 进行设置，其中包括默认波特率、校验方式等，然后调用<a href="#tty_register_driver()">tty_register_driver()</a>函数注册 tty_driver。根据 uart_driver-&gt;nr 来申请 nr 个 uart_state 空间，用来存放驱动所支持的串口端口的物理信息，每一个 uart_state 都有一个 uart_port。</p>
<h3 id="uart-add-one-port"><a href="#uart-add-one-port" class="headerlink" title="uart_add_one_port()"></a>uart_add_one_port()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uart_add_one_port</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv, <span class="keyword">struct</span> uart_port *uport)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">tty_dev</span>;</span></span><br><span class="line">    <span class="type">int</span> num_groups;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uport-&gt;line &gt;= drv-&gt;nr)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    state = drv-&gt;state + uport-&gt;line;</span><br><span class="line">    port = &amp;state-&gt;port;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;port_mutex);</span><br><span class="line">    mutex_lock(&amp;port-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_set</span>(&amp;state-&gt;refcount, <span class="number">1</span>);</span><br><span class="line">    init_waitqueue_head(&amp;state-&gt;remove_wait);</span><br><span class="line">    state-&gt;uart_port = uport;</span><br><span class="line">    uport-&gt;state = state;</span><br><span class="line"></span><br><span class="line">    state-&gt;pm_state = UART_PM_STATE_UNDEFINED;</span><br><span class="line">    uport-&gt;cons = drv-&gt;cons;</span><br><span class="line">    uport-&gt;minor = drv-&gt;tty_driver-&gt;minor_start + uport-&gt;line;</span><br><span class="line">    uport-&gt;name = kasprintf(GFP_KERNEL, <span class="string">&quot;%s%d&quot;</span>, drv-&gt;dev_name,</span><br><span class="line">                drv-&gt;tty_driver-&gt;name_base + uport-&gt;line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(uart_console(uport) &amp;&amp; (uport-&gt;cons-&gt;flags &amp; CON_ENABLED))) &#123;</span><br><span class="line">        spin_lock_init(&amp;uport-&gt;lock);</span><br><span class="line">        lockdep_set_class(&amp;uport-&gt;lock, &amp;port_lock_key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (uport-&gt;cons &amp;&amp; uport-&gt;dev)</span><br><span class="line">        of_console_check(uport-&gt;dev-&gt;of_node, uport-&gt;cons-&gt;name, uport-&gt;line);</span><br><span class="line"></span><br><span class="line">    uart_configure_port(drv, state, uport);</span><br><span class="line"></span><br><span class="line">    port-&gt;console = uart_console(uport);</span><br><span class="line"></span><br><span class="line">    num_groups = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (uport-&gt;attr_group)</span><br><span class="line">        num_groups++;</span><br><span class="line"></span><br><span class="line">    uport-&gt;tty_groups = kcalloc(num_groups, <span class="keyword">sizeof</span>(*uport-&gt;tty_groups),</span><br><span class="line">                    GFP_KERNEL);</span><br><span class="line">    uport-&gt;tty_groups[<span class="number">0</span>] = &amp;tty_dev_attr_group;</span><br><span class="line">    <span class="keyword">if</span> (uport-&gt;attr_group)</span><br><span class="line">        uport-&gt;tty_groups[<span class="number">1</span>] = uport-&gt;attr_group;</span><br><span class="line"></span><br><span class="line">    tty_dev = tty_port_register_device_attr_serdev(port, drv-&gt;tty_driver,</span><br><span class="line">            uport-&gt;line, uport-&gt;dev, port, uport-&gt;tty_groups);</span><br><span class="line"></span><br><span class="line">    uport-&gt;flags &amp;= ~UPF_DEAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>將 uart_prot 关联到 uart_driver 对应的 state。</p>
<h2 id="线路规程"><a href="#线路规程" class="headerlink" title="线路规程"></a>线路规程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc_ops</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> magic;</span><br><span class="line">    <span class="type">char</span>    *name;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> tty_struct *);</span><br><span class="line">    <span class="type">void</span>    (*close)(<span class="keyword">struct</span> tty_struct *);</span><br><span class="line">    <span class="type">void</span>    (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">ssize_t</span> (*read)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *file,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> nr);</span><br><span class="line">    <span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *file,</span><br><span class="line">             <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">size_t</span> nr);</span><br><span class="line">    <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *file,</span><br><span class="line">             <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">int</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *file,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span>    (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios *old);</span><br><span class="line">    <span class="type">__poll_t</span> (*poll)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> file *,</span><br><span class="line">                 <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">    <span class="type">int</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span>    (*receive_buf)(<span class="keyword">struct</span> tty_struct *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *cp,</span><br><span class="line">                   <span class="type">char</span> *fp, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">void</span>    (*write_wakeup)(<span class="keyword">struct</span> tty_struct *);</span><br><span class="line">    <span class="type">void</span>    (*dcd_change)(<span class="keyword">struct</span> tty_struct *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*receive_buf2)(<span class="keyword">struct</span> tty_struct *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *cp,</span><br><span class="line">                <span class="type">char</span> *fp, <span class="type">int</span> count);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ldisc注册"><a href="#ldisc注册" class="headerlink" title="ldisc注册"></a>ldisc注册</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc_ops</span> <span class="title">n_tty_ops</span> =</span> &#123;</span><br><span class="line">    .magic           = TTY_LDISC_MAGIC,</span><br><span class="line">    .name            = <span class="string">&quot;n_tty&quot;</span>,</span><br><span class="line">    .open            = n_tty_open,</span><br><span class="line">    .close           = n_tty_close,</span><br><span class="line">    .flush_buffer    = n_tty_flush_buffer,</span><br><span class="line">    .read            = n_tty_read,</span><br><span class="line">    .write           = n_tty_write,</span><br><span class="line">    .ioctl           = n_tty_ioctl,</span><br><span class="line">    .set_termios     = n_tty_set_termios,</span><br><span class="line">    .poll            = n_tty_poll,</span><br><span class="line">    .receive_buf     = n_tty_receive_buf,</span><br><span class="line">    .write_wakeup    = n_tty_write_wakeup,</span><br><span class="line">    .receive_buf2    = n_tty_receive_buf2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">n_tty_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    tty_register_ldisc(N_TTY, &amp;n_tty_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现代码在n_tty.c中，调用<a href="#tty_register_ldisc()">tty_register_ldisc()</a>函数，注册线路规程的操作函数集。</p>
<h3 id="tty-register-ldis"><a href="#tty-register-ldis" class="headerlink" title="tty_register_ldis()"></a>tty_register_ldis()</h3><h3 id="tty-ldisc-reinit"><a href="#tty-ldisc-reinit" class="headerlink" title="tty_ldisc_reinit()"></a>tty_ldisc_reinit()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_ldisc_reinit</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> disc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ld</span>;</span></span><br><span class="line"></span><br><span class="line">    ld = tty_ldisc_get(tty, disc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tty-&gt;ldisc) &#123;</span><br><span class="line">        tty_ldisc_close(tty, tty-&gt;ldisc);</span><br><span class="line">        tty_ldisc_put(tty-&gt;ldisc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tty-&gt;ldisc = ld;</span><br><span class="line">    tty_set_termios_ldisc(tty, disc);</span><br><span class="line">    retval = tty_ldisc_open(tty, tty-&gt;ldisc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置tty的线路规程，调用 <a href="#tty_ldisc_open()">tty_ldisc_open()</a> 函数打开一个线路规程。</p>
<h3 id="tty-ldisc-get"><a href="#tty-ldisc-get" class="headerlink" title="tty_ldisc_get()"></a>tty_ldisc_get()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tty_ldisc *<span class="title function_">tty_ldisc_get</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> disc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ld</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc_ops</span> *<span class="title">ldops</span>;</span></span><br><span class="line"></span><br><span class="line">    ldops = get_ldops(disc);</span><br><span class="line"></span><br><span class="line">    ld = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tty_ldisc), GFP_KERNEL | __GFP_NOFAIL);</span><br><span class="line">    ld-&gt;ops = ldops;</span><br><span class="line">    ld-&gt;tty = tty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ld;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tty-ldisc-open"><a href="#tty-ldisc-open" class="headerlink" title="tty_ldisc_open()"></a>tty_ldisc_open()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tty_ldisc_open</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> tty_ldisc *ld)</span></span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &amp;tty-&gt;flags));</span><br><span class="line">    <span class="keyword">if</span> (ld-&gt;ops-&gt;open) &#123;</span><br><span class="line">        ret = ld-&gt;ops-&gt;open(tty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="microcom"><a href="#microcom" class="headerlink" title="microcom"></a>microcom</h2><p>microcom工具可以用来调度串口，它会将stdin的字节复制到TTY，并从TTY复制到stdout。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">microcom [-d DELAY] [-t TIMEOUT] [-s SPEED] [-X] TTY</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -d      Wait up to DELAY ms for TTY output before sending every</span><br><span class="line">            next byte to it</span><br><span class="line">    -t      Exit if both stdin and TTY are silent for TIMEOUT ms</span><br><span class="line">    -s      Set serial line to SPEED</span><br><span class="line">    -X      Disable special meaning of NUL and Ctrl-X from stdin</span><br></pre></td></tr></table></figure>

<p>如果想回显输入的字符，可以使用以下命令：</p>
<blockquote>
<p>tee /dev/stderr | microcom /dev/ttyS1</p>
</blockquote>
<hr>
<p><a href="https://blog.csdn.net/lizuobin2/article/details/51773305">https://blog.csdn.net/lizuobin2/article/details/51773305</a></p>
<p><a href="https://www.bbsmax.com/R/obzbBZNBzE/">https://www.bbsmax.com/R/obzbBZNBzE/</a></p>
<p><a href="https://www.shuzhiduo.com/A/ZOJP4pxOJv/">https://www.shuzhiduo.com/A/ZOJP4pxOJv/</a></p>
]]></content>
      <categories>
        <category>device</category>
      </categories>
      <tags>
        <tag>uart</tag>
        <tag>device</tag>
      </tags>
  </entry>
  <entry>
    <title>waitqueue</title>
    <url>/2022/06/07/kernel/waitqueue/</url>
    <content><![CDATA[<p>阻塞操作是指在执行设备操作时，若不能获得资源，则挂起的进程进入休眠状态，直到等待的条件被满足，而非阻塞操作是直接返回，并不挂起。</p>
<p>等待队列用来同步对系统资源的访问，可实现进程阻塞。</p>
<h2 id="waitqueue"><a href="#waitqueue" class="headerlink" title="waitqueue"></a>waitqueue</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">void</span> *private;</span><br><span class="line">    <span class="type">wait_queue_func_t</span> func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>定义等待队列头</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init_waitqueue_head(&amp;<span class="built_in">queue</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAIT_QUEUE_HEAD(name) \</span></span><br><span class="line"><span class="meta">    wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)</span></span><br></pre></td></tr></table></figure>

<p><strong>定义等待队列</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAITQUEUE(name, tsk)                    \</span></span><br><span class="line"><span class="meta">    wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)</span></span><br></pre></td></tr></table></figure>

<p><strong>添加/移除等待队列到等待队列头</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> fastcall <span class="title function_">add_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span> *wait)</span>;</span><br><span class="line"><span class="type">void</span> fastcall <span class="title function_">remove_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span> *wait)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>等待事件</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*有条件等待*/</span></span><br><span class="line">wait_event(<span class="built_in">queue</span>, condition)</span><br><span class="line">wait_event_interruptible(<span class="built_in">queue</span>, condition)</span><br><span class="line">wait_event_timeout(<span class="built_in">queue</span>, condition, timeout)</span><br><span class="line">wait_event_interruptible_timeout(<span class="built_in">queue</span>, condition, timeout)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*无条件等待 */</span></span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">sleep_on</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span>;</span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">interruptible_sleep_on</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span>;</span><br></pre></td></tr></table></figure>

<p>sleep_on()函数将目前进程的状态置成 TASK_UNINTERRUPTIBLE，并定义一个等待队列，之后把它附属到等待队列头 q，直到资源可获得，q引导的等待队列被唤醒。</p>
<p>interruptible_sleep_on()将进程的状态置成TASK_INTERRUPTIBLE，能被等待队列或者信号唤醒。</p>
<p><strong>唤醒队列</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="type">wait_queue_head_t</span> *<span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up_interruptible</span><span class="params">(<span class="type">wait_queue_head_t</span> *<span class="built_in">queue</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>wake_up()应该与 wait_event()或 wait_event_timeout()成对使用，而 wake_up_interruptible()则应与 wait_event_interruptible()或 wait_event_interruptible_timeout()成对使用。</p>
<p>wake_up()可唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 的进程，而 wake_up_interruptible()只能唤醒处于 TASK_INTERRUPTIBLE 的进程。</p>
<p><strong>进程状态切换</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING        0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE    2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __set_current_state(state_value)            \</span></span><br><span class="line"><span class="meta">    do &#123; current-&gt;state = (state_value); &#125; while (0)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_current_state(state_value)      \</span></span><br><span class="line"><span class="meta">    set_mb(current-&gt;state, (state_value))</span></span><br></pre></td></tr></table></figure>

<p>内核中使用<code>set_current_state()</code>函数或<code>__add_current_state()</code>函数来实现目前进程状态的改变，直接采用<code>current-&gt;state = TASK_UNINTERRUPTIBLE</code>类似的赋值语句也行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 改变进程状态为睡眠 */</span></span><br><span class="line">__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">schedule(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) <span class="comment">//如果是被信号唤醒</span></span><br><span class="line">&#123;</span><br><span class="line">    ret = -ERESTARTSYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是非阻塞访问，设备忙时，直接返回-EAGAIN。如果是阻塞访问，需要进行状态切换，通过调用schedule()函数来调度其他进程执行。唤醒后，需通过 signal_pending(current) 判断是否是信号唤醒，如果是则返回-ERESTARTSYS。</p>
]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>buildroot</title>
    <url>/2022/09/04/fs/buildroot/</url>
    <content><![CDATA[<p>下载地址：　<a href="https://buildroot.org/">https://buildroot.org/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── arch: 存放CPU架构相关的配置脚本</span><br><span class="line">├── board</span><br><span class="line">├── boot</span><br><span class="line">├── CHANGES</span><br><span class="line">├── Config.in</span><br><span class="line">├── Config.in.legacy</span><br><span class="line">├── configs: 放置开发板的一些配置参数. </span><br><span class="line">├── COPYING</span><br><span class="line">├── DEVELOPERS</span><br><span class="line">├── dl: 存放下载的源代码及应用软件的压缩包. </span><br><span class="line">├── docs: 存放相关的参考文档. </span><br><span class="line">├── fs: 放各种文件系统的源代码. </span><br><span class="line">├── linux: 存放着Linux kernel的自动构建脚本. </span><br><span class="line">├── Makefile</span><br><span class="line">├── Makefile.legacy</span><br><span class="line">├── output: 是编译出来的输出文件夹. </span><br><span class="line">│   ├── build: 存放解压后的各种软件包编译完成后的现场.</span><br><span class="line">│   ├── host: 存放着制作好的编译工具链，如gcc、arm-linux-gcc等工具.</span><br><span class="line">│   ├── images: 存放着编译好的uboot.bin, zImage, rootfs等镜像文件，可烧写到板子里, 让linux系统跑起来.</span><br><span class="line">│   ├── staging</span><br><span class="line">│   └── target: 存放Linux系统基本的目录结构，以及编译好的应用库和bin可执行文件</span><br><span class="line">├── package：下面放着应用软件的配置文件，每个应用软件的配置文件有Config.in和soft_name.mk。</span><br><span class="line">├── README</span><br><span class="line">├── support</span><br><span class="line">├── system</span><br><span class="line">└── toolchain</span><br></pre></td></tr></table></figure>

<p> Buildroot提供了构建流程的框架。开发者按照格式写脚本，提供必要的构建细节，配置整个系统，最后自动构建出你的系统。</p>
<p> package/pkg-generic.mk中通过调用同目录下的pkg-download.mk、pkg-utils.mk文件，已经帮你自动实现了下载、解压、依赖包下载编译等一系列流程。你只要需要按照格式写Makefile脚app_pkg.mk，填充下载地址，链接依赖库的名字等一些特有的构建细节即可。</p>
<p><img src="/images/rootfs/build.png" alt="构建流程框架"></p>
<p>Buildroot代码仓库默认只包含一个编译框架，真正构建rootfs需要的各种代码包是根据配置选项，在编译的时候才开始下载的。</p>
<p>通过<code>make help</code>可以看到buildroot下make的使用细节，包括对package、uclibc、busybox、linux以及文档生成等配置。</p>
<p>执行命令<code>make list-defconfigs</code>查看buildroot中支持的开发板</p>
<p>设置 toolchain 的版本和内核头文件的内核的版本</p>
<p>System configuration-&gt;Run a getty(login prompt) after boot选项中配置 TTY Port 为 ttyAMA0。否则文件系统挂载后无法进入控制台。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><strong>Target options</strong>：目标板的配置</p>
<ul>
<li><p>Target Architecture：目标架构，这里选择 ARM(little endian)，ARM小端模式</p>
</li>
<li><p>Target Binary Format：二进制格式，为 ELF</p>
</li>
<li><p>Target Architecture Variant：架构变体为 arm920t，内核类型</p>
</li>
<li><p>Target ABI：应用程序二进制接口，为EABI</p>
</li>
<li><p>Floating point strategy：浮点数的策略，选择为 Soft float</p>
</li>
<li><p>ARM instruction set：arm 汇编指令集，选择  ARM</p>
</li>
<li><p><strong>Build　options</strong></p>
</li>
</ul>
<p>主要是一些编译时用到的选项，比如dl的路径，下载代码包使用的路径，同时运行多个编译的上限，是否使能编译器缓冲区等。</p>
<p><strong>Toolchain</strong>：工具链选项</p>
<ul>
<li>Toolchain type：Buildroot提供两种方式使用toolchain<ul>
<li>external toolthain：非Buildroot提供的交叉编译器</li>
<li>Buildroot toolchain：Buildroot本身编译生成的Buildroot toolchain</li>
</ul>
</li>
<li>custom toolchain vendor name：填上S3C2440</li>
<li>C library：C库选择，选择 glibc</li>
<li>Kernel Headers：内核头文件，Linux 4.9.x kernel headers</li>
<li>glibc version：glibc版本选择，2.24</li>
<li>Binutils Version：binutils版本：2.27</li>
<li>Additional binutils options：附加的 binutils 选择，不填即可</li>
<li>GCC compiler Version：GCC版本选择，gcc 6.x</li>
<li>Additional gcc options：附件的GCC选项</li>
<li>Enable C++ support：使能C++支持，选上</li>
<li>Enable Fortran support：使能Fortran语言支持，不选</li>
<li>Enable compiler link-time-optimization support：是否支持LTO，不选</li>
<li>Enable compiler OpenMP support：是否支持OpenMP，OpenMP用于共享内存并行系统的多处理器程序设计，<br>不适合需要复杂的线程间同步和互斥的场合，OpenMp的另一个缺点是不能在非共享内存系统如计算机集群上使用。不选择</li>
<li>Enable graphite support ：是否支持graphite。Graphite是应用WEB应用的一套开源的编程接口。不选择。</li>
<li>Build cross gdb for the host：主机上运行gdb进行调试，不选</li>
<li>Copy gconv libraries：拷贝 gconv库，gconv库用于在不同字符集之间进行转换。默认不选</li>
<li>Enable MMU support：使能 MMU，S3C2440支持MMU，选上</li>
<li>Target Optimizations：不选</li>
<li>Target linker options：不选</li>
<li>Register toolchain within Eclipse Buildroot plug-in：eclipse插件支持，不选</li>
</ul>
<p><strong>System configuration</strong>：系统配置</p>
<ul>
<li>Root FS skeleton：</li>
<li>System hostname：填写JZ2440</li>
<li>System banner</li>
<li>Passwords encoding</li>
<li>Init system：系统初始化，选择 BusyBox</li>
<li>/dev management：设备文件管理，选择Dynamic using devtmpfs + mdev，即使用mdev动态加载设备节点的方式</li>
<li>Path to the permission tables：设备节点的配置表设置，一定要选择system/device_table_dev.txt，否则后面在dev目录下将不会生成各种设备节点。当然我们也可以手动的配置该文件，添加必要的节点或删除不需要的节点。</li>
<li>support extended attributes in device tables</li>
<li>Use symlinks to /usr for /bin, /sbin and /lib</li>
<li>Enable root login with password</li>
<li>Root password：进入linux控制台终端后的密码，为空则登录时不需要密码，默认登录用户名为root。</li>
<li>/bin/sh (busybox’ default shell)</li>
<li>Run a getty (login prompt) after boot：保持默认，默认为选中。<ul>
<li>TTY port：控制台打印串口</li>
<li>Baudrate ：波特率，配置为 115200</li>
<li>TERM environment variable：默认即可</li>
<li>other options to pass to getty：默认即可</li>
</ul>
</li>
<li>remount root filesystem read-write during boot</li>
<li>Network interface to configure through DHCP</li>
<li>Purge unwanted locales</li>
<li>Locales to keep</li>
<li>Generate locale data</li>
<li>Install timezone info</li>
<li>Path to the users tables</li>
<li>Root filesystem overlay directories：</li>
<li>Custom scripts to run before creating filesystem images</li>
<li>Custom scripts to run inside the fakeroot environment</li>
<li>Custom scripts to run after creating filesystem images</li>
</ul>
<p><strong>Kernel</strong>：内核配置</p>
<ul>
<li><p>Kernel version：内核版本，选择用户自定义Custom version</p>
</li>
<li><p>Kernel version：填上自己所需要的版本，4.14.12</p>
</li>
<li><p>Custom kernel patches：自定义的内核补丁</p>
</li>
<li><p>Kernel configuration：内核配置，选择 Using an in-tree defconfig file</p>
</li>
<li><p>Defconfig name：填写为 mini2440</p>
</li>
<li><p>Additional configuration fragment files：暂且不填写</p>
</li>
<li><p>Kernel binary format：内核二进制文件格式，zImage</p>
</li>
<li><p>Kernel compression format：内核压缩格式，选择gzip</p>
</li>
<li><p>Build a Device Tree Blob：设备树？暂且不填写</p>
</li>
<li><p>Install kernel image to /boot in target：暂且不填</p>
</li>
<li><p>Linux Kernel Extensions：内核扩展，默认不选择</p>
</li>
<li><p>Linux Kernel Tools：内核工具，默认不选择</p>
</li>
<li><p><strong>Target packages</strong></p>
</li>
<li><p>Filesystem images：文件系统选择，选择 yaffs2 root filesystem</p>
</li>
<li><p><strong>Bootloaders</strong></p>
</li>
<li><p>Build system：u-boot系统选择为Kconfig</p>
<ul>
<li>legacy：若是选择2015.04之前的u-boot 选择此项</li>
<li>Kconfig：2015.04之后的 u-boot 选择此项，勾选此项　　</li>
</ul>
</li>
<li><p>U-boot Version：U-boot版本，默认为 2017.01，选择为Custom version</p>
</li>
<li><p>U-Boot version：填写为2017.11</p>
</li>
<li><p>Custom U-boot patches：U-boot补丁，不添加</p>
</li>
<li><p>U-Boot configuration：U-boot配置，暂时还没有U-BOOT，所以选择为：Using an in-tree board defconfig file</p>
</li>
<li><p>Board defconfig：板子的配置，选择与架构一样的板子的默认文件，mini2440。后期再修改</p>
</li>
<li><p>U-boot needs dtc：是否需要设备树，默认，后期调试</p>
</li>
<li><p>U-boot needs OpenSSL：是否需要 OpenSSL，默认，后期调试修改</p>
</li>
<li><p>U-boot binary format：二进制文件，选择 .bin文件</p>
</li>
<li><p>produce a .ift signed image：默认</p>
</li>
<li><p>Install U-boot SPL binary image：默认</p>
</li>
<li><p>Environment image：默认</p>
</li>
<li><p><strong>Host utilities</strong></p>
</li>
<li><p><strong>Legacy config options</strong></p>
</li>
</ul>
<h2 id="编译性能"><a href="#编译性能" class="headerlink" title="编译性能"></a>编译性能</h2><p>buildroot还提供了一些命令，用于分析buildroot编译过程中耗时、依赖关系、文件系统尺寸等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Documentation:</span><br><span class="line">  manual               　 * build manual in all formats</span><br><span class="line">  manual-html          　 * build manual in HTML</span><br><span class="line">  manual-split-html      * build manual in split HTML</span><br><span class="line">  manual-pdf             * build manual in PDF</span><br><span class="line">  manual-text            * build manual in text</span><br><span class="line">  manual-epub            * build manual in ePub</span><br><span class="line">  graph-build            * generate graphs of the build times</span><br><span class="line">  graph-depends          * generate graph of the dependency tree</span><br><span class="line">  graph-size             * generate stats of the filesystem size</span><br><span class="line">  list-defconfigs        * list all defconfigs (pre-configured minimal systems)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>rootfs</category>
      </categories>
  </entry>
  <entry>
    <title>watchdog device</title>
    <url>/2022/09/04/kernel/watchdog/</url>
    <content><![CDATA[<ul>
<li>watchdog_dev.c</li>
<li>watchdog_core.c</li>
<li>wdt.c</li>
</ul>
<p>内核配置<code>CONFIG_WATCHDOG_NOWAYOUT</code>选项表示看门狗一旦开启就无法被停止，可设置nowayout模块参数。</p>
<p>如果驱动支持”Magic Close”，除非在关闭看门狗前，魔幻字符’V’发送到/dev/watchdog，否则不能停止看门狗。</p>
]]></content>
      <categories>
        <category>device</category>
      </categories>
  </entry>
  <entry>
    <title>BusyBox</title>
    <url>/2022/09/04/fs/busybox/</url>
    <content><![CDATA[<p><a href="https://busybox.net/downloads/">下载地址</a></p>
<p><a href="https://salsa.debian.org/installer-team/busybox">https://salsa.debian.org/installer-team/busybox</a></p>
<p>修改顶层Makefile，修改交叉编译器和芯片平台：</p>
<blockquote>
<p>CROSS_COMPILE=arm-none-linux-gnueabi- ARCH=arm</p>
</blockquote>
<p><code>make defconfig</code>，busybox提供了3种配置：defconfig (缺省配置)、allyesconfig（最大配置）、 allnoconfig（最小配置）。</p>
<p><code>make menuconfig</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Busybox Settings  ---&gt;</span><br><span class="line">    Build Options  ---&gt;</span><br><span class="line">        [*]Build shared libbusybox</span><br><span class="line">        [ ] Build BusyBox as a static binary (no shared libs) (NEW)</span><br><span class="line"></span><br><span class="line">    (arm-anykav200-linux-uclibcgnueabi-) Cross compiler prefix 　//设置编译器</span><br><span class="line">        </span><br><span class="line">    Installation Options (&quot;make install&quot; behavior)  ---&gt;</span><br><span class="line">        (../rootfs) Destination path for &#x27;make install&#x27;   // 设置编译生成文件的存放路径</span><br><span class="line">        What kind of applet links to install (as soft-links)  ---&gt;　//设置生成后的命令是指向busybox的软链接</span><br><span class="line">  </span><br><span class="line">  Busybox Library Tuning  ---&gt;</span><br><span class="line">      (255) History size </span><br><span class="line">      [*]   History saving (NEW)   // 支持历史记录</span><br><span class="line">      [*]   Tab completion (NEW)   // 支持Tab补全操作</span><br></pre></td></tr></table></figure>

<p><code>make; make install</code></p>
<p>添加相应的库，用<code>readelf -d busybox</code>，查看依赖的库，将交叉编译环境下sysroot/lib目录下库拷贝到/lib。</p>
]]></content>
      <categories>
        <category>rootfs</category>
      </categories>
  </entry>
  <entry>
    <title>fs基础知识</title>
    <url>/2022/09/04/fs/fs/</url>
    <content><![CDATA[<p><strong>扇区</strong>(sector)硬盘的读写基本单位。通常是 512 字节，可以使用 <code>fdisk -l</code> 命令查看扇区大小。</p>
<p>扇区是磁盘物理层面的概念，操作系统是不直接与扇区交互的，而是与多个连续扇区组成的磁盘块交互。由于扇区是物理层面的概念，所以无法在系统中进行大小的更改。</p>
<p><strong>磁盘块</strong>(IO Block)文件系统读写数据的最小单位，也叫磁盘簇。扇区是磁盘最小的物理存储单元，操作系统将相邻的扇区组合在一起，形成一个块，对块进行管理。块是2的指数倍的扇区大小，但必须小于页的大小。磁盘块是操作系统所使用的逻辑概念，而非磁盘的物理概念。磁盘块的大小可以通过命令 <code>stat /boot</code> 查看，一般是 4K。</p>
<p>为了更好地管理磁盘空间和更高效地从硬盘读取数据，操作系统规定一个磁盘块中只能放置一个文件，因此文件所占用的空间，只能是磁盘块的整数倍。</p>
<p>操作系统不能对磁盘扇区直接寻址操写，主要原因是扇区数量庞大，因此才将多个连续扇区组合一起操作。磁盘块的大小是可以通过 <code>blockdev</code> 命令更改的。</p>
<p><strong>页</strong>(page)内存的最小存储单位。页的大小通常为磁盘块大小的 2^n 倍，可以通过命令 getconf PAGE_SIZE 来获取页的大小。</p>
<h2 id="super-block"><a href="#super-block" class="headerlink" title="super block"></a>super block</h2><h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>文件通过inode来访问，inode使用唯一的数值进行标识，称为inode编号。一个inode存储文件关联的元数据，如修改时间，所有者，类型，长度以及文件的数据地址。inode既是unix文件系统在磁盘上实际物理对象，也是linux内中的数据结构的概念实体。</p>
<p>目录存储文件名和inode编号的映射，内核根据文件名获取inode编号，然后根据编号找到对应的inode。</p>
<h2 id="dentry"><a href="#dentry" class="headerlink" title="dentry"></a>dentry</h2><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接允许多个路径名指向相同的数据，为了保证每个文件在所有的链接都移除之后才彻底删除文件，每个inode还包括一个链接计数来跟踪文件系统中指向该文件的硬链接数目，当路径名解除链接，计数减1，当它为0时，与inode关联的数据才真正从文件系统中删除。</p>
<p>软链接有自己的inode和包含被链接文件完整路径名的数据块，意味着可以跨文件系统创建链接。相比硬链接，因需要解析2个文件：符号链接和被链接的文件，故开销更大。</p>
<p>super block对象用于描述挂载文件系统的元信息，即文件系统控制块；inode对象就是存储一个文件的通用信息，如时间戳、所对应的数据块位置等；dentry对象存储一个文件的目录项的链接信息，也就是文件的路径名，因为一个文件可能有多个链接。以上三者都是由文件系统各自实现并以特定格式持久化存储在硬盘上的。</p>
]]></content>
      <categories>
        <category>filesystem</category>
      </categories>
      <tags>
        <tag>fs</tag>
      </tags>
  </entry>
  <entry>
    <title>rootfs of file system</title>
    <url>/2022/09/04/fs/rootfs/</url>
    <content><![CDATA[<h2 id="flash文件系统"><a href="#flash文件系统" class="headerlink" title="flash文件系统"></a>flash文件系统</h2><p>flash芯片可以被划分为多个分区，各分区可以采用不同的文件系统。flash文件系统是基于MTD驱动层的，MTD(Memory Technology Device,存储技术设备)为底层硬件(闪存)和上层(文件系统)之间提供一个统一的抽象接口，专门针对各种非易失性存储器设计，因而对Flash有更好的支持、管理和基于扇区的擦除、读/写操作接口。</p>
<h3 id="jffs"><a href="#jffs" class="headerlink" title="jffs"></a>jffs</h3><p>JFFS文件系统最早是由瑞典Axis Communications公司基于Linux2.0的内核为嵌入式系统开发的文件系统。JFFS2是RedHat公司基于JFFS开发的闪存文件系 统，最初是针对RedHat公司的嵌入式产品eCos开发的嵌入式文件系统，所以JFFS2也可以用在Linux, uCLinux中。</p>
<p>Jffs2: 日志闪存文件系统版本2 (Journalling Flash FileSystem v2)</p>
<p>主要用于NOR型闪存，基于MTD驱动层，特点是：<strong>可读写</strong>的、支持数据压缩的、基于哈希表的日志型文件系统，并提供了崩溃/掉电安全保护，提供“写平衡”支持等。缺点主要是当文件系统已满或接近满时，因为垃圾收集的关系而使jffs2的运行速度大大放慢。</p>
<p>目前jffs3正在开发中。关于jffs系列文件系统的使用详细文档，可参考MTD补丁包中mtd-jffs-HOWTO.txt。</p>
<p><em>jffsx不适合用于NAND闪存</em>主要是因为NAND闪存的容量一般较大，这样导致jffs为维护日志节点所占用的内存空间迅速增大，另 外，jffsx文件系统在挂载时需要扫描整个FLASH的内容，以找出所有的日志节点，建立文件结构，对于大容量的NAND闪存会耗费大量时间。</p>
<h4 id="mkfs-jffs2"><a href="#mkfs-jffs2" class="headerlink" title="mkfs.jffs2"></a>mkfs.jffs2</h4><p>直接安装<code>mkfs.jffs2</code>工具：sudo apt-get install mtd-utils，或编译源码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install liblzo2-2 libuuid1 zlib1g liblzo2-dev uuid-dev libacl1-dev  zlib1g-dev</span><br><span class="line">./configure --prefix=/home/luo_u/usr</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><em>使用说明</em>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./mkfs.jffs2 -v -d rootfs/ -l -s 256 -e 4096 -m none -o root.jffs2</span><br><span class="line"></span><br><span class="line">-p, --pad[=SIZE]        使用0xff填充文件系统到指定大小，不指定则只填充完最后一个擦除块</span><br><span class="line">-r, -d, --root=DIR      使用指定的目录内容构建文件系统</span><br><span class="line">-s, --pagesize=SIZE     使用指定的页大小（最大数据节点大小） (default: 4KiB)</span><br><span class="line">-e, --eraseblock=SIZE   指定擦除块的大小 (default: 64KiB)</span><br><span class="line">-c, --cleanmarker=SIZE  擦除标记的大小 (default 12)</span><br><span class="line">-m, --compr-mode=MODE   选择压缩模式(default: priortiry)</span><br><span class="line">-x, --disable-compressor=COMPRESSOR_NAME  禁用指定的压缩算法</span><br><span class="line">-X, --enable-compressor=COMPRESSOR_NAME   启用指定的压缩算法</span><br><span class="line">-y, --compressor-priority=PRIORITY:COMPRESSOR_NAME  设置压缩算法的优先级</span><br><span class="line">-L, --list-compressors  列出可用的压缩算法</span><br><span class="line">-t, --test-compression  测试压缩算法</span><br><span class="line">-n, --no-cleanmarkers   不添加擦除标记到擦除块</span><br><span class="line">-o, --output=FILE       指定输出镜像文件名称</span><br><span class="line">-l, --little-endian     创建一个小端的文件系统</span><br><span class="line">-b, --big-endian        创建一个大端的文件系统</span><br><span class="line">-q, --squash            压缩权限和设置所有文件的拥有者为root</span><br><span class="line">-U, --squash-uids       设置所有文件的拥有者为root</span><br><span class="line">-P, --squash-perms      压缩所有文件的权限</span><br><span class="line">-v  可视操作</span><br></pre></td></tr></table></figure>

<p><em>挂载分区</em>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t jffs2 /dev/mtdblock1 /mnt</span><br></pre></td></tr></table></figure>

<h3 id="yaffs"><a href="#yaffs" class="headerlink" title="yaffs"></a>yaffs</h3><p>yaffs/yaffs2(Yet Another Flash File System)是专为嵌入式系统使用NAND型闪存而设计的一种日志型文件系统。与jffs2相比，它减少了一些功能(例如不支持数 据压缩)，所以速度更快，挂载时间很短，对内存的占用较小。另外，它还是跨平台的文件系统，除了Linux和eCos，还支持WinCE, pSOS和ThreadX等。</p>
<p>yaffs/yaffs2自带NAND芯片的驱动，并且为嵌入式系统提供了直接访问文件系统的API，用户可以不使用Linux中的MTD与VFS，直接对文件系统操作。当然，yaffs也可与MTD驱动程序配合使用。</p>
<p>yaffs与yaffs2的主要区别在于，前者仅支持小页(512 Bytes) NAND闪存，后者则可支持大页(2KB) NAND闪存。同时，yaffs2在内存空间占用、垃圾回收速度、读/写速度等方面均有大幅提升。</p>
<p><a href="https://yaffs.net/documents/how-yaffs-works">https://yaffs.net/documents/how-yaffs-works</a></p>
<h3 id="cramfs"><a href="#cramfs" class="headerlink" title="cramfs"></a>cramfs</h3><p>Cramfs(Compressed ROM File System)是Linux的创始人 Linus Torvalds参与开发的一种只读的压缩文件系统。它也基于MTD驱动程序。</p>
<p>在cramfs文件系统中，每一页(4KB)被单独压缩，可以随机页访问，其压缩比高达2:1,为嵌入式系统节省大量的Flash存储空间，使系统可通过更低容量的FLASH存储相同的文件，从而降低系统成本。</p>
<p>Cramfs文件系统以压缩方式存储，在运行时解压缩，所以不支持应用程序以XIP方式运行，所有的应用程序要求被拷到RAM里去运行，但这并 不代表比Ramfs需求的RAM空间要大一点，因为Cramfs是采用分页压缩的方式存放档案，在读取档案时，不会一下子就耗用过多的内存空间，只针对目 前实际读取的部分分配内存，尚没有读取的部分不分配内存空间，当我们读取的档案不在内存时，Cramfs文件系统自动计算压缩后的资料所存的位置，再即时 解压缩到RAM中。</p>
<p>另外，它的速度快，效率高，其只读的特点有利于保护文件系统免受破坏，提高了系统的可靠性。由于以上特性，Cramfs在嵌入式系统中应用广泛。但是它的<strong>只读</strong>属性同时又是它的一大缺陷，使得用户无法对其内容对进扩充。Cramfs映像通常是放在Flash中，但是也能放在别的文件系统里，使用loopback 设备可以把它安装别的文件系统里。</p>
<p>单个文件大小不能超过16MB、文件系统大小略大于256MB（最后一个文件允许超过256MB空间范围，即文件系统总大小不超过272MB）。CramFS的gid只保存8位，mkcramfs会简单的将gid截断保留最后8位。CramFS支持硬链接，但是被硬链接的文件引用计数不会增加。CramFS文件没有时间戳，所有文件的创建/访问时间戳都是1970年1月1日 0:00:00 GMT。CramFS的镜像只支持被同样字节对齐方式的机器创建和挂载使用，页面大小只支持4KB。</p>
<h3 id="romfs"><a href="#romfs" class="headerlink" title="romfs"></a>romfs</h3><p>传统型的Romfs文件系统是一种简单的、紧凑的、只读的文件系统，不支持动态擦写保存，按顺序存放数据，因而支持应用程序以 XIP(eXecute In Place，片内运行)方式运行，在系统运行时，节省RAM空间。uClinux系统通常采用Romfs文件系统。<br>　　<br>其他文件系统：fat/fat32也可用于实际嵌入式系统的扩展存储器(例如PDA, Smartphone, 数码相机等的SD卡)，这主要是为了更好的与最流行的Windows桌面操作系统相兼容。ext2也可以作为嵌入式Linux的文件系统，不过将它用于 FLASH闪存会有诸多弊端。</p>
<h3 id="squashfs"><a href="#squashfs" class="headerlink" title="squashfs"></a>squashfs</h3><p>SquashFS [1]  是一套基于Linux内核使用的压缩<strong>只读</strong>文件系统。该文件系统能够压缩系统内的文档,inode以及目录，文件最大支持2^64字节。<br>-　Squashfs 4.2 : 最新的版本，并适用于2.6.29版本以后的Linux内核。<br>-　Squashfs 4.1 : 支持XZ压缩，并适用于2.6.29版本以后的Linux内核。<br>-　Squashfs 3.4 : 该版本是3.X的最后一个版本，并适用于2.6.29版本之前的内核。</p>
<p>安装<code>mksquashfs</code>工具：sudo apt-get install squashfs-tools</p>
<p><em>使用说明</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mksquashfs rootfs/usr usr.sqsh4 -noappend -comp xz</span><br></pre></td></tr></table></figure>

<p><em>挂载分区</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t squashfs /dev/mtdblock6 /usr</span><br></pre></td></tr></table></figure>

<h3 id="RAM文件系统"><a href="#RAM文件系统" class="headerlink" title="RAM文件系统"></a>RAM文件系统</h3><h4 id="ramdisk"><a href="#ramdisk" class="headerlink" title="ramdisk"></a>ramdisk</h4><p>Ramdisk是将一部分固定大小的内存当作分区来使用。它并非一个实际的文件系统，而是一种将实际的文件系统装入内存的机制，并且可以作为根文件系统。将一些经常被访问而又不会更改的文件(如只读的根文件系统)通过Ramdisk放在内存中，可以明显地提高系统的性能。</p>
<p>在Linux的启动阶段，initrd提供了一套机制，可以将内核映像和根文件系统一起载入内存。</p>
<h4 id="ramfs-tmpfs"><a href="#ramfs-tmpfs" class="headerlink" title="ramfs/tmpfs"></a>ramfs/tmpfs</h4><p>Ramfs是Linus Torvalds开发的一种基于内存的文件系统，工作于虚拟文件系统(VFS)层，不能格式化，可以创建多个，在创建时可以指定其最大能使用的内存大 小。(实际上，VFS本质上可看成一种内存文件系统，它统一了文件在内核中的表示方式，并对磁盘文件系统进行缓冲。)</p>
<p>Ramfs/tmpfs文件系统把所有的文件都放在RAM中，所以读/写操作发生在RAM中，可以用ramfs/tmpfs来存储一些临时性或经常要修改的数据，例如/tmp和/var目录，这样既避免了对Flash存储器的读写损耗，也提高了数据读写速度。</p>
<p>Ramfs/tmpfs相对于传统的Ramdisk的不同之处主要在于：不能格式化，文件系统大小可随所含文件内容大小变化。</p>
<p>Tmpfs的一个缺点是当系统重新引导时会丢失所有数据。</p>
]]></content>
      <categories>
        <category>rootfs</category>
      </categories>
  </entry>
  <entry>
    <title>sqlite sql commands and clauses</title>
    <url>/2022/06/07/sql/sqlite-sql/</url>
    <content><![CDATA[<p>SQLite有4类SQL语句：</p>
<ul>
<li>DDL(数据定义语言)用来定义数据库对象、创建库、表、列等。</li>
<li>DML(数据库操作语言)用来操作数据库表中的记录。</li>
<li>DQL(数据查询语言)用来查询数据。</li>
<li>DCL(数据控制语言)用来定义访问权限和安全级别。</li>
</ul>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt;.open database_name.db</span><br><span class="line">sqlite3 database_name.db</span><br></pre></td></tr></table></figure>

<h3 id="附加-分离数据库"><a href="#附加-分离数据库" class="headerlink" title="附加/分离数据库"></a>附加/分离数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ATTACH DATABASE <span class="string">&#x27;file_name&#x27;</span> <span class="keyword">AS</span> database_name;</span><br><span class="line"></span><br><span class="line">DETACH DATABASE <span class="string">&#x27;alias_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; attach database &#x27;test.db&#x27; as test;</span><br><span class="line">sqlite&gt; .databases</span><br><span class="line">seq  name             file                                                      </span><br><span class="line">---  ---------------  ----------------------------------------------------------</span><br><span class="line">0    main             ./test.db                                       </span><br><span class="line">2    test             ./test.db</span><br><span class="line">sqlite&gt; detach database test;</span><br><span class="line">sqlite&gt; .databases</span><br><span class="line">seq  name             file                                                      </span><br><span class="line">---  ---------------  ----------------------------------------------------------</span><br><span class="line">0    main             /home/luo_u/test.db</span><br></pre></td></tr></table></figure>

<h3 id="创建-删除表"><a href="#创建-删除表" class="headerlink" title="创建/删除表"></a>创建/删除表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> database_name.table_name(</span><br><span class="line">   col1_datatype,</span><br><span class="line">   .....</span><br><span class="line">   colN_datatype,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> database_name.table_name;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table tb1(num, name);</span><br><span class="line">sqlite&gt; .tables</span><br><span class="line">tb1</span><br><span class="line">sqlite&gt; drop table tb1;</span><br><span class="line">sqlite&gt; .tables</span><br></pre></td></tr></table></figure>

<h3 id="变更表"><a href="#变更表" class="headerlink" title="变更表"></a>变更表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 重命名表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> database_name.table_name RENAME <span class="keyword">TO</span> new_table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加一个新的列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> database_name.table_name <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_def...;</span><br></pre></td></tr></table></figure>

<h3 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在表的某些列添加值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLE_NAME <span class="keyword">VALUES</span> (value1, ... valueN);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在表的所有列添加值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLE_NAME (col1, ... colN) <span class="keyword">VALUES</span> (value1, ... valueN);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用一个表来填充另一个表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name1 [(col1, ... colN)] <span class="keyword">SELECT</span> col1, ... colN <span class="keyword">FROM</span> table_name2 [<span class="keyword">WHERE</span> <span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; insert into tb1 values(0, &#x27;aaa&#x27;);</span><br><span class="line">sqlite&gt; insert into tb1 values(1, &#x27;bbb&#x27;);</span><br><span class="line">sqlite&gt; select * from tb1;</span><br><span class="line">0|aaa</span><br><span class="line">1|bbb</span><br></pre></td></tr></table></figure>

<h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> col1<span class="operator">=</span>value1, .... colN<span class="operator">=</span>valueN <span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure>

<h3 id="替换记录"><a href="#替换记录" class="headerlink" title="替换记录"></a>替换记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> TABLE_NAME (col1, ... colN) <span class="keyword">VALUES</span> (value1, ... valueN);</span><br></pre></td></tr></table></figure>

<h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure>

<h3 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, ... colN <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>; <span class="comment">--返回系统日期</span></span><br></pre></td></tr></table></figure>

<p>select命令可以支持算术运算，当成计算器使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select 1+1;</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h3><p>WHERE子句用来过滤记录，只获取需要的记录。指定从一个表或多个表中获取数据的条件，如果满足给定的条件，则从表中返回特定的值。可在SELECT、UPDATE、DELETE语句中使用。</p>
<p>WHERE子句支持逻辑运算符、比较运算符和<code>&amp; | ~ &lt;&lt; &gt;&gt;</code>这些位运算符，还有内置函数。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AND</td>
<td align="left">多个条件的与逻辑</td>
</tr>
<tr>
<td align="left">OR</td>
<td align="left">多个条件的或逻辑</td>
</tr>
<tr>
<td align="left">BETWEEN</td>
<td align="left">在给定最小值和最大值范围内的一系列值中搜索值。</td>
</tr>
<tr>
<td align="left">EXISTS</td>
<td align="left">在满足一定条件的指定表中搜索行的存在</td>
</tr>
<tr>
<td align="left">IN</td>
<td align="left">把某个值与一系列指定列表的值进行比较</td>
</tr>
<tr>
<td align="left">LIKE</td>
<td align="left">把某个值与使用通配符运算符的相似值进行比较</td>
</tr>
<tr>
<td align="left">GLOB</td>
<td align="left">把某个值与使用通配符运算符的相似值进行比较，大小写敏感的</td>
</tr>
<tr>
<td align="left">NOT</td>
<td align="left">否定运算符，与其它逻辑运算符结合使用，比如 NOT EXISTS、NOT BETWEEN、NOT IN等等</td>
</tr>
<tr>
<td align="left">IS NULL</td>
<td align="left">与 NULL 值进行比较</td>
</tr>
<tr>
<td align="left">IS</td>
<td align="left">与 = 相似</td>
</tr>
<tr>
<td align="left">IS NOT</td>
<td align="left">与 != 相似</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">连接两个不同的字符串，得到一个新的字符串</td>
</tr>
<tr>
<td align="left">UNIQUE</td>
<td align="left">搜索指定表中的每一行，确保唯一性</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">==</td>
<td align="left">检查两个操作数的值是否相等</td>
</tr>
<tr>
<td align="left">=</td>
<td align="left">检查两个操作数的值是否相等</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">检查两个操作数的值是否不相等</td>
</tr>
<tr>
<td align="left">&lt;&gt;</td>
<td align="left">检查两个操作数的值是否不相等</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">检查左操作数的值是否大于右操作数的值</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">检查左操作数的值是否小于右操作数的值</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">检查左操作数的值是否大于等于右操作数的值</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">检查左操作数的值是否小于等于右操作数的值</td>
</tr>
<tr>
<td align="left">!&lt;</td>
<td align="left">检查左操作数的值是否不小于右操作数的值</td>
</tr>
<tr>
<td align="left">!&gt;</td>
<td align="left">检查左操作数的值是否不大于右操作数的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>求平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>求行数</td>
</tr>
<tr>
<td>FIRST()</td>
<td>返回第一个记录的值</td>
</tr>
<tr>
<td>LAST()</td>
<td>返回最后一个记录的值</td>
</tr>
<tr>
<td>MAX()</td>
<td>求最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>求最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>求总和</td>
</tr>
<tr>
<td>UCASE()</td>
<td>将字符串转换为大写</td>
</tr>
<tr>
<td>LCASE()</td>
<td>将字符串转换为小写</td>
</tr>
<tr>
<td>MID()</td>
<td>从某个文本字段提取字符，MySql 中使用</td>
</tr>
<tr>
<td>SubString()</td>
<td>从某字符串提取子字符</td>
</tr>
<tr>
<td>LEN()</td>
<td>返回字符串的长度</td>
</tr>
<tr>
<td>ROUND()</td>
<td>对某个数值字段进行指定小数位数的四舍五入</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前的系统日期和时间</td>
</tr>
<tr>
<td>FORMAT()</td>
<td>格式化字符串的显示方式</td>
</tr>
<tr>
<td>RANDOM()</td>
<td>返回一个-9223372036854775808到9223372036854775807的伪随机数</td>
</tr>
<tr>
<td>sqlite_version()</td>
<td>返回SQLite库的版本</td>
</tr>
</tbody></table>
<h3 id="Like子句"><a href="#Like子句" class="headerlink" title="Like子句"></a>Like子句</h3><p>LIKE运算符是用来匹配通配符指定模式的文本值，有两个通配符与之配合使用：</p>
<ul>
<li><code>%</code>：代表零个、一个或多个数字或字符</li>
<li><code>_</code>：代表一个单一的数字或字符</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> colN <span class="keyword">LIKE</span> <span class="string">&#x27;XXXX%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> colN <span class="keyword">LIKE</span> <span class="string">&#x27;XXXX_&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Glob子句"><a href="#Glob子句" class="headerlink" title="Glob子句"></a>Glob子句</h3><p>GLOB运算符是用来匹配通配符指定模式的文本值，与Like子句不同的是，它是大小写敏感的，也有两个通配符：</p>
<ul>
<li>*：代表零个、一个或多个数字或字符</li>
<li>?：代表一个单一的数字或字符</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> colN GLOB <span class="string">&#x27;XXXX*&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> colN GLOB <span class="string">&#x27;XXXX?&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Limit子句"><a href="#Limit子句" class="headerlink" title="Limit子句"></a>Limit子句</h3><p>LIMIT子句用于限制由SELECT语句返回的数据数量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, ... colN <span class="keyword">FROM</span> table_name LIMIT [num <span class="keyword">of</span> <span class="keyword">rows</span>]</span><br><span class="line"><span class="keyword">SELECT</span> col1, ... colN <span class="keyword">FROM</span> table_name LIMIT [num <span class="keyword">of</span> <span class="keyword">rows</span>] <span class="keyword">OFFSET</span> [<span class="type">row</span> index]</span><br></pre></td></tr></table></figure>

<h3 id="Order-By子句"><a href="#Order-By子句" class="headerlink" title="Order By子句"></a>Order By子句</h3><p>ORDER BY子句是用来指定一个或多个列按升序或降序顺序来排列返回的数据，ASC为升序，DESC为降序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span><span class="operator">-</span>list <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> <span class="keyword">condition</span>][<span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, ... columnN] [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>];</span><br></pre></td></tr></table></figure>

<h3 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h3><p>GROUP BY子句用来对相同的数据进行分组。必须放在WHERE子句中的条件之后，必须放在ORDER BY子句之前。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span><span class="operator">-</span>list <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> [ conditions ] <span class="keyword">GROUP</span> <span class="keyword">BY</span> col1, ... colN <span class="keyword">ORDER</span> <span class="keyword">BY</span> col1, ... colN;</span><br></pre></td></tr></table></figure>

<h3 id="Having子句"><a href="#Having子句" class="headerlink" title="Having子句"></a>Having子句</h3><p>HAVING子句允许指定条件来过滤由GROUP BY子句创建的分组结果。HAVING子句必须放在GROUP BY子句之后，在ORDER BY子句之前。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> [ conditions ]</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2</span><br><span class="line"><span class="keyword">HAVING</span> [ conditions ]</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2;</span><br></pre></td></tr></table></figure>

<h3 id="Distinct子句"><a href="#Distinct子句" class="headerlink" title="Distinct子句"></a>Distinct子句</h3><p>DISTINCT子句与SELECT语句一起使用，来消除所有重复的记录，保证唯一性。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, ... columnN <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure>

<h3 id="Unions子句"><a href="#Unions子句" class="headerlink" title="Unions子句"></a>Unions子句</h3><p>UNION子句用于合并多个SELECT语句的结果，不返回任何重复的行。前提条件是每个SELECT被选择的列数必须是相同的，相同数目的列表达式，相同的数据类型，并确保它们有相同的顺序，但不需要具有相同的长度。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure>

<h3 id="UNION-ALL子句"><a href="#UNION-ALL子句" class="headerlink" title="UNION ALL子句"></a>UNION ALL子句</h3><p>UNION ALL用于结合两个SELECT语句的结果，包括重复行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://www.runoob.com/sqlite/sqlite-tutorial.html">https://www.runoob.com/sqlite/sqlite-tutorial.html</a></p>
<p><a href="https://www.runoob.com/sql/sql-tutorial.html">https://www.runoob.com/sql/sql-tutorial.html</a></p>
]]></content>
      <categories>
        <category>sqlite</category>
      </categories>
      <tags>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite c++ api</title>
    <url>/2022/06/07/sql/sqlite-api/</url>
    <content><![CDATA[<h2 id="执行语句"><a href="#执行语句" class="headerlink" title="执行语句"></a>执行语句</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sqlite3_open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">char</span> *filename,   <span class="comment">/* Database filename (UTF-8) */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  sqlite3 **ppDb          <span class="comment">/* OUT: SQLite db handle */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sqlite3_close</span><span class="params">(sqlite3*)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sqlite3_exec</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  sqlite3*,                                  <span class="comment">/* An open database */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">char</span> *sql,                           <span class="comment">/* SQL to be evaluated */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> (*callback)(<span class="type">void</span>*,<span class="type">int</span>,<span class="type">char</span>**,<span class="type">char</span>**),  <span class="comment">/* Callback function */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">void</span> *,                                    <span class="comment">/* 1st argument to callback */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">char</span> **errmsg                              <span class="comment">/* Error msg written here */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">callback</span><span class="params">(<span class="type">void</span> *data, <span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **colName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span>*)data);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, colName[i], argv[i] ? argv[i] : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sqlite3 *db = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">sqlite3_open</span>(argv[<span class="number">1</span>], &amp;db);</span><br><span class="line">    <span class="keyword">if</span> (ret || db == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;db open fail.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *errmsg = <span class="literal">nullptr</span>;</span><br><span class="line">    ret = <span class="built_in">sqlite3_exec</span>(db, argv[<span class="number">2</span>], callback, (<span class="type">void</span> *)<span class="string">&quot;callback&quot;</span>, &amp;errmsg);</span><br><span class="line">    <span class="keyword">if</span> (ret != SQLITE_OK) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sql exec fail.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sqlite3_free</span>(errmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sqlite3_close</span>(db);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sqlite3_backup *<span class="title">sqlite3_backup_init</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  sqlite3 *pDest,                        <span class="comment">/* Destination database handle */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">char</span> *zDestName,                 <span class="comment">/* Destination database name */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  sqlite3 *pSource,                      <span class="comment">/* Source database handle */</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">char</span> *zSourceName                <span class="comment">/* Source database name */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sqlite3_backup_step</span><span class="params">(sqlite3_backup *p, <span class="type">int</span> nPage)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sqlite3_backup_finish</span><span class="params">(sqlite3_backup *p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sqlite3_backup_remaining</span><span class="params">(sqlite3_backup *p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sqlite3_backup_pagecount</span><span class="params">(sqlite3_backup *p)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sqlite3 *db = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">sqlite3_open</span>(argv[<span class="number">1</span>], &amp;db);</span><br><span class="line"><span class="keyword">if</span> (ret || db == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;db open fail.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqlite3 *backupDb = <span class="literal">NULL</span>;</span><br><span class="line">ret = <span class="built_in">sqlite3_open</span>(argv[<span class="number">2</span>], &amp;backupDb);</span><br><span class="line"><span class="keyword">if</span> (ret || backupDb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;backup db open fail.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sqlite3_close</span>(db);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqlite3_backup *pbak = <span class="built_in">sqlite3_backup_init</span>(backupDb, <span class="string">&quot;main&quot;</span>, db, <span class="string">&quot;main&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pbak == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;backup init fail &quot;</span> &lt;&lt; <span class="built_in">sqlite3_errcode</span>(backupDb) &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">sqlite3_backup_step</span>(pbak, <span class="number">-1</span>);</span><br><span class="line">    ret = <span class="built_in">sqlite3_backup_finish</span>(pbak);</span><br><span class="line">    <span class="keyword">if</span> (ret != SQLITE_OK) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;backup db fail.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sqlite3_close</span>(db);</span><br><span class="line"><span class="built_in">sqlite3_close</span>(backupDb);</span><br></pre></td></tr></table></figure>

<h2 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h2><table>
<thead>
<tr>
<th align="left">宏</th>
<th align="center">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SQLITE_OK</td>
<td align="center">0</td>
<td align="left">返回成功</td>
</tr>
<tr>
<td align="left">SQLITE_ERROR</td>
<td align="center">1</td>
<td align="left">SQL错误或数据库不存在</td>
</tr>
<tr>
<td align="left">SQLITE_INTERNAL</td>
<td align="center">2</td>
<td align="left">SQLite内部逻辑错误</td>
</tr>
<tr>
<td align="left">SQLITE_PERM</td>
<td align="center">3</td>
<td align="left">拒绝访问</td>
</tr>
<tr>
<td align="left">SQLITE_ABORT</td>
<td align="center">4</td>
<td align="left">回调函数请求中止</td>
</tr>
<tr>
<td align="left">SQLITE_BUSY</td>
<td align="center">5</td>
<td align="left">数据库文件被锁</td>
</tr>
<tr>
<td align="left">SQLITE_LOCKED</td>
<td align="center">6</td>
<td align="left">数据库中的一个表被锁</td>
</tr>
<tr>
<td align="left">SQLITE_NOMEM</td>
<td align="center">7</td>
<td align="left">malloc()分配内存失败</td>
</tr>
<tr>
<td align="left">SQLITE_READONLY</td>
<td align="center">8</td>
<td align="left">试图对只读数据库进行写操作</td>
</tr>
<tr>
<td align="left">SQLITE_INTERRUPT</td>
<td align="center">9</td>
<td align="left">操作被sqlie3_interrupt()中止</td>
</tr>
<tr>
<td align="left">SQLITE_IOERR</td>
<td align="center">10</td>
<td align="left">磁盘I/O发生错误</td>
</tr>
<tr>
<td align="left">SQLITE_CORRUPT</td>
<td align="center">11</td>
<td align="left">数据库磁盘映像格式不正确</td>
</tr>
<tr>
<td align="left">SQLITE_NOTFOUND</td>
<td align="center">12</td>
<td align="left">(Internal Only)表或记录不存在 未知操作码在sqlite3_file_control()</td>
</tr>
<tr>
<td align="left">SQLITE_FULL</td>
<td align="center">13</td>
<td align="left">插入失败，数据库已满</td>
</tr>
<tr>
<td align="left">SQLITE_CANTOPEN</td>
<td align="center">14</td>
<td align="left">不能打开数据库文件</td>
</tr>
<tr>
<td align="left">SQLITE_PROTOCOL</td>
<td align="center">15</td>
<td align="left">数据库锁定协议错误</td>
</tr>
<tr>
<td align="left">SQLITE_EMPTY</td>
<td align="center">16</td>
<td align="left">(Internal Only)数据库为空</td>
</tr>
<tr>
<td align="left">SQLITE_SCHEMA</td>
<td align="center">17</td>
<td align="left">数据库模式改变</td>
</tr>
<tr>
<td align="left">SQLITE_TOOBIG</td>
<td align="center">18</td>
<td align="left">单行数据过多(字符串或BLOB超过大小限制)</td>
</tr>
<tr>
<td align="left">SQLITE_CONSTRAINT</td>
<td align="center">19</td>
<td align="left">由于约束冲突而中止</td>
</tr>
<tr>
<td align="left">SQLITE_MISMATCH</td>
<td align="center">20</td>
<td align="left">数据类型不匹配</td>
</tr>
<tr>
<td align="left">SQLITE_MISUSE</td>
<td align="center">21</td>
<td align="left">数据库错误使用</td>
</tr>
<tr>
<td align="left">SQLITE_NOLFS</td>
<td align="center">22</td>
<td align="left">使用主机操作系统不支持的特性</td>
</tr>
<tr>
<td align="left">SQLITE_AUTH</td>
<td align="center">23</td>
<td align="left">非法授权</td>
</tr>
<tr>
<td align="left">SQLITE_FORMAT</td>
<td align="center">24</td>
<td align="left">辅助数据库格式错误</td>
</tr>
<tr>
<td align="left">SQLITE_RANGE</td>
<td align="center">25</td>
<td align="left">sqlite_bind第二个参数超出范围</td>
</tr>
<tr>
<td align="left">SQLITE_NOTADB</td>
<td align="center">26</td>
<td align="left">打开的不是一个数据库文件</td>
</tr>
<tr>
<td align="left">SQLITE_NOTICE</td>
<td align="center">27</td>
<td align="left">来自sqlite3_log()的通知</td>
</tr>
<tr>
<td align="left">SQLITE_WARNING</td>
<td align="center">28</td>
<td align="left">来自sqlite3_log()的警告</td>
</tr>
<tr>
<td align="left">SQLITE_ROW</td>
<td align="center">100</td>
<td align="left">sqlite_step() 有另一行准备就绪</td>
</tr>
<tr>
<td align="left">SQLITE_DONE</td>
<td align="center">101</td>
<td align="left">sqlite_step() 执行完成</td>
</tr>
</tbody></table>
<hr>
<p><a href="https://sqlite.org/c3ref/funclist.html">https://sqlite.org/c3ref/funclist.html</a></p>
<p><a href="https://www.cnblogs.com/endv/p/12228344.html">https://www.cnblogs.com/endv/p/12228344.html</a></p>
<p><a href="https://sqlite.org/c3ref/backup_finish.html#sqlite3backupfinish">https://sqlite.org/c3ref/backup_finish.html#sqlite3backupfinish</a></p>
]]></content>
      <categories>
        <category>sqlite</category>
      </categories>
      <tags>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite</title>
    <url>/2022/06/07/sql/sqlite/</url>
    <content><![CDATA[<p>SQLite是一款轻量、无服务器的、零配置的、事务性、关系型的数据库引擎，不需要在系统中配置就可以直接使用。</p>
<h2 id="点命令"><a href="#点命令" class="headerlink" title="点命令"></a>点命令</h2><p>可在命令行上输入<code>.help</code>列出所有sqlite支持的点命令。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>每个存储在 SQLite 数据库中的值都具有以下存储类之一：</p>
<table>
<thead>
<tr>
<th align="left">存储类</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NULL</td>
<td align="left">NULL 值。</td>
</tr>
<tr>
<td align="left">INTEGER</td>
<td align="left">有符号整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中</td>
</tr>
<tr>
<td align="left">REAL</td>
<td align="left">浮点数</td>
</tr>
<tr>
<td align="left">TEXT</td>
<td align="left">文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储</td>
</tr>
<tr>
<td align="left">BLOB</td>
<td align="left">值是一个 blob 数据，完全根据它的输入存储</td>
</tr>
</tbody></table>
<p>SQLite通过值的表示来推理其类型：</p>
<ul>
<li>用单引号或双引号括起来的文字被指派为TEXT。</li>
<li>未用引号括起来的数据，并且没有小数点和指数，被指派为INTEGER。</li>
<li>未用引号括起来的数据，并且带有小数点或指数，被指派为REAL。</li>
<li>用NULL说明的值被指派为NULL存储类。</li>
<li>如果一个值的格式为X’ABCD’，其中ABCD为16进制数字，X前缀大小写皆可，则该值被指派为BLOB。</li>
</ul>
<p>SQLite支持列的亲和类型，列仍然可以存储任何类型的数据，当数据插入时，该字段的数据将会优先采用亲缘类型作为该值的存储方式。</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">亲和类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INT、NTEGER、TINYINT、SMALLINT、MEDIUMINT、BIGINT、UNSIGNED BIG INT、INT2、INT8</td>
<td align="left">INTEGER</td>
</tr>
<tr>
<td align="left">CHARACTER(20)、VARCHAR(255)、VARYING CHARACTER(255)、NCHAR(55)、NATIVE CHARACTER(70)、NVARCHAR(100)、TEXT、CLOB</td>
<td align="left">TEXT</td>
</tr>
<tr>
<td align="left">BLOB、no datatype specified</td>
<td align="left">NONE</td>
</tr>
<tr>
<td align="left">REAL、DOUBLE、DOUBLE PRECISION、FLOAT</td>
<td align="left">REAL</td>
</tr>
<tr>
<td align="left">NUMERIC、DECIMAL(10,5)、BOOLEAN、DATE、DATETIME</td>
<td align="left">NUMERIC<br/>可以包含使用所有五个存储类的值</td>
</tr>
</tbody></table>
<p>SQLite 没有单独的 Boolean 存储类，布尔值被存储为整数 0和 1。</p>
<p>SQLite 没有单独用于存储日期或时间的存储类，但 可以存储为 TEXT、REAL 或 INTEGER 值。</p>
<table>
<thead>
<tr>
<th align="left">存储类</th>
<th align="left">日期格式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TEXT</td>
<td align="left">格式为 “YYYY-MM-DD HH:MM:SS.SSS” 的日期。</td>
</tr>
<tr>
<td align="left">REAL</td>
<td align="left">从公元前 4714 年 11 月 24 日格林尼治时间的正午开始算起的天数。</td>
</tr>
<tr>
<td align="left">INTEGER</td>
<td align="left">从 1970-01-01 00:00:00 UTC 算起的秒数。</td>
</tr>
</tbody></table>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>约束是在表或列上强制执行的规则，限制可以插入到表中的数据类型，以确保数据的准确性和可靠性。</p>
<ul>
<li>NOT NULL约束：确保某列不能是NULL值(未知的数据)。</li>
<li>DEFAULT约束：当某列没有指定值时，为该列提供默认值。</li>
<li>UNIQUE约束：确保某列中的所有值是不同的。</li>
<li>PRIMARY Key约束：只能有一个主键唯一标识数据库表中的各行记录。</li>
<li>CHECK约束：确保某列中的所有值满足一定条件。</li>
</ul>
<h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><p>Joins子句用于结合两个或多个数据库中表的记录。JOIN是一种通过共同值来结合两个表中字段的手段。</p>
<p>交叉连接（CROSS JOIN）把第一个表的每一行与第二个表的每一行进行匹配。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> table2 ...;</span><br></pre></td></tr></table></figure>

<p>内连接（INNER JOIN）根据指定的连接条件结合两个表的列值来创建一个新的表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--INNER 关键字是可选的</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> conditional_expression ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">--可以使用USING表达式声明内连接条件，指定一个或多个列的列表</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 <span class="keyword">JOIN</span> table2 <span class="keyword">USING</span> ( column1 ,... ) ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自然连接会自动测试存在两个表中的每一列的值之间相等值</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> table2...;</span><br></pre></td></tr></table></figure>

<p>外连接（OUTER JOIN）是内连接的扩展，不同的是会将未匹配条件的行使用NULL值，也附加到结果表中。虽然 SQL标准定义了三种类型的外连接：LEFT、RIGHT、FULL，但SQLite只支持左外连接（LEFT OUTER JOIN）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> conditional_expression ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">USING</span> ( column1 ,... ) ...;</span><br></pre></td></tr></table></figure>

<h2 id="AS别名"><a href="#AS别名" class="headerlink" title="AS别名"></a>AS别名</h2><p>可以暂时把表或列重命名为另一个名字，重命名是临时的改变，在数据库中实际的表的名称不会改变。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表别名</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, ... columnN</span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列别名</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure>

<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器(Trigger)是数据库的回调函数，它会在自动执行或指定的数据库事件发生时调用。</p>
<ul>
<li><p>SQLite的触发器可以指定在特定的数据库表发生DELETE、INSERT或UPDATE时触发，或在一个或多个指定表的列发生更新时触发。</p>
</li>
<li><p>SQLite只支持FOR EACH ROW触发器，没有FOR EACH STATEMENT触发器。</p>
</li>
<li><p>BEFORE或AFTER关键字决定何时执行触发器动作，决定是在关联行的插入、修改或删除之前或者之后执行触发器动作。</p>
</li>
<li><p>要修改的表必须存在于同一数据库中，作为触发器被附加的表或视图，且必须只使用tablename，而不是database.tablename。</p>
</li>
<li><p>当触发器相关联的表删除时，自动删除触发器。</p>
</li>
<li><p>RAISE()函数可用于触发器程序内抛出异常。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name [BEFORE<span class="operator">|</span>AFTER] </span><br><span class="line"><span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> table_name </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- Trigger logic goes here....</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 列出触发器</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> sqlite_master <span class="keyword">WHERE</span> type <span class="operator">=</span> <span class="string">&#x27;trigger&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列出特定表上的触发器</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> sqlite_master <span class="keyword">WHERE</span> type <span class="operator">=</span> <span class="string">&#x27;trigger&#x27;</span> <span class="keyword">AND</span> tbl_name <span class="operator">=</span> <span class="string">&#x27;table_name_xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> trigger_name;</span><br></pre></td></tr></table></figure>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引(Index)是一种特殊的查找表，用来加快数据检索。索引是一个指向表中数据的指针，索引有助于加快SELECT查询和WHERE子句，但它会减慢使用UPDATE和INSERT语句时的数据输入。</p>
<ul>
<li>单列索引是一个只基于表的一个列上创建的索引。</li>
<li>组合索引是基于一个表的两个或多个列上创建的索引。</li>
<li>唯一索引不允许任何重复的值插入到表中，这是出于性能和数据完整性考虑。</li>
<li>隐式索引是在创建对象时，由数据库服务器自动创建的索引，自动创建的索引为主键约束和唯一约束。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建单列索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建组合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">on</span> table_name (column1, column2);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name <span class="keyword">on</span> table_name (column_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看索引</span></span><br><span class="line">.indices teamTable</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列出数据库所有索引：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sqlite_master <span class="keyword">WHERE</span> type <span class="operator">=</span> <span class="string">&#x27;index&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Indexed-By关键字"><a href="#Indexed-By关键字" class="headerlink" title="Indexed By关键字"></a>Indexed By关键字</h3><p><code>INDEXED BY index-name</code>子句规定必须要指定的索引名来查找表中的值，如果索引名index-name不存在或不能用于查询，就会失败。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span><span class="operator">|</span><span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">UPDATE</span> column1, column2...</span><br><span class="line">INDEXED <span class="keyword">BY</span> (index_name)</span><br><span class="line">table_name</span><br><span class="line"><span class="keyword">WHERE</span> (<span class="keyword">CONDITION</span>);</span><br></pre></td></tr></table></figure>

<p><code>NOT INDEXED</code>子句规定当访问的表（包括由UNIQUE和PRIMARY KEY约束创建的隐式索引）时，没有使用索引。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图(View)是一个以预定义的SQLite查询形式存在的表的组合。视图可以包含一个表的所有行或从一个或多个表选定行，可以从一个单一的表、多个表或其他视图创建。。使用视图可以实现：</p>
<ul>
<li>用这种结构来查找数据更自然或直观。</li>
<li>限制数据访问，只能看到有限的数据，而不是完整的表。</li>
<li>汇总各种表中的数据，用于生成报告。</li>
</ul>
<p>SQLite视图是只读的，因此可能无法在视图上执行DELETE、INSERT或UPDATE语句。但是可以在视图上创建一个触发器，当尝试DELETE、INSERT或UPDATE视图时触发。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> [TEMP <span class="operator">|</span> TEMPORARY] <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务（Transaction）是以逻辑顺序完成的工作单位或序列。事务具有四个属性：</p>
<ul>
<li>原子性：确保工作单位内的所有操作都成功完成，否则，事务会在出现故障时终止，之前的操作也会回滚到以前的状态。</li>
<li>一致性：确保数据库在成功提交的事务上正确地改变状态。</li>
<li>隔离性：使事务操作相互独立和透明。</li>
<li>持久性：确保已提交事务的结果或效果在系统发生故障的情况下仍然存在。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 启动事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将事务调用的更改保存到数据库</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 撤消尚未保存到数据库的事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询是在WHERE子句中内嵌一个查询语句，使用子查询返回的数据将被用在主查询中作为条件，以进一步限制要检索的数据。子查询可以与SELECT、INSERT、UPDATE和DELETE语句一起使用。子查询必须遵循的几个规则：</p>
<ul>
<li>子查询必须用括号括起来。</li>
<li>子查询在SELECT子句中只能有一个列，除非在主查询中有多列与子查询的所选列进行比较。</li>
<li>ORDER BY不能用在子查询中，虽然主查询可以使用ORDER BY。</li>
<li>子查询返回多于一行，只能与多值运算符一起使用，如IN运算符。</li>
<li>BETWEEN运算符不能与子查询一起使用，但是BETWEEN可在子查询内使用。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teamTable <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> teamTable <span class="keyword">WHERE</span> money <span class="operator">&gt;</span> <span class="number">4500</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teamTable_bak <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teamTable <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> teamTable);</span><br><span class="line"><span class="keyword">UPDATE</span> teamTable <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">*</span> <span class="number">0.50</span> <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="keyword">SELECT</span> age <span class="keyword">FROM</span> teamTable_bck <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">24</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> teamTable <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="keyword">SELECT</span> age <span class="keyword">FROM</span> teamTable_bck <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">24</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Autoincrement"><a href="#Autoincrement" class="headerlink" title="Autoincrement"></a>Autoincrement</h2><p>AUTOINCREMENT关键字用于表中的字段值自动递增，可以在创建表时在特定的列名称上使用AUTOINCREMENT关键字实现该字段值的自动增加，只能用于整型（INTEGER）字段。设置了AUTOINCREMENT后insert或者update时不需要指定值，自动从1开始递增。</p>
<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>允许用户通过网页输入，并将输入内容插入到SQLite数据库中，这时需要注意SQL注入的安全问题。</p>
<h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p><code>EXPLAIN</code>或<code>EXPLAIN QUERY PLAN</code>关键字用于描述表的细节，可用于表的交互式分析和排除故障。。</p>
<p>EXPLAIN [SQLite Query]</p>
<p>EXPLAIN  QUERY PLAN [SQLite Query]</p>
<h2 id="PRAGMA"><a href="#PRAGMA" class="headerlink" title="PRAGMA"></a>PRAGMA</h2><p>SQLite的PRAGMA命令是一个特殊的命令，可以用在SQLite环境内控制各种环境变量和状态标志。PRAGMA值可以被读取和设置。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询当前的PRAGMA值</span></span><br><span class="line">PRAGMA pragma_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置一个新的值</span></span><br><span class="line">PRAGMA pragma_name <span class="operator">=</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Vacuum"><a href="#Vacuum" class="headerlink" title="Vacuum"></a>Vacuum</h2><p>VACUUM 命令通过复制主数据库中的内容到一个临时数据库文件，然后清空主数据库，并从副本中重新载入原始的数据库文件。目的是整理数据库文件结构，消除空闲页，把表中的数据排列连续。</p>
<p>如果表中没有明确的整型主键(INTEGER PRIMARY KEY)，VACUUM 命令可能会改变表中条目的行 ID(ROWID)。VACUUM 命令只适用于主数据库，附加的数据库文件是不能使用。如果有一个活动的事务，VACUUM 命令就会失败。由于 VACUUM 命令从头开始重新创建数据库文件，所以 VACUUM 也可以用于修改许多数据库特定的配置参数。</p>
<hr>
<p><a href="https://www.sqlite.org/docs.html">https://www.sqlite.org/docs.html</a></p>
<p><a href="https://runebook.dev/zh-CN/docs/sqlite/-index-">https://runebook.dev/zh-CN/docs/sqlite/-index-</a></p>
<p><a href="https://www.runoob.com/sqlite/sqlite-tutorial.html">https://www.runoob.com/sqlite/sqlite-tutorial.html</a></p>
<p><a href="https://blog.csdn.net/HardWorkingAnt/article/details/70474107">https://blog.csdn.net/HardWorkingAnt/article/details/70474107</a></p>
]]></content>
      <categories>
        <category>sqlite</category>
      </categories>
      <tags>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>ethernet and MAC</title>
    <url>/2022/06/07/net/eth/</url>
    <content><![CDATA[<h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>以太网接口由MAC控制器物理层接口PHY组成。PHY整合了大量模拟硬件，而MAC是典型的全数字器件。考虑到芯片面积及模拟/数字混合架构的原因，通常，将MAC集成进微控制器而将PHY留在片外。</p>
<p><img src="/images/net/eth/eth-arch.png" alt="基本构成"></p>
<p><img src="/images/net/eth/eth-arch2.jpg" alt="cpu内部框架"></p>
<p>网卡工作在osi的最后两层，物理层和数据链路层，物理层定义了数据传送与接收所需要的电与光信号、线路状态、时钟基准、数据编码和电路等，并向数据链路层设备提供标准接口。物理层的芯片称之为PHY。数据链路层则提供寻址机构、数据帧的构建、数据差错检查、传送控制、向网络层提供标准的数据接口等功能。以太网卡中数据链路层的芯片称之为MAC控制器。很多网卡的这两个部分是做到一起的。他们之间的关系是pci总线接mac总线，mac接phy，phy接网线。</p>
<p>隔离变压器的作用是防干扰，防雷击。长距离连接的两个以太网设备，很可能不共地，地线之间有电压差，如果不隔离，电流会经网线走，网卡接口就很容易坏了。</p>
<p>RJ-45接头实现了网卡和网线的连接，10M网卡的RJ-45插口也只用了1,2,3,6四根，而100M或1000M网卡使用八根。其中100M的网络中1,2是传送数据的，3,6是接收数据的，1,2之间是一对差分信号，也就是说它们的波形一样，但是相位相差180度。</p>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC（Media Access Control），即媒体访问控制子层协议。该协议位于OSI七层协议中数据链路层的下半部分，实现了数据链路层。支持 10Mbit/s 或 100Mbit/s 两种速率。主要负责控制与连接物理层的物理介质。在发送数据的时候，MAC协议可以事先判断是否可以发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层;在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误,如果没有错误,则去掉控制信息发送至LLC层。该层协议是以太网MAC由IEEE-802.3以太网标准定义。</p>
<p><img src="/images/net/eth/mac.png" alt="OSI-MAC"></p>
<p>最新的MAC同时支持 10Mbps和100Mbps两种速率。以太网数据链路层其实包含MAC(介质访问控制)子层和LLC(逻辑链路控制)。</p>
<p>目标的MAC地址由ARP协议确定。第一次传送某个目的IP地址的数据的时候，先会发出一个ARP包，其MAC的目标地址是广播地址，因为是广播包，所有这个局域网的主机都收到了这个ARP请求。收到请求的主机将这个IP地址和自己的相比较，如果不相同就不予理会，如果相同就发出ARP响应包。这个IP地址的主机收到这个ARP请求包后回复的ARP响应。这个包里面就包括了他的MAC地址。以后的给这个IP地址的帧的目标MAC地址就被确定了。</p>
<p>IP地址和MAC地址之间的关联关系保存在主机系统里面，叫做ARP表。</p>
<p><img src="/images/net/eth/MAC.jpg" alt="MAC"></p>
<p>以太网MAC芯片的一端接计算机PCI总线，另外一端就接到PHY芯片上。CPU上有两组寄存器用与MAC。一组用户数据的收发，对应上面的DMA；一组用户MIIM，用户对PHY进行配置，两组寄存器由于都在CPU上，配置方式与其他CPU上寄存器一样，直接读写即可。数据的转发通过DMA完成。</p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2022/06/21/net/http/</url>
    <content><![CDATA[<p>HTTP(HyperText Transfer Protocol)超文本传输协议，TCP端口号80，是可靠的数据传输协议，浏览器向服务器发收报文前，先建立TCP连接，HTTP使用TCP连接方式，HTTP请求报文方式：</p>
<ul>
<li>GET：请求指定的页面信息，并返回实体主体；</li>
<li>POST：向指定资源提交数据进行处理请求；</li>
<li>DELETE：请求服务器删除指定的页面；</li>
<li>HEAD：请求读取URL标识的信息的首部，只返回报文头；</li>
<li>OPETION：请求一些选项的信息；</li>
<li>PUT：在指明的URL下存储一个文档。</li>
</ul>
<p>https 是安全的http协议，端口号443。基于 http 协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护。</p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS协议</title>
    <url>/2022/09/25/net/https/</url>
    <content><![CDATA[<p>HTTP 是明文传输数据的，没有安全性。HTTPS = HTTP + SSL / TLS。HTTPS 的整个通信过程可以分为两大阶段：证书验证和数据传输阶段，数据传输阶段又可以分为非对称加密和对称加密两个阶段。具体流程如下：</p>
<ol>
<li><p>客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口)。</p>
</li>
<li><p>采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书，证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。</p>
</li>
<li><p>服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详细信息。</p>
</li>
<li><p>客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
</li>
<li><p>客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。</p>
</li>
<li><p>服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接。</p>
</li>
<li><p>服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。</p>
</li>
<li><p>双方使用对称加密传输所有数据。</p>
</li>
</ol>
<p><img src="/images/net/http/https.png" alt="udp head"></p>
<p><strong>HTTPS 和 HTTP 的区别</strong></p>
<ul>
<li><p>HTTP 明文传输，不对数据进行加密安全性较差。HTTPS安全性较好。</p>
</li>
<li><p>使用 HTTPS 协议需要申请 CA 证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、DigiCert 和 GlobalSign 等。</p>
</li>
<li><p>HTTP 页面响应速度比 HTTPS 快，这个很好理解，由于加了一层安全层，建立连接的过程更复杂，也要交换更多的数据，难免影响速度。</p>
</li>
<li><p>由于 HTTPS 是建构在 SSL / TLS 之上的 HTTP 协议，所以，要比 HTTP 更耗费服务器资源。</p>
</li>
<li><p>HTTPS 和 HTTP 使用的是完全不同的连接方式，用的端口也不一样，前者是 443，后者是 80。</p>
</li>
</ul>
<p><strong>HTTPS 的缺点</strong></p>
<ul>
<li><p>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</p>
</li>
<li><p>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</p>
</li>
<li><p>在现有的证书机制下，中间人攻击依然有可能发生。</p>
</li>
<li><p>HTTPS 需要更多的服务器资源，也会导致成本的升高。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC</title>
    <url>/2022/11/19/net/mac/</url>
    <content><![CDATA[<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC(Medium Access Control)媒体访问控制，控制在往媒体上发送数据的先后，防止发生混乱。</p>
<p>MAC 地址共有 48 bit，用来唯一标识设备，在网卡生产时写入 ROM 里的，网卡驱动程序读取并分配给 MAC模块。通过 ARP 可以查询目标路由器的 MAC 地址。</p>
<table>
<thead>
<tr>
<th align="center">bit</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>0 单播地址<br/>1 多播地址</td>
</tr>
<tr>
<td align="center">2</td>
<td>0 全局地址<br/>1 本地地址</td>
</tr>
<tr>
<td align="center">3-24</td>
<td>厂商识别码</td>
</tr>
<tr>
<td align="center">25-48</td>
<td>网卡唯一标识</td>
</tr>
</tbody></table>
<p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，其作用就是将包送达路由器。</p>
<p><img src="/images/net/tcpip/mac_head.png" alt="img"></p>
<h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>网卡驱动从 IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC 模块发送发送包的命令。MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。再将数字信息按每个比特转换成电信号，然后由 PHY信号收发模块发送出去。</p>
<p><img src="/images/net/tcpip/pack.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改MAC地址</span></span><br><span class="line">ifconfig eth0 hw ether 12:34:56:78:90:12</span><br></pre></td></tr></table></figure>

<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机将网络包原样转发到目的地，交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。交换机的 MAC 地址表主要包含两个信息:设备的 MAC 地址，和该设备连接在交换机的端口。</p>
<p>交换机工作在全双工模式。</p>
<p><img src="/images/net/switch.png" alt="img"></p>
<p>交换机会自行更新或删除地址表中的记录，当收到包时会将发送方 MAC 地址以及其输入端口的号码写入MAC 地址表中，当端口上的设备长时间不工作，就会删除记录。</p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃。相对地，交换机的端口不具有 MAC 地址的端口，故不会核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。</p>
<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><p>集线器工作在物理层，会将收到的数据广播给其它端口。集线器里有一张以太网协议的表，根据以太网头部中记录的目的地信息查出相应的传输方向，在子网中将网络包传输到下一个转发设备。</p>
<p>集线器的接口中有一个 MDI/MDI-X 切换开关，MDI 就是对 RJ-45 接口和信号收发模块进行直连接线，而 MDI-X 则是交叉接线。</p>
<p>集线器工作在半双工模式。</p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
  </entry>
  <entry>
    <title>IP and MAC</title>
    <url>/2022/06/21/net/ip/</url>
    <content><![CDATA[<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><p>IPv4 地址共32位，每 8 位作为一组，用点分十进制的表示方式，包含两部分：网络号负责标识该 IP 地址是属于哪个子网的；主机号负责标识同一子网下的不同主机。</p>
<p>子网掩码也是32bit，为1的部分表示网络号，为0的部分表示主机号，将子网掩码和IP地址相与，可以计算出网络号和主机号。主机号部分全部为0代表整个子网，主机号部分全部为1代表广播地址，向子网上所有设备发送包。</p>
<p><img src="/images/net/tcpip/ip_name.png" alt="ip_name"></p>
<p>本地回环地址127.0.0.1指的是本机地址，等效于localhost或本机IP。不会跟着网络情况的变化而变化。它代表设备的本地虚拟接口，被看作是永远不会宕掉的接口。127.0.0.1 ~ 127.255.255.254范围都是本地回环地址。作用是测试本机的网络配置，能ping通说明本机网络协议正常。</p>
<p>IP 地址分为A类、B类、C类、D类、E类，其中D类和E类没有主机号的，所以不可用于主机 IP，D类常被用于多播，E类预留未使用。</p>
<p><img src="/images/net/tcpip/ip_class.webp" alt="ip_class"></p>
<p><img src="/images/net/tcpip/ip_class.png" alt="ip_class"></p>
<h3 id="IP头"><a href="#IP头" class="headerlink" title="IP头"></a>IP头</h3><p><img src="/images/net/tcpip/ip_head.png" alt="img"></p>
<p>经过分片之后的 IP 数据，只能由目标主机进行重组，路由器并不会重组。</p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv6 地址⻓度是 128 位，以每 16 位作为一组，每组用冒号:隔开。</p>
<p>IPv6 的地址主要有以下类型地址:</p>
<ul>
<li>单播地址，用于一对一的通信</li>
<li>组播地址，用于一对多的通信</li>
<li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li>
<li>没有广播地址</li>
</ul>
<p><img src="/images/net/tcpip/ipv6.png" alt="img"></p>
<ul>
<li><p>取消了首部校验和字段。 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</p>
</li>
<li><p>取消了分片/重新组装相关字段。 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</p>
</li>
<li><p>取消选项字段。 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的下一个首部指出的位置上。删除该选项字段使的 IPv6 的首部成为固定⻓度的 40 字节。</p>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP 协议(Internet Protocol)负责在主机和网络之间寻址和路由数据包。</p>
<p>IP地址的网络地址这一部分是用于进行路由控制，路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最⻓匹配。</p>
<p>IP 模块会添加 IP 头部和 MAC 头部这两种头部。IP 头部包含目的地的 IP 地址，MAC 头部包含 MAC 地址。IP 协议会查找下一个路由器的MAC 地址，并将这个地址写入 MAC 头部中。这样一来，以太网协议就知道要将这个包发到哪一个路由器上了。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS(Domain Name System)域名服务系统，将域名网址自动解析为具体的 IP 地址。</p>
<p>查询 IP 地址时，浏览器会使用系统 Socket 库中的解析器， 向 DNS 服务器发送查询消息，然后 DNS 服务器会从域名与 IP 地址的对照表中查找相应的记录，并返回 IP 地址。客户端的查询消息包含以下 3 种信息：</p>
<ul>
<li>域名：服务器、邮件服务器(邮件地址中 @ 后面的部分)的名称。</li>
<li>Class：网络的信息标识。如今 Class 的值永远是代表互联网的 IN。</li>
<li>记录类型：表示域名对应何种类型的记录。例如，当类型为 A 时，表示域名对应的是 IP 地址；当类型为 MX 时，表示域名对应的是邮件服务器。对于不同的记录类型，服务器向客户端返回的信息也会不同。</li>
</ul>
<p><img src="/images/net/dns_msg.png" alt="dns_msg"></p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>ARP 用于根据 IP 地址查询相应的MAC 地址。</p>
<p>主机会通过广播发送 ARP 请求，这个包中包含了想要查询的 MAC 地址的主机 IP 地址。当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。通常操作系统会把获取的 MAC 地址缓存起来，可以使用 <code>arp -a</code> 命令来查看。</p>
<p>RARP 协议是根据 MAC 地址求 IP 地址。</p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>DHCP(Dynamic Host Configuration Protocol)动态主机配置协议。能实现自动设置 IP 地址、统一管理 IP 地址分配。DHCP 服务器分配的 IP 地址只能在租期内使用。</p>
<h4 id="udhcpc"><a href="#udhcpc" class="headerlink" title="udhcpc"></a>udhcpc</h4><p>默认的目录文件是/usr/share/udhcpc/default.script，当udhcpc 取得了IP地址之后，会把从DHCP server 得到的信息带入 script执行。</p>
<h3 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h3><p>NAT就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址。</p>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>ICMP(Internet Control Message Protocol)互联网控制报文协议，用于告知网络包传送过程中产生的错误以及各种控制信息。在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。</p>
<h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><p>IGMP(Internet Control Message Protocol)互联网控制报文协议，是主机用来向本地多路广播路由器报告主机组成员的协议。ping命令就是基于ICMP协议工作的。</p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器是按照IP 协议传输包的设备，根据接收到的包的 IP 头部中记录的接收方 IP 地址，在路由表中进行查询，以此判断转发目标。</p>
<p>路由器已经集成了集线器和交换机的功能，俗称三层网络设备，每个端口都具有 MAC 地址和 IP 地址，只接收与自身地址匹配的包，不匹配的包则直接丢弃。</p>
<p><img src="/images/net/route_map.png" alt="img"></p>
<p>路由器忽略主机号部分，只匹配网络号。路由表的子网掩码列只是用来在匹配目标地址时告诉路由器应该匹配多少个比特。根据目标地址和子网掩码匹配到某条记录后，路由器就会将网络包交给接口列中指定的端口，并转发到网关列中指定的 IP 地址。跃点计数表示距离目标 IP 地址的距离的远近。数字越小表示距离目的地越近；数字越大表示距离目的地越远。</p>
<p>路由表中子网掩码为 0.0.0.0 的记录表示默认路由，这一行配置的网关地址被称为默认网关，无论任何地址都能匹配到这一条记录。</p>
<p>路由器优先选择主机号比特数越短，跃点计数较小的记录。如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过ICMP 消息告知发送方 。</p>
<p>路由器会更新 IP 头部中的 TTL字段。TTL 字段表示包的有效期，包每经过一个路由器的转发，这个值就会减 1，当这个值变成 0 时，就表示超过了有效期，这个包就会被丢弃。</p>
<p>对于长度大于输出端口MTU的转发包，路由器会根据IP 头部中的标志字段，确认是否可以分片。如果查询标志字段发现不能分片，那么就只能丢弃这个包，并通过ICMP 消息通知发送方。在分片中，TCP 头部及其后面的部分都是可分片的数据，每一份数据前面会加上 IP 头部。</p>
<p>路由转发和IP 模块发送包的过程是相同的，会在包前面加上 MAC 头部，也是从路由表的网关列中查找出下一个路由器的 IP 地址，如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址；如果网关为空 ，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址。然后通过 ARP 根据 IP 地址查询出 MAC 地址，然后将 MAC 地址写入 MAC 头部。</p>
<p>内网与互联网连接需要地址转换。地址转换的基本原理是在转发网络包时对 IP 头部中的 IP 地址和端口号进行改写。因为公网IP只有一个，所以要根据不同的端口号区分内网不同的私有地址，路由器会保存私有地址与端口号对应的记录。如果私有地址和端口号没有保存在对应表中，外网是无法访问私有地址的，除非手动添加记录。</p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
  </entry>
  <entry>
    <title>ntp</title>
    <url>/2022/09/04/net/ntp/</url>
    <content><![CDATA[<p>NTP是计算机系统中的时钟同步协议，是基于用户数据报协议（UDP），端口号是123。</p>
<p>对于同步过程，NTP依赖于协调世界时（UTC），该时间是从分层系统中的各个客户端和服务器获得的。时钟同步的工作过程：</p>
<ol>
<li>客户端发送一个NTP报文给服务器，该报文带有它离开客户端时的时间戳T1。</li>
<li>当NTP报文到达服务器时，服务器加上自己的时间戳T2。</li>
<li>当NTP报文离开服务器时，服务器再加上自己的时间戳T3。</li>
<li>当客户端接收到该响应报文时，客户端的本地时间为T4。</li>
</ol>
<p><img src="/images/net/ntp.png"></p>
<p>如此客户端相对服务器的时间差为((T2-T1) + (T3-T4)) / 2，然后根据时间差来设定自己的时钟，使之与服务器的时钟同步。</p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p><strong>数据报文格式</strong></p>
<p><img src="/images/net/ntp_package.png"></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>长度(bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Leap Indicator</td>
<td>2</td>
<td>闰秒提示：<br/>0: 无leap秒调整<br/>1: 一天的最后一分钟为61秒<br/>2: 一天的最后一分钟为59秒<br/>3:表示告警状态，时钟未被同步。</td>
</tr>
<tr>
<td>Version Number</td>
<td>3</td>
<td>NTP的版本号，目前值为3。</td>
</tr>
<tr>
<td>Mode</td>
<td>3</td>
<td>NTP的工作模式。不同值表示的含义如下：<br/>0：reserved，保留。<br/>1：symmetric active，主动对等体模式。<br/>2：symmetric passive，被动对等体模式。<br/>3：client，客户模式。<br/>4：server，服务器模式。<br/>5：broadcast，广播模式。<br/>6：reserved for NTP control messages，NTP控制报文。<br/>7：reserved for private use，内部使用预留。</td>
</tr>
<tr>
<td>Stratum</td>
<td>8</td>
<td>时钟的层数，定义了时钟的准确度。层数为1的时钟准确度最高，从1到15依次递减。<br/>0：未指定或无效<br/>1：主服务器<br/>2 – 15：辅助服务器<br/>16：未同步<br/>17 –255：保留</td>
</tr>
<tr>
<td>Poll</td>
<td>8</td>
<td>轮询时间（8位有符号整数），即两个连续NTP报文之间最小间隔时间(s)。</td>
</tr>
<tr>
<td>Precision</td>
<td>8</td>
<td>本地时钟精度（8位有符号整数）</td>
</tr>
<tr>
<td>Root Delay</td>
<td>32</td>
<td>到主参考时钟的总往返延迟时间。</td>
</tr>
<tr>
<td>Root Dispersion</td>
<td>32</td>
<td>本地时钟相对于主参考时钟的最大误差。</td>
</tr>
<tr>
<td>Reference Identifier</td>
<td>32</td>
<td>标识特定参考时钟。</td>
</tr>
<tr>
<td>Reference Timestamp</td>
<td>64</td>
<td>参考时间戳，本地时钟最后一次被设定或更新的时间。如果值为0表示本地时钟从未被同步过。</td>
</tr>
<tr>
<td>Originate Timestamp</td>
<td>64</td>
<td>原始时间戳，NTP报文离开源端时的本地时间。</td>
</tr>
<tr>
<td>Receive Timestamp</td>
<td>64</td>
<td>接受时间戳，NTP报文到达目的端的本地时间。</td>
</tr>
<tr>
<td>Transmit Timestamp</td>
<td>64</td>
<td>传送时间戳目的端应答报文离开服务器端的本地时间。</td>
</tr>
<tr>
<td>Authenticator</td>
<td>96</td>
<td>（可选）验证信息。</td>
</tr>
</tbody></table>
<p><strong>控制报文格式</strong></p>
<p><img src="/images/net/ntp_packet.png"></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>长度(bit)</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>2</td>
<td>保留位。NTP本身不做处理。</td>
</tr>
<tr>
<td>VN（Version Number）</td>
<td>3</td>
<td>NTP的版本号，目前值为3。</td>
</tr>
<tr>
<td>6</td>
<td>3</td>
<td>表明是控制报文。</td>
</tr>
<tr>
<td>REM</td>
<td>3</td>
<td>R：0表示命令，1表示响应。 E：0表示发送正常响应，1表示发送错误响应。 M：0表示最后一个分片，1表示其他。</td>
</tr>
<tr>
<td>Op</td>
<td>5</td>
<td>操作码，表明命令的类型。</td>
</tr>
<tr>
<td>Sequence</td>
<td>16</td>
<td>发送或接受到报文的顺序号。</td>
</tr>
<tr>
<td>Status</td>
<td>16</td>
<td>表明当前系统的状态。</td>
</tr>
<tr>
<td>Association ID</td>
<td>16</td>
<td>连接标示。</td>
</tr>
<tr>
<td>Offset</td>
<td>16</td>
<td>偏移量。</td>
</tr>
<tr>
<td>Count</td>
<td>16</td>
<td>数据域的长度。</td>
</tr>
<tr>
<td>Data</td>
<td>最大468</td>
<td>包括发送报文或接受报文中的数据信息。</td>
</tr>
<tr>
<td>Padding</td>
<td>16</td>
<td>填充字段。</td>
</tr>
<tr>
<td>Authenticator</td>
<td>96</td>
<td>（可选）验证信息。</td>
</tr>
</tbody></table>
<hr>
<p><a href="https://www.cnblogs.com/hankgo/p/15586190.html">https://www.cnblogs.com/hankgo/p/15586190.html</a></p>
<p><a href="https://blog.csdn.net/xiaotian_muzi/article/details/90718222">https://blog.csdn.net/xiaotian_muzi/article/details/90718222</a></p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>ntp</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP and UDP</title>
    <url>/2022/06/21/net/tcp-udp/</url>
    <content><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP(Transmission Control Protocol)传输层控制协议是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<ul>
<li>面向连接：只能是一对一连接，不能向多个主机发送消息，故不能广播和多播。</li>
<li>可靠的：无论网络链路怎样变化，都能保证报文到达接收端。</li>
<li>字节流：无论消息多大都可以传输，并且消息是有序的。</li>
</ul>
<p>建立一个TCP连接需要客户端与服务器端达成三个共识:</p>
<ul>
<li>Socket：由 IP 地址和端口号组成</li>
<li>序列号：保证数据包不重复、不丢弃和按序传输，用来解决乱序问题等</li>
<li>窗口大小：用来做流量控制</li>
</ul>
<p>TCP通过源地址、目的地址、源端口和目的端口可以确定一个唯一的连接。</p>
<p>服务器上TCP的最大连接数理论上等于客户端IP数 × 客户端端口数，但实际上会受到内存和socket文件描述符（ulimit配置）的限制。</p>
<p>TCP负载数据⻓度 = IP 总⻓度 - IP 首部⻓度 - TCP 首部⻓度。</p>
<p>TCP具有流量控制、超时重传、拥塞控制、数据校验、数据分片排序等特性来保证数据可靠传输。</p>
<ul>
<li>TCP 使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP 给数据分片进行排序，并使用累积确认保证数据的顺序不变和非重复</li>
<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>
<p>应用程序通过打开一个socket 来使用TCP服务，TCP管理socket 的数据传递。连接操作的第一步是在 TCP 模块处创建表示连接控制信息的头部。当 TCP 头部创建好之后， TCP 模块会将信息传递给 IP 模块并委托它发送 给服务器 。服务器根据TCP 头部中的发送方和接收方端口号可以找到要连接的套接字。</p>
<p>TCP 为了防止发送方无脑的发送数据，导致接收方缓冲区被填满，所以就有了滑动窗口的机制，它可利用接收方的接收窗口来控制发送方要发送的数据量，也就是流量控制。</p>
<p><img src="/images/net/tcpip/tcp_head.png" alt="tcp_head"></p>
<h3 id="TCP分片"><a href="#TCP分片" class="headerlink" title="TCP分片"></a>TCP分片</h3><p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传，如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传，缺乏效率。</p>
<ul>
<li>MTU :一个网络包的最大⻓度，在以太网中一般是 1500 字节。</li>
<li>MSS :除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大⻓度。</li>
</ul>
<p><img src="/images/net/tcpip/mss.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看MTU值</span></span><br><span class="line">cat /sys/class/net/eth0/mtu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改MTU值</span></span><br><span class="line">echo &quot;1400&quot; &gt; /sys/class/net/eth0/mtu</span><br></pre></td></tr></table></figure>

<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。连接之前服务端处于 LISTEN 状态主动监听某个端口，客户端执行connect()时，将触发三次握手。</p>
<p><img src="/images/net/tcpip/tcp-link3.jpg" alt="tcp-link3"></p>
<ol>
<li><p>客户端发送连接请求报文给服务器，将SYN位置1，表示 SYN 报文。同时客户端将初始化的序号，放在包头的序列号字段里。</p>
</li>
<li><p>服务器收到客户端的 SYN 报文之后，把 SYN和ACK 标志位置1，随机初始化自己的序号，并填入序列号字段中，把客户端的 ISN + 1 作为 ACK 的值，表示同意建立连接。</p>
</li>
<li><p>客户端收到服务端 SYN 报文之后，还要回应一个应答报文，表示已经收到了服务端发的同意报文。先将 ACK 标志位置1，自身序列号+1，把服务器的 ISN + 1 作为 ACK 的值。</p>
</li>
<li><p>服务端收到客户端的 ACK，连接已建立，可以数据传输。</p>
</li>
</ol>
<p>在三次连接中，只有第三次握手是可以携带数据的，前两次握手是不可以携带数据的。可以通过<code>netstat -napt</code>命令查看TCP 的连接状态。</p>
<p>之所以需要三次握中，是因为至少需要三次才能初始化确定Socket、序列号和窗口大小等 TCP 连接信息，进而建立可靠的连接。超过3次会有延迟的历史已失效的连接。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>TCP 的连接的断开需要发送四个包，因此称为四次挥手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p>
<p><img src="/images/net/tcpip/tcp-unlink4.jpg" alt="tcp-unlink4"></p>
<ol>
<li>客户端发送 FIN 报文给服务器，将FIN位置1，随机设置序列号，请求释放从客户端到服务器的连接。</li>
<li>服务器接收到客户端发的 FIN，并回复 ACK 给客户端，将客户端的序列号值 +1 作为 ACK 的值，表明同意释放从客户端到服务器的连接。</li>
<li>客户端收到服务端回复的 ACK，，此时从客户端到服务器的连接已释放，但服务端到客户端的连接还未释放，并且客户端还可以接收数据。</li>
<li>服务端继续发送之前没发完的数据给客户端；</li>
<li>服务端发送 FIN+ACK 给客户端，指定一个序列号，请求释放从服务端到客户端的连接。发送完毕后，等待客户端的确认。就算没收到客户端的回复，过了时间也会自动释放。</li>
<li>客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端，将服务端的序列号值+1 作为 ACK 的值，表明同意释放从服务端到客户端的连接，并等待可能出现的要求重传的 ACK 包。</li>
<li>客户端等待了2MSL后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己会关闭连接。</li>
<li>服务端收到客户端的 ACK 后，释放从服务端到客户端的连接，至此连接完全关闭。</li>
</ol>
<p>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</p>
<p>释放连接时，因服务器可能还有数据需要传输给客户端，所以 ACK 和 FIN 要分开发送，先响应客户端 FIN 请求，然后数据传输，传输完成后，服务端再提出 FIN 请求。而连接时因为没有数据要传输，所以 ACK 和 SYN 可以一起发送。</p>
<p>MSL(Maximum Segment Lifetime)报文最大生存时间，它是任何报文在网络上存在的最⻓时间，超过这个时间报文将被丢弃，保证下次连接不会出现旧的连接报文，同时确保这个时间内客户端发送的最后一个 ACK 报文能够到达服务端。2MSL时间是从客户端接收到 FIN 后发送 ACK 开始计时的，如果在 TIME_WAIT 时间内，因为客户端的 ACK没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL时间将重新计时。TIME_WAIT 是2 倍的 MSL，要修改 TIME_WAIT 的时间⻓度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译内核。</p>
<h3 id="内核的TCP参数"><a href="#内核的TCP参数" class="headerlink" title="内核的TCP参数"></a>内核的TCP参数</h3><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP利用 IP 提供面向无连接的通信服务，支持一对一、一对多、多对多的交互通信。不提供复杂的控制机制，只负责发送数据包，不保证数据包是否能抵达对方，实时性和传输效率相对更好。当然UDP要实现可靠传输，就要在应用层上实现TCP 的特性。</p>
<ul>
<li><p>UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次</p>
</li>
<li><p>UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。</p>
</li>
<li><p>UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。</p>
</li>
<li><p>UDP 支持多播和广播。</p>
</li>
</ul>
<p><img src="/images/net/tcpip/udp_head.png" alt="udp head"></p>
<h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><ol>
<li>TCP 是面向连接的，传输数据前先要建立连接，UDP 是不需要连接，直接传输数据。</li>
<li>TCP 只能一对一通信，UDP 支持一对一、一对多、多对多的交互通信。</li>
<li>TCP是面向字节流的，UDP是基于数据报。</li>
<li>TCP 保证可靠，UDP 不保证可靠交付数据。</li>
<li>TCP 有拥塞控制和流量控制机制，UDP 则没有。</li>
<li>TCP 头部长度较长，而且有可变长字段，UDP 固定8字节，开销较小。</li>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，有边界，可能会丢包和乱序。</li>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。</li>
<li>TCP用于FTP 文件传输、HTTP / HTTPS。UDP用于视频、音频等多媒体通信、广播通信场景。</li>
<li>TCP 有可变长字段，所以要有头部长度字段。而 UDP 头部长度是固定的，无需多一个字段去记录 UDP头部长度。</li>
<li>TCP头部没有包长度字段，UDP头部有包长度字段。</li>
</ol>
<hr>
<p><a href="https://www.cnblogs.com/linyfeng/p/9496126.html">https://www.cnblogs.com/linyfeng/p/9496126.html</a></p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
  </entry>
  <entry>
    <title>TCP/IP 网络模型</title>
    <url>/2022/06/21/net/tcpip/</url>
    <content><![CDATA[<h2 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP/IP 模型"></a>TCP/IP 模型</h2><table>
<thead>
<tr>
<th>分层</th>
<th>作用</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>负责给应用程序提供统一的接口</td>
<td>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</td>
</tr>
<tr>
<td>表示层</td>
<td>负责把数据转换成能识别的格式，对数据进行翻译、加密和压缩</td>
<td>JPEG、MPEG、ASII</td>
</tr>
<tr>
<td>会话层</td>
<td>建立、管理和终止会话</td>
<td>NFS、SQL、NETBIOS、RPC</td>
</tr>
<tr>
<td>传输层</td>
<td>负责端到端的可靠报文传递和流量控制</td>
<td>TCP、UDP、SPX</td>
</tr>
<tr>
<td>网络层</td>
<td>负责数据的路由、转发、分片，实现两个端系统之间的数据透明传送</td>
<td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>负责数据的封帧、流量控制、差错检测和重发，及 MAC 寻址</td>
<td>PPP、FR、HDLC、VLAN、MAC（网桥，交换机）</td>
</tr>
<tr>
<td>物理层</td>
<td>负责把数据包转换成电信号，在物理介质中传输数据帧</td>
<td>RJ45、CLOCK、IEEE802.3（中继器，集线器）</td>
</tr>
</tbody></table>
<p><img src="/images/net/tcpip/OSI.png" alt="img"></p>
<p>OSI 模型只是概念理论上的分层，并没有提供具体的实现方案，实际应用中采用的是更为简化的 TCP/IP 模型。</p>
<p><img src="/images/net/tcpip/tcp-ip-arch.webp" alt="img"></p>
<p><img src="/images/net/tcpip/tcp_ip_pack.bmp" alt="tcp_ip_pack"></p>
<h2 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h2><p>ADSL(Asymmetric Digital Subscriber Line)不对称数字用户线，是一种利用架设在电线杆上的金属电话线来进行高速通信的技术，它的上行方向(用户到互联网)和下行方向(互联网到用户)的通信速率是不对称的。</p>
<p>用户端路由器发出的网络包通过ADSL Modem调制解调器和电话线到达电话局，然后到达 ADSL 的网络运营商(即 ISP，互联网服务提供商)。</p>
<p>互联网接入路由器会在网络包前面加上 MAC 头部、PPPoE 头部、PPP 头部，然后发送给 ADSL Modem。ADSL Modem 将包拆分成信元，并调制成电信号发送给分离器。分离器负责将电话和 ADSL 的信号进行分离。</p>
<p><img src="/images/net/modem.png" alt="eth_if"></p>
<p>ADSL采用的调制方式是振幅调制(ASK)和相位调制(PSK)相结合的正交振幅调制(QAM)方式。ADSL 使用间隔为 4.3125 kHz 的上百个不同频率的波进行合成，每个波都采用正交振幅调制。</p>
<p><img src="/images/net/modem2.png" alt="eth_if"></p>
<h2 id="ppp"><a href="#ppp" class="headerlink" title="ppp"></a>ppp</h2><p>PPP (Point-to-Point Protocol)点到点协议。用户向运营商的接入点拨打电话，,电话接通后，输入用户名和密码进行登录操作。用户名和密码通过 RADIUS 协议从 RAS 发送到认证服务器，认证服务器校验这些信息是否正确。当确认无误后,认证服务器会返回 IP 地址等配置信息，为计算机分配一个公有地址。</p>
<p>PPPoE 是将 PPP 消息装入以太网包进行传输的方式。PPP 协议中没有定义以太网中的报头和 FCS 等元素，也没有定义信号的格式，因此无法直接将 PPP 消息转换成信号来发送。</p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
  </entry>
  <entry>
    <title>socket</title>
    <url>/2022/08/27/net/socket/</url>
    <content><![CDATA[<p>套接字用一个相关描述{协议、本地地址、本地端口、远程地址、远程端口}来表示，套接字有3种类型：</p>
<ul>
<li>流式套接字，提供可靠的、面向连接的通信流，使用TCP协议，从而保证了数据传输的正确性和顺序性。</li>
<li>数据报套接字，定义了一种无连接的服务，使用UDP协议，数据通过相互独立的报文进行传输，是无序的，并且不保证是可靠、无差错的。</li>
<li>原始套接字，允许对底层协议如IP或ICMP进行直接访问。</li>
</ul>
<p>描述符是应用程序用来识别套接字的机制，IP 地址和端口号是客户端和服务器之间用来识别对方套接字的机制。</p>
<h2 id="ip地址转换"><a href="#ip地址转换" class="headerlink" title="ip地址转换"></a>ip地址转换</h2><p>网络上数据以大端模式传输，因此需要对网络字节序和主机字节序进行相互转化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> ai_family, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> ai_family, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>inet_pton()函数是将点分十进制地址映射为二进制地址， inet_ntop()函数是将二进制地址映射为点分十进制地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure>

<p>inet_addr()将IPv4点分十进制地址转化为二进制地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> h_errno;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *h_name;         <span class="comment">/* Official name of host.  */</span></span><br><span class="line">  <span class="type">char</span> **h_aliases;     <span class="comment">/* Alias list.  */</span></span><br><span class="line">  <span class="type">int</span> h_addrtype;       <span class="comment">/* Host address type.  */</span></span><br><span class="line">  <span class="type">int</span> h_length;         <span class="comment">/* Length of address.  */</span></span><br><span class="line">  <span class="type">char</span> **h_addr_list;   <span class="comment">/* List of addresses from name server.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_MISC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span>    h_addr  h_addr_list[0] <span class="comment">/* Address, for backward compatibility.*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>       <span class="comment">/* for AF_INET */</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr,</span></span><br><span class="line"><span class="params">                             <span class="type">socklen_t</span> len, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure>

<p>gethostbyname()将主机名或域名转化为IP地址，gethostbyaddr()则将IP地址转化为主机名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>              ai_flags;</span><br><span class="line">    <span class="type">int</span>              ai_family;</span><br><span class="line">    <span class="type">int</span>              ai_socktype;</span><br><span class="line">    <span class="type">int</span>              ai_protocol;</span><br><span class="line">    <span class="type">socklen_t</span>        ai_addrlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span></span><br><span class="line">    <span class="type">char</span>            *ai_canonname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **res)</span>;</span><br></pre></td></tr></table></figure>

<p>getaddrinfo()能自动识别IPv4和IPv6地址。</p>
<h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><p><img src="/images/net/tcpip/socket.png" alt="img"></p>
<p><strong>socket创建</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>       </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p>domain协议族：</p>
<ul>
<li>AF_INET:IPv4协议</li>
<li>AF_INET6:IPv6协议</li>
<li>AF_LOCAL AF_UNIX:UNIX 域协议</li>
<li>AF_ROUTE:路由套接字</li>
<li>AF_KEY:密钥套接字</li>
<li>AF_LINK:链路地址协议</li>
</ul>
<p>type套接字类型：</p>
<ul>
<li>SOCK_STREAM 流套接字</li>
<li>SOCK_DGRAM  数据报套接字</li>
<li>SOCK_RAW    原始套接字</li>
</ul>
<p>protocol为0，原始套接字除外。</p>
<p><strong>socket连接</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];      <span class="comment">/*14 字节的协议地址,包含该 socket 的 IP 地址和端口号。*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INADDR_ANY      ((in_addr_t) 0x00000000)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sa_family;         <span class="comment">/*地址族*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_port; <span class="comment">/*端口号*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">/*IP地址，为0表示允许任何地址*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];   <span class="comment">/*填充 0 以保持与 struct sockaddr 同样大小*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sockaddr 和sockaddr_in结构体都是用来保存socket信息，两者数据类型等效，可以相互转化。服务端设置ip时，可以用INADDR_ANY 自动获取当前服务器的IP。</p>
<p>sin_addr 和 sin_port 分别封装在包的 IP 和 UDP 层。因此，它们必须要 是网络字节顺序。但是 sin_family 域只是被内核使用来决定在数据结构中包含什么类型的地址，并没有发送到网络上，所以它必须是本机字节顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>bind()将本地IP地址绑定到端口号，不能绑定其他IP 地址，它适用于TCP 连接。</p>
<p>listen()创建一个等待队列，用来存放未处理的客户端连接请求。backlog参数指定请求队列中允许的最大请求数，默认为5。</p>
<p>accept()函数从请求队列中取出第一个未处理的连接请求。</p>
<p>connect()函数在TCP中用于bind之后的client端与服务器端建立连接。</p>
<p><strong>socket读写</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>  *iov_base;              <span class="comment">/* Starting address */</span></span><br><span class="line">   <span class="type">size_t</span> iov_len;               <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>         *msg_name;       <span class="comment">/* optional address */</span></span><br><span class="line">   <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">/* size of address */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* scatter/gather array */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">   <span class="type">void</span>         *msg_control;    <span class="comment">/* ancillary data, see below */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_controllen; <span class="comment">/* ancillary data buffer len */</span></span><br><span class="line">   <span class="type">int</span>           msg_flags;      <span class="comment">/* flags on received message */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p><code>SO_RCVBUF</code>选项对UNIX域套接字无效，其默认值由<code>/proc/sys/net/core/wmem_default</code>设置。</p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump 使用指南</title>
    <url>/2022/06/26/net/tcpdump/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump [ -AdDeflLnNOpqRStuUvxX ] [ -c count ]</span><br><span class="line">           [ -C file_size ] [ -F file ]</span><br><span class="line">           [ -i interface ] [ -m module ] [ -M secret ]</span><br><span class="line">           [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]</span><br><span class="line">           [ -W filecount ]</span><br><span class="line">           [ -E spi@ipaddr algo:secret,...  ]</span><br><span class="line">           [ -y datalinktype ] [ -Z user ]</span><br><span class="line">           [ expression ]</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p><img src="/images/net/tcpdump.png"></p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>可以使用表达式过滤指定类型的流量，有三种主要的表达式类型：</p>
<ul>
<li>类型（type）选项包含：host, net, port, portrange</li>
<li>方向（dir）选项包含：src, dst, src or dst</li>
<li>协议（proto）选项包含：tcp, udp, icmp, ip, ip6, arp, rarp,ether,wlan, fddi, tr, decnet</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>捕获所有流量</strong></p>
<pre><code>tcpdump -i any
</code></pre>
<p><strong>指定网卡接口</strong></p>
<pre><code>tcpdump -i eth0
</code></pre>
<p><strong>基于IP地址过滤</strong></p>
<pre><code>tcpdump host 192.168.10.100
</code></pre>
<p><strong>查看包中的内容时，使用hex格式输出</strong></p>
<pre><code>tcpdump -nnvXSs 0 -c1 icmp
</code></pre>
<p><strong>使用源和目的地址过滤</strong></p>
<pre><code>tcpdump src 2.3.4.6
tcpdump dst 3.4.5.6
</code></pre>
<p><strong>基于网段进行过滤</strong></p>
<pre><code>tcpdump net 192.168.10.0/24
</code></pre>
<p><strong>基于端口进行过滤</strong></p>
<pre><code>tcpdump port 8088
</code></pre>
<p><strong>过滤指定协议</strong></p>
<pre><code>tcpdump icmp
</code></pre>
<p><strong>只显示IPV6流量</strong></p>
<pre><code>tcpdump ip6
</code></pre>
<p><strong>使用端口范围过滤</strong></p>
<pre><code>tcpdump portrange 21-23
</code></pre>
<p><strong>基于包的大小过滤流量</strong></p>
<pre><code>tcpdump less 32
tcpdump greater 64
tcpdump &lt;=128
</code></pre>
<p><strong>过滤广播/多播数据包</strong></p>
<pre><code>tcpdump ip broadcast
tcpdump ip multicast
</code></pre>
<p><strong>将捕获的内容写入文件</strong></p>
<pre><code>tcpdump port 8080 -w capturefile.pcap
</code></pre>
<p><strong>使用tcpdump加载之前保存的文件进行分析</strong></p>
<pre><code>tcpdump -r capturefile.pcap
</code></pre>
<p><strong>设置不解析域名提升速度</strong></p>
<ul>
<li><code>-n</code>：不把ip转化成域名，直接显示 ip，避免执行 DNS lookups 的过程，速度会快很多</li>
<li><code>-nn</code>：不把协议和端口号转化成名字，速度也会快很多。</li>
<li><code>-N</code>：不打印出host 的域名部分.。比如,，如果设置了此选现，tcpdump 将会打印’nic’ 而不是 ‘nic.ddn.mil’.</li>
</ul>
<p><strong>控制详细内容的输出</strong></p>
<ul>
<li><code>-v</code>：产生详细的输出. 比如包的TTL，id标识，数据包长度，以及IP包的一些选项。同时它还会打开一些附加的包完整性检测，比如对IP或ICMP包头部的校验和。</li>
<li><code>-vv</code>：产生比-v更详细的输出. 比如NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码。（摘自网络，目前我还未使用过）</li>
<li><code>-vvv</code>：产生比-vv更详细的输出。比如 telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面，其相应的图形选项将会以16进制的方式打印出来（摘自网络，目前我还未使用过）</li>
</ul>
<p><strong>控制时间的显示</strong></p>
<ul>
<li><code>-t</code>：在每行的输出中不输出时间</li>
<li><code>-tt</code>：在每行的输出中会输出时间戳</li>
<li><code>-ttt</code>：输出每两行打印的时间间隔(以毫秒为单位)</li>
<li><code>-tttt</code>：在每行打印的时间戳之前添加日期的打印（此种选项，输出的时间最直观）</li>
</ul>
<p><strong>显示数据包的头部</strong></p>
<ul>
<li><code>-x</code>：以16进制的形式打印每个包的头部数据（但不包括数据链路层的头部）</li>
<li><code>-xx</code>：以16进制的形式打印每个包的头部数据（包括数据链路层的头部）</li>
<li><code>-X</code>：以16进制和 ASCII码形式打印出每个包的数据(但不包括连接层的头部)，这在分析一些新协议的数据包很方便。</li>
<li><code>-XX</code>：以16进制和 ASCII码形式打印出每个包的数据(包括连接层的头部)，这在分析一些新协议的数据包很方便。</li>
</ul>
<p><strong>对输出内容进行控制的参数</strong></p>
<ul>
<li><code>-D</code> : 显示所有可用网络接口的列表</li>
<li><code>-e</code> : 每行的打印输出中将包括数据包的数据链路层头部信息</li>
<li><code>-E</code> : 揭秘IPSEC数据</li>
<li><code>-L</code> ：列出指定网络接口所支持的数据链路层的类型后退出</li>
<li><code>-Z</code>：后接用户名，在抓包时会受到权限的限制。如果以root用户启动tcpdump，tcpdump将会有超级用户权限。</li>
<li><code>-d</code>：打印出易读的包匹配码</li>
<li><code>-dd</code>：以C语言的形式打印出包匹配码.</li>
<li><code>-ddd</code>：以十进制数的形式打印出包匹配码</li>
</ul>
<h2 id="过滤规则组合"><a href="#过滤规则组合" class="headerlink" title="过滤规则组合"></a>过滤规则组合</h2><ul>
<li>and：所有的条件都需要满足，也可以表示为 <code>&amp;&amp;</code></li>
<li>or：只要有一个条件满足就可以，也可以表示为 <code>||</code></li>
<li>not：取反，也可以使用 <code>!</code></li>
</ul>
<p>当你在使用多个过滤器进行组合时，有可能需要用到括号，而括号在 shell 中是特殊符号，因为你需要使用引号将其包含。例子如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump &#x27;src 10.0.2.4 and (dst port 8090 or 22)&#x27;</span><br></pre></td></tr></table></figure>

<p>而在单个过滤器里，常常会判断一条件是否成立，这时候，就要使用下面两个符号</p>
<ul>
<li><code>=</code>：判断二者相等</li>
<li><code>==</code>：判断二者相等</li>
<li><code>!=</code>：判断二者不相等</li>
</ul>
<p>当你使用这两个符号时，tcpdump 还提供了一些关键字的接口来方便我们进行判断，比如</p>
<ul>
<li>if：表示网卡接口名、</li>
<li>proc：表示进程名</li>
<li>pid：表示进程 id</li>
<li>svc：表示 service class</li>
<li>dir：表示方向，in 和 out</li>
<li>eproc：表示 effective process name</li>
<li>epid：表示 effective process ID</li>
</ul>
<p>比如我现在要过滤来自进程名为 ntp 发出的流经 eth0 网卡的数据包，或者不流经 eth0 的入方向数据包，可以这样子写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump &quot;( if=eth0 and proc=ntp ) || (if != en0 and dir=in)&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://www.cnblogs.com/wongbingming/p/13212306.html">https://www.cnblogs.com/wongbingming/p/13212306.html</a></p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>wifi 调试工具</title>
    <url>/2022/06/07/net/wifi-tool/</url>
    <content><![CDATA[<p>wext为linux-2.6.18版本之前实现方式；用户空间使用ioctl方式访问驱动，设置无线参数或者获取无线参数，配置无线驱动进行联网操作；无线驱动事件到应用层的传递采用的netlink socket技术。</p>
<p>linux-2.6.18以后wifi驱动实现方式增加了nl80211，无论是用户层访问驱动还是驱动事件通知应用层、都采用的netlink技术。</p>
<p>用<code>lsusb</code>命令查看USB ID号，无线网上的硬件id为：0bda:xxxx。</p>
<h2 id="wpa-supplicant"><a href="#wpa-supplicant" class="headerlink" title="wpa_supplicant"></a>wpa_supplicant</h2><p>支持OPEN、WEP、WPA(TKIP)、WPA2(AES)无线加密方式。下载地址：<a href="https://w1.fi/releases/">https://w1.fi/releases/</a><br>wpa_supplicant-0.8以前的版本，编译前对.config文件进行裁剪，去掉一些功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#CONFIG_DRIVER_HOSTAP=y</span><br><span class="line">#CONFIG_DRIVER_ATMEL=y</span><br><span class="line">#CONFIG_DRIVER_NL80211=y</span><br><span class="line">#CONFIG_DRIVER_WIRED=y</span><br><span class="line">CONFIG_WPS=y</span><br><span class="line">CONFIG_TLS=internal</span><br><span class="line">CONFIG_INTERNAL_LIBTOMMATH=y</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp defconfig .config</span><br><span class="line">make CC=arm-himix100-linux-gcc clean</span><br><span class="line">make CC=arm-himix100-linux-gcc -j4</span><br><span class="line">arm-himix100-linux-strip wpa_supplicant</span><br></pre></td></tr></table></figure>

<p>依赖libnl，openssl，dbus库，Makefie修改：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS += -I/home/luo_u/usr/hisi/dbus-1.12.10/<span class="keyword">include</span>/dbus-1.0</span><br><span class="line">LIBS += -L/home/luo_u/usr/hisi/dbus-1.12.10/lib -ldbus-1</span><br><span class="line">CFLAGS += -I/home/luo_u/usr/hisi/expat-2.2.9/<span class="keyword">include</span>/</span><br><span class="line">LIBS += -L/home/luo_u/usr/hisi/expat-2.2.9/lib </span><br><span class="line">CFLAGS += -I/home/luo_u/usr/hisi/openssl-1.1.1/<span class="keyword">include</span></span><br><span class="line">LIBS += -L/home/luo_u/usr/hisi/openssl-1.1.1/lib </span><br><span class="line">CFLAGS += -I/home/luo_u/usr/hisi/libnl-3.4.0/<span class="keyword">include</span>/libnl3</span><br><span class="line">LIBS += -L/home/luo_u/usr/hisi/libnl-3.4.0/lib </span><br></pre></td></tr></table></figure>

<p><a href="http://www.linuxfromscratch.org/blfs/view/svn/basicnet/wpa_supplicant.html">http://www.linuxfromscratch.org/blfs/view/svn/basicnet/wpa_supplicant.html</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">ctrl_interface=/var/run/wpa_supplicant/</span><br><span class="line">update_config=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">network=<span class="punctuation">&#123;</span></span><br><span class="line">    ssid=<span class="string">&quot;SECULINK  R&amp;D&quot;</span></span><br><span class="line">    scan_ssid=<span class="number">1</span></span><br><span class="line">    psk=<span class="string">&quot;secueye1&quot;</span></span><br><span class="line">    key_mgmt=WPA-PSK WPA-EAP IEEE8021X NONE</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">#连接无密码的ssid字段，需要添加key_mgmt=NONE去连接这个网络</span><br><span class="line">network=<span class="punctuation">&#123;</span></span><br><span class="line">        key_mgmt=NONE</span><br><span class="line">        ssid=<span class="string">&quot;wifi-name&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./wpa_supplicant -i wlan0 -D wext -c wpa_supplicant.conf -B -dd</span><br></pre></td></tr></table></figure>

<p>加<code>-dd</code>选项，显示调试打印。</p>
<ul>
<li><strong>错误</strong></li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">rfkill: <span class="title">Cannot</span> <span class="title">open</span> <span class="title">RFKILL</span> <span class="title">control</span> <span class="title">device</span></span></span><br></pre></td></tr></table></figure>

<p>打开rfkill失败，这是一个控制接口应该在/dev/rfkill，看了下板子上，确实没有这个设备接口。打开内核配置<code>CONFIG_RFKILL</code></p>
<h2 id="wpa-cli"><a href="#wpa-cli" class="headerlink" title="wpa_cli"></a>wpa_cli</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpa_cli -i wlan0 scan 　       #搜索wifi热点</span><br><span class="line">wpa_cli -i wlan0 scan_result 　#显示搜索wifi热点</span><br><span class="line">wpa_cli -i wlan0 status      　#当前WPA/EAPOL/EAP通讯状态</span><br><span class="line">wpa_cli -i wlan0 ping        　#ping wpa_supplicant</span><br><span class="line"></span><br><span class="line">wpa_cli -i wlan0 add_network   #添加一个网络连接,会返回&lt;network id&gt;</span><br><span class="line">wpa_cli set_network &lt;network id&gt; ssid &#x27;&quot;name&quot;&#x27;  #ssid名称</span><br><span class="line">wpa_cli set_network &lt;network id&gt; psk &#x27;“psk”&#x27;    #密码</span><br><span class="line">wpa_cli set_network &lt;network id&gt; scan_ssid 1</span><br><span class="line">wpa_cli set_network &lt;network id&gt; priority 1     #优先级</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">连接指定的ssid</span></span><br><span class="line">wpa_cli -i wlan0 select_network &lt;network id&gt;   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">连接无密码热点</span></span><br><span class="line">wpa_cli set_network &lt;network id&gt; ssid &quot;wifi-name&quot;</span><br><span class="line">wpa_cli set_network &lt;network id&gt; key_mgmt NONE</span><br><span class="line">       </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">断开连接</span></span><br><span class="line">wpa_cli -i wlan0 disable_network &lt;network id&gt;   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">信息保存到默认的配置文件中</span></span><br><span class="line">wpa_cli -i wlan0 save_config </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列举保存过得连接</span></span><br><span class="line">wpa_cli -i wlan0 list_network     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使能制定的ssid</span></span><br><span class="line">wpa_cli -i wlan0 enable_network &lt;network id&gt;   </span><br></pre></td></tr></table></figure>

<h2 id="iwconfig"><a href="#iwconfig" class="headerlink" title="iwconfig"></a>iwconfig</h2><p>Wireles stools用来设置支持LinuxWireless Extension的无线设备。Wireles stools for Linux 和Linux Wireless Extension 由 Jean Tourrilhes在维护，由HP惠普赞助。</p>
<p>WirelessExtension (WE)是一组通用的API，能在用户空间对通用Wireless LANs进行配置和统计。它的好处在于仅通过一组单一的工具就能对各种各样的WirelessLANs进行管理，不管它们是什么类型，只要其驱动支持WirelessExtension就行；另一个好处就是不用重启驱动或Linux就能改变这些参数。</p>
<p>WirelessTools (WT)就是用来操作Wireless Extensions的工具集，它们使用字符界面，支持所有WirelessExtension。WirelessTools包括以下工具：</p>
<p>-　iwconfig：设置基本无线参数<br>-　iwlist：扫描、列出频率，比特率，密钥等<br>-　iwspy：获取每个节点链接的质量<br>-　iwpriv：操作WirelessExtensions 特定驱动<br>-　ifrename： 基于各种静态标准命名接口</p>
<p>下载地址：<a href="https://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html">https://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html</a><br>修改Makefile，编译。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = arm-himix100-linux-gcc</span><br><span class="line">AR = arm-himix100-linux-ar</span><br><span class="line">RANLIB = arm-himix100-linux-anlib</span><br><span class="line">BUILD_STATIC = y</span><br></pre></td></tr></table></figure>

<p>只适用于OPEN和WEP加密方式。建议用iw工具替代。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iwlist wlan0 scan   #搜索ap</span><br><span class="line">iwconfig wlan0 key &lt;psk&gt;  #验证密码</span><br><span class="line">iwconfig wlan0 key open   #密码验证功能打开</span><br><span class="line">iwconfig wlan0 essid &lt;ssid&gt;  #连接ap</span><br></pre></td></tr></table></figure>

<p>在设置监听模式之前需要将无线网卡down掉，开启监听模式再up，然后在锁定信道.。</p>
<h2 id="iw"><a href="#iw" class="headerlink" title="iw"></a>iw</h2><p>iw 是一种新的基于 nl80211 的用于无线设备的CLI配置实用程序。只能连接 OPEN和WEP 加密方式的热点。下载地址：<a href="https://mirrors.edge.kernel.org/pub/software/network/iw/">https://mirrors.edge.kernel.org/pub/software/network/iw/</a></p>
<p>修改Makefile，依赖libnl库。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = arm-anykav200-linux-uclibcgnueabi-gcc</span><br><span class="line">CFLAGS += -I/home/luoyou/home/usr/anyka/libnl-3.4.0/<span class="keyword">include</span>/libnl3</span><br><span class="line">LIBS += -L/home/luoyou/home/usr/anyka/libnl-3.4.0/lib</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=/home/luoyou/home/usr/anyka/libnl-3.4.0/lib/pkgconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iw help    # 帮助</span><br><span class="line">iw list    # 获得所有设备的功能，如带宽信息和802.11n的信息</span><br><span class="line">iw dev wlan0 scan   # 扫描</span><br><span class="line">iw event            # 监听事件 </span><br><span class="line">iw dev wlan0 link   # 获得链路状态 </span><br><span class="line"></span><br><span class="line">iw wlan0 connect &lt;essid&gt;       # 连接开放的AP</span><br><span class="line">iw wlan0 connect &lt;essid&gt; 2432  # 连接到2432频道的AP </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接WEP的AP，d:default, 0:第0个密码, 1:第0个密码</span></span><br><span class="line">iw wlan0 connect foo keys 0:abcde d:1:123456    </span><br><span class="line"></span><br><span class="line">iw dev wlan1 station dump    # 获取station 的统计信息</span><br><span class="line">iw dev wlan1 station get     # 获得station对应的peer统计信息</span><br><span class="line">iw wlan0 set bitrates legacy-2.4 12 18 24    # 修改传输比特率 </span><br><span class="line">iw dev wlan0 set bitrates mcs-5 4    # 修改tx HT MCS的比特率 </span><br><span class="line">iw dev wlan0 set bitrates mcs-2.4 10  </span><br><span class="line">iw dev wlan0 set bitrates mcs-5  # 清除所有tx比特率和设置的东西来恢复正常</span><br><span class="line">iw dev　set txpower  []   #设置传输功率</span><br><span class="line">iw phy　set txpower  []   #设置传输功率</span><br><span class="line">iw dev wlan0 set power_save on  #设置省电模式</span><br><span class="line">iw dev wlan0 get power_save     #查询当前的节电设定</span><br><span class="line">iw phy phy0 interface add moni0 type monitor  #添加一个monitor接口</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>GitFlow分支策略</title>
    <url>/2022/09/25/tool/GitFlow/</url>
    <content><![CDATA[<p>GitFlow通常包含五种类型的分支：</p>
<ul>
<li><p>Master分支：主干分支，是可以部署到生产环境中的代码，只允许从其他分支合并，不允许向Master分支直接提交代码。</p>
</li>
<li><p>Develop分支：开发分支，用来集成测试最新合入的开发成果，包含要发布到下一个Release的代码。这个主要用于与合并Feature分支合并。</p>
</li>
<li><p>Feature分支：特性分支，从Develop分支拉出，每个新特性的开发对应一个特性分支，用于开发人员提交代码并进行自测。自测完成后，会将Feature分支的代码合并至Develop分支，进入下一个Release。</p>
</li>
<li><p>Release分支：发布分支，发布新版本时，基于Develop分支创建，发布完成后，合并到Master和Develop分支。</p>
</li>
<li><p>Hotfix分支：热修复分支，生产环境发现新Bug时创建的临时分支，问题验证通过后，合并到Master和Develop分支，这样这个改动就会进入下一个Release。</p>
</li>
</ul>
<p>通常开发过程中新特性的开发过程如下：</p>
<ol>
<li><p>从Develop分支拉取一条Feature分支，在此分支上进行新功能开发。</p>
</li>
<li><p>完成开发后，将Feature分支合入到Develop分支，并进行开发环境的验证。</p>
</li>
<li><p>开发环境验证完成后，从Develop分支拉取一条Release分支，到测试环境进行ST/UT测试。</p>
</li>
<li><p>测试发现问题，提问题单修改，代码提交到Release分支上。</p>
</li>
<li><p>问题单都解决完后，可将Release分支合入Master分支。</p>
</li>
<li><p>待发布版本时，直接将Master分支代码部署到生产环境。</p>
</li>
</ol>
<p><img src="/images/git/GitFlow.png" alt="img"></p>
<p>GitFlow的优点是每个分支都有明确的定义，严格按照GitFlow管理项目代码的话，很难出现代码混乱。其缺点是：如果特性分支过多的话很容易造成代码冲突，从而提高了合入的成本。由于每次提交都涉及多个分支，所以不适合提交频率较高的项目。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>beyond compare</title>
    <url>/2022/06/07/tool/beyond_compare/</url>
    <content><![CDATA[<h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><ul>
<li><p>删除C:\Users\xxx\AppData\Roaming\Scooter Software\Beyond Compare 4\文件夹下的所有文件。</p>
</li>
<li><p>修改C:\Users\xxx\AppData\Roaming\Scooter Software\Beyond Compare 4\BCstate.xml配置文件，删除<code>TCheckForUpdatesState</code>字段之间的内容。</p>
</li>
<li><p>删除安装目录下的BCUnrar.dll文件。</p>
</li>
</ul>
<p><strong>密钥</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- BEGIN LICENSE KEY ---</span><br><span class="line">6TTCoWi2N0Pv+o2HGfqUpZfuaMhtf2zX0u1OuNeqTYkKKWh-CKwBWkPUG</span><br><span class="line">3+CiAQ2q4MNPbf0t8+gmPdo+Vyw64aU-zuQQt9d7Q6EcJ+T42by0E+kxf</span><br><span class="line">+q3QLs40H+RD3h5OLjFGpxClodRnTCNoAM39xsWm2aHZI0Z9KdXzLo1fo</span><br><span class="line">1OdNlaptoK17SsxNK-7JUtTztLwBM8BUwWA24ghoeLhFq39FMP+pcdU7R</span><br><span class="line">ttFJoosVk3d-DRrDH0EARo6GXWEeeUgnyjdWKv5ElwrHWw2HMpfFq9VRf</span><br><span class="line">MqcJV00ePAUB4MT3zPE43Tu0BDt-WXYSpUqf7AjaWnBC7MpNfdkS0mWXk</span><br><span class="line">--- END LICENSE KEY -----</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://www.beyondcompare.cc/jiqiao/">https://www.beyondcompare.cc/jiqiao/</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title>perf</title>
    <url>/2022/06/17/tool/binutils/</url>
    <content><![CDATA[<p>GNU binutils是一个二进制工具集。主要包括：</p>
<ul>
<li>ld：gnu链接器；</li>
<li>as：gnu汇编器。</li>
<li>addr2line：把地址转化为文件名和行号；</li>
<li>nm：列出目标文件的符号列表；</li>
<li>objdump：显示目标文件信息；</li>
<li>readelf：显示elf格式的文件信息；</li>
<li>objcopy：拷贝部分section以生成新的可执行文件，elf-&gt;hex,elf-&gt;bin等；</li>
<li>ar：创建，修改，解压一个静态库文件；</li>
<li>size：显示目标文件的节大小；</li>
<li>strings：从目标文件中列出可打印的字符串；</li>
<li>c++filt：过滤c++符号为可识别的c符号；</li>
<li>ranlib：生成库文件中的.o文件索引；</li>
<li>strip：丢弃程序文件中的符号信息。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>config of clang-format</title>
    <url>/2022/06/07/tool/clang-format/</url>
    <content><![CDATA[<p>vscode安装的C/C++插件就自带了clang-format工具，可以很方便的格式化代码，只需将配置文件.clang-format放到工程目录下。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto</span></span><br><span class="line"><span class="attr">Language:</span> <span class="string">Cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预定义样式： LLVM、Google、Chromium、Mozilla、WebKit、Microsoft</span></span><br><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">LLVM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tab宽度</span></span><br><span class="line"><span class="attr">TabWidth:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩进宽度</span></span><br><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问说明符(public、private等)的偏移</span></span><br><span class="line"><span class="attr">AccessModifierOffset:</span> <span class="number">-4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)</span></span><br><span class="line"><span class="attr">AlignAfterOpenBracket:</span> <span class="string">Align</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续赋值时，对齐所有等号</span></span><br><span class="line"><span class="attr">AlignConsecutiveAssignments:</span> <span class="string">AcrossEmptyLines</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续位域</span></span><br><span class="line"><span class="attr">AlignConsecutiveBitFields:</span> <span class="string">Consecutive</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续声明时，对齐所有声明的变量名</span></span><br><span class="line"><span class="attr">AlignConsecutiveDeclarations:</span> <span class="string">AcrossEmptyLines</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续对齐的尾随的注释</span></span><br><span class="line"><span class="attr">AlignTrailingComments:</span> <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># AlignEscapedNewlines: Right</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 左对齐逃脱换行(使用反斜杠换行)的反斜杠</span></span><br><span class="line"><span class="comment"># #AlignEscapedNewlinesLeft: true</span></span><br><span class="line"><span class="comment"># # 水平对齐二元和三元表达式的操作数</span></span><br><span class="line"><span class="comment"># AlignOperands: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 允许函数声明的所有参数在放在下一行</span></span><br><span class="line"><span class="comment"># AllowAllParametersOfDeclarationOnNextLine: false</span></span><br><span class="line"><span class="comment"># # 允许短的块放在同一行</span></span><br><span class="line"><span class="comment"># AllowShortBlocksOnASingleLine: true</span></span><br><span class="line"><span class="comment"># # 允许短的case标签放在同一行</span></span><br><span class="line"><span class="comment"># AllowShortCaseLabelsOnASingleLine: true</span></span><br><span class="line"><span class="comment"># # 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All</span></span><br><span class="line"><span class="comment"># AllowShortFunctionsOnASingleLine: Empty</span></span><br><span class="line"><span class="comment"># # 允许短的if语句保持在同一行</span></span><br><span class="line"><span class="comment"># AllowShortIfStatementsOnASingleLine: false</span></span><br><span class="line"><span class="comment"># # 允许短的循环保持在同一行</span></span><br><span class="line"><span class="comment"># AllowShortLoopsOnASingleLine: false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 总是在定义返回类型后换行(deprecated)</span></span><br><span class="line"><span class="comment"># AlwaysBreakAfterDefinitionReturnType: None</span></span><br><span class="line"><span class="comment"># # 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数), </span></span><br><span class="line"><span class="comment"># #   AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)</span></span><br><span class="line"><span class="comment"># AlwaysBreakAfterReturnType: None</span></span><br><span class="line"><span class="comment"># # 总是在多行string字面量前换行</span></span><br><span class="line"><span class="comment"># AlwaysBreakBeforeMultilineStrings: false</span></span><br><span class="line"><span class="comment"># # 总是在template声明后换行</span></span><br><span class="line"><span class="comment"># AlwaysBreakTemplateDeclarations: false</span></span><br><span class="line"><span class="comment"># # false表示函数实参要么都在同一行，要么都各自一行</span></span><br><span class="line"><span class="comment"># BinPackArguments: true</span></span><br><span class="line"><span class="comment"># # false表示所有形参要么都在同一行，要么都各自一行</span></span><br><span class="line"><span class="comment"># BinPackParameters: false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)</span></span><br><span class="line"><span class="comment"># BreakBeforeBinaryOperators: None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似), </span></span><br><span class="line"><span class="comment">#   Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似), </span></span><br><span class="line"><span class="comment">#   Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom</span></span><br><span class="line"><span class="comment">#   注：这里认为语句块也属于函数</span></span><br><span class="line"><span class="attr">BreakBeforeBraces:</span> <span class="string">Custom</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 在三元运算符前换行</span></span><br><span class="line"><span class="comment"># BreakBeforeTernaryOperators: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效</span></span><br><span class="line"><span class="attr">BraceWrapping:</span></span><br><span class="line">  <span class="comment"># class定义后面</span></span><br><span class="line">  <span class="attr">AfterClass:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#   # 控制语句后面</span></span><br><span class="line"><span class="comment">#   AfterControlStatement: false</span></span><br><span class="line"><span class="comment">#   # enum定义后面</span></span><br><span class="line"><span class="comment">#   AfterEnum: false</span></span><br><span class="line"><span class="comment">#   # 函数定义后面</span></span><br><span class="line"><span class="comment">#   AfterFunction: true</span></span><br><span class="line"><span class="comment">#   # 命名空间定义后面</span></span><br><span class="line"><span class="comment">#   AfterNamespace: false</span></span><br><span class="line"><span class="comment">#   # ObjC定义后面</span></span><br><span class="line"><span class="comment">#   AfterObjCDeclaration: false</span></span><br><span class="line"><span class="comment">#   # struct定义后面</span></span><br><span class="line"><span class="comment">#   AfterStruct: true</span></span><br><span class="line"><span class="comment">#   # union定义后面</span></span><br><span class="line"><span class="comment">#   AfterUnion: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#   AfterExternBlock: false</span></span><br><span class="line"><span class="comment">#   # catch之前</span></span><br><span class="line"><span class="comment">#   BeforeCatch: true</span></span><br><span class="line"><span class="comment">#   # else之前</span></span><br><span class="line"><span class="comment">#   BeforeElse: true</span></span><br><span class="line"><span class="comment">#   # 缩进大括号</span></span><br><span class="line"><span class="comment">#   IndentBraces: false</span></span><br><span class="line"><span class="comment">#   SplitEmptyFunction: true</span></span><br><span class="line"><span class="comment">#   SplitEmptyRecord: true</span></span><br><span class="line"><span class="comment">#   SplitEmptyNamespace: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 在构造函数的初始化列表的逗号前换行</span></span><br><span class="line"><span class="comment"># BreakConstructorInitializersBeforeComma: false</span></span><br><span class="line"><span class="comment"># BreakConstructorInitializers: BeforeColon</span></span><br><span class="line"><span class="comment"># # 每行字符的限制，0表示没有限制</span></span><br><span class="line"><span class="comment"># ColumnLimit: 120</span></span><br><span class="line"><span class="comment"># # 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变</span></span><br><span class="line"><span class="comment"># CommentPragmas: &#x27;^ IWYU pragma:&#x27;</span></span><br><span class="line"><span class="comment"># CompactNamespaces: false</span></span><br><span class="line"><span class="comment"># # 构造函数的初始化列表要么都在同一行，要么都各自一行</span></span><br><span class="line"><span class="comment"># ConstructorInitializerAllOnOneLineOrOnePerLine: false</span></span><br><span class="line"><span class="comment"># # 构造函数的初始化列表的缩进宽度</span></span><br><span class="line"><span class="comment"># ConstructorInitializerIndentWidth: 4</span></span><br><span class="line"><span class="comment"># # 延续的行的缩进宽度</span></span><br><span class="line"><span class="comment"># ContinuationIndentWidth: 4</span></span><br><span class="line"><span class="comment"># # 去除C++11的列表初始化的大括号&#123;后和&#125;前的空格</span></span><br><span class="line"><span class="comment"># Cpp11BracedListStyle: true</span></span><br><span class="line"><span class="comment"># # 继承最常用的指针和引用的对齐方式</span></span><br><span class="line"><span class="comment"># DerivePointerAlignment: false</span></span><br><span class="line"><span class="comment"># # 关闭格式化</span></span><br><span class="line"><span class="comment"># DisableFormat: false</span></span><br><span class="line"><span class="comment"># # 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)</span></span><br><span class="line"><span class="comment"># ExperimentalAutoDetectBinPacking: false</span></span><br><span class="line"><span class="comment"># # 需要被解读为foreach循环而不是函数调用的宏</span></span><br><span class="line"><span class="comment"># ForEachMacros: [ foreach, Q_FOREACH, BOOST_FOREACH ]</span></span><br><span class="line"><span class="comment"># # 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，</span></span><br><span class="line"><span class="comment"># #   可以定义负数优先级从而保证某些#include永远在最前面</span></span><br><span class="line"><span class="comment"># IncludeCategories: </span></span><br><span class="line"><span class="comment">#   - Regex: &#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27;</span></span><br><span class="line"><span class="comment">#     Priority: 2</span></span><br><span class="line"><span class="comment">#   - Regex: &#x27;^(&lt;|&quot;(gtest|isl|json)/)&#x27;</span></span><br><span class="line"><span class="comment">#     Priority: 3</span></span><br><span class="line"><span class="comment">#   - Regex: &#x27;.*&#x27;</span></span><br><span class="line"><span class="comment">#     Priority: 1</span></span><br><span class="line"><span class="comment"># # 缩进case标签</span></span><br><span class="line"><span class="comment"># IndentCaseLabels: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># IndentPPDirectives:  AfterHash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 函数返回类型换行时，缩进函数声明或函数定义的函数名</span></span><br><span class="line"><span class="comment"># IndentWrappedFunctionNames: false</span></span><br><span class="line"><span class="comment"># # 保留在块开始处的空行</span></span><br><span class="line"><span class="comment"># KeepEmptyLinesAtTheStartOfBlocks: false</span></span><br><span class="line"><span class="comment"># # 开始一个块的宏的正则表达式</span></span><br><span class="line"><span class="comment"># MacroBlockBegin: &#x27;&#x27;</span></span><br><span class="line"><span class="comment"># # 结束一个块的宏的正则表达式</span></span><br><span class="line"><span class="comment"># MacroBlockEnd: &#x27;&#x27;</span></span><br><span class="line"><span class="comment"># # 连续空行的最大数量</span></span><br><span class="line"><span class="comment"># MaxEmptyLinesToKeep: 1</span></span><br><span class="line"><span class="comment"># # 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All</span></span><br><span class="line"><span class="comment"># NamespaceIndentation: Inner</span></span><br><span class="line"><span class="comment"># # 使用ObjC块时缩进宽度</span></span><br><span class="line"><span class="comment"># ObjCBlockIndentWidth: 4</span></span><br><span class="line"><span class="comment"># # 在ObjC的@property后添加一个空格</span></span><br><span class="line"><span class="comment"># ObjCSpaceAfterProperty: false</span></span><br><span class="line"><span class="comment"># # 在ObjC的protocol列表前添加一个空格</span></span><br><span class="line"><span class="comment"># ObjCSpaceBeforeProtocolList: true</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 在call(后对函数调用换行的penalty</span></span><br><span class="line"><span class="comment"># PenaltyBreakBeforeFirstCallParameter: 19</span></span><br><span class="line"><span class="comment"># # 在一个注释中引入换行的penalty</span></span><br><span class="line"><span class="comment"># PenaltyBreakComment: 300</span></span><br><span class="line"><span class="comment"># # 第一次在&lt;&lt;前换行的penalty</span></span><br><span class="line"><span class="comment"># PenaltyBreakFirstLessLess: 120</span></span><br><span class="line"><span class="comment"># # 在一个字符串字面量中引入换行的penalty</span></span><br><span class="line"><span class="comment"># PenaltyBreakString: 1000</span></span><br><span class="line"><span class="comment"># # 对于每个在行字符数限制之外的字符的penalty</span></span><br><span class="line"><span class="comment"># PenaltyExcessCharacter: 1000000</span></span><br><span class="line"><span class="comment"># # 将函数的返回类型放到它自己的行的penalty</span></span><br><span class="line"><span class="comment"># PenaltyReturnTypeOnItsOwnLine: 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SpaceAroundPointerQualifiers: Before</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指针和引用的对齐: Left, Right, Middle</span></span><br><span class="line"><span class="comment"># PointerAlignment: Right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 允许重新排版注释</span></span><br><span class="line"><span class="comment"># ReflowComments: true</span></span><br><span class="line"><span class="comment"># # 允许排序#include</span></span><br><span class="line"><span class="comment"># SortIncludes: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 在C风格类型转换后添加空格</span></span><br><span class="line"><span class="comment"># SpaceAfterCStyleCast: false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># SpaceAfterTemplateKeyword: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在赋值运算符之前添加空格</span></span><br><span class="line"><span class="comment"># SpaceBeforeAssignmentOperators: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开圆括号之前添加一个空格: Never, ControlStatements, Always</span></span><br><span class="line"><span class="comment"># SpaceBeforeParens: ControlStatements</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在空的圆括号中添加空格</span></span><br><span class="line"><span class="comment"># SpaceInEmptyParentheses: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在尾随的注释前添加的空格数(只适用于//)</span></span><br><span class="line"><span class="comment"># SpacesBeforeTrailingComments: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在尖括号的&lt;后和&gt;前添加空格</span></span><br><span class="line"><span class="comment"># SpacesInAngles: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格</span></span><br><span class="line"><span class="comment"># SpacesInContainerLiterals: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在C风格类型转换的括号中添加空格</span></span><br><span class="line"><span class="comment"># SpacesInCStyleCastParentheses: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在圆括号的(后和)前添加空格</span></span><br><span class="line"><span class="comment"># SpacesInParentheses: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响</span></span><br><span class="line"><span class="comment"># SpacesInSquareBrackets: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 标准: Cpp03, Cpp11, Auto</span></span><br><span class="line"><span class="comment"># Standard: Cpp11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, Always</span></span><br><span class="line"><span class="comment"># UseTab: Never</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>usage for gdb</title>
    <url>/2022/06/07/tool/gdb/</url>
    <content><![CDATA[<p>set val a=10  //更改程序变量的值</p>
<p><a href="https://blog.csdn.net/chen1415886044/article/details/105094688">https://blog.csdn.net/chen1415886044/article/details/105094688</a><br><a href="https://www.cnblogs.com/wuyuegb2312/archive/2013/03/29/2987025.html">https://www.cnblogs.com/wuyuegb2312/archive/2013/03/29/2987025.html</a><br><a href="https://www.cnblogs.com/chenshengkai/p/14218678.html">https://www.cnblogs.com/chenshengkai/p/14218678.html</a></p>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
  </entry>
  <entry>
    <title>gcc compile and link options</title>
    <url>/2022/09/24/tool/gcc_options/</url>
    <content><![CDATA[<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--help</span><br><span class="line">--target-help</span><br><span class="line">显示 gcc 帮助说明。‘target-help’是显示目标机器特定的命令行选项。</span><br><span class="line"></span><br><span class="line">--version</span><br><span class="line">显示 gcc 版本号和版权信息。</span><br><span class="line"></span><br><span class="line">-wall</span><br><span class="line">显示警告信息；</span><br><span class="line"></span><br><span class="line">-o outfile</span><br><span class="line">输出到指定的文件。</span><br><span class="line"></span><br><span class="line">-x language</span><br><span class="line">指明使用的编程语言，包括：c c++ assembler none 。 ‘none’意味着恢复默认行为，即根据文件的扩展名猜测源文件的语言。</span><br><span class="line"></span><br><span class="line">-v</span><br><span class="line">打印较多信息，显示编译器调用的程序。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-#</span><span class="language-bash"><span class="comment">##</span></span></span><br><span class="line">与 -v 类似，但选项被引号括住，并且不执行命令。</span><br><span class="line"></span><br><span class="line">-E</span><br><span class="line">仅作预处理，不进行编译、汇编和链接。</span><br><span class="line"></span><br><span class="line">-S</span><br><span class="line">仅编译到汇编语言，不进行汇编和链接。</span><br><span class="line"></span><br><span class="line">-c</span><br><span class="line">仅编译、汇编到目标代码，不进行链接。</span><br><span class="line"></span><br><span class="line">-C</span><br><span class="line">告诉预处理器不要丢弃注释，配合-E选项使用。</span><br><span class="line"></span><br><span class="line">-P</span><br><span class="line">告诉预处理器不要产生#line命令，配合-E选项使用。</span><br><span class="line"></span><br><span class="line">-pipe</span><br><span class="line">使用管道代替临时文件。</span><br><span class="line"></span><br><span class="line">-combine</span><br><span class="line">将多个源文件一次性传递给汇编器。</span><br><span class="line"></span><br><span class="line">-fsanitize=address</span><br><span class="line">gcc从4.8版本起，集成了Address Sanitizer工具，可以用来检查内存访问的错误，编译时指定`-fsanitize=address -g`，可以检测内存泄漏、堆栈和全局内存越界访问、free后继续使用、局部内存被外层使用和Initialization order bugs问题。</span><br></pre></td></tr></table></figure>

<h2 id="链接选项"><a href="#链接选项" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-l library</span><br><span class="line">-llibrary</span><br><span class="line">进行链接时搜索名为library的库。</span><br><span class="line"></span><br><span class="line">-Ldir</span><br><span class="line">把dir 加入到搜索库文件的路径列表中。</span><br><span class="line"></span><br><span class="line">-Idir</span><br><span class="line">把dir 加入到搜索头文件的路径列表中。</span><br><span class="line"></span><br><span class="line">-Dname</span><br><span class="line">预定义一个名为name 的宏，值为1。</span><br><span class="line"></span><br><span class="line">-Dname=definition</span><br><span class="line">预定义名为name ，值为definition 的宏。</span><br><span class="line"></span><br><span class="line">-ggdb</span><br><span class="line">-ggdblevel</span><br><span class="line">为调试器 gdb 生成调试信息。level 可以为1，2，3，默认值为2。</span><br><span class="line"></span><br><span class="line">-g</span><br><span class="line">-glevel</span><br><span class="line">生成操作系统本地格式的调试信息，level 取值同上。</span><br><span class="line"></span><br><span class="line">-s</span><br><span class="line">去除可执行文件中的符号表和重定位信息。用于减小可执行文件的大小。</span><br><span class="line"></span><br><span class="line">-static</span><br><span class="line">禁止使用动态库</span><br><span class="line"></span><br><span class="line">-share</span><br><span class="line">尽量使用动态库</span><br><span class="line"></span><br><span class="line">-nostdlib</span><br><span class="line">不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器。</span><br><span class="line"></span><br><span class="line">-rdynamic</span><br><span class="line">指示连接器把所有符号都添加到动态符号表（.dynsym）里，以便那些使用符号表的函数使用，如dlopen() 或 backtrace()。</span><br></pre></td></tr></table></figure>

<h2 id="优化项"><a href="#优化项" class="headerlink" title="优化项"></a>优化项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-O0 禁止编译器进行优化。默认为此项。</span><br><span class="line">-O1 尝试优化编译时间和可执行文件大小。</span><br><span class="line"></span><br><span class="line">-O2 更多的优化，会尝试几乎全部的优化功能，但不会进行“空间换时间”的优化方法。</span><br><span class="line"></span><br><span class="line">-O3 在 -O2 的基础上再打开一些优化选项：-finline-functions， -funswitch-loops 和 -fgcse-after-reload。</span><br><span class="line"></span><br><span class="line">-Os 对生成文件大小进行优化。它会打开 -O2 开的全部选项，除了会那些增加文件大小的。</span><br></pre></td></tr></table></figure>

<h2 id="指定标准"><a href="#指定标准" class="headerlink" title="指定标准"></a>指定标准</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-ansi 支持符合ANSI标准的C程序。这样就会关闭GNU C中某些不兼容ANSI C的特性。</span><br><span class="line"></span><br><span class="line">-std=c89 指明使用标准 ISO C90 作为标准来编译程序。</span><br><span class="line"></span><br><span class="line">-std=c99 指明使用标准 ISO C99 作为标准来编译程序。</span><br><span class="line"></span><br><span class="line">-std=c++98 指明使用标准 C++98 作为标准来编译程序。</span><br><span class="line"></span><br><span class="line">-std=gnu9x 使用 ISO C99 再加上 GNU 的一些扩展。</span><br><span class="line"></span><br><span class="line">-fno-asm 不把asm, inline或typeof当作关键字，因此这些词可以用做标识符。用 __asm__， __inline__和__typeof__能够替代它们。 `-ansi&#x27; 隐含声明了`-fno-asm&#x27;。</span><br><span class="line"></span><br><span class="line">-fgnu89-inline 告诉编译器在 C99 模式下看到 inline 函数时使用传统的 GNU 句法。</span><br></pre></td></tr></table></figure>

<h2 id="C选项"><a href="#C选项" class="headerlink" title="C选项"></a>C选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-pedantic</span><br><span class="line">以ANSI/ISO C标准列出的所有警告</span><br><span class="line"></span><br><span class="line">-fsigned-char</span><br><span class="line">把char定义为有符号类型，如同signed char。</span><br><span class="line"></span><br><span class="line">-funsigned-char</span><br><span class="line">把char定义为无符号类型，如同unsigned char。</span><br><span class="line"></span><br><span class="line">-traditional</span><br><span class="line">尝试支持传统C编译器的某些方面。详见GNU C手册。</span><br><span class="line"></span><br><span class="line">-fno-builtin</span><br><span class="line">-fno-builtin-function</span><br><span class="line">不接受没有 __builtin_ 前缀的函数作为内建函数。</span><br><span class="line"></span><br><span class="line">-trigraphs</span><br><span class="line">支持ANSI C的三联符（ trigraphs）。-ansi选项隐含声明了此选项。</span><br><span class="line"></span><br><span class="line">-fsigned-bitfields</span><br><span class="line">-funsigned-bitfields</span><br><span class="line">如果没有明确声明signed或unsigned修饰符，这些选项用来定义有符号位域或无符号位域。缺省情况下，位域是有符号的，因为它们继承的基本整数类型，如int，是有符号数。</span><br><span class="line"></span><br><span class="line">-fno-strict-aliasing</span><br><span class="line">启用严格别名规则，“-fno-strict-aliasing”表示禁用严格别名规则，当gcc的编译优化参数为“-O2”、“-O3”和“-Os”时，默认会打开“-fstrict-aliasing”。</span><br></pre></td></tr></table></figure>

<h2 id="C-选项"><a href="#C-选项" class="headerlink" title="C++选项"></a>C++选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-fsyntax-only</span><br><span class="line">检查代码中的语法错误，但除此之外不要做任何事情。</span><br><span class="line"></span><br><span class="line">-ffor-scope</span><br><span class="line">从头开始执行程序，也允许进行重定向。</span><br><span class="line"></span><br><span class="line">-fno-rtti</span><br><span class="line">关闭对 dynamic_cast 和 typeid 的支持。如果你不需要这些功能，关闭它会节省一些空间。</span><br></pre></td></tr></table></figure>

<h2 id="机器选项"><a href="#机器选项" class="headerlink" title="机器选项"></a>机器选项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-mtune=cpu-type</span><br><span class="line">为指定类型的 CPU 生成代码。cpu-type 可以是：i386，i486，i586，pentium，i686，pentium4 等等。</span><br><span class="line"></span><br><span class="line">-msse</span><br><span class="line">-msse2</span><br><span class="line">-mmmx</span><br><span class="line">-mno-sse</span><br><span class="line">-mno-sse2</span><br><span class="line">-mno-mmx</span><br><span class="line">使用或者不使用MMX，SSE，SSE2指令。</span><br><span class="line"></span><br><span class="line">-m32</span><br><span class="line">-m64</span><br><span class="line">生成32位/64位机器上的代码。</span><br><span class="line"></span><br><span class="line">-mpush-args</span><br><span class="line">-mno-push-args</span><br><span class="line">（不）使用 push 指令来进行存储参数。默认是使用。</span><br><span class="line"></span><br><span class="line">-mregparm=num</span><br><span class="line">当传递整数参数时，控制所使用寄存器的个数。</span><br></pre></td></tr></table></figure>

<h2 id="依赖文件"><a href="#依赖文件" class="headerlink" title="依赖文件"></a>依赖文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-M</span><br><span class="line">生成文件的依赖关系，依赖项是源文件中引用的所有头文件，同时也把一些标准库的头文件包含了进来。</span><br><span class="line"></span><br><span class="line">-MM</span><br><span class="line">生成文件的依赖关系，和 -M 类似，但不包含标准库的头文件。</span><br><span class="line"></span><br><span class="line">-MG</span><br><span class="line">要求把缺失的头文件按存在对待，并且假定他们和源文件在同一目录下，必须和`-M`选项一起用。</span><br><span class="line"></span><br><span class="line">-MF [file]</span><br><span class="line">当使用了-M或-MM选项时，则把依赖关系写入名为file的文件中。若同时也使用了-MD或-MMD,-MF将覆写输出的依赖文件的名称 。</span><br><span class="line"></span><br><span class="line">-MD</span><br><span class="line">等同于 -M -MF file，但是默认关闭了 -E 选项。其输出的文件名是基于 -o 选项，若给定了 -o 选项，则输出的文件名是 -o 指定的文件名，并添加 .d 后缀，若没有给定，则输入的文件名作为输出的文件名，并添加 .d 后缀，同时继续指定的编译工作。</span><br><span class="line"></span><br><span class="line">-MMD</span><br><span class="line">类似于-MD”，但是输出的依赖文件中，不包含标准头文件。</span><br><span class="line"></span><br><span class="line">-MP</span><br><span class="line">生成的依赖文件里面，依赖规则中的所有 .h 依赖项都会在该文件中生成一个伪目标，其不依赖任何其他依赖项。该伪规则将避免删除了对应的头文件而没有更新Makefile去匹配新的依赖关系而导致 make 出错的情况出现。</span><br><span class="line"></span><br><span class="line">-MT Target</span><br><span class="line">在生成的依赖文件中，指定依赖规则中的目标。</span><br></pre></td></tr></table></figure>

<h2 id="其他项"><a href="#其他项" class="headerlink" title="其他项"></a>其他项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-finline-functions</span><br><span class="line">把所有简单的函数内联进调用者。编译器会探索式地决定哪些函数足够简单，值得做这种内联。</span><br><span class="line"></span><br><span class="line">-fstrict-aliasing</span><br><span class="line">施加最强的别名规则（aliasing rules）。</span><br><span class="line"></span><br><span class="line">-fPIC</span><br><span class="line">告诉编译器产生与位置无关代码，在产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。如果不加-fPIC，则加载.so文件的代码段时，代码段引用的数据对象需要重定位， 重定位会修改代码段的内容，这就造成每个使用这个.so文件代码段的进程在内核里都会生成这个.so文件代码段的拷贝。</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://zhuanlan.zhihu.com/p/347611674">https://zhuanlan.zhihu.com/p/347611674</a></p>
]]></content>
      <categories>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作大全</title>
    <url>/2022/08/27/tool/git/</url>
    <content><![CDATA[<p><img src="/images/git/lifecycle.png" alt="img"></p>
<p><img src="/images/git/git2.png" alt="img"></p>
<p><img src="/images/git/git1.jpg" alt="img"></p>
<p><a href="https://github.com/jaywcjlove/git-tips">https://github.com/jaywcjlove/git-tips</a></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用<code>git config --list</code>命令列出配置信息。</p>
<p><strong>生成SSH公钥</strong></p>
<ol>
<li>配置用户名和邮箱</li>
</ol>
<blockquote>
<p>git config –global user.name “luo_u”<br>git config –global user.email “<a href="mailto:&#108;&#x75;&#111;&#95;&#x75;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#109;">&#108;&#x75;&#111;&#95;&#x75;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#109;</a>“</p>
</blockquote>
<ol start="2">
<li>生成SSH，密钥保存在<code>~/.ssh/id_rsa.pub</code></li>
</ol>
<blockquote>
<p>ssh-keygen -t rsa -C <a href="mailto:&#x6c;&#x75;&#111;&#x5f;&#x75;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#x6d;">&#x6c;&#x75;&#111;&#x5f;&#x75;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#x6d;</a><br>ssh-keygen -t ed25519 -C “<a href="mailto:&#x6c;&#x75;&#111;&#x5f;&#117;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;">&#x6c;&#x75;&#111;&#x5f;&#117;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;</a>“</p>
</blockquote>
<ol>
<li>测试是否连接</li>
</ol>
<blockquote>
<p>ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#x65;&#x2e;&#x63;&#x6f;&#x64;&#105;&#x6e;&#103;&#46;&#x6e;&#101;&#x74;">&#103;&#105;&#x74;&#x40;&#x65;&#x2e;&#x63;&#x6f;&#x64;&#105;&#x6e;&#103;&#46;&#x6e;&#101;&#x74;</a></p>
</blockquote>
<p><strong>设置编辑器</strong></p>
<blockquote>
<p>git config –global core.editor vim</p>
</blockquote>
<p><strong>git status 显示中文</strong></p>
<blockquote>
<p>git config –global core.quotepath false</p>
</blockquote>
<h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加指定文件到暂存区</span></span><br><span class="line">git add &lt;file&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加指定目录到暂存区，包括子目录</span></span><br><span class="line">git add &lt;dir&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加当前目录的所有文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加每个变化前，都会要求确认</span></span><br><span class="line">git add -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">git rm &lt;file&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">git rm --cached &lt;file&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制删除</span></span><br><span class="line">git rm -f &lt;filename&gt; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件改名</span></span><br><span class="line">git mv &lt;old-name&gt; &lt;new-name&gt; </span><br></pre></td></tr></table></figure>

<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交暂存区到仓库区</span></span><br><span class="line">git commit -m [message]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交暂存区的指定文件到仓库区</span></span><br><span class="line">git commit [file1] [file2] ... -m [message]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把所有已经跟踪过的文件暂存起来一并提交</span></span><br><span class="line">git commit -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交时显示所有diff信息</span></span><br><span class="line">git commit -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><code>master</code> 默认开发分支</p>
<p><code>HEAD</code> 当前开发分支</p>
<p><code>HEAD^([n])</code> HEAD的第n次父提交提交, ^相当于^1</p>
<p><code>HEAD~([n])</code> HEAD的第n个祖先提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch # 查看分支</span><br><span class="line"></span><br><span class="line">git branch -r #查看远程分支</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此命令将显示包含特定提交的所有分支。</span></span><br><span class="line">git branch --contains &lt;commit&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有本地分支和远程分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line">git branch &lt;name&gt; # 创建分支</span><br><span class="line"></span><br><span class="line">git checkout &lt;name&gt; # 切换分支</span><br><span class="line"></span><br><span class="line">git checkout -b &lt;name&gt; # 创建 + 切换分支</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重命名本地分支</span></span><br><span class="line">git branch -m &lt;old-name&gt; &lt;new-name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重命名刚切换的新分支</span></span><br><span class="line">git branch -m &lt;new-name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支，指向指定commit</span></span><br><span class="line">git branch [branch] [commit]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">git branch --track [branch] [remote-branch]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重命名远程分支： 一旦在本地重命名了分支，您需要先远程删除该分支，然后再次推送重命名的分支。</span></span><br><span class="line">git push origin :&lt;old-name&gt;</span><br><span class="line">git push origin &lt;new-name&gt;</span><br><span class="line"></span><br><span class="line">git merge &lt;name&gt; # 合并某分支到当前分支</span><br><span class="line"></span><br><span class="line">git branch -d &lt;name&gt; # 删除分支</span><br><span class="line"></span><br><span class="line">git branch -D &lt;name&gt; # 强制删除分支</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到上一个分支</span></span><br><span class="line">git checkout -</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择一个commit，合并进当前分支</span></span><br><span class="line">git cherry-pick [commit]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程分支(先在本地删除该分支)，原理是把一个空分支push到server上，相当于删除该分支。</span></span><br><span class="line">git push origin :&lt;name&gt;</span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br><span class="line"></span><br><span class="line">git cherry-pick [commitid]</span><br><span class="line">git cherry-pick [[branch]]</span><br></pre></td></tr></table></figure>

<p><code>checkout</code>只会移动<code>HEAD</code>指针，<code>reset</code>会改变<code>HEAD</code>的引用值</p>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有被忽略的文件</span></span><br><span class="line">git status --ignored </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看修改内容</span></span><br><span class="line">git diff &lt;filename&gt; </span><br><span class="line"></span><br><span class="line">git diff &lt;first_branch&gt;..&lt;second_branch&gt; # 显示两次提交之间的差异</span><br><span class="line"></span><br><span class="line">git diff --shortstat &quot;@&#123;n day ago&#125;&quot; # 显示n天的代码数量</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示暂存区和上一个commit的差异</span></span><br><span class="line">git diff --cached [file]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">git diff HEAD</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将差异文件打包，使用 --name-only 参数只显示文件名</span></span><br><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt; --name-only | xargs tar -czvf ../update.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制出差异文件</span></span><br><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt; --name-only | xargs -t -i&#123;&#125; cp --parents &#123;&#125; ../update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示某次提交的元数据和内容变化</span></span><br><span class="line">git show [commit]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示某次提交时，某个文件的内容</span></span><br><span class="line">git show [commit]:[filename]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示某次提交发生变化的文件</span></span><br><span class="line">git show --name-only [commit]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前分支的最近几次提交</span></span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">git blame &lt;filename&gt; # 显示指定文件修改信息</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前分支的版本历史</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">git log --stat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索提交历史，根据关键词</span></span><br><span class="line">git log -S [keyword]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示某个commit之后的所有变动，其<span class="string">&quot;提交说明&quot;</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git whatchanged [file]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示过去5次提交</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git shortlog -sn</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git blame [file]</span></span><br></pre></td></tr></table></figure>

<h2 id="撤销-版本回滚"><a href="#撤销-版本回滚" class="headerlink" title="撤销/版本回滚"></a>撤销/版本回滚</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD # 撤销工作目录中暂存的所有未提交文件的修改内容</span><br><span class="line"></span><br><span class="line">git reset --keep [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line"></span><br><span class="line">git commit --amend # 将暂存区中的文件提交</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复暂存区的指定文件到工作区</span></span><br><span class="line">git checkout [file]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">git checkout [commit] [file]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复暂存区的所有文件到工作区</span></span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">git checkout HEAD &lt;filename&gt; # 取消指定未提交文件的修改内容</span><br><span class="line"></span><br><span class="line">git checkout --patch &lt;filename&gt; # 撤消对文件的修改</span><br><span class="line"></span><br><span class="line">git revert &lt;commit_id&gt; # 撤销指定提交</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">git reset [file]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">git reset --hard</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">git reset [commit]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">git reset --hard [commit]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">git reset --keep [commit]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后者的所有变化都将被前者抵消，并且应用到当前分支，用于修改远程仓库</span></span><br><span class="line">git revert [commit]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h2><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#rlog_options">常见参数选项</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`-p`: 显示每次提交的内容差异。</span><br><span class="line"></span><br><span class="line">`—stat`: 显示每次更新的文件修改统计信息。</span><br><span class="line"></span><br><span class="line">`—shortstat`: 只显示 `—stat` 中最后的行数修改添加移除统计。</span><br><span class="line"></span><br><span class="line">`--name-only` 仅在提交信息后显示已修改的文件清单。</span><br><span class="line"></span><br><span class="line">`--name-status` 显示新增、修改、删除的文件清单。</span><br><span class="line"></span><br><span class="line">`--abbrev-commit`: 仅显示 `SHA-1` 的前几个字符，而非所有的 40 个字符。</span><br><span class="line"></span><br><span class="line">`--relative-date`: 使用较短的相对时间显示（比如，`2 weeks ago`）。</span><br><span class="line"></span><br><span class="line">`--graph`: 显示 `ASCII` 图形表示的分支合并历史。</span><br><span class="line"></span><br><span class="line">`—pretty=(oneline,short,medium(默认值),full,fuller,email,raw,format)`： 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。</span><br><span class="line"></span><br><span class="line">- `oneline`: 将每个提交放在一行显示，查看的提交数很大时非常有用。</span><br><span class="line">- [`format`](https://git-scm.com/book/zh/v2/Git-基础-查看提交历史#rpretty_format): 列出了常用的格式占位符写法及其代表的意义。</span><br></pre></td></tr></table></figure>

<p><code>—oneline</code>: <code>--pretty=oneline --abbrev-commit</code> 的简化用法。</p>
<p><code>--date= (relative|local|default|iso|rfc|short|raw)</code>：定制出现日期格式。</p>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#rlimit_options">常见输出参数</a>:</p>
<p><code>-n</code>: 仅显示最近的 n 条提交</p>
<p><code>—since</code>, <code>—after</code>: 仅显示指定时间之后的提交</p>
<p><code>--until</code>, <code>—before</code>: 仅显示指定作者相关的提交。</p>
<p><code>—author</code>: 仅显示指定提交者相关的提交。</p>
<p><code>—grep</code>: 仅显示含指定关键字的提交</p>
<p><code>-S</code>: 仅显示添加或移除了某个关键字的提交</p>
<p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看所有提交历史</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> -p -n <span class="comment"># 查看最近提交的n条历史</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> -p -n &lt;filename&gt; <span class="comment"># 查看指定文件最近提交的n条历史</span></span><br></pre></td></tr></table></figure>

<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>Git可以给历史中的某一个提交打上标签，以示重要。</p>
<p>Git使用两种主要类型的标签：轻量标签(lightweight)与附注标签(annotated)。</p>
<p>轻量标签: 很像一个不会改变的分支 - 它只是一个特定提交的引用。它本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。</p>
<p>附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard(GPG)签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>
<p>-a: 创建附注标签</p>
<p>-m: 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag # 列出已有的标签</span><br><span class="line"></span><br><span class="line">git tag &lt;tagname&gt; # 创建标签，-a 创建附注标签</span><br><span class="line"></span><br><span class="line">git tag -d &lt;tagname&gt; # 删除掉你本地仓库上的标签</span><br><span class="line"></span><br><span class="line">git show &lt;tagname&gt; # 查看标签信息与对应的提交信息</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程tag</span></span><br><span class="line">git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line">git push origin &lt;tagname&gt; # 推送标签到远程仓库服务器上</span><br><span class="line"></span><br><span class="line">git push origin --tags # 一次性推送所有不在远程仓库服务器上的标签</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支，指向某个tag</span></span><br><span class="line">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h2 id="储藏与清理"><a href="#储藏与清理" class="headerlink" title="储藏与清理"></a>储藏与清理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add . &amp;&amp; git stash # 将新的储藏推送到栈上</span><br><span class="line"></span><br><span class="line">git stash save &#x27;message&#x27; # 储藏修改，并留下stash信息</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p（或-patch）允许交互选择要提交的每个跟踪文件的各个部分。 这样每个提交只包含相关的更改。</span></span><br><span class="line">git stash -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下，当存储时，不包括未跟踪的文件。 为了更改该行为并包含这些文件，您需要使用-u参数。 还有-a（-all）可以完全存储未跟踪和忽略的文件，这可能是您通常不需要的东西。</span></span><br><span class="line">git stash -u</span><br><span class="line"></span><br><span class="line">git stash list # 查看栈中所有暂存</span><br><span class="line"></span><br><span class="line">git stash apply &lt;stash_id&gt; # 恢复复对应编号暂存到工作区，如果不指定编号为栈顶的，注意：这些暂存还在栈中</span><br><span class="line"></span><br><span class="line">git stash pop &lt;stash_id&gt; #将栈顶的暂存，恢复到工作区，并从栈中弹出，注意：这些暂存不在栈中</span><br><span class="line"></span><br><span class="line">git stash drop &lt;stash_id&gt; # 移除的储藏在栈中的东西</span><br><span class="line"></span><br><span class="line">git stash clear #清空暂存栈</span><br><span class="line"></span><br><span class="line">git stash branch &lt;branch_name&gt; # 从储藏创建一个分支</span><br></pre></td></tr></table></figure>

<h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程仓库及其URL</span></span><br><span class="line">git remote -v </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程仓库的信息</span></span><br><span class="line">git remote show &lt;remote-name&gt; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加一个新的远程仓库</span></span><br><span class="line">git remote add &lt;shortname&gt; &lt;url&gt; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除远程仓库</span></span><br><span class="line">git remote rm &lt;name&gt; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重命名远程仓库</span></span><br><span class="line">git remote rename &lt;oldname&gt; &lt;newname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库中拉取数据</span></span><br><span class="line">git fetch &lt;remote-name&gt; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载代码及快速合并</span></span><br><span class="line">git pull &lt;remote-name&gt; &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line">git pull --rebase</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一次推送到远程仓库，--set-upstream可简写为-u</span></span><br><span class="line">git push --set-upstream &lt;remote-name&gt; &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送到远程仓库</span></span><br><span class="line">git push &lt;remote&gt; &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强行推送当前分支到远程仓库</span></span><br><span class="line">git push [remote] --force </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送所有分支到远程仓库</span></span><br><span class="line">git push [remote] --all </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程分支或标签</span></span><br><span class="line">git push &lt;remote&gt; :&lt;branch-name/tag-name&gt; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上传所有标签</span></span><br><span class="line">git push --tag </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git push origin &lt;source&gt;:&lt;destination&gt;</span><br></pre></td></tr></table></figure>

<h3 id="克隆部分文件"><a href="#克隆部分文件" class="headerlink" title="克隆部分文件"></a>克隆部分文件</h3><p>配置需要下载代码的路径到 <code>.git/info/sparse-checkout</code> 文件，每个一行只能书写一个路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;some/dir/&quot; &gt;&gt; .git/info/sparse-checkout</span><br><span class="line">echo &quot;another/sub/tree&quot; &gt;&gt; .git/info/sparse-checkout</span><br></pre></td></tr></table></figure>

<p>如果后续想增删路径，直接编辑 <code>.git/info/sparse-checkout</code> 文件，然后执行 <code>git read-tree -mu HEAD</code> 或<code>git read-tree --dry-run HEAD</code>。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成一个可供发布的压缩包</span></span><br><span class="line">git archive</span><br></pre></td></tr></table></figure>

<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="精准搜索"><a href="#精准搜索" class="headerlink" title="精准搜索"></a>精准搜索</h3><ul>
<li>in:name xxx // 按照项目名搜索</li>
<li>in:readme xxx // 按照README搜索</li>
<li>in:description xxx // 按照description搜索</li>
<li>stars:&gt;xxx // stars数大于xxx</li>
<li>forks:&gt;3000 // forks数大于xxx</li>
<li>language:xxx // 编程语言是xxx</li>
<li>pushed:&gt;YYYY-MM-DD // 最后更新时间大于YYYY-MM-DD</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://git-scm.com/">Git官网</a></li>
<li><a href="http://gitref.org/zh/index.html">Git参考手册</a></li>
<li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/">Git Magic</a></li>
<li><a href="http://gitbook.liuhui998.com/index.html">Git Community Book 中文版</a></li>
<li><a href="http://git-scm.com/book/en/v2">Pro Git</a></li>
<li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解Git</a></li>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">git-简明指南</a></li>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">初级教程</a> </li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰的Git教程</a></li>
<li><a href="http://www.worldhello.net/gotgithub/">蒋鑫老师将带你入github的大门</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069609436.html">git详解</a></li>
<li><a href="http://git.oschina.net/progit/">oschina教程</a></li>
<li><a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git">How to undo (almost) anything with Git撤销一切，汇总各种回滚撤销的场景，加强学习。</a></li>
<li><a href="http://www.runoob.com/git/git-tutorial.html">Git 教程 | 菜鸟教程runoob.com</a></li>
<li><a href="https://gold.xitu.io/post/5842f9b861ff4b005889ade6">Git 本地仓库和裸仓库</a></li>
<li><a href="http://www.kancloud.cn/kancloud/igit/46710">沉浸式学 Git</a><br><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc 告警选项</title>
    <url>/2022/06/07/tool/gcc_warning/</url>
    <content><![CDATA[<h2 id="告警开关"><a href="#告警开关" class="headerlink" title="告警开关"></a>告警开关</h2><p><code>-fsyntax-only</code>  检查代码中的语法错误，但除此之外不要做任何事情。</p>
<p><code>-w</code>  关闭所有警告消息。以<code>-W</code>开头开启特定的警告，以<code>-Wno-</code>开头关闭特定的警告。</p>
<p><code>-Werror</code>  将所有的警告当成错误进行处理。<code>-Werror=</code> 将指定的警告转换为错误。<code>-Wno-error</code>  取消编译选项-Werror。</p>
<p><code>-Wfatal-errors</code>  在发生第一个错误时中止编译。</p>
<p>具体的选项优先于不特定的选项，与命令行中的位置无关。对于相同特征的选项，最后一个生效。</p>
<h2 id="Wall"><a href="#Wall" class="headerlink" title="-Wall"></a>-Wall</h2><p>该选项相当于同时使用了下列所有的选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unused-function：遇到仅声明过但尚未定义的静态函数时发出警告。</span><br><span class="line">unused-label：遇到声明过但不使用的标号的警告。</span><br><span class="line">unused-parameter：从未用过的函数参数的警告。</span><br><span class="line">unused-variable：在本地声明但从未用过的变量的警告。</span><br><span class="line">unused-value：仅计算但从未用过的值得警告。</span><br><span class="line">Format：检查对printf和scanf等函数的调用，确认各个参数类型和格式串中的一致。</span><br><span class="line">implicit-int：警告没有规定类型的声明。</span><br><span class="line">implicit-function-：在函数在未经声明就使用时给予警告。</span><br><span class="line">char-subscripts：警告把char类型作为数组下标。这是常见错误，程序员经常忘记在某些机器上char有符号。</span><br><span class="line">missing-braces：聚合初始化两边缺少大括号。</span><br><span class="line">Parentheses：在某些情况下如果忽略了括号，编译器就发出警告。</span><br><span class="line">return-type：如果函数定义了返回类型，而默认类型是int型，编译器就发出警告。同时警告那些不带返回值的 return语句，如果他们所属的函数并非void类型。</span><br><span class="line">sequence-point：出现可疑的代码元素时，发出报警。</span><br><span class="line">Switch：如果某条switch语句的参数属于枚举类型，但是没有对应的case语句使用枚举元素，编译器就发出警告（在switch语句中使用default分支能够防止这个警告）。超出枚举范围的case语句同样会导致这个警告。</span><br><span class="line">strict-aliasing：对变量别名进行最严格的检查。</span><br><span class="line">unknown-pragmas：使用了不允许的#pragma。</span><br><span class="line">Uninitialized：在初始化之前就使用自动变量。</span><br></pre></td></tr></table></figure>

<p>但是以下警告项并不会生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast-align：一旦某个指针类型强制转换时，会导致目标所需的地址对齐边界扩展，编译器就发出警告。例如，某些机器上只能在2或4字节边界上访问整数，如果在这种机型上把char *强制转换成int *类型， 编译器就发出警告。</span><br><span class="line">sign-compare：将有符号类型和无符号类型数据进行比较时发出警告。</span><br><span class="line">missing-prototypes ：如果没有预先声明函数原形就定义了全局函数，编译器就发出警告。即使函数定义自身提供了函数原形也会产生这个警告。这样做的目的是检查没有在头文件中声明的全局函数。</span><br><span class="line">Packed：当结构体带有packed属性但实际并没有出现紧缩式给出警告。</span><br><span class="line">Padded：如果结构体通过充填进行对齐则给出警告。</span><br><span class="line">unreachable-code：如果发现从未执行的代码时给出警告。</span><br><span class="line">Inline：如果某函数不能内嵌（inline），无论是声明为inline或者是指定了-finline-functions 选项，编译器都将发出警告。</span><br><span class="line">disabled-optimization：当需要太长时间或过多资源而导致不能完成某项优化时给出警告。</span><br></pre></td></tr></table></figure>

<h2 id="Wextra"><a href="#Wextra" class="headerlink" title="-Wextra"></a>-Wextra</h2><p>启用一些额外警告标志。（此选项过去称为-W。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Wclobbered  </span><br><span class="line">-Wcast-function-type  </span><br><span class="line">-Wempty-body  </span><br><span class="line">-Wignored-qualifiers</span><br><span class="line">-Wimplicit-fallthrough=3</span><br><span class="line">-Wmissing-field-initializers  </span><br><span class="line">-Wmissing-parameter-type (C only)  </span><br><span class="line">-Wold-style-declaration (C only)  </span><br><span class="line">-Woverride-init  </span><br><span class="line">-Wsign-compare (C only)</span><br><span class="line">-Wtype-limits  </span><br><span class="line">-Wuninitialized  </span><br><span class="line">-Wshift-negative-value (in C++03 and in C99 and newer)  </span><br><span class="line">-Wunused-parameter (only with -Wunused or -Wall)</span><br><span class="line">-Wunused-but-set-parameter (only with -Wunused or -Wall)</span><br></pre></td></tr></table></figure>

<h2 id="其他告警项"><a href="#其他告警项" class="headerlink" title="其他告警项"></a>其他告警项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Wfatal-errors 发生第一个错误时中止编译</span><br><span class="line"></span><br><span class="line">-Wchkp  警告由指针界限检查器（ -fcheck-pointer-bounds ）发现的无效内存访问。</span><br><span class="line"></span><br><span class="line">-Wno-coverage-mismatch  如果使用-fprofile-use选项时反馈配置文件不匹配，则警告 。 如果在使用-fprofile-gen编译和使用-fprofile-use编译时源文件发生更改，则具有配置文件反馈的文件可能无法与源文件匹配，并且GCC无法使用配置文件反馈信息。 默认情况下，此警告已启用并被视为错误。 -Wno-coverage-mismatch可用于禁用警告或-Wno-error = coverage-mismatch可用于禁用该错误。 禁用此警告的错误可能会导致代码质量不佳，并且仅在非常小的更改情况下才有用，例如修复现有代码库的错误。 不建议完全禁用该警告。</span><br><span class="line"></span><br><span class="line">-Wno-cpp 禁止`#warning`指令发出的警告消息。（仅限于Objective-C，C ++，Objective-C ++和Fortran）</span><br><span class="line"></span><br><span class="line">-Wshadow  当一个局部变量遮盖住了另一个局部变量，或者全局变量时，给出警告。很有用的选项，建议打开。 -Wall 并不会打开此项。</span><br><span class="line"></span><br><span class="line">-Wpointer-arith  对函数指针或者void *类型的指针进行算术操作时给出警告。也很有用。 -Wall 并不会打开此项。</span><br><span class="line"></span><br><span class="line">-Wcast-qual  当强制转化丢掉了类型修饰符时给出警告。 -Wall 并不会打开此项。</span><br><span class="line"></span><br><span class="line">-Waggregate-return  如果定义或调用了返回结构体或联合体的函数，编译器就发出警告。</span><br><span class="line"></span><br><span class="line">-Winline  无论是声明为 inline 或者是指定了-finline-functions 选项，如果某函数不能内联，编译器都将发出警告。如果你的代码含有很多 inline 函数的话，这是很有用的选项。</span><br><span class="line"></span><br><span class="line">-Wundef  当一个没有定义的符号出现在`#if`中时，给出警告。</span><br><span class="line"></span><br><span class="line">-Wredundant-decls  如果在同一个可见域内某定义多次声明，编译器就发出警告，即使这些重复声明有效并且毫无差别。</span><br><span class="line"></span><br><span class="line">-Wstrict-prototypes  如果函数的声明或定义没有指出参数类型，编译器就发出警告。很有用的警告。</span><br><span class="line"></span><br><span class="line">-Wctor-dtor-privacy （C++ only）当一个类没有用时给出警告。因为构造函数和析构函数会被当作私有的。</span><br><span class="line"></span><br><span class="line">-Wnon-virtual-dtor （C++ only）当一个类有多态性，而又没有虚析构函数时，发出警告。-Wall会开启这个选项。</span><br><span class="line"></span><br><span class="line">-Wreorder （C++ only）如果代码中的成员变量的初始化顺序和它们实际执行时初始化顺序不一致，给出警告。</span><br><span class="line"></span><br><span class="line">-Wno-deprecated（C++ only）使用过时的特性时不要给出警告。</span><br><span class="line"></span><br><span class="line">-Woverloaded-virtual（C++ only）如果函数的声明隐藏住了基类的虚函数，就给出警告。</span><br><span class="line"></span><br><span class="line">-Winit-self (C, C++, Objective-C and Objective-C++ only)警告使用自己初始化的未初始化变量。 请注意，此选项只能与-Wuninitialized选项一起使用。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 搭建个人博客</title>
    <url>/2022/08/27/tool/hexo/</url>
    <content><![CDATA[<h2 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h2><h2 id="更改npm源"><a href="#更改npm源" class="headerlink" title="更改npm源"></a>更改npm源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init      # 初始化</span><br><span class="line">npm install    # 安装组件</span><br></pre></td></tr></table></figure>

<p>hexo安装在node的目录下了，为了方便使用，还要设置一个软连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── _config.yml     ## 网站的配置信息</span><br><span class="line">├── package.json    ## 应用程序的信息，初始化时自动创建。</span><br><span class="line">├── .deploy_git     ## 部署到github后自动创建</span><br><span class="line">├── node_modules    ## 存放安装的Hexo扩展</span><br><span class="line">├── public          ## 生成的静态网页内容目录</span><br><span class="line">├── scaffolds       ## 模版文件夹</span><br><span class="line">├── source          ## 存放用户资源文章</span><br><span class="line">│    └── _posts         ## 文章</span><br><span class="line">└── themes          ## 主题</span><br><span class="line">     └── landscape</span><br><span class="line">          ├── _config.yml   ## 主题配置文件</span><br><span class="line">          ├── languages     ## 语言文件夹</span><br><span class="line">          ├── layout        ## 主题的模板</span><br><span class="line">          ├── scripts       ## 脚本文件夹</span><br><span class="line">          └── source        ## CSS JavaScript资源文件夹</span><br></pre></td></tr></table></figure>

<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署发布</span><br><span class="line">hexo s                # 本地预览 http://localhost:4000</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line"><span class="bullet">-</span> c</span><br><span class="line">tags: # 标签</span><br><span class="line"><span class="bullet">-</span> c</span><br><span class="line"><span class="section">- printf</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<h2 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h2><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p>
<p>首先安装 hexo-deployer-git：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:makeko/makeko.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>完成后运行 hexo d 将网站上传部署到 GitHub Pages。</p>
<h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><ol>
<li>安装插件 hexo-generator-searchdb</li>
</ol>
<p>npm install hexo-generator-searchdb –save</p>
<ol start="2">
<li>配置根目录文件_config.yml</li>
</ol>
<p>search: path: search.xml;<br>field: post;<br>format: html;<br>limit: 10000;</p>
<p>3.配置主题文件_config.yml</p>
<p>local_search: enable: true;</p>
<hr>
<p><a href="https://blog.51cto.com/luweir/4878247">https://blog.51cto.com/luweir/4878247</a><br><a href="https://www.jianshu.com/p/e17711e44e00">https://www.jianshu.com/p/e17711e44e00</a><br><a href="https://www.bilibili.com/read/cv10197254/">https://www.bilibili.com/read/cv10197254/</a><br><a href="https://yuleweici.com/2018/08/07/Hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/">https://yuleweici.com/2018/08/07/Hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile</title>
    <url>/2022/06/07/tool/makefile/</url>
    <content><![CDATA[<p>下载地址：<a href="http://ftp.gnu.org/gnu/make/">http://ftp.gnu.org/gnu/make/</a></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong>makefile预定义变量</strong></p>
<table>
<thead>
<tr>
<th align="center">预定义变量</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AR</td>
<td align="center">库文件维护程序的名称，默认为ar</td>
</tr>
<tr>
<td align="center">AS</td>
<td align="center">汇编程序的名称，默认为as</td>
</tr>
<tr>
<td align="center">CC</td>
<td align="center">c编译器的名称，默认为cc</td>
</tr>
<tr>
<td align="center">CXX</td>
<td align="center">c++编译器的名称，默认为g++</td>
</tr>
<tr>
<td align="center">ARFLAGS</td>
<td align="center">库文件维护程序选项，无默认值</td>
</tr>
<tr>
<td align="center">ASFLAGS</td>
<td align="center">汇编程序选项，无默认值</td>
</tr>
<tr>
<td align="center">CFLAGS</td>
<td align="center">c编译器选项，无默认值</td>
</tr>
<tr>
<td align="center">CXXFLAGS</td>
<td align="center">c++编译器选项，无默认值</td>
</tr>
</tbody></table>
<h3 id="makefile自动变量"><a href="#makefile自动变量" class="headerlink" title="makefile自动变量"></a>makefile自动变量</h3><table>
<thead>
<tr>
<th align="center">自动变量</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$*</td>
<td align="center">不包含扩展名的目标文件名称</td>
</tr>
<tr>
<td align="center">$&lt;</td>
<td align="center">第一个依赖文件名称</td>
</tr>
<tr>
<td align="center">$?</td>
<td align="center">所有时间戳比目标文件晚的依赖文件</td>
</tr>
<tr>
<td align="center">$@</td>
<td align="center">目标文件的完整名称</td>
</tr>
<tr>
<td align="center">$^</td>
<td align="center">所有不重复的依赖文件</td>
</tr>
</tbody></table>
<h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p><code>$@</code>表示规则中的目标文件集。在模式规则中，如果有多个目标，那么就是匹配于目标中模式定义的集合。</p>
<p><code>$%</code>仅当目标是函数库文件时，表示规则中的目标成员名，如果目标不是函数库文件（Unix 下是 .a ， Windows下是 .lib ），那么其值为空。</p>
<p><code>$?</code>所有更新过的依赖目标的集合。以空格分隔。</p>
<p><code>$^</code>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p>
<p><code>$&lt;</code>依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 $&lt; 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p>
<p><code>$+</code>所有依赖目标的集合，不去除重复的依赖目标。</p>
<p><code>$*</code> 就是除了后缀的那一部分。如果目标中的后缀是make 所不能识别的，那么 $* 就是空值。</p>
<h4 id="PHONY"><a href="#PHONY" class="headerlink" title=".PHONY"></a>.PHONY</h4><p>伪目标意思是这个目标本身不代表一个文件，执行这个目标不是为了得到某个文件或者东西，而是单纯为了执行这个目标下面的命令。</p>
<h3 id="subst"><a href="#subst" class="headerlink" title="subst"></a>subst</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> 要被替换的字符串,用来替换的字符串,被处理的字符串)</span></span><br></pre></td></tr></table></figure>

<p><code>$(subst .c,.o,test1.c test2.c)</code>意思是用.o替换test1.c test2.c中的.c，最终得到test1.o test2.o。</p>
<h3 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> 寻找的文件)</span></span><br></pre></td></tr></table></figure>

<p>在系统中寻找文件，<code>$(wildcard *.c)</code>就等于找到系统中所有后缀为.c的文件，返回成以空格隔开的一整行字符。</p>
<h3 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> 文件名)</span></span><br></pre></td></tr></table></figure>

<p>取得文件的名字（去掉后缀的意思），<code>$(basename test1.c)</code>就会取得test1。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>在makefile中使用shell命令，$var：将Makefile中的变量var展开，将其值传给shell命令。$$var：访问shell命令中定义的变量var，而非makefile的变量，如果某规则有多个shell命令行构成，而相互之间没有用’;’和’&#39;连接起来的话，就是没有关联，相互之间也不能变量共享。</p>
<ul>
<li>error: unused variable ‘a’ [-Werror=unused-variable]<br> 去掉编译配置的 -Werror<blockquote>
<p>LOCAL_CFLAGS += -Werror</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>makefile</category>
      </categories>
  </entry>
  <entry>
    <title>jekyll 配色方案优化</title>
    <url>/2022/06/07/tool/jekyll_rouge/</url>
    <content><![CDATA[<h2 id="1-安装rouge"><a href="#1-安装rouge" class="headerlink" title="1.安装rouge"></a>1.安装rouge</h2><p>使用gem安装rouge、kramdown，需要先安装Ruby。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gem install kramdown</span><br><span class="line">gem install rouge</span><br></pre></td></tr></table></figure>

<h2 id="2-配置-config-yml文件"><a href="#2-配置-config-yml文件" class="headerlink" title="2.配置_config.yml文件"></a>2.配置_config.yml文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlighter: rouge</span><br><span class="line">markdown: kramdown</span><br><span class="line">kramdown:</span><br><span class="line">  input: GFM</span><br><span class="line">  syntax_highlighter: rouge</span><br></pre></td></tr></table></figure>

<h2 id="3-生成rouge-css"><a href="#3-生成rouge-css" class="headerlink" title="3.生成rouge css"></a>3.生成rouge css</h2><p>用附带的 rougify 工具来生成多种高亮主题的CSS文件，支持的 css 主题可以使用<code>rougify help style</code>命令查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rougify style monokai.sublime &gt; monokai.css</span><br></pre></td></tr></table></figure>

<h2 id="4-使用rouge"><a href="#4-使用rouge" class="headerlink" title="4.使用rouge"></a>4.使用rouge</h2><p>将生成的css文件拷到网站的css目录下，在网站的HTML代码的<code>&lt;head&gt;</code>标签内加载。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/assets/css/monokai.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-修改rouge"><a href="#5-修改rouge" class="headerlink" title="5.修改rouge"></a>5.修改rouge</h2><p>修改代码块的背景和字体，在刚才的css文件后面加上：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.highlight</span> pre &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#272822</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title>jekyll 搭建个人博客</title>
    <url>/2022/06/21/tool/jekyll/</url>
    <content><![CDATA[<p>Jekyll是一个简单的，博客感知的静态站点生成器。书写Markdown格式的博客，并将其放到文件夹中，然后使用Liquid HTML模板构建网站。Jekyll自动将博客和模板联系在一起，生成完全由静态资源组成的网站。Jekyll恰好是GitHub Pages的引擎，因此可以在GitHub的服务器上免费托管项目的Jekyll页面/博客/网站。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>安装Ruby，下载包含Ruby + DevKit 的安装包，下载地址：<a href="http://rubyinstaller.org/downloads/">http://rubyinstaller.org/downloads/</a></p>
</li>
<li><p>更换gem的软件源</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gem -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前源</span></span><br><span class="line">gem sources -l</span><br><span class="line"></span><br><span class="line">删除默认源，因为它太慢了，替换成国内RubyGems镜像站点</span><br><span class="line">gem sources -r https://rubygems.org/</span><br><span class="line">gem sources -a http://gems.ruby-china.com</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装jekyll</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install jekyll</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ERROR: Could not find a valid gem ‘jekyll’ (&gt;= 0), here is why:<br>Unable to download data from <a href="https://rubygems.org/">https://rubygems.org/</a> - SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (<a href="https://api.rubygems.org/latest_spece.4.8.gz">https://api.rubygems.org/latest_spece.4.8.gz</a>)</p>
</blockquote>
<p>错误原因是因为证书问题，解决办法为：下载最新的证书：<a href="http://curl.haxx.se/ca/cacert.pem">http://curl.haxx.se/ca/cacert.pem</a> 放到指定文件夹，并配置环境变量。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SSL_CERT_FILE=/c/APP/Ruby21-x64/cacert.pe</span><br></pre></td></tr></table></figure>

<blockquote>
<p>C:/APP/Ruby30-x64/lib/ruby/gems/3.0.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `require’: cannot load such file – webrick (LoadError)</p>
</blockquote>
<p>因为版本过高，需要添加webrick</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gem install bundler</span><br><span class="line">bundle add webrick</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个新的Jekyll站</span></span><br><span class="line">jekyll new mylog</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务器</span></span><br><span class="line">jekyll serve</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">浏览器访问</span></span><br><span class="line">http://localhost:4000/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Deprecation: You appear to have pagination turned on, but you haven’t included the jekyll-paginate gem. Ensure you have plugins: [jekyll-paginate] in your configuration file.</p>
</blockquote>
<p>安装jekyll-paginate，并在 _config.yml 中增加插件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gem install jekyll-paginate</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins: </span><br><span class="line">    [jekyll-paginate]</span><br></pre></td></tr></table></figure>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">├── _config.yml  存储配置数据，执行jekyll命令时会自动使用。</span><br><span class="line">├── _drafts   草稿是未发布的文章，这些文件的命名格式是没有日期的。</span><br><span class="line">├── _posts   存放你要发表的文章，格式YEAR-MONTH-DAY-title.MARKUP。</span><br><span class="line">├── _layouts  包装文章的模板，通过&#123;&#123; content &#125;&#125;包含_posts里面的文章。</span><br><span class="line">├── _includes</span><br><span class="line">├── _data  jekyll会自动加载这里的所有.jml或者.yaml结尾的文件。</span><br><span class="line">├── _site  存放生成的网站</span><br><span class="line">├── index.html</span><br><span class="line">├── feed.xml</span><br></pre></td></tr></table></figure>

<hr>
<p>mzlogin.github.io<br>qiubaiying.github.io</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title>Regex</title>
    <url>/2022/06/07/tool/regex/</url>
    <content><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="left">转义符</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配输入字符串的开始位置</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入字符串的结束位置</td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除“<code>\n</code>之外的任何单个字符</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次，等价于{1,}</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次，等价于{0,1}</td>
</tr>
<tr>
<td align="center">*?</td>
<td align="left">匹配前面任意个表达式（尽可能少）</td>
</tr>
<tr>
<td align="center">+?</td>
<td align="left">匹配前面至少一个表达式（尽可能少）</td>
</tr>
<tr>
<td align="center">(pattern)</td>
<td align="left">匹配pattern并获取这一匹配，捕获并为括号内的字符隐式编号</td>
</tr>
<tr>
<td align="center">[abc]</td>
<td align="left">匹配集合中的任何字符</td>
</tr>
<tr>
<td align="center">[a-z]</td>
<td align="left">匹配范围中的任何字符</td>
</tr>
<tr>
<td align="center">[^abc]</td>
<td align="left">非字符集合，匹配未包含的任意字符</td>
</tr>
<tr>
<td align="center">[^a-z]</td>
<td align="left">非字符范围，匹配任何不在指定范围内的任意字符</td>
</tr>
<tr>
<td align="center">|</td>
<td align="left">两项之间匹配一个，使用时要加转义符</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">指定前一个字符出现次数</td>
</tr>
<tr>
<td align="center">{<em>n</em>,}</td>
<td align="left">其前面的字符出现不小于n次</td>
</tr>
<tr>
<td align="center">{<em>n</em>,<em>m</em>}</td>
<td align="left">其前面的字符至少出现n次，最多出现m次</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如，“<code>er\b</code>”可以匹配“<code>never</code>”中的“<code>er</code>”，但不能匹配“<code>verb</code>”中的“<code>er</code>”。</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">匹配非单词边界。“<code>er\B</code>”能匹配“<code>verb</code>”中的“<code>er</code>”，但不能匹配“<code>never</code>”中的“<code>er</code>”。</td>
</tr>
<tr>
<td align="center">\cx</td>
<td align="left">匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“<code>c</code>”字符。</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="left">匹配十进制字符，等价于[0-9]。</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="left">匹配一个非数字字符，等价于[^0-9]。</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="left">匹配一个换页符，等价于\x0c和\cL。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符，等价于\x0a和\cJ。</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符，等价于\x0d和\cM。</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等，等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配任何非空白字符，等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个制表符，等价于\x09和\cI。</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">匹配一个垂直制表符，等价于\x0b和\cK。</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配包括下划线的任何文字字符，等价于<code>[A-Za-z0-9_]</code></td>
</tr>
<tr>
<td align="center">\W</td>
<td align="left">匹配任何非单词字符，等价于“<code>[^A-Za-z0-9_]</code>”</td>
</tr>
<tr>
<td align="center">\u<em>n</em></td>
<td align="left">匹配<em>n</em>，其中<em>n</em>是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td>
</tr>
<tr>
<td align="center">\x<em>n</em></td>
<td align="left">匹配<em>n</em>，其中<em>n</em>为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<code>\x41</code>”匹配“<code>A</code>”。“<code>\x041</code>”则等价于“<code>\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。.</td>
</tr>
<tr>
<td align="center">(?:pattern)</td>
<td align="left">匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(</td>
</tr>
<tr>
<td align="center">(?=pattern)</td>
<td align="left">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95</td>
</tr>
<tr>
<td align="center">(?!pattern)</td>
<td align="left">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95</td>
</tr>
<tr>
<td align="center">(?&lt;=pattern)</td>
<td align="left">反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95</td>
</tr>
<tr>
<td align="center">(?&lt;!pattern)</td>
<td align="left">反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95</td>
</tr>
<tr>
<td align="center">*num*</td>
<td align="left">匹配<em>num</em>，其中<em>num</em>是一个正整数。对所获取的匹配的引用。例如，“<code>(.)\1</code>”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td align="center">*n*</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果*n<em>之前至少</em>n<em>个获取的子表达式，则</em>n<em>为向后引用。否则，如果</em>n<em>为八进制数字（0-7），则</em>n*为一个八进制转义值。</td>
</tr>
<tr>
<td align="center">*nm*</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果*nm<em>之前至少有</em>nm<em>个获得子表达式，则</em>nm<em>为向后引用。如果*nm</em>之前至少有<em>n</em>个获取，则<em>n</em>为一个后跟文字<em>m</em>的向后引用。如果前面的条件都不满足，若<em>n</em>和<em>m</em>均为八进制数字（0-7），则*nm<em>将匹配八进制转义值</em>nm*。</td>
</tr>
<tr>
<td align="center">*nml*</td>
<td align="left">如果<em>n</em>为八进制数字（0-3），且<em>m和l</em>均为八进制数字（0-7），则匹配八进制转义值<em>nm</em>l。</td>
</tr>
</tbody></table>
<p><img src="/images/code/regexp-metachar.png" alt="img"></p>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">ignore - 不区分大小写</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">global - 全局匹配</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">multi line - 多行匹配</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 s 之后, <strong>.</strong> 中包含换行符 <strong>\n</strong>。</td>
</tr>
</tbody></table>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">转义符</td>
</tr>
<tr>
<td align="left">(), (?:), (?=), []</td>
<td align="left">圆括号和方括号</td>
</tr>
<tr>
<td align="left">*, +, ?, {n}, {n,}, {n,m}</td>
<td align="left">限定符</td>
</tr>
<tr>
<td align="left">^, $, \任何元字符、任何字符</td>
<td align="left">定位点和序列（即：位置和顺序）</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td>
</tr>
</tbody></table>
<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><table>
<thead>
<tr>
<th align="center">用户名</th>
<th>/^[a-z0-9_-]{3,16}$/</th>
</tr>
</thead>
<tbody><tr>
<td align="center">密码</td>
<td>/^[a-z0-9_-]{6,18}$/</td>
</tr>
<tr>
<td align="center">十六进制值</td>
<td>/^#?([a-f0-9]{6}|[a-f0-9]{3})$/</td>
</tr>
<tr>
<td align="center">电子邮箱</td>
<td>/^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$/ /^[a-z\d]+(.[a-z\d]+)*@(<a href="-%5B%5Cda-z%5D">\da-z</a>?)+(.{1,2}[a-z]+)+$/</td>
</tr>
<tr>
<td align="center">URL</td>
<td>/^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-]*)*/?$/</td>
</tr>
<tr>
<td align="center">IP 地址</td>
<td>/((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/ /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</td>
</tr>
<tr>
<td align="center">HTML 标签</td>
<td>/^&lt;([a-z]+)([^&lt;]+)<em>(?:&gt;(.</em>)&lt;/\1&gt;|\s+/&gt;)$/</td>
</tr>
<tr>
<td align="center">删除代码\注释</td>
<td>(?&lt;!http:|\S)//.*$</td>
</tr>
<tr>
<td align="center">Unicode编码中的汉字范围</td>
<td>/^[\u2E80-\u9FFF]+$/</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title>repo</title>
    <url>/2022/06/07/tool/repo/</url>
    <content><![CDATA[<p>repo是Google开发的用于管理Android版本库的一个工具。repo并不是用来取代Git，而是用Python对Git进行了一定的封装，简化了对多个Git版本库的管理。</p>
<p>Repo 分为两部分：第一部分是下载并安装的 repo 启动器。这是一个 Python 脚本，该脚本知道如何初始化检出，并可下载第二部分，即 Android 源代码检出中包含的完整 repo 工具。完整的 Repo 工具默认位于 <code>$SRCDIR/.repo/repo/</code> 中，它可以从下载的 Repo 启动器接收转发的命令。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install repo</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/.bin/repo</span><br><span class="line">chmod a+rx ~/.bin/repo</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo init -u &lt;URL&gt; [&lt;OPTIONS&gt;]</span><br></pre></td></tr></table></figure>

<p>在当前目录下安装 Repo。这会产生一个 .repo/ 目录，目录包括装 Repo 源代码和标准 Android 清单文件的 Git 仓库。.repo/ 目录还包括manifest.xml，是一个在.repo/manifests/目录选择清单的符号链接。</p>
<p>选项：</p>
<ul>
<li>-u 指定manifest仓库地址（URL）。</li>
<li>-m 选择仓库中某个manifest文件，如果没有设置，就使用default.xml。</li>
<li>-b 指定一个分支或修正版本。</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>更新本地环境中的工作文件。如果不带参数，将同步所有项目的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo sync [&lt;PROJECT_LIST&gt;]</span><br></pre></td></tr></table></figure>

<p>选项:</p>
<ul>
<li>-j <numbers>  多任务</li>
<li>-c  只下载当前分支代码</li>
<li>-d  让工程回退到manifest指定的版本</li>
<li>-f  如果某个工程同步失败，继续同步</li>
<li>-q  通过抑制状态消息来确保运行过程没有干扰。</li>
<li>-s  同步到当前清单中的 manifest-server 元素指定的一个已知良好 build。</li>
</ul>
<h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo upload [&lt;PROJECT_LIST&gt;]</span><br></pre></td></tr></table></figure>

<p>在指定的项目中，Repo 把本地分支的更新比作远程分支在最后一次 Repo 同步。Repo 会提示你选择一个或更多尚未上传审查的分支。</p>
<h3 id="forall"><a href="#forall" class="headerlink" title="forall"></a>forall</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo forall [&lt;PROJECT_LIST&gt;] -c &lt;COMMAND&gt;</span><br></pre></td></tr></table></figure>

<p>在每个项目中被给予的 shell 命令。如下的附加环境变量是通过 repo forall 才变得有效的：</p>
<ul>
<li>REPO_PROJECT 设置项目唯一的名称。</li>
<li>REPO_PATH 是相对于客户端 root 的路径。</li>
<li>REPO_REMOTE 是清单中远程系统的名称。</li>
<li>REPO_LREV 是清单中修订本的名字，翻译成一个本地跟踪分支。如果你需要通过清单修正去本地执行 git 命令的时候可以使用。</li>
<li>REPO_RREV 是清单中修订本的名字，正如在清单中所写的那样。</li>
</ul>
<p>选项：</p>
<ul>
<li>-c  执行命令和参数。命令是通过 /bin/sh 评估的并且后面的任何参数就如 shell 位置的参数通过。</li>
<li>-p  在指定命令的输出前显示项目标题。这是通过绑定管道到命令的stdin，stdout，和 sterr 流，并且用管道输送所有输出量到一个连续的流，显示在一个单一的页面调度会话中。</li>
<li>-v  显示命令写到 sterr 的信息。</li>
</ul>
<h3 id="修改repo"><a href="#修改repo" class="headerlink" title="修改repo"></a>修改repo</h3><p>应该在 .repo/manifests 文件夹里面修改repo的结构，然后用git命令提交。manifest.xml 文件结构:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">&quot;shift&quot;</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">fetch</span>=<span class="string">&quot;git://git.mygit.com/&quot;</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">default</span> <span class="attr">revision</span>=<span class="string">&quot;kk-shift&quot;</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">remote</span>=<span class="string">&quot;shift&quot;</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">sync-j</span>=<span class="string">&quot;1&quot;</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">path</span>=<span class="string">&quot;packages/shift/VideoPlayer&quot;</span> <span class="attr">name</span>=<span class="string">&quot;platform/packages/shift/VideoPlayer&quot;</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">&quot;another_manifest.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<ul>
<li>manifest<br> 这个是配置的顶层元素，即根标志。</li>
<li>remote<br> name：在每一个.git/config文件的remote项中用到这个name，即表示每个git的远程服务器的名字(这个名字很关键，如果多个remote属性的话，default属性中需要指定default remote)。git pull、get fetch的时候会用到这个remote name。<br> alias ：可以覆盖之前定义的remote name，name必须是固定的，但是alias可以不同，可以用来指向不同的remote url<br> fetch ：所有git url真正路径的前缀，所有git 的project name加上这个前缀，就是git url的真正路径<br> review ：指定Gerrit的服务器名，用于repo upload操作。如果没有指定，则repo upload没有效果。</li>
<li>default<br> 设定所有projects的默认属性值，如果在project元素里没有指定一个属性，则使用default元素的属性值。<br> remote ：远程服务器的名字（上面remote属性中提到过，多个remote的时候需要指定default remote，就是这里设置了）<br> revision ：所有git的默认branch，后面project没有特殊指出revision的话，就用这个branch<br> sync_j ： 在repo sync中默认并行的数目<br> sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容<br> sync_s ： 如果设置为true，则会同步git的子项目。</li>
<li>manifest-server<br> 它的url属性用于指定manifest服务的URL，通常是一个XML RPC 服务<br> 它要支持一下RPC方法：<br> GetApprovedManifest(branch, target) ：返回一个manifest用于指示所有projects的分支和编译目标。<br> target参数来自环境变量<code>TARGET_PRODUCT</code>和<code>TARGET_BUILD_VARIANT</code>，组成<code>$TARGET_PRODUCT-$TARGET_BUILD_VARIANT</code><br> GetManifest(tag) ：返回指定tag的manifest。</li>
<li>project<br> 需要clone的单独git<br> name ：git 的名称，用于生成git url。URL格式是：${remote fetch}/${project name}.git 其中的 fetch就是上面提到的remote 中的fetch元素，name 就是此处的name<br> path ：clone到本地的git的工作目录，如果没有配置的话，跟name一样<br> remote ：定义remote name，如果没有定义的话就用default中定义的remote name<br> revision ：指定需要获取的git提交点，可以定义成固定的branch，或者是明确的commit 哈希值<br> groups ：列出project所属的组，以空格或者逗号分隔多个组名。所有的project都自动属于”all”组。每一个project自动属于<br> name:’name’ 和path:’path’组。例如<project name="monkeys" path="barrel-of"/>，它自动属于default, name:monkeys, and path:barrel-of组。如果一个project属于notdefault组，则，repo sync时不会下载<br> sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容。<br> sync_s ： 如果设置为true，则会同步git的子项目<br> upstream ：在哪个git分支可以找到一个SHA1。用于同步revision锁定的manifest(-c 模式)。该模式可以避免同步整个ref空间<br> annotation ：可以有0个或多个annotation，格式是name-value，repo forall命令是会用来定义环境变量。</li>
<li>include<br> 通过name属性可以引入另外一个manifest文件(路径相对与当前的manifest.xml 的路径)<br> name ：另一个需要导入的manifest文件名字<br> 可以在当前的路径下添加一个another_manifest.xml，这样可以在另一个xml中添加或删除project。</li>
<li>remove-project<br> 从内部的manifest表中删除指定的project。经常用于本地的manifest文件，用户可以替换一个project的定义。</li>
</ul>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>根据当前.repo的状态来创建一个配置文件，这个文件用来保存当前的工作状态。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">repo manifest -o snapshot<span class="selector-class">.xml</span> -r</span><br></pre></td></tr></table></figure>

<p>恢复一个快照，可以用下面的命令：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">cp snapshot.xml .repo/manifests/</span><br><span class="line">repo init -m snapshot.xml</span><br><span class="line">repo <span class="keyword">sync</span> -d</span><br></pre></td></tr></table></figure>

<p>注意：没有commit的修改不会恢复，已经commit的但是没有push的是可以恢复的，但只能从本地恢复。</p>
<h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo status [project-list]</span><br></pre></td></tr></table></figure>

<p>对于每个指定的项目，将工作树与临时区域（索引）以及此分支 (HEAD) 上的最近一次提交进行比较。针对这三种状态之间存在差异的每个文件，显示其摘要行。</p>
<p>如需查看当前分支的状态，请运行 <code>repo status</code>。系统会按项目列出状态信息。对于项目中的每个文件，系统使用两个字母的代码来表示：</p>
<p>在第一列中，大写字母表示临时区域与上次提交状态之间的不同之处。</p>
<table>
<thead>
<tr>
<th align="left">字母</th>
<th align="left">含义</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-</td>
<td align="left">没有变化</td>
<td align="left">在 HEAD 与索引中相同</td>
</tr>
<tr>
<td align="left">A</td>
<td align="left">已添加</td>
<td align="left">不存在于 HEAD 中，但存在于索引中</td>
</tr>
<tr>
<td align="left">M</td>
<td align="left">已修改</td>
<td align="left">存在于 HEAD 中，但索引中的文件已修改</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">已删除</td>
<td align="left">存在于 HEAD 中，但不存在于索引中</td>
</tr>
<tr>
<td align="left">R</td>
<td align="left">已重命名</td>
<td align="left">不存在于 HEAD 中，索引中文件的路径已更改</td>
</tr>
<tr>
<td align="left">C</td>
<td align="left">已复制</td>
<td align="left">不存在于 HEAD 中，复制自索引中的另一个文件</td>
</tr>
<tr>
<td align="left">T</td>
<td align="left">模式已更改</td>
<td align="left">HEAD 与索引中的内容相同，但模式已更改</td>
</tr>
<tr>
<td align="left">U</td>
<td align="left">未合并</td>
<td align="left">HEAD 与索引之间存在冲突；需要加以解决</td>
</tr>
</tbody></table>
<p>在第二列中，小写字母表示工作目录与索引之间的不同之处。</p>
<table>
<thead>
<tr>
<th align="left">字母</th>
<th align="left">含义</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-</td>
<td align="left">新/未知</td>
<td align="left">不存在于索引中，但存在于工作树中</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">已修改</td>
<td align="left">存在于索引中，也存在于工作树中（但已修改）</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">已删除</td>
<td align="left">存在于索引中，但不存在于工作树中</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo update[ project-list ]</span><br></pre></td></tr></table></figure>

<p>上传修改的代码 ，如果你本地的代码有所修改，那么在运行 repo sync 的时候，会提示你上传修改的代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo diff [ project-list ]</span><br></pre></td></tr></table></figure>

<p>显示提交的代码和当前工作目录代码之间的差异。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo download  target revision</span><br></pre></td></tr></table></figure>

<p>下载特定的修改版本到本地， 例如:  repo download pltform/frameworks/base 1241 下载修改版本为 1241 的代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo start branch-name [project-list]</span><br></pre></td></tr></table></figure>

<p>从清单中指定的修订版本开始，创建一个新的分支进行开发。</p>
<ul>
<li><code>branch-name</code> 参数用于说明您尝试对项目进行的更改。如果您不知道，请考虑使用名称 <code>default</code>。</li>
<li><code>project-list</code> 参数指定了将参与此主题分支的项目。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo prune [project list]</span><br></pre></td></tr></table></figure>

<p>删除已经merge 的 project</p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>repo</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text插件与配置</title>
    <url>/2022/08/27/tool/sublime/</url>
    <content><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;auto_complete&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;auto_complete_commit_on_tab&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;auto_complete_with_fields&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;color_scheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Packages/Color Scheme - Default/Mariana.sublime-color-scheme&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;theme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Default.sublime-theme&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;font_face&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JetBrains Mono&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;font_face1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Consolas&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;font_face2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DejaVu Sans Mono&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;font_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;gray_antialias&quot;</span><span class="punctuation">,</span> <span class="string">&quot;gdi&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;default_encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UTF-8&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;default_line_ending&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unix&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;font_size&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tab_size&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;translate_tabs_to_spaces&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;highlight_line&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;update_check&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vintage_ctrl_keys&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vintage_start_in_command_mode&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;word_wrap&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rulers&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="number">100</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ignored_packages&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;Package Control&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ignored_packages_bak&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;Vintage&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;file_exclude_patterns&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;*.pyc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.pyo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.dll&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.obj&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.o&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.a&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.lib&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.so&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.dylib&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.ncb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.sdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.suo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.pdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.idb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;.DS_Store&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.class&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.psd&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.db&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.sublime-workspace&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.ko.*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.mod.*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.o.*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;a.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.order&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.ko&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.symvers&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*_test&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;folder_exclude_patterns&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;.svn&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;.git&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;.hg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;CVS&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;.tags&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;.tmp*&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;navigate_to_definition&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;alt+t&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jump_prev&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;alt+b&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span> </span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alignment&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ctrl+shift+a&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>配置鼠标操作，点击Preferences-&gt;Browse Packages进入Packages目录，然后打开User目录，查看User目录里面有没有Default (Windows).sublime-mousemap文件，如果没有则创建一个。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;button&quot;</span><span class="punctuation">:</span> <span class="string">&quot;button1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;press_command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;drag_select&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;modifiers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;alt&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;navigate_to_definition&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;button&quot;</span><span class="punctuation">:</span> <span class="string">&quot;button2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;modifiers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;alt&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jump_prev&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h2 id="package-control"><a href="#package-control" class="headerlink" title="package control"></a>package control</h2><h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><h3 id="All-Autocomplete"><a href="#All-Autocomplete" class="headerlink" title="All Autocomplete"></a>All Autocomplete</h3><h3 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h3><h3 id="Color-Highlight"><a href="#Color-Highlight" class="headerlink" title="Color Highlight"></a>Color Highlight</h3><h3 id="Higlighter"><a href="#Higlighter" class="headerlink" title="Higlighter"></a>Higlighter</h3><h3 id="WordHighlight"><a href="#WordHighlight" class="headerlink" title="WordHighlight"></a>WordHighlight</h3><h3 id="Block-Cursor-Everywhere"><a href="#Block-Cursor-Everywhere" class="headerlink" title="Block Cursor Everywhere"></a>Block Cursor Everywhere</h3><h3 id="BracketHighlighter"><a href="#BracketHighlighter" class="headerlink" title="BracketHighlighter"></a>BracketHighlighter</h3><h3 id="Side-Bar"><a href="#Side-Bar" class="headerlink" title="Side Bar"></a>Side Bar</h3><h3 id="DocBlockr"><a href="#DocBlockr" class="headerlink" title="DocBlockr"></a>DocBlockr</h3><h3 id="CTags"><a href="#CTags" class="headerlink" title="CTags"></a>CTags</h3><ol>
<li>安装ctags，设置环境变量。</li>
<li>在Preferences菜单中打开Package settings-&gt;ctags-&gt;settings-user和settings-default<br>把default中的配置全部复制到user中，然后改一下command配置项，为ctags的可执行文件路径</li>
<li>工程目录执行<code>ctags -R -f .tags</code></li>
<li>设置键盘快捷键</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;navigate_to_definition&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;alt+t&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jump_prev&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;alt+b&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>5.设置鼠标快捷键</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;button&quot;</span><span class="punctuation">:</span> <span class="string">&quot;button1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;press_command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;drag_select&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;modifiers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ctrl&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;navigate_to_definition&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;button&quot;</span><span class="punctuation">:</span> <span class="string">&quot;button2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;modifiers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ctrl&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jump_prev&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h3><p>1.设置默认信息键值对，Preferences -&gt; Pacakge Settings -&gt; File Header -&gt; Setting User</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;luo_u&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;luo_u@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>2.更改模板文件，进入SublimeText 插件安装目录，Preferences -&gt; Browse Packages-&gt;File Header -&gt; template -&gt; header，有大量的.tmpl 文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description:    </span></span><br><span class="line"><span class="comment"> * @Author: &#123;&#123;author&#125;&#125;</span></span><br><span class="line"><span class="comment"> * @Date: &#123;&#123;create_time&#125;&#125;</span></span><br><span class="line"><span class="comment"> * @LastEditor: &#123;&#123;last_modified_by&#125;&#125;</span></span><br><span class="line"><span class="comment"> * @LastEditTime: &#123;&#123;last_modified_time&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;terminal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Git\\git-bash.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ctrl+shift+a&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alignment&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Snippets"><a href="#Snippets" class="headerlink" title="Snippets"></a>Snippets</h2><p>打开Tools-&gt;New snippet创建代码段</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">snippet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">content</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">/******************************************************************</span><br><span class="line">  * @file    $TM_FILENAME</span><br><span class="line">  * @brief   $1</span><br><span class="line">  * @author  $&#123;2:luo_u&#125;</span><br><span class="line">  * @date    $3</span><br><span class="line">******************************************************************/</span><br><span class="line">]]&gt;<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Set a tabTrigger to define how to trigger the snippet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tabTrigger</span>&gt;</span>hand<span class="tag">&lt;/<span class="name">tabTrigger</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Set a scope to limit where the snippet will trigger --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>source.c<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Optional: Description to show in the menu --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>c file hand<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snippet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>content</code>其中必须包含<code>&lt;![CDATA[…]]&gt;</code>,否则无法工作, [..]中写你自己的代码片段</li>
<li><code>tabTrigger</code>用来引发代码片段的字符或者字符串</li>
<li><code>scope</code>表示你的代码片段会在那种语言环境下激活</li>
<li><code>description</code> 展示代码片段的描述，默认使用代码片段的文件名作为描述</li>
</ul>
<h3 id="Snippet环境变量"><a href="#Snippet环境变量" class="headerlink" title="Snippet环境变量"></a>Snippet环境变量</h3><table>
<thead>
<tr>
<th><strong>环境变量名</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>$PARAM1 .. $PARAMn</td>
<td>Arguments passed to the <code>insert_snippet</code> command.</td>
</tr>
<tr>
<td>$SELECTION</td>
<td>The text that was selected when the snippet was triggered.</td>
</tr>
<tr>
<td>$TM_CURRENT_LINE</td>
<td>Content of the cursor’s line when the snippet was triggered.</td>
</tr>
<tr>
<td>$TM_CURRENT_WORD</td>
<td>Word under the cursor when the snippet was triggered.</td>
</tr>
<tr>
<td>$TM_DIRECTORY</td>
<td>Directory name of the file being edited. (since 3154)</td>
</tr>
<tr>
<td>$TM_FILENAME</td>
<td>用户文件名</td>
</tr>
<tr>
<td>$TM_FILEPATH</td>
<td>用户的用户名</td>
</tr>
<tr>
<td>$TM_FULLNAME</td>
<td>用户的用户名</td>
</tr>
<tr>
<td>$TM_LINE_INDEX</td>
<td>插入多少列, 默认为0</td>
</tr>
<tr>
<td>$TM_LINE_NUMBER</td>
<td>一个snippet插入多少行</td>
</tr>
<tr>
<td>$TM_SELECTED_TEXT</td>
<td>An alias for $SELECTION.</td>
</tr>
<tr>
<td>$TM_SCOPE</td>
<td>The scope of the beginning of each selected region. (since 3154)</td>
</tr>
<tr>
<td>$TM_SOFT_TABS</td>
<td>如果设置translate_tabs_to_spaces : true 则为Yes</td>
</tr>
<tr>
<td>$TM_TAB_SIZE</td>
<td>每个Tab包含几个空格</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2022/06/07/tool/shell/</url>
    <content><![CDATA[<p>unset 命令用于取消变量或取消变量赋值。</p>
<p><code>$?</code> 可以来检查前一命令的结束状态。如果是 0，说明前一个命令执行成功，否则执行失败。</p>
<p>反引号将命令括起来执行。格式：`pwd`，可以得到这个命令的返回值。</p>
<h2 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h2><p>任何输入到这个设备的数据都将被直接丢弃，常见的用法是把不需要的输出重定向到这个文件。</p>
<ul>
<li>禁止标准输出，文件内容丢失，而不会输出到标准输出</li>
</ul>
<blockquote>
<p>cat $filename &gt;/dev/null</p>
</blockquote>
<ul>
<li>禁止标准错误</li>
</ul>
<blockquote>
<p>cat $filename 2&gt;/dev/null</p>
</blockquote>
<ul>
<li>禁止标准输出和标准错误的输出</li>
</ul>
<blockquote>
<p>cat $filename 2&gt;/dev/null &gt;/dev/null</p>
</blockquote>
<blockquote>
<p>cat $filename &amp;&gt;/dev/null</p>
</blockquote>
<ul>
<li>清空文件的内容</li>
</ul>
<blockquote>
<p>cat /dev/null &gt; /var/log/messages</p>
</blockquote>
<ul>
<li>隐藏cookie而不再使用</li>
</ul>
<blockquote>
<p>ln -s /dev/null ~/.netscape/cookies</p>
</blockquote>
<p><code>/dev/zero</code>是一个伪文件，产生连续不断的null的流（二进制的零流，而不是ASCII型的）。写入它的输出会丢失不见，主要的用处是用来创建一个指定长度用于初始化的空文件，像临时交换文件。</p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>vim插件与配置</title>
    <url>/2022/09/04/tool/vim/</url>
    <content><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&quot; 设置当文件被改动时自动载入</span><br><span class="line">set autoread</span><br><span class="line"></span><br><span class="line">&quot;代码补全</span><br><span class="line">set completeopt=preview,menu</span><br><span class="line"></span><br><span class="line">&quot;允许插件  </span><br><span class="line">filetype plugin on</span><br><span class="line"></span><br><span class="line">&quot;共享剪贴板  </span><br><span class="line">set clipboard+=unnamed</span><br><span class="line"></span><br><span class="line">&quot;从不备份  </span><br><span class="line">set nobackup</span><br><span class="line"></span><br><span class="line">&quot;自动保存</span><br><span class="line">set autowrite</span><br><span class="line">set ruler                   &quot; 打开状态栏标尺</span><br><span class="line">set cursorline              &quot; 突出显示当前行</span><br><span class="line"></span><br><span class="line">&quot; 高亮光标所在的行列</span><br><span class="line">highlight CursorLine   cterm=NONE ctermbg=black ctermfg=NONE guibg=NONE guifg=NONE</span><br><span class="line">highlight CursorColumn cterm=NONE ctermbg=black ctermfg=NONE guibg=NONE guifg=NONE</span><br><span class="line"></span><br><span class="line">&quot; CursorLine 和 CursorColumn 分别表示当前所在的行列，cterm 表示为原生vim设置样式，设置为NONE表示可以自定义设置。ctermbg 设置终端vim的背景色；ctermfg 设置终端vim的前景色。guibg 和 guifg 分别是设置gvim的背景色和前景色</span><br><span class="line"></span><br><span class="line">set magic                   &quot; 设置魔术</span><br><span class="line">set guioptions-=T           &quot; 隐藏工具栏</span><br><span class="line">set guioptions-=m           &quot; 隐藏菜单栏</span><br><span class="line"></span><br><span class="line">&quot; 设置在状态行显示的信息</span><br><span class="line">&quot;set foldcolumn=0</span><br><span class="line">&quot;set foldmethod=indent</span><br><span class="line">&quot;set foldlevel=3</span><br><span class="line">&quot;set foldenable              &quot; 开始折叠</span><br><span class="line"></span><br><span class="line">&quot; 不要使用vi的键盘模式，而是vim自己的</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">&quot; 语法高亮</span><br><span class="line">set syntax=on</span><br><span class="line"></span><br><span class="line">&quot; 配色方案</span><br><span class="line">&quot;&quot;colorscheme darkblue</span><br><span class="line"></span><br><span class="line">&quot; 去掉输入错误的提示声音</span><br><span class="line">set noeb</span><br><span class="line"></span><br><span class="line">&quot; 在处理未保存或只读文件的时候，弹出确认</span><br><span class="line">set confirm</span><br><span class="line"></span><br><span class="line">&quot; 自动缩进</span><br><span class="line">set autoindent</span><br><span class="line">set cindent</span><br><span class="line"></span><br><span class="line">&quot; Tab键的宽度</span><br><span class="line">set tabstop=2</span><br><span class="line"></span><br><span class="line">&quot; 统一缩进为4</span><br><span class="line">set softtabstop=2</span><br><span class="line">set shiftwidth=2</span><br><span class="line"></span><br><span class="line">&quot; 不要用空格代替制表符</span><br><span class="line">set noexpandtab</span><br><span class="line"></span><br><span class="line">&quot; 在行和段开始处使用制表符</span><br><span class="line">set smarttab</span><br><span class="line"></span><br><span class="line">&quot; 显示行号</span><br><span class="line">set number</span><br><span class="line"></span><br><span class="line">&quot; 历史记录数</span><br><span class="line">set history=1000</span><br><span class="line"></span><br><span class="line">&quot;禁止生成临时文件</span><br><span class="line">set nobackup</span><br><span class="line">set noswapfile</span><br><span class="line"></span><br><span class="line">&quot;搜索逐字符高亮</span><br><span class="line">set hlsearch</span><br><span class="line">set incsearch</span><br><span class="line"></span><br><span class="line">&quot;行内替换</span><br><span class="line">set gdefault</span><br><span class="line"></span><br><span class="line">&quot;编码设置</span><br><span class="line">set enc=utf-8</span><br><span class="line">set fencs=utf-8,GB18030,ucs-bom,default,latin1</span><br><span class="line"></span><br><span class="line">&quot;语言设置</span><br><span class="line">set langmenu=zh_CN.UTF-8</span><br><span class="line">set helplang=cn</span><br><span class="line"></span><br><span class="line">&quot; 总是显示状态行</span><br><span class="line">set laststatus=2</span><br><span class="line"></span><br><span class="line">&quot; 命令行（在状态行下）的高度，默认为1，这里是2</span><br><span class="line">set cmdheight=2</span><br><span class="line"></span><br><span class="line">&quot; 侦测文件类型</span><br><span class="line">filetype on</span><br><span class="line"></span><br><span class="line">&quot; 载入文件类型插件</span><br><span class="line">filetype plugin on</span><br><span class="line"></span><br><span class="line">&quot; 为特定文件类型载入相关缩进文件</span><br><span class="line">filetype indent on</span><br><span class="line"></span><br><span class="line">&quot; 保存全局变量</span><br><span class="line">set viminfo+=!</span><br><span class="line"></span><br><span class="line">&quot; 带有如下符号的单词不要被换行分割</span><br><span class="line">set iskeyword+=_,$,@,%,#,-</span><br><span class="line"></span><br><span class="line">&quot; 字符间插入的像素行数目</span><br><span class="line">set linespace=0</span><br><span class="line"></span><br><span class="line">&quot; 增强模式中的命令行自动完成操作</span><br><span class="line">set wildmenu</span><br><span class="line"></span><br><span class="line">&quot; 使回格键（backspace）正常处理indent, eol, start等</span><br><span class="line">set backspace=2</span><br><span class="line"></span><br><span class="line">&quot; 允许backspace和光标键跨越行边界</span><br><span class="line">set whichwrap+=&lt;,&gt;,h,l</span><br><span class="line"></span><br><span class="line">&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）</span><br><span class="line">set mouse=a</span><br><span class="line">set selection=exclusive</span><br><span class="line">set selectmode=mouse,key</span><br><span class="line"></span><br><span class="line">&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过</span><br><span class="line">set report=0</span><br><span class="line"></span><br><span class="line">&quot; 在被分割的窗口间显示空白，便于阅读</span><br><span class="line">set fillchars=vert:\ ,stl:\ ,stlnc:\</span><br><span class="line"></span><br><span class="line">&quot; 高亮显示匹配的括号</span><br><span class="line">set showmatch</span><br><span class="line"></span><br><span class="line">&quot; 匹配括号高亮的时间（单位是十分之一秒）</span><br><span class="line">set matchtime=1</span><br><span class="line"></span><br><span class="line">&quot; 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line">set scrolloff=3</span><br><span class="line"></span><br><span class="line">&quot; 为C程序提供自动缩进</span><br><span class="line">set smartindent</span><br><span class="line"></span><br><span class="line">&quot; 高亮显示普通txt文件（需要txt.vim脚本）</span><br><span class="line">au BufRead,BufNewFile *  setfiletype txt</span><br><span class="line"></span><br><span class="line">&quot;自动补全</span><br><span class="line">:inoremap ( ()<span class="tag">&lt;<span class="name">ESC</span>&gt;</span>i</span><br><span class="line">:inoremap &#123; &#123;&#125;<span class="tag">&lt;<span class="name">ESC</span>&gt;</span>i</span><br><span class="line">:inoremap [ []<span class="tag">&lt;<span class="name">ESC</span>&gt;</span>i</span><br><span class="line">:inoremap &quot; &quot;&quot;<span class="tag">&lt;<span class="name">ESC</span>&gt;</span>i</span><br><span class="line">:inoremap &#x27; &#x27;&#x27;<span class="tag">&lt;<span class="name">ESC</span>&gt;</span>i</span><br><span class="line"></span><br><span class="line">&quot; 按tab键依次选择</span><br><span class="line">set wildmenu</span><br><span class="line"></span><br><span class="line">&quot;配置规则</span><br><span class="line">set wildmode=longest,list,full</span><br><span class="line"></span><br><span class="line">&quot;---------------------------------------------&quot;</span><br><span class="line">&quot; cscope  设置</span><br><span class="line">&quot;---------------------------------------------&quot;</span><br><span class="line">:cs add cscope.out</span><br><span class="line"></span><br><span class="line">&quot;---------------------------------------------&quot;</span><br><span class="line">&quot; Tag List  设置</span><br><span class="line">&quot;---------------------------------------------&quot;</span><br><span class="line">nmap <span class="tag">&lt;<span class="name">F5</span>&gt;</span> :TlistToggle<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line"></span><br><span class="line">let Tlist_Ctags_Cmd=&quot;/usr/bin/ctags&quot;  &quot;ctags程序位置</span><br><span class="line">let Tlist_Inc_Winwidth=0        &quot;window width change off</span><br><span class="line">let Tlist_Auto_Open=0           &quot;vim 开始时window open=off</span><br><span class="line">let Tlist_Use_Left_Window=1     &quot;显示在左侧</span><br><span class="line">let Tlist_Show_One_File=1       &quot;不同时显示多个文件的tag，只显示当前文件的    </span><br><span class="line">let Tlist_Exit_OnlyWindow=1     &quot;如果taglist窗口是最后一个窗口，则退出vim   </span><br><span class="line">set ut=100</span><br><span class="line"></span><br><span class="line">&quot;---------------------------------------------&quot;</span><br><span class="line">&quot; NERDTree  设置</span><br><span class="line">&quot;---------------------------------------------&quot;</span><br><span class="line">nmap <span class="tag">&lt;<span class="name">F8</span>&gt;</span> :NERDTreeToggle<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">let NERDTreeWinPos=&quot;right&quot;</span><br><span class="line"></span><br><span class="line">&quot;---------------------------------------------&quot;</span><br><span class="line">&quot; SrcExpl  设置</span><br><span class="line">&quot;---------------------------------------------&quot;</span><br><span class="line">&quot; // The switch of the Source Explorer </span><br><span class="line">nmap <span class="tag">&lt;<span class="name">F7</span>&gt;</span> :SrcExplToggle<span class="tag">&lt;<span class="name">CR</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">&quot; // Set the height of Source Explorer window </span><br><span class="line">let g:SrcExpl_winHeight = 8 </span><br><span class="line"></span><br><span class="line">&quot; // Set 100 ms for refreshing the Source Explorer </span><br><span class="line">let g:SrcExpl_refreshTime = 100 </span><br><span class="line"></span><br><span class="line">&quot; // Set &quot;Enter&quot; key to jump into the exact definition context </span><br><span class="line">let g:SrcExpl_jumpKey = &quot;<span class="tag">&lt;<span class="name">ENTER</span>&gt;</span>&quot; </span><br><span class="line"></span><br><span class="line">&quot; // Set &quot;Space&quot; key for back from the definition context </span><br><span class="line">let g:SrcExpl_gobackKey = &quot;<span class="tag">&lt;<span class="name">SPACE</span>&gt;</span>&quot; </span><br><span class="line"></span><br><span class="line">&quot; // In order to avoid conflicts, the Source Explorer should know what plugins except</span><br><span class="line">&quot; // itself are using buffers. And you need add their buffer names into below list</span><br><span class="line">&quot; // according to the command &quot;:buffers!&quot;</span><br><span class="line">let g:SrcExpl_pluginList = [</span><br><span class="line">        \ &quot;__Tag_List__&quot;,</span><br><span class="line">        \ &quot;_NERD_tree_&quot;,</span><br><span class="line">        \ &quot;Source_Explorer&quot;</span><br><span class="line">    \ ]</span><br><span class="line"></span><br><span class="line">&quot; // The color schemes used by Source Explorer. There are five color schemes</span><br><span class="line">&quot; // supported for now - Red, Cyan, Green, Yellow and Magenta. Source Explorer</span><br><span class="line">&quot; // will pick up one of them randomly when initialization.</span><br><span class="line">let g:SrcExpl_colorSchemeList = [</span><br><span class="line">        \ &quot;Red&quot;,</span><br><span class="line">        \ &quot;Cyan&quot;,</span><br><span class="line">        \ &quot;Green&quot;,</span><br><span class="line">        \ &quot;Yellow&quot;,</span><br><span class="line">        \ &quot;Magenta&quot;</span><br><span class="line">    \ ]</span><br><span class="line"></span><br><span class="line">&quot; // Enable/Disable the local definition searching, and note that this is not </span><br><span class="line">&quot; // guaranteed to work, the Source Explorer doesn&#x27;t check the syntax for now. </span><br><span class="line">&quot; // It only searches for a match with the keyword according to command &#x27;gd&#x27; </span><br><span class="line">let g:SrcExpl_searchLocalDef = 1 </span><br><span class="line"></span><br><span class="line">&quot; // Workaround for Vim bug @https://goo.gl/TLPK4K as any plugins using autocmd for</span><br><span class="line">&quot; // BufReadPre might have conflicts with Source Explorer. e.g. YCM, Syntastic etc.</span><br><span class="line">let g:SrcExpl_nestedAutoCmd = 1</span><br><span class="line"></span><br><span class="line">&quot; // Do not let the Source Explorer update the tags file when opening </span><br><span class="line">let g:SrcExpl_isUpdateTags = 0 </span><br><span class="line"></span><br><span class="line">&quot; // Use &#x27;Exuberant Ctags&#x27; with &#x27;--sort=foldcase -R .&#x27; or &#x27;-L cscope.files&#x27; to </span><br><span class="line">&quot; // create/update the tags file </span><br><span class="line">let g:SrcExpl_updateTagsCmd = &quot;ctags --sort=foldcase -R .&quot; </span><br><span class="line"></span><br><span class="line">&quot; // Set &quot;<span class="tag">&lt;<span class="name">F12</span>&gt;</span>&quot; key for updating the tags file artificially </span><br><span class="line">let g:SrcExpl_updateTagsKey = &quot;<span class="tag">&lt;<span class="name">F12</span>&gt;</span>&quot; </span><br><span class="line"></span><br><span class="line">&quot; // Set &quot;<span class="tag">&lt;<span class="name">F3</span>&gt;</span>&quot; key for displaying the previous definition in the jump list </span><br><span class="line">let g:SrcExpl_prevDefKey = &quot;<span class="tag">&lt;<span class="name">F3</span>&gt;</span>&quot; </span><br><span class="line"></span><br><span class="line">&quot; // Set &quot;<span class="tag">&lt;<span class="name">F4</span>&gt;</span>&quot; key for displaying the next definition in the jump list </span><br><span class="line">let g:SrcExpl_nextDefKey = &quot;<span class="tag">&lt;<span class="name">F4</span>&gt;</span>&quot; </span><br><span class="line"></span><br><span class="line">&quot;---------------------------------------------&quot;</span><br><span class="line">&quot; Trinity  设置</span><br><span class="line">&quot;---------------------------------------------&quot;</span><br><span class="line">nmap <span class="tag">&lt;<span class="name">F6</span>&gt;</span>  :TrinityToggleAll<span class="tag">&lt;<span class="name">CR</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">vmap <span class="tag">&lt;<span class="name">c-c</span>&gt;</span> &quot;+y</span><br></pre></td></tr></table></figure>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a>ctags</h3><p>ctags 默认并不会提取所有标识符的tag标签，以下命令可以生成更加详细的tag文件</p>
<blockquote>
<p>ctags -R –c-kinds=+c+d+e+f+g+m+n+s+t+u+v –fields=+liaS –extra=+q –langmap=c:+.h.s.S –exclude=build/*</p>
</blockquote>
<p>可以在Vim尾行模式或Vim配置文件 .~/.vimrc 中通过以下命令显式地指定tag文件路径：<code>:set tags+=tags文件路径</code></p>
<p><code>--list-kinds=c++</code> 可列出C++支持生成的标签类型的全量列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c     类classes)</span><br><span class="line">d     宏定义(macro definitions)</span><br><span class="line">e     枚举变量(enumerators)</span><br><span class="line">f     函数定义(function definitions)</span><br><span class="line">g     枚举类型(enumeration names)</span><br><span class="line">l     局部变量(local variables)，默认不提取</span><br><span class="line">m     类、结构体、联合体(class, struct, and union members)</span><br><span class="line">n     命名空间(namespaces)</span><br><span class="line">p     函数原型(function prototypes)，默认不提取</span><br><span class="line">s     结构体类型(structure names)</span><br><span class="line">t     类型定义(typedefs)</span><br><span class="line">u     联合体类型(union names)</span><br><span class="line">v     变量定义(variable definitions)</span><br><span class="line">x     外部变量(external and forward variable declarations)，默认不提取</span><br></pre></td></tr></table></figure>

<p>局部对象、函数声明、外部变量等类型默认不会生成标签，所以在上面的ctags命令中显式加上了这些类型，用于生成所有类型的标签。</p>
<p><code>--list-maps</code> 查看默认情况下支持那些语言，每一种支持的语言支持的文件扩展名是什么。</p>
<p><code>--list-kinds=c++</code> 查看c++语言可以识别哪些语法元素。</p>
<p><code>--langmap=c++:+.hpp</code> 认定某种扩展名的文件为某种语法语言文件</p>
<p><code>fields=+iaS</code> 表明ctags要求描述的信息</p>
<ul>
<li>i 表示如果有继承，要标明父类；</li>
<li>a 表示如果是类的成员，要标明其访问权限</li>
<li>S 表示如果是函数，则生成的tag文件要标识函数的原型</li>
<li>K 表示要显示语法元素类型的全称；</li>
<li>z 表示在显示语法元素的类型时，使用格式kind:type。</li>
</ul>
<p><code>extra=+q</code> 表示强制要求ctags对同一个语法元素 再 记一行(如果某个语法元素是类的一个成员，ctags默认会给其记录一行)，这样可以保证在Vim中多个同名函数可以通过路径不同来区分。</p>
<p><code>--exclude=</code> 路径不能加./。</p>
<p><code>Ctrl + ]</code> 转跳到光标所在函数定义处；<code>Ctrl + t</code>跳回；</p>
<h3 id="cscope"><a href="#cscope" class="headerlink" title="cscope"></a>cscope</h3><blockquote>
<p>cscope -Rbqk</p>
</blockquote>
<ul>
<li>R : 对目录和子目录下所有文件都递归创建索引</li>
<li>b : 生成数据库后不进入查询界面</li>
<li>q : 建立cscope.in.out和cscope.po.out，可加快搜索速度</li>
<li>k : 不在预定义的系统路径中搜索(如：/usr/include)</li>
<li>i: 指定保存文件列表的文件名（cscope.files），可以使用”–“，表示由标准输入获得文件列表。</li>
<li>I dir: 在-I选项指出的目录中查找头文件</li>
<li>u: 扫描所有文件，重新生成交叉索引文件</li>
<li>C: 搜索时忽略大小写</li>
<li>P path: 在以相对路径表示的文件前加上的path，这样不用切换到数据库文件所在的目录也可以使用。</li>
</ul>
<p>在代码所在根目录下，用vim打开代码，导入索引文件：<code>:cs add cscope.out</code>就可以使用以下命令了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:cs find s &#123;name&#125; : 查找c语言符号，即查找函数名、宏、枚举值等出现的地方</span><br><span class="line">:cs find g &#123;name&#125; : 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能</span><br><span class="line">:cs find c &#123;name&#125; : 找出使用name的地方</span><br><span class="line">:cs find t &#123;name&#125; : 找出name的字串</span><br><span class="line">:cs find e &#123;name&#125; : 查找egrep模式，相当于egrep功能，但查找速度快多了</span><br><span class="line">:cs find f &#123;name&#125; : 查找并打开文件，类似vim的find功能</span><br><span class="line">:cs find i &#123;name&#125; : 查找include此文件的文件</span><br><span class="line">:cs find d &#123;name&#125; : 查找调用本函数的函数</span><br></pre></td></tr></table></figure>

<p>Cscope缺省只解析C文件(.c和.h)、lex文件(.l)和yacc文件(.y)，虽然它也可以支持C++以及Java，但它在扫描目录时会跳过C++及Java后缀的文件。如果你希望cscope解析C++或Java文件，需要把这些文件的名字和路径保存在一个名为cscope.files的文件。当cscope发现在当前目录中存在cscope.files时，就会为cscope.files中列出的所有文件生成索引数据库。通常我们使用 find 来生成cscope.files文件。</p>
<h3 id="taglist"><a href="#taglist" class="headerlink" title="taglist"></a>taglist</h3><p><a href="https://www.vim.org/scripts/script.php?script_id=273">https://www.vim.org/scripts/script.php?script_id=273</a></p>
<p>在Vim命令行下运行”:Tlist”就可以打开Taglist窗口，再次运行”:Tlist”则关闭。左右窗口切换Ctrl+ww在taglist窗口中，还可以使用下面的快捷键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;CR&gt;          跳到光标下tag所定义的位置，用鼠标双击此tag功能也一样</span><br><span class="line">o             在一个新打开的窗口中显示光标下tag</span><br><span class="line">&lt;Space&gt;       显示光标下tag的原型定义</span><br><span class="line">u             更新taglist窗口中的tag</span><br><span class="line">s             更改排序方式，在按名字排序和按出现顺序排序间切换</span><br><span class="line">x             taglist窗口放大和缩小，方便查看较长的tag</span><br><span class="line">+             打开一个折叠，同zo</span><br><span class="line">-             将tag折叠起来，同zc</span><br><span class="line">*             打开所有的折叠，同zR</span><br><span class="line">=             将所有tag折叠起来，同zM</span><br><span class="line">[[            跳到前一个文件</span><br><span class="line">]]            跳到后一个文件</span><br><span class="line">q             关闭taglist窗口</span><br><span class="line">&lt;F1&gt;          显示帮助</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&quot; Tag List  设置</span><br><span class="line">nmap <span class="tag">&lt;<span class="name">F5</span>&gt;</span> :TlistToggle<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line"></span><br><span class="line">let Tlist_Ctags_Cmd=&quot;/home/luoyou/home/usr/bin/ctags&quot;  &quot;ctags程序位置</span><br><span class="line">let Tlist_Inc_Winwidth=0     &quot;window width change off</span><br><span class="line">let Tlist_Auto_Open=0        &quot;vim 开始时window open=off</span><br><span class="line">let Tlist_Use_Left_Window=1  &quot;显示在左侧</span><br><span class="line">let Tlist_Show_One_File=1    &quot;不同时显示多个文件的tag，只显示当前文件的    </span><br><span class="line">let Tlist_Exit_OnlyWindow=1  &quot;如果taglist窗口是最后一个窗口，则退出vim   </span><br><span class="line">let Tlist_File_Fold_Auto_Close=1             &quot; 自动折叠</span><br><span class="line">set ut=100</span><br></pre></td></tr></table></figure>

<h3 id="Trinity"><a href="#Trinity" class="headerlink" title="Trinity"></a>Trinity</h3><p><a href="https://github.com/wenlongche/Trinity">https://github.com/wenlongche/Trinity</a></p>
<h3 id="NERD-tree"><a href="#NERD-tree" class="headerlink" title="NERD tree"></a>NERD tree</h3><p>要用Trinity插件包里的NERD_tree.vim</p>
<h3 id="SrcExpl"><a href="#SrcExpl" class="headerlink" title="SrcExpl"></a>SrcExpl</h3><p><a href="https://www.vim.org/scripts/script.php?script_id=2179">https://www.vim.org/scripts/script.php?script_id=2179</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>shell if 条件判断</title>
    <url>/2022/08/13/tool/shell-if/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ command ]; then</span><br><span class="line"></span><br><span class="line">elif [ command ]; then</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><em>注意</em>：</p>
<p>1、[ ]表示条件测试，要注意在’[‘后面和’]’前面都必须要有空格。</p>
<p>2、在shell中，then和fi是分开的语句。如果要在同一行里面输入，则需要用分号将他们隔开。</p>
<p>3、if判断中对于变量的处理，需要加引号，以免一些不必要的错误。没有加双引号会在一些含空格等的字符串变量判断的时候产生错误。比如<code>[ -n &quot;$var&quot; ]</code>，如果var为空会出错。</p>
<p>4、不支持浮点值。</p>
<p>5、如果只单独使用&gt;或者&lt;号，系统会认为是输出或者输入重定向，虽然结果显示正确，但是其实是错误的，因此要对这些符号进行转义。</p>
<p>6、运行if语句中的命令所产生的错误信息默认仍然出现在脚本的输出结果中。</p>
<p>7、使用-z或者-n来检查长度的时候，没有定义的变量也为0。</p>
<p>8、空变量和没有初始化的变量可能会对shell脚本测试产生灾难性的影响，因此在不确定变量的内容的时候，在测试前使用-n或者-z测试一下。</p>
<p>9、? 变量包含了之前执行命令的退出状态（最近完成的前台进程），可以用于检测退出状态。</p>
<h2 id="文件-目录判断"><a href="#文件-目录判断" class="headerlink" title="文件/目录判断"></a>文件/目录判断</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。</span><br><span class="line">[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。</span><br><span class="line">[ -d DIR ]  如果 FILE 存在且是一个目录则为真。</span><br><span class="line">[ -e FILE ] 如果 FILE 存在则为真。</span><br><span class="line">[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。</span><br><span class="line">[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。</span><br><span class="line">[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。</span><br><span class="line">[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。</span><br><span class="line">[ -r FILE ] 如果 FILE 存在且是可读的则为真。</span><br><span class="line">[ -s FILE ] 如果 FILE 存在且大小不为0则为真。</span><br><span class="line">[ -t FD ]   如果文件描述符 FD 打开且指向一个终端则为真。</span><br><span class="line">[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。</span><br><span class="line">[ -w FILE ] 如果 FILE存在且是可写的则为真。</span><br><span class="line">[ -x FILE ] 如果 FILE 存在且是可执行的则为真。</span><br><span class="line">[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。</span><br><span class="line">[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。</span><br><span class="line">[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。</span><br><span class="line">[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。</span><br><span class="line">[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。</span><br><span class="line">[ FILE1 -nt FILE2 ] 如果 FILE1 比 FILE2 新，则为真。</span><br><span class="line">[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。</span><br><span class="line">[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。</span><br></pre></td></tr></table></figure>

<h2 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ -z STRING ] 判断是否为空</span><br><span class="line">[ -n STRING ] 判断是否为非空</span><br><span class="line">[ STRING1 ]　 如果字符串不为空则为真</span><br><span class="line">[ STRING1 = STRING2 ]  如果两个字符串相同则为真</span><br><span class="line">[ STRING1 == STRING2 ] 如果两个字符串相同则返回为真</span><br><span class="line">[ STRING1 != STRING2 ] 如果字符串不相同则为真</span><br><span class="line">[ STRING1 &lt; STRING2 ]  如果 “STRING1”字典排序在“STRING2”前面则返回为真。</span><br><span class="line">[ STRING1 &gt; STRING2 ]  如果 “STRING1”字典排序在“STRING2”后面则返回为真。</span><br></pre></td></tr></table></figure>

<p><strong>比较两个字符串是否相等的办法</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ &quot;$test&quot;x = &quot;test&quot;x ]; then</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ol>
<li>使用单个等号，等号两边各有一个空格。</li>
<li>注意到”$test”x最后的x，这是特意安排的，因为当$test为空的时候，上面的表达式就变成了x = testx，显然是不相等的。而如果没有这个x，表达式就会报错：”[: =: unary operator expected”。</li>
</ol>
<p><strong>==的功能在<code>[[]]</code>和<code>[]</code>中的行为是不同的</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[ \$a == z* ]]      # 如果$a以&quot;z&quot;开头(模式匹配)那么将为true</span><br><span class="line">[[ \$a == &quot;z*&quot; ]]    # 如果$a等于z*(字符匹配),那么结果为true</span><br><span class="line">[ \$a == z* ]        # File globbing 和word splitting将会发生</span><br><span class="line">[ &quot;\$a&quot; == &quot;z&quot; ]     # 如果$a等于z(字符匹配),那么结果为true</span><br></pre></td></tr></table></figure>

<h2 id="数值判断"><a href="#数值判断" class="headerlink" title="数值判断"></a>数值判断</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INT1 -eq INT2           INT1和INT2两数相等为真</span><br><span class="line">INT1 -ne INT2           INT1和INT2两数不等为真</span><br><span class="line">INT1 -gt INT2           INT1大于INT1为真</span><br><span class="line">INT1 -ge INT2           INT1大于等于INT2为真</span><br><span class="line">INT1 -lt INT2           INT1小于INT2为真</span><br><span class="line">INT1 -le INT2           INT1小于等于INT2为真</span><br></pre></td></tr></table></figure>

<h2 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ ! EXPR ]         逻辑非，如果 EXPR 是false则返回为真。</span><br><span class="line">[ EXPR1 -a EXPR2 ] 逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。</span><br><span class="line">[ EXPR1 -o EXPR2 ] 逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。</span><br><span class="line">[ ] || [ ]         用OR来合并两个条件</span><br><span class="line">[ ] &amp;&amp; [ ]         用AND来合并两个条件</span><br></pre></td></tr></table></figure>

<h2 id="其他判断"><a href="#其他判断" class="headerlink" title="其他判断"></a>其他判断</h2><p>[ -t FD ] 如果文件描述符 FD （默认值为1）打开且指向一个终端则返回为真<br>[ -o optionname ] 如果shell选项optionname开启则返回为真</p>
<h2 id="IF高级特性"><a href="#IF高级特性" class="headerlink" title="IF高级特性"></a>IF高级特性</h2><p>双圆括号<code>(( ))</code>：表示数学表达式，比判断命令提供更多的数学符号，而且在双圆括号里面的’&gt;’,’&lt;’号不需要转义。</p>
<p>双方括号<code>[[ ]]</code>：表示高级字符串处理函数，使用标准的字符串比较，还可以使用匹配模式，从而定义与字符串相匹配的正则表达式。</p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>vimium</title>
    <url>/2022/06/07/tool/vimium/</url>
    <content><![CDATA[<p>Vimium 是一个浏览器扩展，它本着 Vim 编辑器的精神提供基于键盘的导航和网络控制。可通过 <a href="https://chrome.google.com/extensions/detail/dbepggeogbaibhgnhhndojpepiihcmeb">Chrome 网上应用店</a>安装。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>修饰键分别指定为<code>&lt;c-x&gt;</code>、<code>&lt;m-x&gt;</code>、 和<code>&lt;a-x&gt;</code>，分别对应ctrl+x、meta+x 和 alt+x。键入<code>?</code>可以显示快捷键列表。</p>
<p><img src="/images/tool/vimium.png" alt="img"></p>
<p><strong>当前页面操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?       显示帮助对话框以获取所有可用键的列表</span><br><span class="line">h       向左滚动一点</span><br><span class="line">j       向下滚动一点</span><br><span class="line">k       向上滚动一点</span><br><span class="line">l       向右滚动一点</span><br><span class="line">gg      滚动到页面顶部</span><br><span class="line">G       滚动到页面底部</span><br><span class="line">d       向下滚动半页</span><br><span class="line">u       向上滚动半页</span><br><span class="line">f       打开元素定位器，是在当前标签页打开</span><br><span class="line">F       打开元素定位器，是在新标签页打开</span><br><span class="line">r       刷新</span><br><span class="line">gs      查看源码</span><br><span class="line">i       进入插入模式 - 在您按Esc退出之前，将忽略所有命令</span><br><span class="line">yy      将当前网址复制到剪贴板</span><br><span class="line">yf      将链接URL复制到剪贴板</span><br><span class="line">gf      循环到下一帧(尤其在选择网页内置视频的时候很管用)</span><br><span class="line">gF      聚焦主/顶框架</span><br></pre></td></tr></table></figure>

<p><strong>新页面</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o   从URL、书签、历史记录中搜索地址，回车打开</span><br><span class="line">O   从URL、书签、历史记录中搜索地址，回车在新标签页中打开</span><br><span class="line">b   仅从书签搜索地址，回车打开</span><br><span class="line">B   仅从书签搜索地址，回车新标签页中打开</span><br><span class="line">T   搜索当前浏览器的所有标签</span><br></pre></td></tr></table></figure>

<p><strong>查找</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/       进入查找模式 - 输入您的搜索查询并按Enter键进行搜索，或按Esc键取消</span><br><span class="line">n       查找下一个匹配项</span><br><span class="line">N       查找上一个匹配项</span><br></pre></td></tr></table></figure>

<p><strong>浏览历史记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H       回到历史，也就是回到前一页</span><br><span class="line">L       在历史上前进，也就是回到后一页</span><br></pre></td></tr></table></figure>

<p><strong>标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">J, gT   跳到左标签</span><br><span class="line">K, gt   跳到右标签</span><br><span class="line">g0      跳转到第一个标签(根据不同的数字跳到第几个标签)</span><br><span class="line">g$      跳转到最后一个标签</span><br><span class="line">^       回到上一个访问的标签</span><br><span class="line">t       创建一个新的标签</span><br><span class="line">yt      复制当前页面，在新标签页打开</span><br><span class="line">x       关闭当前标签</span><br><span class="line">X       恢复关闭的上一个标签</span><br><span class="line">p       在当前标签页打开剪切板中的URL，如不是URL则默认引擎搜索</span><br><span class="line">P       在新标签页打开剪切板中的URL，如不是URL则默认引擎搜索</span><br><span class="line">T       在当前打开的所有标签中搜索</span><br><span class="line">W       将当前标签移动到新窗口</span><br><span class="line">&lt;a-p&gt;   pin/unpin current tab</span><br></pre></td></tr></table></figure>

<p><strong>标记</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ma      设置本地标记 a</span><br><span class="line">mA      设置全局标记 A </span><br><span class="line">`a      跳转到本地标记 a</span><br><span class="line">`A      跳转到q全局标记 a</span><br><span class="line">``      跳回到跳转之前的位置 (也就是说，在执行gg，G，n，N，或/ a 之前的位置）</span><br></pre></td></tr></table></figure>

<p><strong>其他高级浏览命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;      当前标签页向左移动  </span><br><span class="line">&gt;&gt;      当前标签页向右移动  </span><br><span class="line">&lt;a-f&gt;   在新标签中打开多个链接</span><br><span class="line">gi      聚焦页面上的第一个（或第n个）文本输入框</span><br><span class="line">gu      跳转到URL层次的父类(xxx.com/yyy/zzz 跳转到 xxx.com/yyy)</span><br><span class="line">gU      转到URL层次结构的根目录(也就是 xxx.com)</span><br><span class="line">ge      编辑当前URL</span><br><span class="line">gE      编辑当前URL并在新选项卡中打开</span><br><span class="line">zH      向左滚动</span><br><span class="line">zL      向右滚动</span><br><span class="line">v       进入预览模式;使用p / P粘贴，然后使用y来拷贝</span><br><span class="line">V       enter visual line mode</span><br><span class="line">&lt;a-m&gt;   开/关静音 </span><br><span class="line">&lt;a-p&gt;   固定标签栏 </span><br></pre></td></tr></table></figure>

<p><strong>预览模式</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">先用 / 定位，找到想要选择的字符</span><br><span class="line">    再按 v ,进入模式</span><br><span class="line">    然后使用</span><br><span class="line">        j：向下一行</span><br><span class="line">        k：向上一行</span><br><span class="line">        h：向左一个字符或标点（数字+h，可以移动多个字符）</span><br><span class="line">        l：向右一个字符或标点（数字+l，可以移动多个字符）</span><br><span class="line">        w：下一个标点符号后位置，包括看不见的换行符</span><br><span class="line">        e：下一个标点符号前位置</span><br><span class="line">        b：取消选中上一个字符，字符和标点算一个字符</span><br></pre></td></tr></table></figure>

<p>Vimium 支持命令重复，例如，点击<code>5t</code>将快速连续打开 5 个选项卡。<code>&lt;Esc&gt;</code> (或<code>&lt;c-[&gt;</code>) 将清除队列中的任何部分命令，并且还将退出插入和查找模式。</p>
<h2 id="自定义键映射"><a href="#自定义键映射" class="headerlink" title="自定义键映射"></a>自定义键映射</h2><p>您可以在选项页面的“自定义键映射”中重新映射或取消映射任何默认键绑定。每行输入以下键映射命令之一：</p>
<ul>
<li><code>map key command</code>: 将键映射到 Vimium 命令。覆盖 Chrome 的默认行为。</li>
<li><code>unmap key</code>：取消映射键并恢复 Chrome 的默认行为。</li>
<li><code>unmapAll</code>：清除映射的所有绑定。</li>
</ul>
<p>以下特殊键可用于映射：</p>
<ul>
<li><code>&lt;c-*&gt;</code>, <code>&lt;a-*&gt;</code>, <code>&lt;m-*&gt;</code>，使用任意键替换*。</li>
<li><code>&lt;left&gt;</code>, <code>&lt;right&gt;</code>, <code>&lt;up&gt;</code>,<code>&lt;down&gt;</code>方向键。</li>
<li><code>&lt;f1&gt;</code>通过<code>&lt;f12&gt;</code>功能键</li>
<li><code>&lt;space&gt;</code> 空格键</li>
<li><code>&lt;tab&gt;</code>, <code>&lt;enter&gt;</code>, <code>&lt;delete&gt;</code>, <code>&lt;backspace&gt;</code>, <code>&lt;insert&gt;</code>,<code>&lt;home&gt;</code>和<code>&lt;end&gt;</code></li>
</ul>
<h2 id="自定义搜索引擎"><a href="#自定义搜索引擎" class="headerlink" title="自定义搜索引擎"></a>自定义搜索引擎</h2><p>配置自定义搜索引擎，通过快捷键<code>o</code>或<code>O</code>调起搜索框，输入搜索引擎简写，再输入空格，再输入搜索词回车，则会调用对应的搜索引擎进行搜索</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;搜索引擎简写&gt; &lt;搜索引擎地址&gt; &lt;搜索引擎名字&gt;</span><br><span class="line">例如：BZ https://search.bilibili.com/all?keyword=%s b站</span><br></pre></td></tr></table></figure>

<p>在插件选项Custom search engines里自定义搜索引擎配置。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">w: https://www.wikipedia.org/w/index.php?title=Special:Search&amp;search=%s Wikipedia</span><br><span class="line"></span><br><span class="line"># More examples.</span><br><span class="line">#</span><br><span class="line"># (Vimium supports search completion Wikipedia, as</span><br><span class="line"># above, and for these.)</span><br><span class="line">#</span><br><span class="line">g: https://www.google.com/search?q=%s Google</span><br><span class="line">G: https://www.google.com/search?q=%s Google</span><br><span class="line">zh: https://www.zhihu.com/search?type=content&amp;q=%s 知乎</span><br><span class="line">ZH: https://www.zhihu.com/search?type=content&amp;q=%s 知乎</span><br><span class="line">tb https://s.taobao.com/search?q=%s 淘宝</span><br><span class="line">TB https://s.taobao.com/search?q=%s 淘宝</span><br><span class="line">jd https://search.jd.com/Search?keyword=%s 京东</span><br><span class="line">JD https://search.jd.com/Search?keyword=%s 京东</span><br><span class="line">bd: https://www.baidu.com/s?wd=%s 百度</span><br><span class="line">BD: https://www.baidu.com/s?wd=%s 百度</span><br><span class="line">bz https://search.bilibili.com/all?keyword=%s b站</span><br><span class="line">BZ https://search.bilibili.com/all?keyword=%s b站</span><br><span class="line">tm https://list.tmall.com/search_product.htm?q=%s 天猫</span><br><span class="line">TM https://list.tmall.com/search_product.htm?q=%s 天猫</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title>usage of zsh</title>
    <url>/2022/06/07/tool/zsh/</url>
    <content><![CDATA[<p>Zsh是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。Zsh的一些特性：</p>
<ol>
<li><p>兼容bash</p>
</li>
<li><p>强大的历史纪录功能，在用或者方向上键查找历史命令时，zsh支持限制查找。比如输入ls然后再按方向上键，则只会查找用过的ls命令。而此时使用则会仍然按之前的方式查找，忽略ls。</p>
</li>
<li><p>多个终端会话共享历史记录。</p>
</li>
<li><p>智能拼写纠正，输入gtep mactalk * -R，系统会提示：zsh: correct ‘gtep’ to ‘grep’ [nyae]?</p>
</li>
<li><p>各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下tab键，补全项可以使用ctrl+n/p/f/b上下左右切换。比如你想杀掉java的进程，只需要输入kill java + tab键，如果只有一个java进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh+空格+两个tab键，zsh会列出所有访问过的主机和用户名进行补全。</p>
</li>
<li><p>智能跳转，安装了autojump之后，zsh 会自动记录你访问过的目录，通过 [j + 目录名] 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过hadoop-1.0.0目录，输入j hado 即可正确跳转。j –stat 可以看你的历史路径库。</p>
</li>
<li><p>目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</p>
</li>
<li><p>在当前目录下输入 <code>..</code> 或 <code>...</code> ，或直接输入当前目录名都可以跳转，不再需要输入cd命令。</p>
</li>
<li><p>通配符搜索：<code>ls -l **/*.sh</code>，可以递归显示当前目录下的 shell 文件。</p>
</li>
</ol>
<p>Oh My Zsh是基于zsh命令行的一个扩展工具集，提供了丰富的扩展功能。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>安装zsh</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install zsh</span><br></pre></td></tr></table></figure>

<p>可以使用<code>zsh --version</code>命令查看是否安装了zsh</p>
<ol start="2">
<li>设置默认shell为zsh</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh -s $(which zsh)</span><br></pre></td></tr></table></figure>

<p>完成后可以使用<code>echo $SHELL</code>命令检查是否设置成功。</p>
<ol start="3">
<li>安装Oh My Zsh</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Oh My Zsh的配置在<code>~/.zshrc</code>文件，默认自带了一些默认主题，在<code>~/.oh-my-zsh/themes</code>目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置主题 essembeh tonotdo fletcherm lambda，设成random就是随机的</span></span><br><span class="line">ZSH_THEME=&quot;fletcherm&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给<span class="built_in">history</span>命令增加时间</span></span><br><span class="line">HIST_STAMPS=&quot;yyyy-mm-dd&quot;</span><br><span class="line"></span><br><span class="line">DISABLE_AUTO_UPDATE=&quot;true&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode插件与配置</title>
    <url>/2022/08/27/tool/vscode/</url>
    <content><![CDATA[<p>官网：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a><br>使用指南：<a href="https://code.visualstudio.com/docs">https://code.visualstudio.com/docs</a></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;files.exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;**/.tags*&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/cmake_install.cmake&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/CMakeCache.txt&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/CMakeFiles&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.srctrlprj&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.srctrldb&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.srctrlbm&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.exe&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.exe.*&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.o&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.cmd&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.ko&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.a&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.so&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.mod.c&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.symvers&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.order&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/.gitignore&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/.jekyll-cache&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/_site/&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/obj/&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/libs/&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*_test&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/.tmp_*/&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files.autoSave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onWindowChange&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;workbench.colorTheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;One Dark Vivid&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.fontSize&quot;</span><span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;todo-tree.tree.showScanModeButton&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.rightClickCopyPaste&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.fontFamily&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#x27;JetBrains Mono&#x27;, Consolas, &#x27;Courier New&#x27;, monospace&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.fontLigatures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.fontSize&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.detectIndentation&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.multiCursorModifier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrlCmd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.occurrencesHighlight&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.selectionHighlight&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.tokenColorCustomizations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;textMateRules&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;One Dark italic&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;comment&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;entity.other.attribute-name&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;markup.underline.link&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;storage.modifier&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;storage.type&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;string.url&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;variable.language.super&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;variable.language.this&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;fontStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;italic&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;One Dark italic reset&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;keyword.operator&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;keyword.other.type&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;storage.modifier.import&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;storage.modifier.package&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;storage.type.built-in&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;storage.type.function.arrow&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;storage.type.generic&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;storage.type.java&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;storage.type.primitive&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;fontStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fileheader.configObj&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;createFileTime&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;autoAdd&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;annotationStr&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;head&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;middle&quot;</span><span class="punctuation">:</span> <span class="string">&quot; * @&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="string">&quot; */&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;use&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;headInsertLine&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;php&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fileheader.cursorMode&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;brief&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;param&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;return&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fileheader.customMade&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Description&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span> <span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Author&quot;</span><span class="punctuation">:</span><span class="string">&quot;luo_u&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Do not edit&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;LastEditTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Do not edit&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;highlightwords.colors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;light&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#b3d9ff&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;dark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cyan&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;light&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#e6ffb3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;dark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pink&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;light&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#b3b3ff&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;dark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lightgreen&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;light&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ffd9b3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;dark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;magenta&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;light&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ffb3ff&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;dark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cornflowerblue&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;light&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#b3ffb3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;dark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;orange&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;light&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ffff80&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;dark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;green&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;light&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#d1e0e0&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;dark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;red&quot;</span> <span class="punctuation">&#125;</span>                                        </span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;highlightwords.box&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;light&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dark&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;[cpp]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ms-vscode.cpptools&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;C_Cpp.clang_format_style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123; BasedOnStyle: LLVM, UseTab: Never, IndentWidth: 4, TabWidth: 4, AccessModifierOffset: -4, AlignConsecutiveAssignments: AcrossEmptyLines, AlignConsecutiveBitFields: Consecutive, AlignConsecutiveDeclarations: AcrossEmptyLines, AlignTrailingComments: true, PointerAlignment: Right, SpaceAroundPointerQualifiers: Before&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;bracket-pair-colorizer-2.depreciation-notice&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;git.enabled&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;git.autorefresh&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;search.followSymlinks&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul>
<li>C/C++</li>
<li>CMake</li>
<li>Bracket Pair Colorizer</li>
<li>Color Highlight</li>
<li>highlight-words</li>
<li>hightlight-selections-vscode</li>
<li>koroFileHeader</li>
<li>Filter Line</li>
<li>Foam</li>
<li>Image preview</li>
<li>Filter Line</li>
<li>Markdown All in One</li>
<li>markdownlint</li>
<li>Markdown Image</li>
<li>Markdown Preview Enhanced</li>
<li>vscode-icons</li>
<li>Simple Vim</li>
<li>Sublime Text Keymap and Settings Importer</li>
<li>One Dark Theme</li>
</ul>
<h2 id="Filter-Line"><a href="#Filter-Line" class="headerlink" title="Filter Line"></a>Filter Line</h2><ol>
<li>打开log文件。</li>
<li>运行 <code>command+shift+p</code> ，输入 filter line，选择 Filter Line By Config File。</li>
<li>回车就生成了新的文件.log.filterline.log ，这就是过滤、翻译好的日志。</li>
</ol>
<p>配置文件格式：</p>
<ul>
<li>type general，指通用类型。</li>
<li>prefix 匹配前缀的正则表达式。这里就是为了匹配每一行的时间、线程等信息。</li>
<li>rules 过滤、翻译（替换）的规则。</li>
<li>src 匹配的正则。dest是要替换成什么的字符串。</li>
<li>tag 匹配到时，输出中增加的前缀。某些特殊行，例如闪退，可以明显的加个emoji图标。</li>
<li>flag 全局的标记。例如app进入后台，则在所有行都加个标记，会前台时取消这个标记。</li>
<li>until 匹配到某行时，后面紧跟的几行连续输出原始内容，直到某一行匹配正则表达式。</li>
</ul>
<p>更多信息可以参考 <a href="https://github.com/everettjf/vscode-filter-line">https://github.com/everettjf/vscode-filter-line</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2022/06/07/code/design-patterns/AbstractFactory/</url>
    <content><![CDATA[<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是对工厂的抽象，生产一系列相关或相互依赖产品，考虑的是一类产品的生产，而无须指定它们具体的类。</p>
<p><img src="/images/code/design-pattern/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.jpg" alt="抽象工厂"></p>
<ul>
<li>抽象工厂（AbstractFactory）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li>
<li>具体工厂（ConcreteFactory）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族。</li>
<li>抽象产品（AbstractProduct）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li>
<li>具体产品（ConcreteProduct）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象产品类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象方法：</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//具体产品类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> :<span class="keyword">public</span> AbstractProductA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//具体实现方法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象产品类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象方法：</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//具体产品类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> :<span class="keyword">public</span> AbstractProductB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//具体实现方法</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象方法生产产品A：</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductA *<span class="title">createProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductB *<span class="title">createProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//具体工厂类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryA</span> :<span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//具体工厂生产具体产品</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体工厂类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryB</span> :<span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//具体工厂生产具体产品</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>抽象工厂和工厂方法不同的地方在于，生产产品的工厂是抽象的。举例，可口可乐公司生产可乐的同时，也需要生产装可乐的瓶子和箱子，瓶子和箱子也是可口可乐专属定制的，同样百事可乐公司也会有这个需求。这个时候我们的工厂不仅仅是生产可乐饮料的工厂，还必须同时生产同一主题的瓶子和箱子，所以它是一个抽象的主题工厂，专门生产同一主题的不同商品。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可乐抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cola</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可口可乐产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CocaCola</span> : <span class="keyword">public</span> Cola</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CocaCola&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 百事可乐产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PesiCola</span> : <span class="keyword">public</span> Cola</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;PesiCola&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 瓶子抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buttle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可口可乐瓶子产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CocaColaButtle</span> : <span class="keyword">public</span> Buttle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CocaCola Buttle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 百事可乐瓶子产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PesiColaButtle</span> : <span class="keyword">public</span> Buttle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;PesiCola Buttle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cola *<span class="title">CreateColo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Buttle *<span class="title">CreateButtle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可口可乐主题工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CocaFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cola *<span class="title">CreateColo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CocaCola</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Buttle *<span class="title">CreateButtle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CocaColaButtle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 百事可乐主题工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PesiFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cola *<span class="title">CreateColo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PesiCola</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Buttle *<span class="title">CreateButtle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PesiColaButtle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CocaFactory factory1;</span><br><span class="line">    Cola *cola = factory1.<span class="built_in">CreateColo</span>();</span><br><span class="line">    cola-&gt;<span class="built_in">What</span>();</span><br><span class="line">    Buttle *buttle = factory1.<span class="built_in">CreateButtle</span>();</span><br><span class="line">    buttle-&gt;<span class="built_in">What</span>();</span><br><span class="line"></span><br><span class="line">    PesiFactory factory2;</span><br><span class="line">    cola = factory2.<span class="built_in">CreateColo</span>();</span><br><span class="line">    cola-&gt;<span class="built_in">What</span>();</span><br><span class="line">    buttle = factory1.<span class="built_in">CreateButtle</span>();</span><br><span class="line">    buttle-&gt;<span class="built_in">What</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> cola;</span><br><span class="line">    <span class="keyword">delete</span> buttle;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>具体产品在应用层代码隔离，不需要关心产品细节。只需要知道自己需要的产品是属于哪个工厂的即可，当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2022/06/07/code/design-patterns/Adapter/</url>
    <content><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式(Adapter Pattern) ：通过创建它们可以进行通信和交互的公共对象，将一个类的接口转换成期望的另外一个接口，使得接口不兼容的对象能够一起工作。比如读卡器、电源适配器等各种转接头。</p>
<p><img src="/images/code/design-pattern/Adapter.jpg" alt="Adapter"></p>
<ul>
<li><p>Adapter（目标抽象类）： 目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</p>
</li>
<li><p>ConcreteAdapter（适配器类）： 适配器类是适配器模式的核心，可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。</p>
</li>
<li><p>Adaptee（适配者类）： 适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码只有接口。</p>
</li>
</ul>
<p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器是继承适配者来实现，对象适配器通过组合多个适配者来实现。</p>
<p><img src="/images/code/design-pattern/Adapter-class.jpg" alt="类适配器"><br><img src="/images/code/design-pattern/Adapter-obj.jpg" alt="对象适配器"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 目标抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 适配者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdaptedOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;adapted operation()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 类适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassAdapter</span> : <span class="keyword">public</span> Adapter, <span class="keyword">private</span> Adaptee</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">AdaptedOperation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 对象适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectAdapter</span> : <span class="keyword">public</span> Adapter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.<span class="built_in">AdaptedOperation</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Adaptee adaptee;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Adapter *adapter1 = <span class="built_in">dynamic_cast</span>&lt;Adapter *&gt;(<span class="keyword">new</span> <span class="built_in">ClassAdapter</span>());</span><br><span class="line">    adapter1-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">    Adapter *adapter2 = <span class="built_in">dynamic_cast</span>&lt;Adapter *&gt;(<span class="keyword">new</span> <span class="built_in">ObjectAdapter</span>());</span><br><span class="line">    adapter2-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> adapter1;</span><br><span class="line">    <span class="keyword">delete</span> adapter2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>统一多个类的接口设计，兼容老版本接口，适配不同格式的数据。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2022/06/07/code/design-patterns/Bridge/</url>
    <content><![CDATA[<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式(Bridge Pattern)：将<strong>抽象和实现分离</strong>，让它们可以独立变化。一个类存在多个独立变化的维度，桥接模式通过将继承改为组合的方式，让这多维度可以独立进行扩展。比如电脑通过usb连接鼠标，接口是固定的，电脑和鼠标品牌可以随意购买。</p>
<p><img src="/images/code/design-pattern/Bridge.png" alt="Bridge"></p>
<ul>
<li><p>Abstraction（抽象类） ： 用于定义抽象类的接口，它一般是抽象类，定义了一个Implementor（实现类接口）类型的对象，与其之间具有关联关系，从而分离抽象接口与实现部分。</p>
</li>
<li><p>RefinedAbstraction（扩充抽象类）： 扩充由Abstraction定义的接口，通常情况下它是具体类，实现Abstraction的抽象业务方法，并可以调用在Implementor中定义的业务方法。</p>
</li>
<li><p>Implementor（实现类接口）: 定义实现类的接口，Implementor接口声明了一些基本操作，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用Implementor中定义的方法。</p>
</li>
<li><p>ConcreteImplementor：具体实现Implementor接口。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 实现类接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OperationImp</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorA</span> : <span class="keyword">public</span> Implementor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OperationImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplementor A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorB</span> : <span class="keyword">public</span> Implementor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OperationImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplementor B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Abstraction</span>(Implementor *imp) : <span class="built_in">imp_</span>(imp) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        imp_-&gt;<span class="built_in">OperationImp</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Implementor *imp_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ConcreteImplementorA impa;</span><br><span class="line">    ConcreteImplementorB impb;</span><br><span class="line">    Abstraction abs1 = <span class="built_in">Abstraction</span>(&amp;impa);</span><br><span class="line">    abs1.<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">    Abstraction abs2 = <span class="built_in">Abstraction</span>(&amp;impb);</span><br><span class="line">    abs2.<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2022/06/07/code/design-patterns/Builder/</url>
    <content><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，能够分步骤创建复杂对象，可以使用相同的创建代码生成不同类型和形式的对象。建造者模式是对流程本身的一种抽象化，关注的是零件装配的顺序。</p>
<p><img src="/images/code/design-pattern/Builder.jpg" alt="Builder"></p>
<ul>
<li>抽象建造者（AbstractBuilder）：创建一个Product对象的各个部件指定的抽象接口；一般声明两类方法，一类方法是buildPart_X()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。</li>
<li>具体建造者（ConcreteBuilder）：实现AbstractBuilder的接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</li>
<li>产品角色（Product）：被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</li>
<li>指挥者（Director）： 它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与Director交互，指定建造者类型，然后通过构造函数或者set方法将具体建造者对象传入Director。它主要作用是：隔离客户与对象的生产过程，并负责控制产品对象的生产过程。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">What</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; logo_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; wight_ &lt;&lt; <span class="string">&quot;KG.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string logo_;</span><br><span class="line">    <span class="type">int</span> wight_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPartA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPartB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> Product &amp;<span class="title">GetProduct</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Product product_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> : <span class="keyword">public</span> Builder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;build part A&quot;</span> &lt;&lt; endl;</span><br><span class="line">        product_.logo_ = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;build part B&quot;</span> &lt;&lt; endl;</span><br><span class="line">        product_.wight_ = <span class="number">900</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Director</span>(Builder *builder) &#123;</span><br><span class="line">        builder_ = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Product <span class="title">Construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder_-&gt;<span class="built_in">BuildPartA</span>();</span><br><span class="line">        builder_-&gt;<span class="built_in">BuildPartB</span>();</span><br><span class="line">        <span class="keyword">return</span> builder_-&gt;<span class="built_in">GetProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Builder *builder_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ConcreteBuilder builder;</span><br><span class="line">    Director director = <span class="built_in">Director</span>(&amp;builder);</span><br><span class="line">    director.<span class="built_in">Construct</span>().<span class="built_in">What</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>[优点]</strong><br>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p>
<p>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</p>
<p>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合开闭原则。</p>
<p>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>
<p><strong>[缺点]</strong><br>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p>
<p>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2022/06/07/code/design-patterns/Chain/</url>
    <content><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链，将接收者对象连接成一条链，通常每个接收者都包含对另一个接收者的引用，请求会沿着这条链传递请求，每个接收者均可对请求进行处理， 或将其传递给链上的下个接收者，，直到有对象处理它为止。比如领导逐级审批申请。</p>
<p><img src="/images/code/design-pattern/Chain.jpg" alt="Chain"></p>
<ul>
<li><p>Handler（抽象处理者）： 定义了一个处理请求的接口，一般设计为抽象类，在其中定义了抽象请求处理方法，由具体处理者实现各自的处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。</p>
</li>
<li><p>ConcreteHandler（具体处理者）： 抽象处理者的子类，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法来处理用户请求，不过在处理请求之前需要进行判断，看是否有相应的处理权限，有权限就处理它，没有则将请求通过下家的引用转发给后继者；</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNextHandler</span><span class="params">(AbstractHandler *next)</span> </span>&#123;</span><br><span class="line">        nextHandler = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="type">int</span> num)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AbstractHandler *nextHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandlerA</span> : <span class="keyword">public</span> AbstractHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">50</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;handlerA handle it&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">HandleRequest</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandlerB</span> : <span class="keyword">public</span> AbstractHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">80</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;handlerB handle it&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">HandleRequest</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandlerC</span> : <span class="keyword">public</span> AbstractHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;handlerC handle it&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HandlerA ha;</span><br><span class="line">    HandlerB hb;</span><br><span class="line">    HandlerC hc;</span><br><span class="line"></span><br><span class="line">    ha.<span class="built_in">SetNextHandler</span>(&amp;hb);</span><br><span class="line">    hb.<span class="built_in">SetNextHandler</span>(&amp;hc);</span><br><span class="line"></span><br><span class="line">    ha.<span class="built_in">HandleRequest</span>(<span class="number">40</span>);</span><br><span class="line">    ha.<span class="built_in">HandleRequest</span>(<span class="number">60</span>);</span><br><span class="line">    ha.<span class="built_in">HandleRequest</span>(<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>[优点]</strong></p>
<p>使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。</p>
<p>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。</p>
<p>在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。</p>
<p>在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。</p>
<p><strong>[缺点]</strong></p>
<p>由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。</p>
<p>对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。如果建链不当，可能会造成循环调用，将导致系统陷入死循环。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2022/06/07/code/design-patterns/Command/</url>
    <content><![CDATA[<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式（Command Pattern）将一个请求封装为一个对象，从而使我们可以用不同的请求将方法参数化、延迟请求执行、对请求排队或者记录请求日志，以及支持可撤销的操作。</p>
<p><img src="/images/code/design-pattern/Command.png" alt="Command"></p>
<ul>
<li><p>Command（抽象命令类）： 抽象命令类一般是一个抽象类或接口，声明了用于执行命令的接口execute()。</p>
</li>
<li><p>ConcreteCommand（具体命令类）： 抽象命令类的子类，实现了在抽象命令类中声明的方法。它对应具体的接收者对象（类中包含），将接收者的动作绑定其中。在execu()方法中将调用接收者的动作action()。</p>
</li>
<li><p>Invoker（调用者）： 请求的发送者，与抽象命令类之间存在关联关系。具体实现中，可以将一个具体命令对象通过构造注入或者设值注入到调用者中，再通过调用具体命令对象的execute()方法，从而间接调用接收者的操作。</p>
</li>
<li><p>Receiver（接收者）： 实现处理请求的具体操作（action）。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;recv&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Excute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetReceiver</span><span class="params">(Receiver *r)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetReceiver</span><span class="params">(Receiver *r)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        receiver_ = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Excute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;excute command&quot;</span> &lt;&lt; endl;</span><br><span class="line">        receiver_-&gt;<span class="built_in">Action</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Receiver *receiver_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddCommand</span><span class="params">(Command *c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        commands_.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : commands_) &#123;</span><br><span class="line">            c-&gt;<span class="built_in">Excute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;Command *&gt; commands_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteCommand command;</span><br><span class="line">    Receiver recver;</span><br><span class="line">    command.<span class="built_in">SetReceiver</span>(&amp;recver);</span><br><span class="line">    command.<span class="built_in">Excute</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Invoker invoker;</span><br><span class="line">    invoker.<span class="built_in">AddCommand</span>(&amp;command);</span><br><span class="line">    invoker.<span class="built_in">Notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>[优点]</strong></p>
<p>降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。</p>
<p>增加新的具体命令类很容易，无须修改原有系统源代码。</p>
<p>可以比较容易地设计一个命令队列或宏命令。</p>
<p>为请求的撤销和恢复操作提供了一种设计和实现方案。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2022/06/07/code/design-patterns/Composite/</url>
    <content><![CDATA[<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式(Composite Pattern)： 组合多个对象形成<strong>树形结构</strong>以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（叶子对象）和组合对象（容器对象）的操作方法相同，比如二叉树的全部结点的遍历用的都是同一个接口。</p>
<p>组合模式跟面向对象设计中的组合关系是不同的，这里的组合模式主要是用来处理树形结构数据，</p>
<p><img src="/images/code/design-pattern/Composite.jpg" alt="Composite"></p>
<ul>
<li><p>Component（抽象构件）：可以是接口或抽象类，定义了构件的一些公共接口，这些接口是管理或者访问它的子构件的方法（如果有子构件），具体的实现在叶子构件和容器构件中进行。</p>
</li>
<li><p>Leaf（叶子构件）：它代表树形结构中的叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法（非叶子构件功能，属于容器构件的功能），可以通过抛出异常、提示错误等方式进行处理。</p>
</li>
<li><p>Composite（容器构件） ：表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为。</p>
</li>
</ul>
<p>根据抽象构件类包含的叶子构件行为和容器构件行为是并集还是交集，可将组合模式分为两种：</p>
<ul>
<li>透明组合，抽象构件类包含叶子构件行为和容器构件行为的并集，抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()以及getChild()等方法，这样做的好处是确保所有的构件类都有相同的接口。也是组合模式的标准形式，管理成员对象的方法在叶子构件可见所以是透明的，对于这些方法需要通过抛出异常、提示错误等方式进行处理。</li>
</ul>
<p><img src="/images/code/design-pattern/Composite2.JPEG" alt="透明组合"></p>
<ul>
<li>安全组合，抽象构件类包含叶子构件行为和容器构件行为的交集，在抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法。</li>
</ul>
<p><img src="/images/code/design-pattern/Composite1.JPEG" alt="安全组合"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>透明组合模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 抽象构件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(Component *c)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(Component *c)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaf</span>(string name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(Component *c)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(Component *c)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;leaf &quot;</span> &lt;&lt; name_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(string name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(Component *c)</span> </span>&#123;</span><br><span class="line">        leafList_.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(Component *c)</span> </span>&#123;</span><br><span class="line">        leafList_.<span class="built_in">remove</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Composite &quot;</span> &lt;&lt; name_ &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> leaf : leafList_) &#123;</span><br><span class="line">            leaf-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name_;</span><br><span class="line">    list&lt;Component *&gt; leafList_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Component *la = <span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    Component *lb = <span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Component *com = <span class="keyword">new</span> <span class="built_in">Composite</span>(<span class="string">&quot;001&quot;</span>);</span><br><span class="line"></span><br><span class="line">    com-&gt;<span class="built_in">Add</span>(la);</span><br><span class="line">    com-&gt;<span class="built_in">Add</span>(lb);</span><br><span class="line">    com-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    com-&gt;<span class="built_in">Remove</span>(lb);</span><br><span class="line">    com-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">    la-&gt;<span class="built_in">Add</span>(lb);</span><br><span class="line">    la-&gt;<span class="built_in">Remove</span>(lb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> la;</span><br><span class="line">    <span class="keyword">delete</span> lb;</span><br><span class="line">    <span class="keyword">delete</span> com;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安全组合模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 抽象构件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaf</span>(string name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;leaf &quot;</span> &lt;&lt; name_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(string name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(Component *c)</span> </span>&#123;</span><br><span class="line">        leafList_.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(Component *c)</span> </span>&#123;</span><br><span class="line">        leafList_.<span class="built_in">remove</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Composite &quot;</span> &lt;&lt; name_ &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> leaf : leafList_) &#123;</span><br><span class="line">            leaf-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name_;</span><br><span class="line">    list&lt;Component *&gt; leafList_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;安全组合模式&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Leaf *la = <span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    Leaf *lb = <span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Composite *com = <span class="keyword">new</span> <span class="built_in">Composite</span>(<span class="string">&quot;001&quot;</span>);</span><br><span class="line"></span><br><span class="line">    com-&gt;<span class="built_in">Add</span>(la);</span><br><span class="line">    com-&gt;<span class="built_in">Add</span>(lb);</span><br><span class="line">    com-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    com-&gt;<span class="built_in">Remove</span>(lb);</span><br><span class="line">    com-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> la;</span><br><span class="line">    <span class="keyword">delete</span> lb;</span><br><span class="line">    <span class="keyword">delete</span> com;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/2022/06/07/code/design-patterns/Decorator/</url>
    <content><![CDATA[<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰模式(Decorator Pattern) ：创建了一个装饰类，包装了原有的类，在不改变原有对象的前提下，动态增强它们现有的职责和行为。</p>
<p>装饰器并不是继承，因为继承是静态的，而装饰者模式可以在运行时扩展一个对象的功能。也可以在运行时选择不同的装饰器，从而实现不同的行为。。</p>
<p><img src="/images/code/design-pattern/Decorator.jpg" alt="Decorator"></p>
<ul>
<li><p>Component（抽象构件）： 它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，使客户端能够以一致的方式处理未被装饰的对象以及装饰之后的对象。</p>
</li>
<li><p>ConcreteComponent（具体构件）： 它是抽象构件类的子类，实现了在抽象构件中声明的方法，装饰器就是为它增加额外的功能。</p>
</li>
<li><p>Decorator（抽象装饰类）： 它也是抽象构件类的子类，用于给具体构件增加功能，但是具体功能在它的子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用构件对象的方法，并通过其子类(具体装饰类)扩展该方法，以达到装饰的目的。</p>
</li>
<li><p>ConcreteDecorator（具体装饰类）： 它是抽象装饰类的子类，负责向构件添加新的功能。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> : <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Decorator</span>(Component *com) : <span class="built_in">component_</span>(com) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        component_-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Component *component_; <span class="comment">// 维持一个对抽象构件对象的引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> : <span class="keyword">public</span> Decorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecorator</span>(Component *com) : <span class="built_in">Decorator</span>(com) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteDecorator&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        Decorator::<span class="built_in">Operation</span>();</span><br><span class="line">        <span class="built_in">AddedBehavior</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddedBehavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;add function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> : <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;origin operation &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Component *component_; <span class="comment">// 维持一个对抽象构件对象的引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Component *com = <span class="keyword">new</span> <span class="built_in">ConcreteComponent</span>();</span><br><span class="line">    com-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\r\n---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Component *com2 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator</span>(com);</span><br><span class="line">    com2-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> com;</span><br><span class="line">    <span class="keyword">delete</span> com2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2022/06/07/code/design-patterns/Facade/</url>
    <content><![CDATA[<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式（Facade Pattern）是一种结构型设计模式， 为系统内的一组接口提供单一接口，来隐藏系统的复杂性。</p>
<p><img src="/images/code/design-pattern/Facade.jpg" alt="Facade"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2022/06/07/code/design-patterns/Factory/</url>
    <content><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式(Factory Pattern)，工厂父类负责定义创建产品对象的公共接口，由工厂子类来具体实现工厂方法，创建具体的产品对象。。公开创建对象的方法，允许子类控制实际的创建过程。</p>
<p><img src="/images/code/design-pattern/%E5%B7%A5%E5%8E%82.jpg" alt="工厂方法"></p>
<ul>
<li>抽象工厂（AbstractFactory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象方法：</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> :<span class="keyword">public</span> AbstractProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//具体实现方法</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象方法生产产品：</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProduct * <span class="title">createProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//具体工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> :<span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//具体工厂生产具体产品</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>工厂方法和简单工厂有一些区别，简单工厂是由一个代工厂生产不同的产品，而工厂方法是对工厂进行抽象化，不同产品都由专门的具体工厂来生产。可口可乐工厂专门生产可口可乐，百事可乐工厂专门生产百事可乐。</p>
<p><img src="/images/code/design-pattern/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.png" alt="工厂方法"></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可乐抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cola</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowLogo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可口可乐产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CocaCola</span> : <span class="keyword">public</span> Cola</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowLogo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CocaCola&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 百事可乐产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PesiCola</span> : <span class="keyword">public</span> Cola</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowLogo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;PesiCola&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cola *<span class="title">CreateColo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可口可乐工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CocaFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cola *<span class="title">CreateColo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CocaCola</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 百事可乐工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PesiFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cola *<span class="title">CreateColo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PesiCola</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CocaFactory factory1;</span><br><span class="line">    Cola *cola = factory1.<span class="built_in">CreateColo</span>();</span><br><span class="line">    cola-&gt;<span class="built_in">ShowLogo</span>();</span><br><span class="line"></span><br><span class="line">    PesiFactory factory2;</span><br><span class="line">    cola = factory2.<span class="built_in">CreateColo</span>();</span><br><span class="line">    cola-&gt;<span class="built_in">ShowLogo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> cola;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2022/06/07/code/design-patterns/Flyweight/</url>
    <content><![CDATA[<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式(Flyweight Pattern)：以共享的方式高效地支持大量细粒度对象的复用，减少创建对象的数量，以降低内存占用和提高性能。享元模式的意图是<strong>复用对象，节省内存</strong>。</p>
<p>享元对象能做到共享的关键是区分了<strong>内部状态和外部状态</strong>。内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。外部状态是随环境改变而改变的、不可以共享的状态。享元模式保证共享内部状态，而外部状态根据不同需求定制如各种访问权限，使用中不能去改变内部状态，以达到共享的目的。</p>
<p><img src="/images/code/design-pattern/Flyweight.jpg" alt="Flyweight"></p>
<ul>
<li><p>Flyweight（抽象享元类）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外部提供享元对象的内部状态数据，也可以通过这些方法设置外部状态。</p>
</li>
<li><p>ConcreteFlyweight（具体享元类）：具体实现抽象享元类声明的方法，其实例称为享元对象；具体享元类中为内部状态提供存储空间。具体享元类通常可以结合单例模式来设计实现，为每个具体享元类提供唯一的享元对象。</p>
</li>
<li><p>UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有抽象享元类的子类都需要被共享，可以将这些类设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</p>
</li>
<li><p>FlyweightFactory（享元工厂类）：用于创建并管理享元对象，针对抽象享元类编程，将各种具体享元类对象存储在一个享元池中，享元池一般设计为一个存储键值对的集合（或者其他类型的集合），可结合工厂模式设计。客户需要某个享元对象时，如果享元池中已有该对象实例，则返回该实例，否则创建一个新的实例，给客户返回新的实例，并将新实例保存在享元池中。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>对于学生对象来说，所有个体都是人，而不同在于学号不同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flyweight</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name_ = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetId</span><span class="params">(<span class="type">int</span> id)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> : <span class="keyword">public</span> Flyweight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ConcreteFlyweight *<span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> ConcreteFlyweight *p = <span class="keyword">new</span> <span class="built_in">ConcreteFlyweight</span>();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetId</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="built_in">GetName</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ConcreteFlyweight</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConcreteFlyweight</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsharedConcreteFlyweight</span> : <span class="keyword">public</span> Flyweight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetId</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        id_ = id;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="built_in">GetName</span>() &lt;&lt; <span class="string">&quot; id: &quot;</span> &lt;&lt; id_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FlyweightFactory</span>() &#123;</span><br><span class="line">        map_[<span class="number">0</span>] = ConcreteFlyweight::<span class="built_in">GetInstance</span>();</span><br><span class="line">        map_[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">UnsharedConcreteFlyweight</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FlyweightFactory</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> map_[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">delete</span> map_[<span class="number">1</span>];</span><br><span class="line">        map_.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Flyweight *<span class="title">GetFlyweight</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map_[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Flyweight *&gt; map_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FlyweightFactory factory;</span><br><span class="line">    Flyweight *fa = factory.<span class="built_in">GetFlyweight</span>(<span class="number">0</span>);</span><br><span class="line">    fa-&gt;<span class="built_in">SetName</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Flyweight *fb = factory.<span class="built_in">GetFlyweight</span>(<span class="number">0</span>);</span><br><span class="line">    fb-&gt;<span class="built_in">SetName</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Flyweight *fc = factory.<span class="built_in">GetFlyweight</span>(<span class="number">1</span>);</span><br><span class="line">    fc-&gt;<span class="built_in">SetName</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Flyweight *fd = factory.<span class="built_in">GetFlyweight</span>(<span class="number">1</span>);</span><br><span class="line">    fd-&gt;<span class="built_in">SetName</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fa fb is the same obj：&quot;</span> &lt;&lt; (fa == fb) &lt;&lt;  endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fc fd is the same obj：&quot;</span> &lt;&lt; (fc == fd) &lt;&lt;  endl;</span><br><span class="line"></span><br><span class="line">    fa-&gt;<span class="built_in">SetId</span>(<span class="number">001</span>);</span><br><span class="line">    fb-&gt;<span class="built_in">SetId</span>(<span class="number">002</span>);</span><br><span class="line">    fc-&gt;<span class="built_in">SetId</span>(<span class="number">003</span>);</span><br><span class="line">    fd-&gt;<span class="built_in">SetId</span>(<span class="number">004</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>[优点]</strong></p>
<p>使用享元模可以减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份，降低系统的使用内存，也可以提性能。</p>
<p>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</p>
<p><strong>[缺点]</strong></p>
<p>使用享元模式需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</p>
<p>对象在缓冲池中的复用需要考虑线程问题。</p>
<p>缓存是为了提高访问效率，对象池复用是节省对象创建时间，享元模式中的复用是节省空间。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/2022/06/07/code/design-patterns/Interpreter/</url>
    <content><![CDATA[<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式(Interpreter Pattern)：定义语法的表示，并且建立一个解释器来解释该语言中的句子。</p>
<p><img src="/images/code/design-pattern/Interpreter.jpg" alt="Interpreter"></p>
<ul>
<li><p>AbstractExpression（抽象表达式）： 声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</p>
</li>
<li><p>TerminalExpression（终结符表达式）： 终结符是文法规则的组成元素中最基本的语言单位，不能再分解。 实现了与文法规则中终结符相关的解释操作，句子中的每一个终结符都是该类的一个实例。</p>
</li>
<li><p>NonterminalExpression（非终结符表达式）： 实现了文法中非终结符的解释操作，非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。</p>
</li>
<li><p>Context（环境类）： 环境类又称为上下文类，存储解释器之外的一些全局信息，通常它可以临时存储需要解释的语句。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算加法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Interpret</span><span class="params">(<span class="type">const</span> Context *context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 解析数值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TerminalExpression</span> : <span class="keyword">public</span> AbstractExpression</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TerminalExpression</span><span class="params">(<span class="type">const</span> string &amp;s)</span> : exp_(s) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Interpret</span><span class="params">(<span class="type">const</span> Context *context)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atoi</span>(exp_.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string exp_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 解析加号连接符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonterminalExpression</span> : <span class="keyword">public</span> AbstractExpression</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonterminalExpression</span>(AbstractExpression *leftExp, AbstractExpression *rightExp)</span><br><span class="line">        : <span class="built_in">leftExp_</span>(leftExp), <span class="built_in">rightExp_</span>(rightExp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Interpret</span><span class="params">(<span class="type">const</span> Context *context)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftExp_-&gt;<span class="built_in">Interpret</span>(context) + rightExp_-&gt;<span class="built_in">Interpret</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractExpression *leftExp_;</span><br><span class="line">    AbstractExpression *rightExp_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Context</span><span class="params">(<span class="type">const</span> string &amp;s)</span> : exp_(s), stackExp_&#123;</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 分割 expression</span></span><br><span class="line">        <span class="type">char</span>* input = <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(exp_.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="type">char</span> *token = <span class="built_in">strtok</span>(input, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (token != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            expVec_.<span class="built_in">emplace_back</span>(token);</span><br><span class="line">            token = <span class="built_in">strtok</span>(<span class="literal">nullptr</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; expVec_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span> != expVec_[i]) &#123; <span class="comment">// </span></span><br><span class="line">                <span class="comment">// 如果是数値，直接入栈</span></span><br><span class="line">                stackExp_.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">TerminalExpression</span>(expVec_[i]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是+，拼接表达式入栈</span></span><br><span class="line">                AbstractExpression *left = stackExp_.<span class="built_in">top</span>();</span><br><span class="line">                stackExp_.<span class="built_in">pop</span>();</span><br><span class="line">                i++;</span><br><span class="line">                AbstractExpression *right = <span class="keyword">new</span> <span class="built_in">TerminalExpression</span>(expVec_[i]);</span><br><span class="line">                stackExp_.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">NonterminalExpression</span>(left, right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!stackExp_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            resultExp_ = stackExp_.<span class="built_in">top</span>();</span><br><span class="line">            stackExp_.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Result</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resultExp_-&gt;<span class="built_in">Interpret</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string exp_;</span><br><span class="line">    vector&lt;string&gt; expVec_;</span><br><span class="line">    stack&lt;AbstractExpression *&gt; stackExp_;</span><br><span class="line">    AbstractExpression *resultExp_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Context <span class="title">ctx</span><span class="params">(<span class="string">&quot;12&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ctx.<span class="built_in">Handle</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; ctx.<span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx = <span class="built_in">Context</span>(<span class="string">&quot;1 + 2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ctx.<span class="built_in">Handle</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; ctx.<span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx = <span class="built_in">Context</span>(<span class="string">&quot;1 + 2 + 3&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ctx.<span class="built_in">Handle</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; ctx.<span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2022/06/07/code/design-patterns/Iterator/</url>
    <content><![CDATA[<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式(Iterator Pattern)：提供一种方法来遍历聚合对象，而不用暴露这个对象的内部表示。比如C++ STL容器。</p>
<p><img src="/images/code/design-pattern/Iterator.jpg" alt="Iterator"></p>
<ul>
<li><p>Iterator（抽象迭代器）：声明了访问和遍历聚合对象元素的接口，如first()方法用于访问聚合对象中第一个元素，next()方法用于访问下一个元素，hasNext()判断是否还有下一个元素，currentItem()方法用于获取当前元素。</p>
</li>
<li><p>ConcreteIterator（具体迭代器）：实现抽象迭代器声明的方法，完成对聚合对象的遍历，通常具体迭代器中会专门用一个游标来记录迭代器在聚合对象中所处的位置。游标通常是一个表示位置的非负整数。通过关联关系持有一个聚合类引用。</p>
</li>
<li><p>Aggregate（抽象聚合类）：用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。</p>
</li>
<li><p>ConcreteAggregate（具体聚合类）：实现了方法createIterator()，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator的实例。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Prev</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">GetItem</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Iterator&lt;T&gt; *<span class="title">CreateIterator</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">GetItem</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> SIZE = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAggregate</span> : <span class="keyword">public</span> Aggregate&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayAggregate</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            nums[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; *<span class="title">CreateIterator</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteIterator</span>&lt;T&gt;(<span class="keyword">dynamic_cast</span>&lt;Aggregate&lt;T&gt; *&gt;(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">GetItem</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T nums[SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> : <span class="keyword">public</span> Iterator&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteIterator</span>(Aggregate&lt;T&gt; *ag) &#123;</span><br><span class="line">        aggregate_ = ag;</span><br><span class="line">        cursor_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cursor_--;</span><br><span class="line">        <span class="keyword">if</span> (cursor_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cursor_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cursor_++;</span><br><span class="line">        <span class="keyword">if</span> (cursor_ &gt;= aggregate_-&gt;<span class="built_in">GetSize</span>()) &#123;</span><br><span class="line">            cursor_ = aggregate_-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">GetItem</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aggregate_-&gt;<span class="built_in">GetItem</span>(cursor_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cursor_;</span><br><span class="line">    Aggregate&lt;T&gt; *aggregate_;  <span class="comment">// 持有一个集合的引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArrayAggregate&lt;<span class="type">int</span>&gt; array;</span><br><span class="line">    <span class="keyword">auto</span> *iter = array.<span class="built_in">CreateIterator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; --&gt; &quot;</span> &lt;&lt; iter-&gt;<span class="built_in">GetItem</span>() &lt;&lt; endl;</span><br><span class="line">        iter-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> iter;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>[优点]</strong></p>
<p>可以自定义不同的迭代器来实现不同的方式遍历聚合对象。</p>
<p>由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</p>
<p><strong>[缺点]</strong></p>
<p>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，在一定程度上增加了系统的复杂性。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2022/06/07/code/design-patterns/Mediator/</url>
    <content><![CDATA[<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式(Mediator Pattern)：通过封装不同的对象集相互交互和通信的方式，允许松散耦合。允许每个对象集的操作彼此独立地变化。中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。</p>
<p>在中介者模式中，中介者类承担了两方面的职责：</p>
<ul>
<li>中转作用（结构性）：对象与对象之间通过中介者对象中转来发生相互作用，而不需要显式地相互引用。</li>
<li>协调作用（行为性）：中介者可以对对象发来的请求进行进一步处理。</li>
</ul>
<p><img src="/images/code/design-pattern/Mediator.jpg" alt="Mediator"></p>
<ul>
<li><p>Mediator（抽象中介者）：声明一个与各个同事对象之间交互的接口，通常声明一个注册方法，用于增加同事对象。</p>
</li>
<li><p>ConcreteMediator（具体中介者）：抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用。</p>
</li>
<li><p>Colleague（抽象同事类）：声明各个同事类公有的接口，同时维持了一个对抽象中介者类的引用。</p>
</li>
<li><p>ConcreteColleague（具体同事类）： 具体实现接口，具体同事类只需与中介者通信，通过中介者完成与其他同事类的通信。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>消息收发中转</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RegisterColleague</span><span class="params">(Colleague *coll)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMsg</span><span class="params">(<span class="type">const</span> Colleague *from, <span class="type">const</span> Colleague *to, string msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Colleague</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name_ = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BindMediator</span><span class="params">(Mediator* mediator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mediator_ = mediator;</span><br><span class="line">        mediator_-&gt;<span class="built_in">RegisterColleague</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMsg</span><span class="params">(<span class="type">const</span> Colleague *to, string msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RecvMsg</span><span class="params">(<span class="type">const</span> Colleague *from, string msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name_;</span><br><span class="line">    Mediator *mediator_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague</span> : <span class="keyword">public</span> Colleague</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ConcreteColleague</span><span class="params">(string name)</span> : Colleague(name) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendMsg</span><span class="params">(<span class="type">const</span> Colleague *to, string msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mediator_-&gt;<span class="built_in">SendMsg</span>(<span class="keyword">this</span>, to, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RecvMsg</span><span class="params">(<span class="type">const</span> Colleague *from, string msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;recv msg form: &quot;</span> &lt;&lt; from-&gt;<span class="built_in">GetName</span>() &lt;&lt; <span class="string">&quot; --- &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> : <span class="keyword">public</span> Mediator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RegisterColleague</span><span class="params">(Colleague *coll)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        map_[coll-&gt;<span class="built_in">GetName</span>()] = coll;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendMsg</span><span class="params">(<span class="type">const</span> Colleague *from, <span class="type">const</span> Colleague *to, string msg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        map_[to-&gt;<span class="built_in">GetName</span>()]-&gt;<span class="built_in">RecvMsg</span>(from, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, Colleague *&gt; map_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ConcreteMediator mediator;</span><br><span class="line">    ConcreteColleague coll_a = <span class="built_in">ConcreteColleague</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    ConcreteColleague coll_b = <span class="built_in">ConcreteColleague</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    coll_a.<span class="built_in">BindMediator</span>(&amp;mediator);</span><br><span class="line">    coll_b.<span class="built_in">BindMediator</span>(&amp;mediator);</span><br><span class="line"></span><br><span class="line">    coll_a.<span class="built_in">SendMsg</span>(&amp;coll_b, <span class="string">&quot;hello b&quot;</span>);</span><br><span class="line">    coll_b.<span class="built_in">SendMsg</span>(&amp;coll_a, <span class="string">&quot;ok a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>[优点]</strong></p>
<p>中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。</p>
<p>中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。</p>
<p>可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2022/06/07/code/design-patterns/Memento/</url>
    <content><![CDATA[<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式(Memento Pattern)：在不破坏封装的前提下，允许捕获和外部化对象的内部状态，以便日后可以恢复，比如游戏存档。</p>
<p><img src="/images/code/design-pattern/Memento.jpg" alt="Memento"></p>
<ul>
<li><p>Originator（原发器）： 将系统中需要保存内部状态的类设计为原发器，通过创建一个备忘录类存储当前的内部状态，或者使用备忘录来恢复其内部状态。</p>
</li>
<li><p>Memento（备忘录）： 存储原发器的内部状态。参考原发器的设计确定备忘录类中的属性。 除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用。</p>
</li>
<li><p>Caretaker（负责人）： 负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。可以存储一个或多个备忘录对象，但是只负责保存对象，不能修改对象，也不必知道对象的实现细节。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(<span class="type">int</span> num, <span class="type">const</span> string &amp;name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num_ = num;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name_ = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num_; &#125;</span><br><span class="line">    <span class="function">string <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num_;</span><br><span class="line">    string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Memento <span class="title">Save</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Memento</span>(num_, name_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Load</span><span class="params">(<span class="type">const</span> Memento &amp;m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name_ = m.<span class="built_in">GetName</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;num_ = m.<span class="built_in">GetNum</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; num_ = n; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(<span class="type">const</span> string &amp;n)</span> </span>&#123; name_ = n; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">What</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; num_ &lt;&lt; <span class="string">&quot; name: &quot;</span> &lt;&lt; name_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_;</span><br><span class="line">    string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SaveTo</span><span class="params">(<span class="type">const</span> Memento &amp;m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        memento_.<span class="built_in">push_back</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento <span class="title">Load</span><span class="params">(<span class="type">int</span> state)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento_[state];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Memento&gt; memento_;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Caretaker caretaker;</span><br><span class="line">    Originator obj;</span><br><span class="line">    obj.<span class="built_in">SetNum</span>(<span class="number">0</span>);</span><br><span class="line">    obj.<span class="built_in">SetName</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    Memento m1 = obj.<span class="built_in">Save</span>();</span><br><span class="line">    caretaker.<span class="built_in">SaveTo</span>(m1);</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">SetNum</span>(<span class="number">1</span>);</span><br><span class="line">    obj.<span class="built_in">SetName</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    Memento m2 = obj.<span class="built_in">Save</span>();</span><br><span class="line">    caretaker.<span class="built_in">SaveTo</span>(m2);</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">Load</span>(caretaker.<span class="built_in">Load</span>(<span class="number">0</span>));</span><br><span class="line">    obj.<span class="built_in">What</span>();</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">Load</span>(caretaker.<span class="built_in">Load</span>(<span class="number">1</span>));</span><br><span class="line">    obj.<span class="built_in">What</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>[优点]</strong></p>
<p>它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。</p>
<p>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</p>
<p><strong>[缺点]</strong></p>
<p>每保存一次对象的状态都需要消耗一定的系统资源。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2022/06/07/code/design-patterns/Observer/</url>
    <content><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式（Observer Pattern）定义对象之间的一种一对多依赖关系，当一个对象状态被修改时，则会自动通知其它观察它的对象，其相关依赖对象皆得到通知并被自动更新。</p>
<p><img src="/images/code/design-pattern/Observer.jpg" alt="Observer"></p>
<ul>
<li><p>Subject：目标类，它是一个抽象类，也是所有目标对象的父类。它用一个列表记录当前目标对象有哪些观察者对象，并提供增加、删除观察者对象和通知观察者对象的接口。</p>
</li>
<li><p>Observer：观察者类，它也是一个抽象类，是所有观察者对象的父类；它为所有的观察者对象都定义了一个名为update的方法。当目标对象的状态改变时，它就是通过调用它的所有观察者对象的update方法来通知它们的。</p>
</li>
<li><p>ConcreteSubject：具体目标类，可以有多个不同的具体目标类，它们同时继承Subject类。一个目标对象就是某个具体目标类的对象，一个具体目标类负责定义它自身的事务逻辑，并在状态改变时通知它的所有观察者对象。</p>
</li>
<li><p>ConcreteObserver：具体观察者类，可以有多个不同的具体观察者类，它们同时继承Observer类。一个观察者对象就是某个具体观察者类的对象。每个具体观察者类都要重定义Observer类中定义的update方法，在该方法中实现它自己的任务逻辑，当它被通知的时候（目标对象调用它的update方法）就执行自己特有的任务。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(Subject *)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">attach</span><span class="params">(Observer *obs)</span> </span>&#123;</span><br><span class="line">        observerList_.<span class="built_in">push_back</span>(obs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">detach</span><span class="params">(Observer *obs)</span> </span>&#123;</span><br><span class="line">        observerList_.<span class="built_in">remove</span>(obs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> obs : observerList_) &#123;</span><br><span class="line">            obs-&gt;<span class="built_in">updata</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;Observer *&gt; observerList_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> : <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">        state_ = s;</span><br><span class="line">        <span class="built_in">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetState</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;state_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> state_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(Subject *sub)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cSub = <span class="built_in">dynamic_cast</span>&lt;ConcreteSubject *&gt;(sub);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;state updata: &quot;</span> &lt;&lt; cSub-&gt;<span class="built_in">GetState</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ConcreteObserver obs;</span><br><span class="line">    ConcreteSubject sub;</span><br><span class="line"></span><br><span class="line">    sub.<span class="built_in">attach</span>(&amp;obs);</span><br><span class="line"></span><br><span class="line">    sub.<span class="built_in">SetState</span>(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2022/06/07/code/design-patterns/Prototype/</url>
    <content><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式（Prototype Pattern）也叫克隆模式，通过克隆基于现有对象来创建对象，并根据需求对新对象进行微调。和移动构造的区别在于不需要知道任何创建的细节，不调用构造函数。</p>
<p><img src="/images/code/design-pattern/Prototype.png" alt="Prototype"></p>
<ul>
<li><p>抽象原型类（AbstractPrototype）：规定了具体原型对象必须实现的接口（如果要提供深拷贝，则必须具有实现clone的规定）。</p>
</li>
<li><p>具体原型类（ConcretePrototype）：从抽象原型派生而来，是客户程序使用的对象，即被复制的对象，需要实现抽象原型角色所要求的接口。</p>
</li>
<li><p>客户端（Client）：客户端中声明一个抽象原型类，根据客户需求clone具体原型类对象实例。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Prototype</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Prototype *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> : <span class="keyword">public</span> Prototype</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcretePrototype</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ConcretePrototype</span>(<span class="type">int</span> n, <span class="type">int</span> *ptr) &#123;</span><br><span class="line">        num_ = n;</span><br><span class="line">        <span class="keyword">if</span> (ptr_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ptr_ = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Prototype *<span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcretePrototype</span>(num_, ptr_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_;</span><br><span class="line">    <span class="type">int</span> *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    ConcretePrototype p1;</span><br><span class="line">    p1.num_ = <span class="number">1</span>;</span><br><span class="line">    p1.ptr_ = &amp;tmp;</span><br><span class="line">    cout &lt;&lt; p1.num_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;p1.ptr_ &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ConcretePrototype *p2 = <span class="built_in">dynamic_cast</span>&lt;ConcretePrototype *&gt;(p1.<span class="built_in">clone</span>());</span><br><span class="line">    cout &lt;&lt; p2-&gt;num_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;p2-&gt;ptr_ &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>[优点]</strong></p>
<p>可以利用原型模式简化对象的创建过程，尤其是对一些创建过程繁琐，可以节约系统资源，提高对象生成的效率。</p>
<p>可以很方便得通过改变值来生成新的对象：有些对象之间的差别可能只在于某些值的不同；用原型模式可以快速复制出新的对象并手动修改值即可。</p>
<p><strong>[缺点]</strong></p>
<p>对象包含的所有对象都需要配备一个克隆的方法，这就使得在对象层级比较多的情况下，代码量会很大，也更加复杂。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2022/06/07/code/design-patterns/SimpleFactory/</url>
    <content><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式(Simple Factory Pattern)：专门定义一个工厂类来负责创建其他类的实例，工厂类包含一个用户可以调用的工厂方法，该工厂方法根据用户传递给它的不同参数而创建不同产品类的实例并返回给用户。</p>
<p><img src="/images/code/design-pattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.webp" alt="简单工厂模式"></p>
<ul>
<li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li>
<li>具体产品（ConcreteProduct）：抽象产品的派生类，包含具体产品特有的实现方法，是简单工厂模式的创建目标。</li>
<li>简单工厂（SimpleFactory）：根据客户提供的具体产品参数，创建具体产品实例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象方法：</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> :<span class="keyword">public</span> AbstractProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//具体实现方法</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">AbstractProduct <span class="title">createProduct</span><span class="params">(string productName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AbstractProduct pro = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (productName == <span class="string">&quot;ProductA&quot;</span>)&#123;</span><br><span class="line">            pro = <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (productName == <span class="string">&quot;ProductB&quot;</span>)&#123;</span><br><span class="line">            pro = <span class="keyword">new</span> <span class="built_in">ProductB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单工厂模式像一个代工厂，可以生产多种产品。比如，饮料加工厂同时帮百事可乐和可口可乐代工，加工厂根据输入参数Type来生产不同的产品。</p>
<p><img src="/images/code/design-pattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png" alt="简单工厂"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ColoType</span> &#123;COCA, PESI&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 可乐抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cola</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowLogo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可口可乐产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CocaCola</span> : <span class="keyword">public</span> Cola</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowLogo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CocaCola&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 百事可乐产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PesiCola</span> : <span class="keyword">public</span> Cola</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowLogo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;PesiCola&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Cola *<span class="title">CreateColo</span><span class="params">(ColoType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == ColoType::COCA) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CocaCola</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ColoType::PESI) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PesiCola</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CocaCola</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory factory;</span><br><span class="line">    Cola *cola = factory.<span class="built_in">CreateColo</span>(ColoType::COCA);</span><br><span class="line">    cola-&gt;<span class="built_in">ShowLogo</span>();</span><br><span class="line"></span><br><span class="line">    cola = factory.<span class="built_in">CreateColo</span>(ColoType::PESI);</span><br><span class="line">    cola-&gt;<span class="built_in">ShowLogo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> cola;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>产品类的创建逻辑全都集中在工厂类中，分离了产品类实例的创建和使用，在一定程度上实现了代码的解耦。每当增加产品类时都要修改工厂类，即要修改已存在的代码，违背了开闭原则。而且当产品类很多的时候，工厂类中的创建逻辑将变得非常复杂。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2022/06/07/code/design-patterns/Proxy/</url>
    <content><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式(Proxy Pattern) ：为某个对象提供一个代理对象，通过充当传递实体或占位符对象，并由代理对象来<strong>控制对原对象的访问</strong>。</p>
<p><img src="/images/code/design-pattern/Proxy.png" alt="Proxy"></p>
<ul>
<li><p>Subject（抽象主题角色）：声明了真实主题和代理主题的共同接口程。</p>
</li>
<li><p>Proxy（代理主题角色）：代理主题角色通过关联关系引用真实主题角色，因此可以控制和操纵真实主题对象；代理主题角色中提供一个与真实主题角色相同的接口，同时还可以在调用对真实主题对象的操作之前或之后增加新的服务和功能。</p>
</li>
<li><p>RealSubject（真实主题角色）：定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</p>
</li>
</ul>
<p>代理模式根据其目的和实现方式不同可分为很多种类：</p>
<ul>
<li><p>远程代理（Remote Proxy）：为一个位于不同地址空间的对象提供一个本地的代理对象。不同的地址空间可以在相同或不同的主机中。它使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端的请求。</p>
</li>
<li><p>虚拟代理（Virtual Proxy）：对于一些占用系统资源较多或者加载时间较长的对象，可以先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象，从而降低系统开销、缩短运行时间。</p>
</li>
<li><p>保护代理（Protect Proxy）：给不同的用户提供不同的对象访问权限。</p>
</li>
<li><p>缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时存储空间，以使更多用户可以共享这些结果。</p>
</li>
<li><p>智能引用代理（Smart Reference Proxy）：当一个对象被引用时提供一些额外的操作，比如将对象被调用的次数记录下来等。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> : <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;RealSubject request&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Proxy</span>() &#123;</span><br><span class="line">        realSubject_ = <span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Proxy request&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        realSubject_-&gt;<span class="built_in">Request</span>();</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RealSubject *realSubject_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subject *sub = <span class="keyword">new</span> <span class="built_in">Proxy</span>();</span><br><span class="line">    sub-&gt;<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> sub;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>但在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2022/06/07/code/design-patterns/Singleton/</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）确保在一个系统中只允许一个类的一个实例，定义一个getInstance()获取实例的静态方法来返回其所属类的一个相同实例，此方法必须是获取单例对象的唯一方式。</p>
<p><img src="/images/code/design-pattern/Singleton.jpg" alt="单例"></p>
<ul>
<li>单例的构造析构函数必须对外隐藏，不能为public属性。</li>
<li>禁用拷贝构造和赋値运算符。</li>
<li>在多线程下要避免多次创建单例对象。</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::mutex mutex_;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>= (<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="type">static</span> Singleton ins &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>单例类提供了对唯一实例的受控访问，在系统内存中只存在一个对象，所以可以节约系统资源。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2022/06/07/code/design-patterns/State/</url>
    <content><![CDATA[<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式（State Pattern）将对象环境与其行为联系起来，允许对象根据其内部状态改变时改变它的行为，对象的行为应该受其状态的影响。</p>
<p><img src="/images/code/design-pattern/State.jpg" alt="State"></p>
<ul>
<li><p>Context（上下文类）：环境类又称为上下文类，它是拥有多种状态的对象。在上下文类中，维护了一个抽象状态类的实例。上下文类的状态存在多样性，并且在不同的状态下，对象表现出不同的行为。</p>
</li>
<li><p>State（抽象状态类）：用于定义一个接口以封装与环境类的一个特定状态相关的行为。</p>
</li>
<li><p>ConcreteState（具体状态类）：抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Handle</span><span class="params">(Context *pContext)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>(State* pState) &#123;</span><br><span class="line">        state_ = pState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state_-&gt;<span class="built_in">Handle</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ChangeState</span><span class="params">(State *pState)</span> </span>&#123;</span><br><span class="line">        state_ = pState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State *state_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateB</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> : <span class="keyword">public</span> State</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Handle</span><span class="params">(Context *pContext)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateB</span> : <span class="keyword">public</span> State</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Handle</span><span class="params">(Context *pContext)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;state B&quot;</span> &lt;&lt; endl;</span><br><span class="line">        pContext-&gt;<span class="built_in">ChangeState</span>(<span class="keyword">new</span> <span class="built_in">ConcreteStateA</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteStateA::Handle</span><span class="params">(Context *pContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;state A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    pContext-&gt;<span class="built_in">ChangeState</span>(<span class="keyword">new</span> <span class="built_in">ConcreteStateB</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ConcreteStateA sa;</span><br><span class="line">    <span class="function">Context <span class="title">ctx</span><span class="params">(&amp;sa)</span></span>;</span><br><span class="line">    ctx.<span class="built_in">Request</span>();</span><br><span class="line">    ctx.<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ConcreteStateB sb;</span><br><span class="line">    ctx.<span class="built_in">ChangeState</span>(&amp;sb);</span><br><span class="line">    ctx.<span class="built_in">Request</span>();</span><br><span class="line">    ctx.<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>[优点]</strong></p>
<p>封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。</p>
<p>将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。</p>
<p>允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。</p>
<p>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p>
<p><strong>[缺点]</strong></p>
<p>状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。</p>
<p>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。</p>
<p>状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2022/06/07/code/design-patterns/Strategy/</url>
    <content><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式(Strategy Pattern)：定义一组封装的算法，可以交换这些算法以执行特定的行为。可以动态地在几种算法中切换，类之间的唯一区别是行为不同。</p>
<p><img src="/images/code/design-pattern/Strategy.jpg" alt="Strategy"></p>
<ul>
<li><p>Context（上下文类） ：环境类是使用算法的角色，在解决某个问题时可以采用多种策略，通过对抽象策略类的引用实例定义所采用的策略。</p>
</li>
<li><p>Strategy（抽象策略类）：声明所支持的算法的抽象方法，可以是抽象类或具体类，也可以是接口，是所有具体策略类的父类。</p>
</li>
<li><p>ConcreteStrategy（具体策略类）：实现了在抽象策略类中声明的算法。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 抽象策略类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 具体策略类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Strategy A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> : <span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Strategy B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetStrategy</span><span class="params">(Strategy *strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;run with &quot;</span>;</span><br><span class="line">        strategy_-&gt;<span class="built_in">Execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy *strategy_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Context ctx;</span><br><span class="line">    ctx.<span class="built_in">SetStrategy</span>(<span class="keyword">new</span> <span class="built_in">ConcreteStrategyA</span>());</span><br><span class="line">    ctx.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    ctx.<span class="built_in">SetStrategy</span>(<span class="keyword">new</span> <span class="built_in">ConcreteStrategyB</span>());</span><br><span class="line">    ctx.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>[优点]</strong></p>
<p>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</p>
<p>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。</p>
<p>策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。</p>
<p>使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。</p>
<p>策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。</p>
<p><strong>[缺点]</strong></p>
<p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</p>
<p>策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</p>
<p>无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2022/06/07/code/design-patterns/Visitor/</url>
    <content><![CDATA[<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式(Visitor Pattern): 访问者模式包含访问者和被访问元素两个主要组成部分，不同的访问者可以对访问元素进行不同的访问操作。比如，对于旅游景点来说，游客只负责游玩，清洁工只负责打扫卫生。</p>
<p><img src="/images/code/design-pattern/Visitor.jpeg" alt="Visitor"></p>
<ul>
<li><p>Visitor（抽象访问者）： 为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，通过名称或参数类型这个方法知道需要访问的具体元素的类型，具体访问者实现这些操作方法，定义对这些元素的访问操作（重载）。</p>
</li>
<li><p>ConcreteVisitor（具体访问者）： 实现了抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。</p>
</li>
<li><p>Element（抽象元素）： 一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数。</p>
</li>
<li><p>ConcreteElement（具体元素）： 针对具体被访问的元素，实现accept()方法。</p>
</li>
<li><p>ObjectStructure（对象结构）： 元素的集合，提供了遍历对象结构中所有元素的方法。对象结构存储了不同类型的元素对象，以供不同的访问者访问。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Visit</span><span class="params">(Element *e)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElement</span> : <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor-&gt;<span class="built_in">Visit</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor</span> : <span class="keyword">public</span> Visitor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Visit</span><span class="params">(Element *e)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;visit element&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">ObjectStructure</span>() &#123;</span><br><span class="line">        elemVec_.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddElement</span><span class="params">(Element *e)</span> </span>&#123;</span><br><span class="line">        elemVec_.<span class="built_in">push_back</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Visit</span><span class="params">(Visitor *visitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : elemVec_) &#123;</span><br><span class="line">            e-&gt;<span class="built_in">Accept</span>(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Element *&gt; elemVec_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ConcreteVisitor visitor;</span><br><span class="line">    ConcreteElement elem;</span><br><span class="line"></span><br><span class="line">    visitor.<span class="built_in">Visit</span>(&amp;elem);</span><br><span class="line"></span><br><span class="line">    ObjectStructure obj;</span><br><span class="line">    obj.<span class="built_in">AddElement</span>(&amp;elem);</span><br><span class="line">    obj.<span class="built_in">Visit</span>(&amp;visitor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>模板模式</title>
    <url>/2022/06/07/code/design-patterns/Template/</url>
    <content><![CDATA[<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>模板模式（Template Pattern）在基类中定义了一个算法的框架， 允许实现类在不修改结构的情况下重写算法来定义实际行为。流程上的统一，细节实现上的分离。</p>
<p><img src="/images/code/design-pattern/Template.jpg" alt="Template"></p>
<ul>
<li><p>AbstractClass（抽象类）：定义一个多个算法的工作流程框架，里面一个操作都对应算法的一个步骤，在其派生类中可以重定义。</p>
</li>
<li><p>ConcreteClass（派生类）：用于实现在父类中声明的抽象的特定算法，也可以覆盖在父类中已经实现的具体基本操作。</p>
</li>
</ul>
<p>将提取算法的框架流程定义在基类中，将可变的行为留给子类来实现。提取公共行为并集中到一个公共父类以避免代码重复。通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。`</p>
<p>模板方法模式具体应用又分为三类：</p>
<ul>
<li><p>抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。</p>
</li>
<li><p>具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p>
</li>
<li><p>钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">step1</span>();</span><br><span class="line">        <span class="built_in">step2</span>();</span><br><span class="line">        <span class="built_in">step3</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step3</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> : <span class="keyword">public</span> AbstractClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;step1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;step2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;step3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AbstractClass *p = <span class="keyword">new</span> <span class="built_in">ConcreteClass</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template method: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    p-&gt;<span class="built_in">TemplateMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>c语言实现面向对象</title>
    <url>/2022/06/07/code/design-patterns/c-object/</url>
    <content><![CDATA[<p>面向对象语言有三个最重要的特点，即继承、封装、多态，其中类可以用结构体实现。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>把基类结构体作为派生类结构体的第一个成员，这样就可以对基类进行访问与强转。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data_parent;</span><br><span class="line"> </span><br><span class="line">&#125;Parent;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Child</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">parent</span> <span class="title">parent</span>;</span></span><br><span class="line">    <span class="type">int</span> data_child;</span><br><span class="line"> </span><br><span class="line">&#125;Child;</span><br></pre></td></tr></table></figure>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装的意义在于函数和数据是绑在一起的，其中将该对象结构体指针作为函数的参数，相当于类的this指针，这样就可以遍历类中的所有函数和成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Data</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span>  <span class="title function_">void</span> <span class="params">(*func)</span><span class="params">(<span class="keyword">struct</span> _Data* pData)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    func pfunc;</span><br><span class="line">&#125;Data;</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态就是实现同一接口处理不同的事情，可以用函数指针来实现，通过给函数指针赋于不同的値。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Play</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span>* pData;</span><br><span class="line">    <span class="type">void</span> (*start_play)(<span class="keyword">struct</span> _Play* pPlay);</span><br><span class="line">&#125;Play;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>软件设计模式与原则</title>
    <url>/2022/06/07/code/design-patterns/design-patterns/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是对互相通信对象和类的描述，这些对象和类被定制以解决特定场景下的一般设计问题。也可以理解为是某一类问题的通用解决方案，使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p>
<h3 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h3><p>用于创建对象，为设计类实例化新对象提供指南。</p>
<table>
<thead>
<tr>
<th>中文名称</th>
<th>英文名称</th>
<th>简要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td>工厂方法</td>
<td>Factory Method</td>
<td>定义了创建对象的接口，让子类决定实例化哪个类。</td>
<td>动态生产对象</td>
</tr>
<tr>
<td>抽象工厂</td>
<td>Abstract Factory</td>
<td>提供一个可以创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</td>
<td>生产系列对象</td>
</tr>
<tr>
<td>构建器</td>
<td>Builder</td>
<td>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</td>
<td>复制对象构造</td>
</tr>
<tr>
<td>原型</td>
<td>Prototype</td>
<td>通过拷贝原型对象创建新的对象。</td>
<td>克隆对象</td>
</tr>
<tr>
<td>单例</td>
<td>Singleton</td>
<td>确保一个类只有一个实例，并提供一个访问它的全局访问点。</td>
<td>单实例</td>
</tr>
</tbody></table>
<h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><p>用于处理类或对象的组合，对类如何设计以形成更大的结构提供指南。</p>
<table>
<thead>
<tr>
<th>中文名称</th>
<th>英文名称</th>
<th>简要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td>适配器</td>
<td>Adapter</td>
<td>将一个类的接口转换成希望的另外一个接口，使得原本不兼容的接口可以协同工作。</td>
<td>转化接口</td>
</tr>
<tr>
<td>桥接</td>
<td>Bridge</td>
<td>将类的抽象部分与它的实现分离，使它们都可以独立地变化。</td>
<td>继承树拆分</td>
</tr>
<tr>
<td>组合</td>
<td>Composite</td>
<td>将对象组合成树形结构以表示“部分-整体”的层次结构，同时对单个对象和组合对象的使用保持一致。</td>
<td>树形目录结构</td>
</tr>
<tr>
<td>装饰</td>
<td>Decorator</td>
<td>动态地给一个对象添加一些额外的职责。</td>
<td>动态附加职责</td>
</tr>
<tr>
<td>外观</td>
<td>Facade</td>
<td>为子系统中的一组接口提供一个统一的接口。</td>
<td>对外统一接口</td>
</tr>
<tr>
<td>享元</td>
<td>Flyweight</td>
<td>运用共享对象有效地支持大量细粒度的对象。</td>
<td>汉字编码</td>
</tr>
<tr>
<td>代理</td>
<td>Proxy</td>
<td>为控制对象的访问而提供的代理对象。</td>
<td>快捷方式</td>
</tr>
</tbody></table>
<p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问。</p>
<p>桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p>
<p>装饰模式在不改变原始类接口的情况下，对原始类功能进行增强，</p>
<p>适配器模式是一种事后的补救策略，用来补救接口不兼容。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p>
<h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><p>用于描述类或对象的交互以及职责的分配，对类之间交互以及分配责任的方式提供指南。</p>
<table>
<thead>
<tr>
<th>中文名称</th>
<th>英文名称</th>
<th>简要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td>职责链</td>
<td>Chain of Responsibility</td>
<td>将对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它。</td>
<td>传递职责</td>
</tr>
<tr>
<td>命令</td>
<td>Command</td>
<td>将请求封装为对象，就可以保存、传递命令，以及支持可撤销的操作。</td>
<td>日志记录，可撤销</td>
</tr>
<tr>
<td>解释器</td>
<td>Interpreter</td>
<td>可以解释自定义语法表示的解释器。</td>
<td>虚拟机的机制</td>
</tr>
<tr>
<td>迭代器</td>
<td>Iterator</td>
<td>提供一种方法可以顺序访问集合中的各个元素，又不需要暴露该集合的内部表示。</td>
<td>数据集</td>
</tr>
<tr>
<td>中介者</td>
<td>Mediator</td>
<td>用一个中介对象来封装一系列的对象交互。</td>
<td>不直接引用</td>
</tr>
<tr>
<td>备忘录</td>
<td>Memento</td>
<td>捕获一个对象的内部状态，并在该对象之外保存这个状态。</td>
<td>游戏存档</td>
</tr>
<tr>
<td>观察者</td>
<td>Observer</td>
<td>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</td>
<td>订阅、广播、联动</td>
</tr>
<tr>
<td>状态</td>
<td>State</td>
<td>允许对象在其内部状态改变时改变它的行为。</td>
<td>状态变成类</td>
</tr>
<tr>
<td>策略</td>
<td>Strategy</td>
<td>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</td>
<td>多方案切换</td>
</tr>
<tr>
<td>模板方法</td>
<td>Template Method</td>
<td>定义一个操作中的算法的骨架，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</td>
<td>框架</td>
</tr>
<tr>
<td>访问者</td>
<td>Visitor</td>
<td>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</td>
<td>数据与操作分离</td>
</tr>
</tbody></table>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul>
<li><strong>开闭原则</strong></li>
</ul>
<p>一个软件实体应当对扩展开放，对修改关闭。为了满足开闭原则，需要对系统进行抽象化设计，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可。</p>
<p>开闭原则的优点在于可以在不改动原有代码的前提下给程序扩展功能。增加了程序的可扩展性，同时也降低了程序的维护成本。</p>
<ul>
<li><strong>里氏替换原则</strong></li>
</ul>
<p>所有引用基类对象的地方能够透明地使用其子类的对象。在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，来替换父类对象。这样可以检验继承使用的正确性，约束继承在使用上的泛滥。</p>
<ul>
<li><strong>依赖倒置原则</strong></li>
</ul>
<p>抽象不应该依赖于具体类，具体类应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。在传递参数时或在关联关系中，尽量使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体实现类来做这些事情。</p>
<ul>
<li><strong>单一职责原则</strong></li>
</ul>
<p>类的功能应该单一，高内聚、低耦合，降低了程序的维护成本。</p>
<ul>
<li><strong>迪米特法则</strong></li>
</ul>
<p>又称为最少知道原则，降低类与类之间的耦合度，减少类与类之间的关联程度，这样当其中一个模块发生修改时，就不会波及关联的类。</p>
<ul>
<li><strong>接口分离原则</strong></li>
</ul>
<p>接口应该功能单一，责任划分明确，使用多个专门的接口，而不是单个总接口。</p>
<p><img src="/images/code/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.jpg" alt="设计原则"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ningskyer/articles/3615312.html">https://www.cnblogs.com/ningskyer/articles/3615312.html</a><br><a href="https://blog.csdn.net/leacock1991/category_10688843.html">https://blog.csdn.net/leacock1991/category_10688843.html</a><br><a href="https://wangyazhou.blog.csdn.net/article/details/110356374">https://wangyazhou.blog.csdn.net/article/details/110356374</a><br><a href="https://blog.csdn.net/u012611878/category_6954011.html">https://blog.csdn.net/u012611878/category_6954011.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>UML class diagram</title>
    <url>/2022/06/07/code/uml/uml_class/</url>
    <content><![CDATA[<p>类图是UML结构图，在类和接口的层次上展现所设计系统的结构、特征、约束和关系。类图有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。</p>
<p><img src="/images/code/uml/uml.png" alt="类的表示"></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是具有相似结构、行为和关系的一组对象的描述符，是面向对象系统中最重要的构造块。</p>
<p>如下图所示，就表示一个类：</p>
<p><img src="/images/code/uml/class.png" alt="类的表示"></p>
<p>三个格子从上至下分别表示：</p>
<ul>
<li>类名称（如果是接口，就使用斜体表示）</li>
<li>类的特性（一般是类的字段和属性，可以没有）</li>
<li>类的操作（一般是类的方法或行为）</li>
</ul>
<p>它们前边的符号有以下几种情况：</p>
<ul>
<li><code>+</code>表示public</li>
<li><code>-</code>表示private</li>
<li><code>#</code>表示protected</li>
<li><code>~</code>表示default,也就是包权限</li>
<li><code>_</code>下划线表示static</li>
<li>斜体表示抽象</li>
</ul>
<h2 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h2><p>泛化是一种继承关系，它指定了子类如何特化父类的所有特征和行为，例如：鸟是动物的一种。用空心箭头+实线表示，箭头指向父类。</p>
<p><img src="/images/code/uml/%E7%BB%A7%E6%89%BF.png" alt="继承"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现是一种类与接口的关系，表示类是接口所有特征和行为的实现。用空心箭头的虚线表示，箭头指向接口。</p>
<p><img src="/images/code/uml/%E5%AE%9E%E7%8E%B0.png" alt="实现"><br><img src="/images/code/uml/%E5%AE%9E%E7%8E%B02.png" alt="实现"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goose</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合是一种弱的整体拥有部分的关系，且部分可以离开整体而单独存在，有各自的生命周期。比如，雁群与大雁。<br>用空心的菱形+实线箭头表示，菱形指向整体。</p>
<p><img src="/images/code/uml/%E8%81%9A%E5%90%88.png" alt="聚合"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GooseGroup</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addGoose</span><span class="params">(Goose &amp;g)</span> </span>&#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(g);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;Goose&gt; vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>组合是整体与部分的关系，但部分不能离开整体而单独存在，部分和整体的生命周期一样，如果整体不存在了，则部分也不存在了。比如，鸟与翅膀。<br>用实心的菱形+实线箭头表示，菱形指向整体。还可以使用连线两端的数字表示某一端有几个实例。</p>
<p><img src="/images/code/uml/%E7%BB%84%E5%90%88.png" alt="组合"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="built_in">Bird</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;wind = <span class="keyword">new</span> <span class="built_in">Wind</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  Wind *wind;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p>关联一种拥有的关系，它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的，双向关联是指双方都拥有对方的引用，拥有者可以调用被拥有者的公共属性和方法。<br>用实线箭头表示，指向被拥有者，双向关联可以有两个箭头或者没有箭头，单向的关联只有一个箭头。</p>
<p><img src="/images/code/uml/%E5%85%B3%E8%81%94.png" alt="关联"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  Weather state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>依赖是一种使用的关系，不管是用作成员变量，还是参数、返回值、局部变量，都称它们有依赖关系。<br>用虚线箭头表示，指向被使用者。</p>
<p><img src="/images/code/uml/%E4%BE%9D%E8%B5%96.png" alt="依赖"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Eat</span><span class="params">(water &amp;w)</span> </span>&#123; w -= <span class="number">3</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span> </span>&#123; content -= <span class="number">5</span>; &#125;</span><br><span class="line"></span><br><span class="line">  Oxygen content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/wounler/article/details/119207742">https://blog.csdn.net/wounler/article/details/119207742</a></p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
  </entry>
  <entry>
    <title>UML Sequence diagram</title>
    <url>/2022/06/07/code/uml/uml_sequence/</url>
    <content><![CDATA[<p>时序图(Sequence Diagram)，又名序列图，是一种UML交互图，通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作，关注于多个生命线之间的消息交换。</p>
<p><img src="/images/code/uml/sequence-diagram-overview.png" alt="Sequence diagram"></p>
<p>画时序图时会涉及下面7种元素：</p>
<p><strong>角色</strong>(Actor)可以是人或者其他系统和子系统。以一个小人图标表示。</p>
<p><strong>对象</strong>(Object)位于时序图的顶部，以一个矩形表示。</p>
<p><strong>生命线</strong>(LifeLine)代表时序图中每个对象的时间线，以一条垂直的虚线表示。</p>
<p><strong>控制焦点</strong>(Activation)代表时序图中在对象时间线上某段时期执行的操作，以一个很窄的矩形表示。</p>
<p><strong>消息</strong>(Message)表示对象之间发送的信息：</p>
<ul>
<li>同步消息(Synchronous Message)用一条实线和实心箭头表示。</li>
<li>异步消息(Asynchronous Message)用一条实线和大于号表示。</li>
<li>返回消息(Return Message)用小于号和虚线表示。</li>
</ul>
<p><strong>自关联消息</strong>表示调用自身的方法，用一个半闭合的长方形+下方实心剪头表示。</p>
<p><strong>组合片段</strong><br>用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。</p>
<table>
<thead>
<tr>
<th>组合名称</th>
<th>组合含义</th>
</tr>
</thead>
<tbody><tr>
<td>alt抉择</td>
<td>在一组行为中根据特定的条件选择某个交互，相当于if else</td>
</tr>
<tr>
<td>opt选项</td>
<td>表示一个可选的行为</td>
</tr>
<tr>
<td>loop循环</td>
<td>说明交互片段会被重复执行</td>
</tr>
<tr>
<td>break中断</td>
<td>和编程语言中的break类似的机制，放弃序列的其余部分</td>
</tr>
<tr>
<td>par并行</td>
<td>支持交互片段的并发执行</td>
</tr>
<tr>
<td>strict强顺序</td>
<td>明确定义了一组交互片段的执行顺序</td>
</tr>
<tr>
<td>seq弱顺序</td>
<td>同一生命线片段必须顺序执行，不同生命线可能会顺序执行</td>
</tr>
<tr>
<td>critical关键</td>
<td>用在Par或Seq片段中，指示此片段中的消息不得与其他消息交错</td>
</tr>
<tr>
<td>ref</td>
<td>引用其他地方定义的组合片段</td>
</tr>
<tr>
<td>region</td>
<td>标志在组合片段中先于其他交互片断发生的交互</td>
</tr>
<tr>
<td>ignore忽略</td>
<td>明确定义了交互片段不应该响应的消息</td>
</tr>
<tr>
<td>consider考虑</td>
<td>明确标志了应该被处理的消息</td>
</tr>
<tr>
<td>assert断言</td>
<td>标志了在交互片段中作为事件唯一的合法继续者的操作数，用在 Consider 或 Ignore 片段中</td>
</tr>
<tr>
<td>neg否定</td>
<td>用来标志不应该发生的交互，用在 Consider 或 Ignore 片段中</td>
</tr>
</tbody></table>
<hr>
<p><a href="https://www.uml-diagrams.org/sequence-diagrams.html">https://www.uml-diagrams.org/sequence-diagrams.html</a></p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2022/12/04/algo/SlideWindow/</url>
    <content><![CDATA[<p>滑动窗口就是维护一个窗口(队列/数组)，通过双指针同向移动不断滑动，然后更新答案，主要用来处理连续问题。</p>
<p><strong>固定窗口大小</strong></p>
<ol>
<li>left 初始化为 0，初始化 right，使得 right - left + 1 等于窗口大小。</li>
<li>同时移动 left 和 right，判断窗口内的连续元素是否满足限定条件。</li>
<li>如果满足，再判断是否需要更新最优解，如果不满足，则继续。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 固定窗口大小为 k</span></span><br><span class="line"><span class="comment">// 在 s 中寻找窗口大小为 k 时的所包含最大元音字母个数</span></span><br><span class="line">string s;</span><br><span class="line">window window;</span><br><span class="line"><span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    window.<span class="built_in">add</span>(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    <span class="comment">// 如果符合要求，说明窗口构造完成，</span></span><br><span class="line">    <span class="keyword">if</span> (right&gt;=k) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 把 right -k 位置元素从窗口里面移除</span></span><br><span class="line">        window.<span class="built_in">remove</span>(s[right -k]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p><strong>可变窗口大小</strong></p>
<ol>
<li>left 和 right 都初始化为 0。</li>
<li>right 指针剃每向右移动一步，就判断窗口内的连续元素是否满足限定条件。</li>
<li>如果满足，再判断是否需要更新最优解，通过移动 left 指针收缩窗口。 如果不满足，则继续。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建窗口window容器保存窗口内元素，可以采用数组、hashset、hashmap等</span></span><br><span class="line">window window;</span><br><span class="line"><span class="comment">//保存最优结果、最大或最小等</span></span><br><span class="line"><span class="type">int</span> result = defaltValue;</span><br><span class="line"><span class="comment">//构造窗口的左右边界指针</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.<span class="built_in">add</span>(s[right]);</span><br><span class="line">    <span class="comment">// 如果符合要求，说明窗口构造完成，移动 left 缩小窗口</span></span><br><span class="line">    <span class="keyword">while</span> (window 符合要求) &#123;</span><br><span class="line">        <span class="comment">// 如果这个窗口的条件更优，则更新result</span></span><br><span class="line">        result = <span class="built_in">maxOrMin</span>(result, window);</span><br><span class="line">        <span class="comment">//移出左指针元素</span></span><br><span class="line">        window.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和≥ s的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<p>输入: s = 7, nums = [2,3,1,2,4,3]<br>输出: 2<br>解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line">cin &gt;&gt; target;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = INT16_MAX;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    sum += nums[right];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">        res = <span class="built_in">MIN</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">        sum -= nums[left];</span><br><span class="line">        left++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;---- &quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot; res = &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot;   sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    right++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (res == INT16_MAX ? <span class="number">0</span> : res) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>给定一个字符串 s 、一个字符串 t ，返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”</p>
<p><img src="/images/code/algo/slide-window.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &amp;window, <span class="type">const</span> unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &amp;target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : target) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;        &quot; &lt;&lt; it.first &lt;&lt; &quot; : &quot; &lt;&lt; window[it.first] &lt;&lt; &quot;, &quot; &lt;&lt; it.second &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (window[it.first] &lt; it.second) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;ADOBECODEBANC&quot;</span>;</span><br><span class="line">    string t = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">        target[c]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> len = UINT16_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        window[s[right]]++;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;    &quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot; &quot; &lt;&lt; s[right] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">Check</span>(window, target)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            window[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">substr</span>(start, len) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2022/12/05/algo/Greedy/</url>
    <content><![CDATA[<p>贪心算法是指在对问题求解时，总是做出局部最优的选择，通过每一步贪心选择，最终可得到问题的一个整体最优解。</p>
<p>贪心算法和动态规划对比：</p>
<ul>
<li>贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。</li>
<li>贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。</li>
<li>动态规划主要运用于二维或三维问题，而贪心一般是一维问题。</li>
</ul>
<h2 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h2><p>给定多个形如[start, end]的闭区间，请计算出最多有多少个互不相交的区间。</p>
<ol>
<li>从排序后的区间中选出end最小的区间x</li>
<li>把所有与x区间相交的区间删除</li>
<li>重复步骤1和2，直到最后一个区间。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">interval</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector&lt;struct interval&gt; vec = &#123;&#123;1, 3&#125;, &#123;4, 6&#125;, &#123;2, 4&#125;&#125;;</span></span><br><span class="line">    vector&lt;<span class="keyword">struct</span> interval&gt; vec = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">        cout &lt;&lt; it.start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; it.end &lt;&lt; it.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [] (<span class="keyword">struct</span> interval a, <span class="keyword">struct</span> interval b) &#123; <span class="keyword">return</span> a.end &lt; b.end; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">        cout &lt;&lt; it.start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; it.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end = vec[<span class="number">0</span>].end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vec[i].start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec[i].end &lt;&lt; <span class="string">&quot; ==&gt; &quot;</span> &lt;&lt; end &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (vec[i].start &gt; end) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            end = vec[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
<ol>
<li><p>从后往前选择，先找到一个可以一步跳到结尾的位置n，如果有多个，就选择距离结尾最远的那个n-1。然后找到可以跳到n-1处的最远的地方n-2。依次类推，最终找到开头位置。</p>
</li>
<li><p>从前往后选择，在当前位置可以跳的步数范围内，选择下一跳可以跳到的最远的那个步数，来决定当前跳多少步。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; nums = &#123;2, 3, 1, 1, 4&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums[cur]; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[cur+i] &gt;= max) &#123;</span><br><span class="line">                max = nums[cur+i];</span><br><span class="line">                distance = i;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; cur &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; --&gt; &quot;</span> &lt;&lt; nums[cur+i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        cur += distance;</span><br><span class="line">        step++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;index = &quot;</span> &lt;&lt; cur &lt;&lt; <span class="string">&quot;, step = &quot;</span> &lt;&lt; step &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; step &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/2022/12/11/algo/backtrack/</url>
    <content><![CDATA[<p>回溯算法是从一条路往前走，能进则进，走不通就退回，换一条路再试，实际 上就是一个决策树的遍历过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtrack</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表 &#123;</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表); <span class="comment">// 路径就是已经做出的选择</span></span><br><span class="line">        回溯撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p>给定2个整数n和k，返回范围[1,n]中所有可能的k的个数从小到大顺序的组合<br>输入：n = 4, k = 2<br>输出：[[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]</p>
<p><img src="/images/code/algo/backtrack.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;<span class="type">int</span>&gt; &amp;tmp, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : tmp) &#123;</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == target) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, tmp, i+<span class="number">1</span>);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    target = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// target = 3;</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">backtrack</span>(nums, tmp, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vec : res) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">            cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/2022/12/11/algo/divided/</url>
    <content><![CDATA[<p>分治算法的基本思想是将一个规模为N的问题，分解为K个规模较小的子问题，这些子问题相互独立且原问题性质相同。分而治之，逐个击破，递归解决子问题，然后合并得到原问题的解。</p>
<h2 id="二分法搜索"><a href="#二分法搜索" class="headerlink" title="二分法搜索"></a>二分法搜索</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (min &lt;= max) &#123;</span><br><span class="line">        mid = (min + max) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; data) &#123;</span><br><span class="line">            max = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; data) &#123;</span><br><span class="line">            min = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种取中位数的方式，当 min 和 max 很大的时候，会出现溢出的情况，从而导致数组访问出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mid = (min + max) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>改进的办法是将加法变成减法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防止溢出</span></span><br><span class="line">mid =  min + (max - min) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="寻找假币"><a href="#寻找假币" class="headerlink" title="寻找假币"></a>寻找假币</h2><p>有N个硬币，其中有一个质量较轻的假币，如何通过一个天平将假币挑出。</p>
<p>将硬币分成2份去称，轻的寻一半包含假币，再将轻的那一份又分为2份，直到最后剩下两枚，轻的那一枚即为假币。考虑到硬币个数为奇数的情况，照样分为两半，剩下一个多余的，如果两半相等，多余那个就是假币，否则处理那两半。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FakeCoin</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = end - start + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; end &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> coins[start] &lt; coins[end] ? start : end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = num / <span class="number">2</span> + start;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; mid; ++i) &#123;</span><br><span class="line">            left += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &lt;= end; ++i) &#123;</span><br><span class="line">            right += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot;) --&gt; &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, mid, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; mid; ++i) &#123;</span><br><span class="line">            left += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">            right += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot;) --&gt; &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; coins = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; coins = &#123;1, 1, 1, 1, 0, 1, 1, 1, 1&#125;;</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt; coins = &#123;1, 1, 1, 1, 1, 1, 1, 1, 0&#125;;</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">FakeCoin</span>(coins, <span class="number">0</span>, coins.<span class="built_in">size</span>() - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p>从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的3个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。</p>
<p>实现汉诺塔算法只需要以下三个步骤：</p>
<p>​ 1.利用目标柱为媒介，将上面n-1个圆盘从原始柱暂时移动到辅助柱</p>
<p>​ 2.将原始柱上的最后一个最大的圆盘移动到目标柱上</p>
<p>​ 3.将暂存在辅助柱上的n-1个柱子全部移动到目标柱上</p>
<p><img src="/images/code/algo/hanoi.png" alt="汉诺塔"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">char</span> src, <span class="type">char</span> dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;move &quot;</span> &lt;&lt; src &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; dest &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> src, <span class="type">char</span> dest, <span class="type">char</span> tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">Move</span>(src, dest);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Hanoi</span>(n - <span class="number">1</span>, src, tmp, dest);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Move</span>(src, dest);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Hanoi</span>(n - <span class="number">1</span>, tmp, dest, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树算法题</title>
    <url>/2022/12/31/algo/tree-code/</url>
    <content><![CDATA[<h2 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">MaxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">MaxDepth</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MAX</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Flip</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Flip</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">Flip</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相同的二叉树"><a href="#相同的二叉树" class="headerlink" title="相同的二叉树"></a>相同的二叉树</h2><p>(1)如果两棵树的根结点都为空，则两棵树相同。<br>(2)如果两棵树的根结点有一个为空，则两棵树必然不相同。<br>(3)如果两棵树都不为空，则判断根结点的值是否相同，不相同则这两棵树必然不相同。<br>(4)如果两棵树根结点的值相同，则需要判断两棵树的左右子树是否相同，如果相同则这两棵树相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == q &amp;&amp; p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;                                                            <span class="comment">//(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                                                           <span class="comment">//(2)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                                                           <span class="comment">//(3)</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);      <span class="comment">//(4)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="另一棵树的子树"><a href="#另一棵树的子树" class="headerlink" title="另一棵树的子树"></a>另一棵树的子树</h2><p>判断一棵树是否为另一棵树的子树我们可以基于判断两棵树是否相同去做。<br>(1)如果<code>root</code>与<code>subRoot</code>的地址相同，则说明两棵树是同一棵树，那么<code>subRoot</code>肯定是<code>root</code>的子树。<br>(2)如果<code>root</code>与<code>subRoot</code>有一棵树是空，那么<code>subRoot</code>必然不是<code>root</code>的子树。<br>(3)如果<code>root</code>与<code>subRoot</code>相同，那么<code>subRoot</code>肯定是<code>root</code>的子树。<br>(4)如果<code>root</code>的子树含有与<code>subRoot</code>相同的树，那么<code>subRoot</code>肯定是<code>root</code>的子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="comment">//判断两棵树是否相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == q &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == subRoot) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || subRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//整棵树是否与subRoot相同</span></span><br><span class="line">        <span class="keyword">if</span> (isSameTree(root, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//subRoot是否是左子树的子树</span></span><br><span class="line">        <span class="keyword">if</span> (isSubtree(root.left, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//subRoot是否是右子树的子树</span></span><br><span class="line">        <span class="keyword">if</span> (isSubtree(root.right, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//上面都不满足，则subRoot不是该树的子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>判断一棵树是否是对称二叉树，其实就是判断这棵树的左右子树是否相同，如果相同则该二叉树对称，反之不对称，当然如果这棵二叉树是空树，那这棵树也是对称的。所以这又回到比较两棵树是否相等这个题目上去了。<br>(1)如果二叉树为空，返回<code>true</code>。<br>(2)比较左右子树是否相等，相等返回<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//(2)判断左右子树是否相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetricChild</span><span class="params">(TreeNode leftTree,TreeNode rightTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftTree == rightTree &amp;&amp; leftTree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftTree == <span class="literal">null</span> || rightTree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftTree.val != rightTree.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricChild(leftTree.left, rightTree.right) &amp;&amp; isSymmetricChild(leftTree.right, rightTree.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">//(1)</span></span><br><span class="line">        <span class="keyword">return</span> isSymmetricChild(root.left,root.right);<span class="comment">//(2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h2><p>(1)如果树为空，则这棵树是平衡二叉树。<br>(2)获取该树左右子树的高度差的绝对值，如果大于1，则这棵树肯定不是平衡二叉树。<br>(3)如果高度差绝对值不大于1，再判断该树的左右子树是否都是平衡二叉树，如果是，则这一整棵树是平衡二叉树。</p>
<p>所以这道题最终回到了求二叉树的高度上来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//获取二叉树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDeep</span><span class="params">(TreeNode subtree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subtree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDeep(subtree.left), maxDeep(subtree.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;            <span class="comment">//(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Math.abs(maxDeep(root.left) - maxDeep(root.right));       <span class="comment">//(2)</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right)) &#123;  <span class="comment">//(3)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h2><p>当遍历当前层时如果遇到空节点，如果该空节点右侧还有节点，说明该树一定不是完全二叉树，直接返回false，遍历完返回true；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">isCompleteTree</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 层次遍历方法</span></span><br><span class="line">        <span class="comment">// 标记空节点</span></span><br><span class="line">        boolean target = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.<span class="built_in">offer</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            TreeNode cur = queue.<span class="built_in">poll</span>();</span><br><span class="line">            <span class="comment">//如果当前结点为空结点，将标记位left设置为false</span></span><br><span class="line">            <span class="keyword">if</span>(cur == null)&#123;</span><br><span class="line">                target = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">// 遇到空节点直接返回false</span></span><br><span class="line">                <span class="keyword">if</span>(target == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                queue.<span class="built_in">offer</span>(cur.left);</span><br><span class="line">                queue.<span class="built_in">offer</span>(cur.right);</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断二叉搜索树"><a href="#判断二叉搜索树" class="headerlink" title="判断二叉搜索树"></a>判断二叉搜索树</h2><p>提前设置最小值pre<br>1、先判断空<br>2、进行递归左子树，如果不满足，返回false<br>3、判断当前root值和pre值大小，如果root&lt;pre,则返回false<br>4、更新pre值<br>5、然后递归右子树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param root TreeNode类 </span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> pre = Integer.MIN_VALUE; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValidBST</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先判断为空</span></span><br><span class="line">        <span class="keyword">if</span>(root ==null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isValidBST</span>(root.left))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 更新最值</span></span><br><span class="line">        pre = root.val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://blog.csdn.net/qq_36317312/article/details/124026664">https://blog.csdn.net/qq_36317312/article/details/124026664</a></p>
<p><a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-172f0/">https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-172f0/</a></p>
<p><a href="https://bbs.huaweicloud.com/blogs/357408">https://bbs.huaweicloud.com/blogs/357408</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2022/12/17/algo/tree_search/</url>
    <content><![CDATA[<p>二叉搜索树（Binary Search Tree， BST）支持动态数据集合的快速插入、删除、查找操作，是一棵空树或者有如下性质的二叉树：</p>
<ul>
<li>若任意节点的左子树不空，其左子树中的每个节点的值都小于这个节点的值；</li>
<li>若任意节点的右子树不空，其右子树每个节点的值都大于这个节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ul>
<p>不管操作是插入、删除还是查找，其时间复杂度其实都跟树的高度成正比， O(height)。</p>
<p>将二叉搜索树进行中序亢奋可以等到由小到大的顺序排序。</p>
<p><strong>查找操作</strong></p>
<p>先取根节点，如果它等于要查找的数据就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<p><img src="/images/code/algo/tree/findtree.png" alt="二叉搜索树"></p>
<p><strong>插入操作</strong></p>
<p>二叉查找树的插入过程需要从根节点开始，依次比较要插入的数据和节点的大小关系：</p>
<ol>
<li><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</p>
</li>
<li><p>如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
</li>
</ol>
<p><img src="/images/code/algo/tree/findtree-add.png" alt="img"></p>
<p><strong>删除操作</strong></p>
<p>针对要删除节点的子节点个数的不同需要分2种情况来处理:</p>
<ol>
<li><p>如果要删除的节点只有一个子节点或没有子节点，只需要要将要删除节点的父节点的指针指向要删除节点的子节点。比如下图中删除节点 55、 13。</p>
</li>
<li><p>如果要删除的节点有两个子节点。需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再按照上面方法删除掉这个最小节点。比如下图中的删除节点 18。（用左子树的最大节点进行替换也可以）。</p>
</li>
</ol>
<p><img src="/images/code/algo/tree/findtree-del.png" alt="img"></p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>为了解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。平衡二叉查找树就是让整棵树左右看起来比较平衡，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p>
<p>任何节点的左右子树高度相差不超过 1，完全二叉树、满二叉树都是平衡二叉树，非完全二叉树有可能是平衡二叉树。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一颗特殊的二叉查找树，除了二叉查找树的要求外，它还具有以下特性：</p>
<ul>
<li>每个节点是黑色或者红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点(NIL，空节点)是黑色。</li>
<li>从根节点到叶子节点，不会出现两个连续的红色节点。如果一个节点是红色的，则它的子节点必是黑色。</li>
<li>从任何节点到叶子节点，这条路径上有相同数目的黑色节点。</li>
</ul>
<p><strong>旋转</strong></p>
<p>左旋就是当新加入节点之后，树的高度及颜色不再满足红黑树定义规则后；将不满足的节点进行左旋转，使得它取代之前它的父节点，同时它的父节点变为它的左子节点，最后调整颜色的过程。</p>
<p><img src="/images/code/algo/tree/rbtree.png" alt="img"></p>
<p>对x左旋，意味着降低x节点的高度，将x变成一个左节点，提升x节点右节点y的高度。</p>
<ol>
<li>x的右子树指向y的左子树</li>
<li>本来指向x结点的父指针，改成指向y</li>
<li>y的左子树指向x结点</li>
</ol>
<p><img src="/images/code/algo/tree/rbtree2.png" alt="img"></p>
<p>右旋就是以某节点为中心进行向右的旋转，取代并成为之前自己的父节点，然后把之前的父节点变为自己的右子节点，最后调整颜色的过程。</p>
<ol>
<li>x的左子树指向y的右子树</li>
<li>本来指向x结点的父指针，改成指向y</li>
<li>y的右子树指向x结点</li>
</ol>
<hr>
<h2 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h2><p>带权路径最短的二叉树称为哈夫曼树或最优二叉树。<br><a href="https://www.cnblogs.com/wuqinglong/p/9709048.html">https://www.cnblogs.com/wuqinglong/p/9709048.html</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>ARM指令集</title>
    <url>/2022/12/31/cpu/asm/</url>
    <content><![CDATA[<h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><p>跳转指令用于实现程序流程的跳转，在ARM程序中有以下两种方法可以实现程序流程的跳转：</p>
<ul>
<li>使用跳转指令，可以从当前指令向前或向后的32MB的地址空间的跳转</li>
<li>直接向程序计数器PC写入跳转地址值，通过向程序计数器PC写入跳转地址值，可以实现在4GB的地址空间中的任意跳转，在跳转之前结合使用MOV LR，PC等类似指令，可以保存将来的返回地址值，从而实现在4GB连续的线性地址空间的子程序调用。</li>
</ul>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>B指令立即跳转到给定的目标地址，从那里继续执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BL"><a href="#BL" class="headerlink" title="BL"></a>BL</h3><p>BL跳转到某地址（有返回），先将下一指令地址（即函数返回地址）保存到寄存器 lr (x30)中，再进行跳转。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BL&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BLX"><a href="#BLX" class="headerlink" title="BLX"></a>BLX</h3><p>BLX指令从ARM指令集跳转到指令中所指定的目标地址，并将处理器的工作状态有ARM状态切换到Thumb状态，该指令同时将PC的当前内容保存到寄存器R14中。因此，当子程序使用Thumb指令集，而调用者使用ARM指令集时，可以通过BLX指令实现子程序的调用和处理器工作状态的切换。同时，子程序的返回可以通过将寄存器R14值复制到PC中来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BLX 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BX"><a href="#BX" class="headerlink" title="BX"></a>BX</h3><p>BX指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BX&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure>

<h3 id="BR"><a href="#BR" class="headerlink" title="BR"></a>BR</h3><p>跳转到某寄存器(的值)指向的地址（无返回）, 不会改变 lr (x30) 寄存器的值。</p>
<h3 id="RET"><a href="#RET" class="headerlink" title="RET"></a>RET</h3><p>子程序（函数调用）返回指令，返回地址已默认保存在寄存器 lr (x30) 中。</p>
<h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><h3 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h3><p>MOV指令可完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV&#123;条件&#125;&#123;S&#125; 目的寄存器，源操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>S选项决定指令的操作是否影响CPSR中条件标志位的值，当没有S 时指令不更新CPSR中条件标志位的值。</li>
</ul>
<h3 id="MVN"><a href="#MVN" class="headerlink" title="MVN"></a>MVN</h3><p>MVN取反移动指令可完成从另一个寄存器、被移位的寄存器、或将一个立即数加载到目的寄存器，与MOV指令不同之处是在传送之前按位被取反了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MVN&#123;条件&#125;&#123;S&#125; 目的寄存器，源操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>S决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MVN R0，#0   ; 将立即数0取反传送到寄存器R0中，完成后R0=-1</span><br></pre></td></tr></table></figure>

<h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><h3 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h3><p>CMP指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较（操作数1 - 操作数2），同时更新CPSR中条件标志位的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMP&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<p>该指令进行一次减法运算，但不存储结果，只更改条件标志位。 标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT后缀的指令将可以执行。</p>
<h3 id="CMN"><a href="#CMN" class="headerlink" title="CMN"></a>CMN</h3><p>CMN指令用于把一个寄存器的内容和另一个寄存器的内容或立即数取反后进行比较，同时更新CPSR中条件标志位的值。该指令实际完成操作数1和操作数2相加，并根据结果更改条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMN&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<h3 id="TST"><a href="#TST" class="headerlink" title="TST"></a>TST</h3><p>TST指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的与运算，并根据运算结果更新CPSR中条件标志位的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TST&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1是要测试的数据，而操作数2是一个位掩码，该指令一般用来检测是否设置了特定的位。</li>
</ul>
<h3 id="TEQ"><a href="#TEQ" class="headerlink" title="TEQ"></a>TEQ</h3><p>TEQ是相等测试指令，用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位异或运算，并根据结果设置CPSR的标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEQ&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure>

<h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD指令用于把两个操作数相加，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<h3 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h3><p>ADC是带进位相加指令，用于把两个操作数相加，再加上CPSR中的C条件标志位的值，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>它使用一个进位标志位，这样就可以做比32位大的数的加法，注意不要忘记设置S后缀来更改进位标志。</li>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一 个寄存器，被移位的寄存器，或一个立即数</li>
</ul>
<p>示例：</p>
<p>以下指令序列完成两个128位数的加法，第一个数由高到低存放在寄存器R7～R4，第二个数由高到低存放在寄存器R11～R8，运算结果由高到低存放在寄 存器R3～R0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADDS    R0，R4，R8         ;  加低端的字</span><br><span class="line">ADCS    R1，R5，R9         ;  加第二个字，带进位</span><br><span class="line">ADCS    R2，R6，R10        ;  加第三个字，带进位</span><br><span class="line">ADC     R3，R7，R11        ;  加第四个字，带进位</span><br></pre></td></tr></table></figure>

<h3 id="SUB"><a href="#SUB" class="headerlink" title="SUB"></a>SUB</h3><p>SUB指令用于把操作数1减去操作数2，并将结果存放到目的寄存器中。该指令可用于有符号数或无符号数的减法运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUB&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<h3 id="SBC"><a href="#SBC" class="headerlink" title="SBC"></a>SBC</h3><p>SBC带进位减法指令用于把操作数1减去操作数2，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SBC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。该指令可用于有符号数或无符号数的减法运算。</p>
<h3 id="RSB"><a href="#RSB" class="headerlink" title="RSB"></a>RSB</h3><p>RSB指令称为逆向减法指令，用于把操作数2减去操作数1，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSB&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令可用于有符号数或无符号数的减法运算。</p>
<h3 id="RSC"><a href="#RSC" class="headerlink" title="RSC"></a>RSC</h3><p>RSC反向带进位减法指令用于把操作数2减去操作数1，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器操作</li>
<li>数2可以是一个寄存器，被移位 的寄存器，或一个立即数。</li>
</ul>
<p>该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。该指令可用于有符号数或 无符号数的减法运算。</p>
<p><strong>乘法指令</strong></p>
<p>乘法指令与前面的数据处理指令不同，指令中的所有操作数、目的寄存器 必须为通用寄存器，不能对操作数使用立即数或被移位的寄存器，同时，目的寄存器和操作数1必须是不同的寄存器。</p>
<h3 id="MUL"><a href="#MUL" class="headerlink" title="MUL"></a>MUL</h3><p>MUL指令完成将操作数1与操作数2的乘法运算，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MUL&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操 作数2均为32位的有符号数或无符号数。</li>
</ul>
<h3 id="MLA"><a href="#MLA" class="headerlink" title="MLA"></a>MLA</h3><p>MLA带累加的相乘指令完成将操作数1与操作数2的乘法运算，再将乘积加上操作数3，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MLA&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2，操作数3</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的有符号数或无符号数。</li>
</ul>
<h3 id="SMULL"><a href="#SMULL" class="headerlink" title="SMULL"></a>SMULL</h3><p>SMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMULL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的有符号数。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMULL   R0，R1，R2，R3     ; R0 = （R2 × R3）的低32位</span><br><span class="line">                          ; R1 = （R2 × R3）的高32位</span><br></pre></td></tr></table></figure>

<h3 id="SMLAL"><a href="#SMLAL" class="headerlink" title="SMLAL"></a>SMLAL</h3><p>SMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMLAL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的有符号数。</li>
<li>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位;</li>
<li>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMLAL   R0，R1，R2，R3       ; R0 = （R2 × R3）的低32位 ＋ R0</span><br><span class="line">                            ; R1 = （R2 × R3）的高32位 ＋ R1</span><br></pre></td></tr></table></figure>

<h3 id="UMULL"><a href="#UMULL" class="headerlink" title="UMULL"></a>UMULL</h3><p>UMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UMULL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的无符号数。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UMULL   R0，R1，R2，R3       ; R0 = （R2 × R3）的低32位</span><br><span class="line">                            ; R1 = （R2 × R3）的高32位</span><br></pre></td></tr></table></figure>

<h3 id="UMLAL"><a href="#UMLAL" class="headerlink" title="UMLAL"></a>UMLAL</h3><p>UMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High 中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UMLAL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1和操作数2均为32位的无符号数；</li>
<li>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位;</li>
<li>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UMLAL   R0，R1，R2，R3            ; R0 = （R2 × R3）的低32位 ＋ R0</span><br><span class="line">                                 ; R1 = （R2 × R3）的高32位 ＋ R1</span><br></pre></td></tr></table></figure>

<h3 id="SDIV"><a href="#SDIV" class="headerlink" title="SDIV"></a>SDIV</h3><p>SDIV指令有符号数)将某一寄存器的值和另一个寄存器的值相除 并将结果保存在另一寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDIV 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><p>AND指令用于在两个操作数上进行逻辑与运算，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令常用于屏蔽操作数1的某些位。</p>
<h3 id="ORR"><a href="#ORR" class="headerlink" title="ORR"></a>ORR</h3><p>ORR指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORR&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li>
</ul>
<p>该指令常用于设置操作数1的某些位。</p>
<h3 id="EOR"><a href="#EOR" class="headerlink" title="EOR"></a>EOR</h3><p>EOR指令用于在两个操作数上进行逻辑异或运算，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EOR&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数</li>
</ul>
<p>该指令常用于反转操作数1的某些位。</p>
<h3 id="BIC指令"><a href="#BIC指令" class="headerlink" title="BIC指令"></a>BIC指令</h3><p>BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BIC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数1应是一个寄存器</li>
<li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。 操作数2为32位的掩码，如果在掩码中设置了某一位，则清除这一位。未设置的掩码位保持不变。</li>
</ul>
<h3 id="LSL-ASL"><a href="#LSL-ASL" class="headerlink" title="LSL ASL"></a>LSL ASL</h3><p>LSL逻辑左移、ASL算术左移可完成对通用寄存器中的内容进行逻辑（或算术）的左移操作，按操作数所指定的数量向左移位，低位用零来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通用寄存器，LSL/ASL 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   R0, R1, LSL #2          ; 将R1中的内容左移两位后传送到R0 中。</span><br></pre></td></tr></table></figure>

<h3 id="LSR"><a href="#LSR" class="headerlink" title="LSR"></a>LSR</h3><p>LSR逻辑右移可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用零来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通用寄存器，LSR 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   R0, R1, LSR #2         ; 将R1中的内容右移两位后传送到R0 中，左端用零来填充。</span><br></pre></td></tr></table></figure>

<h3 id="ASR"><a href="#ASR" class="headerlink" title="ASR"></a>ASR</h3><p>ASR算术右移可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用第31位的值来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通用寄存器，ASR 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV    R0, R1, ASR #2        ; 将R1中的内容右移两位后传送到R0 中，左端用第31位的值来填充。</span><br></pre></td></tr></table></figure>

<h3 id="ROR"><a href="#ROR" class="headerlink" title="ROR"></a>ROR</h3><p>ROR可完成对通用寄存器中的内容进行循环右移的操作，按操作数所指定的数量向右循环移位，左端用右端移出的位来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通用寄存器，ROR 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>其中，操作数可以是通用寄存器，也可以是立即数（0～31）。显然，当进行32位的循环右移操作时，通用寄存器中的值不改变。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV    R0, R1, ROR #2       ; 将R1中的内容循环右移两位后传送到R0 中。</span><br></pre></td></tr></table></figure>

<h3 id="RRX"><a href="#RRX" class="headerlink" title="RRX"></a>RRX</h3><p>RRX可完成对通用寄存器中的内容进行带扩展的循环右移的操作，按操作数所指定的数量向右循环移位，左端用进位标志位C来填充。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通用寄存器，RRX 操作数</span><br></pre></td></tr></table></figure>

<ul>
<li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   R0, R1, RRX #2         ; 将R1中的内容进行带扩展的循环右移两位 后传送到R0中。</span><br></pre></td></tr></table></figure>

<h2 id="程序状态寄存器访问指令"><a href="#程序状态寄存器访问指令" class="headerlink" title="程序状态寄存器访问指令"></a>程序状态寄存器访问指令</h2><p>此类指令向通用寄存器或者从通用寄存器往外移动状态寄存器的内容。</p>
<h3 id="MRS指令"><a href="#MRS指令" class="headerlink" title="MRS指令"></a>MRS指令</h3><p>MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。该指令一般用在以下两种情况：</p>
<ul>
<li>当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器。</li>
<li>当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用该指令读出程序状态寄存器的值，然后保存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRS&#123;条件&#125;  通用寄存器 程序状态寄存器（CPSR或SPSR）</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRS R0，CPSR      ; 传送 CPSR的内容到R0</span><br><span class="line">MRS R0，SPSR      ; 传送 SPSR的内容到R0</span><br></pre></td></tr></table></figure>

<h3 id="MSR指令"><a href="#MSR指令" class="headerlink" title="MSR指令"></a>MSR指令</h3><p>MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中。其中，操作数可以为通用寄存器或立即数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MSR&#123;条件&#125;    程序状态寄存器（CPSR或SPSR）_&lt;域&gt;，操作数</span><br></pre></td></tr></table></figure>

<p>&lt;域&gt;用于设置程序状态寄存器中需要 操作的位，32位的程序状态寄存器可分为4个域：</p>
<ul>
<li>位[31：24]为条件位域，用f表示；</li>
<li>位[23：16]为状态位域，用s表示；</li>
<li>位[15：8] 为扩展位域，用x表示；</li>
<li>位[7：0] 为控制位域，用c表示；</li>
</ul>
<p>该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MSR CPSR，R0        ; 传送R0的内容到CPSR</span><br><span class="line">MSR SPSR，R0        ; 传送R0的内容到SPSR</span><br><span class="line">MSR CPSR_c，R0      ; 传送R0的内容到SPSR，但仅仅修改CPSR中的控制位域</span><br></pre></td></tr></table></figure>

<h2 id="加载-存储指令"><a href="#加载-存储指令" class="headerlink" title="加载/存储指令"></a>加载/存储指令</h2><p>数据在存储器中，都是二进制码，计算机单凭数据本身是无法区分数据格式(有符号、无符号、多少位是一个数据)，甚至无法区分数据和代码的区别。这个取决于我们使用的汇编指令。</p>
<p>ARM微处理器支持加载/存储指令用于在寄存器和存储器之间传送数据：</p>
<ul>
<li>加载指令用于将存储器中的数据传送到寄存器；</li>
<li>存储指令则完成相反的操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldr = Load Word</span><br><span class="line">ldrh = Load unsigned Half Word</span><br><span class="line">ldrsh = Load signed Half Word</span><br><span class="line">ldrb = Load unsigned Byte</span><br><span class="line">ldrsb = Load signed Bytes</span><br><span class="line"></span><br><span class="line">str = Store Word</span><br><span class="line">strh = Store unsigned Half Word</span><br><span class="line">strsh = Store signed Half Word</span><br><span class="line">strb = Store unsigned Byte</span><br><span class="line">strsb = Store signed Byte</span><br></pre></td></tr></table></figure>

<h3 id="LDR"><a href="#LDR" class="headerlink" title="LDR"></a>LDR</h3><p>LDR(Load Word)指令用于从存储器中将一个32位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR&#123;条件&#125; 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li>
</ul>
<p>该指令在程序设计中比较常用，且寻址方式灵活多样，请读者认真掌握。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R0，[R1]             ; 将存储器地址为R1的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，R2]         ; 将存储器地址为R1+R2的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，#8]         ; 将存储器地址为R1+8的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，R2] ！       ; 将存储器地址为R1+R2的字数据读入寄存器R0，并将新地址R1＋R2写入R1。</span><br><span class="line">LDR R0，[R1，#8] ！       ; 将存储器地址为R1+8的字数据读入寄存器R0，并将新地址 R1＋8写入R1。</span><br><span class="line">LDR R0，[R1]，R2          ; 将存储器地址为R1的字数据读入寄存器R0，并将新地址 R1＋R2写入R1。</span><br><span class="line">LDR R0，[R1，R2，LSL#2]！  ; 将存储器地址为R1＋R2×4的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。</span><br><span class="line">LDR R0，[R1]，R2，LSL#2   ; 将存储器地址为R1的字数据读入 寄存器R0，并将新地址R1＋R2×4写入R1。</span><br></pre></td></tr></table></figure>

<h3 id="LDRB"><a href="#LDRB" class="headerlink" title="LDRB"></a>LDRB</h3><p>LDRB(Load unsigned Byte)指令用于从存储器中将一个8位的字节数据传送到目的寄存器中，同时将寄存器的高24位清零。 该指令通常用于从存储器中读取8位的字节数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR&#123;条件&#125;B 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDRB R0，[R1]           ; 将存储器地址为R1的字节数据读入寄存器R0，并将R0的高24位清零。</span><br><span class="line">LDRB R0，[R1，#8]       ; 将存储器地址为R1＋8的字节数据读入寄存器R0，并将R0的高24位清零。</span><br></pre></td></tr></table></figure>

<h3 id="LDRH"><a href="#LDRH" class="headerlink" title="LDRH"></a>LDRH</h3><p>LDRH(Load unsigned Half Word)指令用于从存储器中将一个16位的半字数据传送到目的寄存器中，同时将寄存器的高16位清零。 该指令通常用于从存储器中读取16位的半字数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR&#123;条件&#125;H 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDRH   R0，[R1]         ; 将存储器地址为R1的半字数据读入寄存器 R0，并将R0的高16位清零。</span><br><span class="line">LDRH   R0，[R1，#8]     ; 将存储器地址为R1＋8的半字数据读入寄存器R0，并将R0 的高16位清零。</span><br><span class="line">LDRH   R0，[R1，R2]     ; 将存储器地址为R1＋R2的半字数据读入寄存器R0，并将 R0的高16位清零。</span><br></pre></td></tr></table></figure>

<h3 id="STR"><a href="#STR" class="headerlink" title="STR"></a>STR</h3><p>STR(Store Word)指令用于从源寄存器中将一个32位的字数据传送到存储器中。 该指令在程序设计中比较常用，且寻址方式灵活多样，使用方式可参考指令LDR。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STR&#123;条件&#125; 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STR R0，[R1]，#8           ; 将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。</span><br><span class="line">STR R0，[R1，#8]           ; 将R0中的字数据写入以R1＋8为地址的存储器中。</span><br></pre></td></tr></table></figure>

<h3 id="STRB"><a href="#STRB" class="headerlink" title="STRB"></a>STRB</h3><p>STRB(Store unsigned Byte)指令用于从源寄存器中将一个8位的字节数据传送到存储器中。该字节数据为源寄存器中的低8位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STR&#123;条件&#125;B 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STRB    R0，[R1]             ; 将寄存器R0中的字节数据写入以R1为地 址的存储器中。</span><br><span class="line">STRB    R0，[R1，#8]         ; 将寄存器R0中的字节数据写入以R1＋8为地址的存 储器中。</span><br></pre></td></tr></table></figure>

<h3 id="STRH"><a href="#STRH" class="headerlink" title="STRH"></a>STRH</h3><p>STRH(Store unsigned Half Word)指令用于从源寄存器中将一个16位的半字数据传送到存储器中。该半字数据为源寄存器中的低16位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STR&#123;条件&#125;H 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STRH   R0，[R1]            ; 将寄存器R0中的半字数据写入以R1为地址的 存储器中。</span><br><span class="line">STRH   R0，[R1，#8]        ; 将寄存器R0中的半字数据写入以R1＋8 为地址的存储器中。</span><br></pre></td></tr></table></figure>

<h3 id="ADR"><a href="#ADR" class="headerlink" title="ADR"></a>ADR</h3><p>将一个立即值与 pc 值相加，并将结果写入目标寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADR&#123;cond&#125;&#123;.W&#125;  Rd,label</span><br></pre></td></tr></table></figure>

<h3 id="ADRP"><a href="#ADRP" class="headerlink" title="ADRP"></a>ADRP</h3><p>以页为单位的大范围的地址读取指令，这里的P就是page的意思。取得page的基地址存入寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADRP&#123;cond&#125;  Rd  label</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adrp    x2, .LANCHOR0   ; .LANCHOR0是个&lt;lable&gt;——一个大小为4KB的页的基址，指令的作用就是将该页的基址存到寄存器x2中</span><br><span class="line"></span><br><span class="line">adrp    x0, l_.str@PAGE         ; 将符号l.str所在的page基址读入x0</span><br><span class="line">add     x0, x0, l_.str@PAGEOFF  ; x0 = x0 + l.str所在page中的偏移量</span><br></pre></td></tr></table></figure>

<p><strong>批量数据加载/存储指令</strong></p>
<p>ARM微处理器所支持批量数据加载/存储指令可以一次在一片连续的存储器单元和多个寄存器之间传送数据，批量加载指令 用于将一片连续的存储器中的数据传送到多个寄存器，批量数据存储指令则完成相反的操作。</p>
<h3 id="LDM-STM-指令（加载、存储多个寄存器）"><a href="#LDM-STM-指令（加载、存储多个寄存器）" class="headerlink" title="LDM(STM)指令（加载、存储多个寄存器）"></a>LDM(STM)指令（加载、存储多个寄存器）</h3><p>LDM（或STM）指令用于从由基址寄存器所指示的一片连续存储器到寄存器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDM（或STM）&#123;条件&#125;&#123;类型&#125; 基址寄存器&#123;！&#125;，寄存器列表&#123;∧&#125;</span><br></pre></td></tr></table></figure>

<p>类型为以下几种情况：</p>
<ul>
<li>IA 每次传送后地址加1;</li>
<li>IB 每次传送前地址加1;</li>
<li>DA 每次传送后地址减1;</li>
<li>DB 每次传送前地址减1;</li>
<li>FD 满递减堆栈;</li>
<li>ED 空递减堆栈;</li>
<li>FA 满递增堆栈;</li>
<li>EA 空递增堆栈;</li>
</ul>
<p><code>&#123;！&#125;</code>为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。基址寄存器不允许为R15，寄存器列表可以为R0～R15的任意组合。</p>
<p><code>&#123;∧&#125;</code> 为可选后缀，当指令为LDM且寄存器列表中包含R15，选用该后缀时表示：除了正常的数据传送之外，还将SPSR复制到CPSR。同时，该后缀还表 示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STMFD R13!， &#123;R0，R4-R12，LR&#125;        ; 将寄存器列表中的寄存器（R0，R4到R12，LR）存入堆栈。</span><br><span class="line">LDMFD R13!， &#123;R0，R4-R12，PC&#125;        ; 将堆栈内容恢复到寄存器（R0，R4到R12，LR）。</span><br></pre></td></tr></table></figure>

<p><strong>数据交换指令</strong></p>
<p>在寄存器和内存之间交换数据</p>
<h3 id="SWP"><a href="#SWP" class="headerlink" title="SWP"></a>SWP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SWP&#123;条件&#125; 目的寄存器，源寄存器1，[源寄存器2]</span><br></pre></td></tr></table></figure>

<p>SWP指令用于将源寄存器2所指向的存储器中的字数据传送到目的寄存器中，同时将源寄存器1中的字数据传送到源寄存器2所指向的存储器中。显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SWP   R0，R1，[R2]     ; 将R2所指向的存储器中的字数据传送到R0，同时将R1 中的字数据传送到R2所指向的存储单元。</span><br><span class="line">SWP   R0，R0，[R1]     ; 该指令完成将R1所指向的存储器中的字数 据与R0中的数据交换。</span><br></pre></td></tr></table></figure>

<p>SWP{B}：B是一个可选的后缀。如果存在 B，则交换一个字节。否则，交换一个32位字。</p>
<h3 id="SWPB"><a href="#SWPB" class="headerlink" title="SWPB"></a>SWPB</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SWP&#123;条件&#125;B 目的寄存器，源寄存器1，[源寄存器2]</span><br></pre></td></tr></table></figure>

<p>SWPB指令用于将源寄存器2所指向的存储器中的字节数据传送到目的寄存器中，目的寄存器的高24清零，同时将源寄存器1中的字节数据传送到源寄存器2所指向的存储器中。</p>
<p>显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SWPB   R0，R1，[R2]       ; 将R2所指向的存储器中的字节数据传送到 R0，R0的高24位清零，同时将R1中的低8位数据传送到R2所指向的存储单元。</span><br><span class="line">SWPB   R0，R0，[R1]       ; 该指令完成将R1所指向的存储器中的 字节数据与R0中的低8位数据交换。</span><br></pre></td></tr></table></figure>

<h2 id="协处理器指令"><a href="#协处理器指令" class="headerlink" title="协处理器指令"></a>协处理器指令</h2><p>ARM 微处理器可支持多达 16 个协处理器，用于各种协处理操作，在程序执行的过程中，每个协处理器只执行针对自身的协处理指令，忽略 ARM 处理器和其他协处理器的指令。</p>
<p>ARM 的协处理器指令主要用于 ARM 处理器初始化 ARM 协处理器的数据处理操作，以及在ARM 处理器的寄存器和协处理器的寄存器之间传送数据，和在 ARM 协处理器的寄存器和存储器之间传送数据。</p>
<h3 id="CDP"><a href="#CDP" class="headerlink" title="CDP"></a>CDP</h3><p>CDP指令用于ARM处理器通知ARM协处理器执行特定的操作，若协处理器不能成功完成特定的操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CDP&#123;条件&#125; 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure>

<p>其中协处理器操作码1和协处理 器操作码2为协处理器将要执行的操作，目的寄存器和源寄存器均为协处理器的寄存器，指令不涉及ARM处理器的寄存器和存储器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CDP   P3，2，C12，C10，C3，4  ; 该指令完成协处理器P3的初始化 </span><br></pre></td></tr></table></figure>

<h3 id="LDC"><a href="#LDC" class="headerlink" title="LDC"></a>LDC</h3><p>LDC指令用于将源寄存器所指向的存储器中的字数据传送到目的寄存器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDC&#123;条件&#125;&#123;L&#125; 协处理器编码，目的寄存器，[源寄存器]</span><br></pre></td></tr></table></figure>

<p>其中，{L}选项表示指 令为长读取操作，如用于双精度数据的传输。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDC   P3，C4，[R0]        ; 将ARM处理器的寄存器R0所指向的存储器中的字数 据传送到协处理器P3的寄存器C4中。 </span><br></pre></td></tr></table></figure>

<h3 id="STC"><a href="#STC" class="headerlink" title="STC"></a>STC</h3><p>STC指令用于将源寄存器中的字数据传送到目的寄存器所指向的存储器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STC&#123;条件&#125;&#123;L&#125; 协处理器编码，源寄存器，[目的寄存器]</span><br></pre></td></tr></table></figure>

<p>其中，{L}选项表示指 令为长读取操作，如用于双精度数据的传输。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STC   P3，C4，[R0]     ; 将协处理器P3的寄存器C4中的字数据传送到ARM处理 器的寄存器R0所指向的存储器中。 </span><br></pre></td></tr></table></figure>

<h3 id="MCR"><a href="#MCR" class="headerlink" title="MCR"></a>MCR</h3><p>MCR指令用于将ARM处理器寄存器中的数据传送到协处理器寄存器中，若协处理器不能成功完成操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MCR&#123;条件&#125; 协处理器编码，协处理器操作码1，源寄存器，目的寄存器1，目的寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure>

<p>其中协处理器操作码1和协处理 器操作码2为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄 存器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MCR   P3，3，R0，C4，C5，6     ; 将ARM处理器寄存器R0中的数据传送到协处 理器P3的寄存器C4和C5中。 </span><br></pre></td></tr></table></figure>

<h3 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h3><p>MRC指令用于将协处理器寄存器中的数据传送到ARM处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRC&#123;条件&#125; 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure>

<p>其中协处理器操作码1和协处理器操作码2为协处理器将要执行的操作，目的寄存器为ARM处理器的寄存器，源寄存器1和源寄存器2均为协处理器的寄存器。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRC   P3，3，R0，C4，C5，6     ; 该指令将协处理器P3的寄存器中的数据传送到 ARM处理器寄存器中。</span><br></pre></td></tr></table></figure>

<h2 id="异常产生指令"><a href="#异常产生指令" class="headerlink" title="异常产生指令"></a>异常产生指令</h2><p>ARM指令集中提供了两条产生异常的指令，通过这两条指令可以用软件的方法实现异常。</p>
<h3 id="SWI"><a href="#SWI" class="headerlink" title="SWI"></a>SWI</h3><p>SWI指令用于产生软件中断，以便用户程序能调用操作系统的系统例程。操作系统在SWI的异常处理程序中提供相应的系统服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SWI&#123;条件&#125; 24位的立即数</span><br></pre></td></tr></table></figure>

<p>指令中24位的立即数指定用户程序调用系统例程的类型，相关参数通过通用寄存器传递，当指令中24位的立即数被忽略时，用户程序调用系统例程的类型由通用寄存器R0的内容决定，同时，参数通过其他通用寄存器传递。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SWI   0x02     ; 该指令调用操作系统编号位02的系统例程。</span><br></pre></td></tr></table></figure>

<h3 id="BKPT"><a href="#BKPT" class="headerlink" title="BKPT"></a>BKPT</h3><p>BKPT指令产生软件断点中断，可用于程序的调试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BKPT   16位的立即数</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="WFE"><a href="#WFE" class="headerlink" title="WFE"></a>WFE</h3><p>等待事件（Wait For Event）指令。自旋锁就使用到了WFE指令。</p>
<p>ARM架构下，有一个全局的事件寄存器（Event Register），系统中的每一个CPU核在这个寄存器上都有对应的位。当前CPU执行WFE指令的时候，如果事件寄存器对应当前CPU的位没有被设置（也就是0），则当前CPU核会进入低功耗模式，会被挂起，不会再执行其它操作；而如果事件寄存器对应当前CPU的位被设置了（也就是1），则会将事件寄存器对应当前CPU的位清空（设置成0），然后立即返回，继续执行下面的指令，不会进入低功耗模式。</p>
<p>只有在如下情况下才可能被重新唤醒：</p>
<ul>
<li>发生了IRQ中断（前提是没有被屏蔽）；</li>
<li>发生了FIQ中断（前提是没有被屏蔽）；</li>
<li>发生了SError中断（前提是没有被屏蔽）；</li>
<li>事件寄存器对应当前CPU核的位被置位（设置成1），如果是通过这种方式唤醒的，唤醒后会立即将事件寄存器对应当前CPU核的位清0。</li>
</ul>
<h3 id="WFI"><a href="#WFI" class="headerlink" title="WFI"></a>WFI</h3><p>等待中断（Wait For Interrupt）指令。执行WFI指令后，当前CPU核会立即进入低功耗状态。只有在如下情况下才可能被重新唤醒：</p>
<ul>
<li>发生了IRQ中断（不管有没有被屏蔽）；</li>
<li>发生了FIQ中断（不管有没有被屏蔽）；</li>
<li>发生了SError中断（不管有没有被屏蔽）。</li>
</ul>
<h3 id="SEV"><a href="#SEV" class="headerlink" title="SEV"></a>SEV</h3><p>发送事件（Send Event）指令将想系统中的所有CPU核发送事件。对应系统中的每个CPU核，设置事件寄存器（Event Register）相应的位。如果某个CPU核正在等待事件（WFE），那么该CPU核会被立即唤醒，并清除掉表示该CPU的事件寄存器相应的位。</p>
<h3 id="SEVL"><a href="#SEVL" class="headerlink" title="SEVL"></a>SEVL</h3><p>发送本地事件（Send Event Locally）指令。只会向当前CPU核心发送。如果是多核CPU那也只向当前核心，不会向CPU内的其它核心发送。</p>
<p>stp： 入栈指令（str 的变种指令，可以同时操作两个寄存器）</p>
<p>stp x29, x30, [sp, #0x10]     ; 将 x29, x30 的值存入 sp 偏移 16 个字节的位置 </p>
<p>ldp： 出栈指令（ldr 的变种指令，可以同时操作两个寄存器）</p>
<p>ldp x29, x30, [sp, #0x10]     ; 将 sp 偏移 16 个字节的值取出来，存入寄存器 x29 和寄存器 x30 </p>
<p>scvtf： (Signed Convert To Float)带符号 定点数 转换为 浮点数</p>
<p>scvtf    d1, w0      ; 将寄存器 w0 的值(顶点数，转化成 浮点数) 保存到 向量寄存器/浮点寄存器 d1 中</p>
<p>fcvtzs： (Float Convert To Zero Signed)浮点数 转化为 定点数 （舍入为0）</p>
<p>fcvtzs w0, s0        ; 将向量寄存器 s0 的值(浮点数，转换成 定点数)保存到寄存器 w0 中</p>
]]></content>
      <categories>
        <category>cpu</category>
      </categories>
      <tags>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot Makefile 分析</title>
    <url>/2023/01/02/boot/uboot-makefile/</url>
    <content><![CDATA[<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VERSION = 2013    <span class="comment">#主版本号</span></span><br><span class="line">PATCHLEVEL = 10   <span class="comment">#次版本号</span></span><br><span class="line">SUBLEVEL =        <span class="comment">#子版本号</span></span><br><span class="line">EXTRAVERSION =    <span class="comment">#附加的版本信息</span></span><br><span class="line"></span><br><span class="line">version_h := <span class="keyword">include</span>/generated/version_autogenerated.h</span><br></pre></td></tr></table></figure>

<p>uboot编译时，会将版本信息输出到 include\generated\version_autogenerated.h 文件中。</p>
<p>使用 <code>make V=1</code> 可以看到完整的执行命令</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="string">&quot;$(origin V)&quot;</span>, <span class="string">&quot;command line&quot;</span>)</span><br><span class="line">  KBUILD_VERBOSE = <span class="variable">$(V)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifndef</span> KBUILD_VERBOSE</span><br><span class="line">  KBUILD_VERBOSE = 0</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KBUILD_VERBOSE)</span>,1)</span><br><span class="line">  quiet =</span><br><span class="line">  Q =</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  quiet=quiet_</span><br><span class="line">  Q = @</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p><code>make -s</code>(静默模式)，禁止命令回显</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">filter</span> 4.%,<span class="variable">$(MAKE_VERSION)</span>)</span>,)	<span class="comment"># make-4</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">filter</span> %s ,$(<span class="built_in">firstword</span> x<span class="variable">$(MAKEFLAGS)</span>)</span>),)</span><br><span class="line">  quiet=silent_</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">else</span>					<span class="comment"># make-3.8x</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">filter</span> s% -s%,<span class="variable">$(MAKEFLAGS)</span>)</span>,)</span><br><span class="line">  quiet=silent_</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> quiet Q KBUILD_VERBOSE</span><br></pre></td></tr></table></figure>

<p><code>make O=</code> 设置编译输出目录。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="string">&quot;$(origin O)&quot;</span>, <span class="string">&quot;command line&quot;</span>)</span><br><span class="line">  KBUILD_OUTPUT := <span class="variable">$(O)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>获取主机的CPU架构和操作系统</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">HOSTARCH := <span class="variable">$(<span class="built_in">shell</span> uname -m | \</span></span><br><span class="line"><span class="variable">	sed -e s/i.86/x86/ \</span></span><br><span class="line"><span class="variable">	    -e s/sun4u/sparc64/ \</span></span><br><span class="line"><span class="variable">	    -e s/arm.*/arm/ \</span></span><br><span class="line"><span class="variable">	    -e s/sa110/arm/ \</span></span><br><span class="line"><span class="variable">	    -e s/ppc64/powerpc/ \</span></span><br><span class="line"><span class="variable">	    -e s/ppc/powerpc/ \</span></span><br><span class="line"><span class="variable">	    -e s/macppc/powerpc/\</span></span><br><span class="line"><span class="variable">	    -e s/sh.*/sh/)</span></span><br><span class="line"></span><br><span class="line">HOSTOS := <span class="variable">$(<span class="built_in">shell</span> uname -s | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27; | \</span></span><br><span class="line"><span class="variable">	    sed -e &#x27;s/\(cygwin\)</span>.*/cygwin/&#x27;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> HOSTARCH HOSTOS</span><br></pre></td></tr></table></figure>

<p>设置编译器和配置文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KCONFIG_CONFIG	?= .config</span><br><span class="line"><span class="keyword">export</span> KCONFIG_CONFIG</span><br><span class="line"></span><br><span class="line">HOST_LFS_CFLAGS := <span class="variable">$(<span class="built_in">shell</span> getconf LFS_CFLAGS 2&gt;/dev/null)</span></span><br><span class="line">HOST_LFS_LDFLAGS := <span class="variable">$(<span class="built_in">shell</span> getconf LFS_LDFLAGS 2&gt;/dev/null)</span></span><br><span class="line">HOST_LFS_LIBS := <span class="variable">$(<span class="built_in">shell</span> getconf LFS_LIBS 2&gt;/dev/null)</span></span><br><span class="line"></span><br><span class="line">HOSTCC       = cc</span><br><span class="line">HOSTCXX      = c++</span><br><span class="line">KBUILD_HOSTCFLAGS   := -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer \</span><br><span class="line">		<span class="variable">$(HOST_LFS_CFLAGS)</span> <span class="variable">$(HOSTCFLAGS)</span></span><br><span class="line">KBUILD_HOSTCXXFLAGS := -O2 <span class="variable">$(HOST_LFS_CFLAGS)</span> <span class="variable">$(HOSTCXXFLAGS)</span></span><br><span class="line">KBUILD_HOSTLDFLAGS  := <span class="variable">$(HOST_LFS_LDFLAGS)</span> <span class="variable">$(HOSTLDFLAGS)</span></span><br><span class="line">KBUILD_HOSTLDLIBS   := <span class="variable">$(HOST_LFS_LIBS)</span> <span class="variable">$(HOSTLDLIBS)</span></span><br></pre></td></tr></table></figure>

<p>制作变量，设置编译器完整名称</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">AS		= <span class="variable">$(CROSS_COMPILE)</span>as</span><br><span class="line"><span class="comment"># Always use GNU ld</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CROSS_COMPILE)</span>ld.bfd -v 2&gt; /dev/null)</span>,)</span><br><span class="line">LD		= <span class="variable">$(CROSS_COMPILE)</span>ld.bfd</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LD		= <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">CC		= <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">CPP		= <span class="variable">$(CC)</span> -E</span><br><span class="line">AR		= <span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">NM		= <span class="variable">$(CROSS_COMPILE)</span>nm</span><br><span class="line">LDR		= <span class="variable">$(CROSS_COMPILE)</span>ldr</span><br><span class="line">STRIP		= <span class="variable">$(CROSS_COMPILE)</span>strip</span><br><span class="line">OBJCOPY		= <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP		= <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">MKCONFIG := <span class="variable">$(SRCTREE)</span>/mkconfig</span><br><span class="line"><span class="keyword">export</span> MKCONFIG</span><br><span class="line"></span><br><span class="line"><span class="section">unconfig:</span></span><br><span class="line">    @rm -f <span class="variable">$(obj)</span><span class="keyword">include</span>/config.h <span class="variable">$(obj)</span><span class="keyword">include</span>/config.mk \</span><br><span class="line">        <span class="variable">$(obj)</span>board/*/config.tmp <span class="variable">$(obj)</span>board/*/*/config.tmp \</span><br><span class="line">        <span class="variable">$(obj)</span><span class="keyword">include</span>/autoconf.mk <span class="variable">$(obj)</span><span class="keyword">include</span>/autoconf.mk.dep \</span><br><span class="line">        <span class="variable">$(obj)</span><span class="keyword">include</span>/spl-autoconf.mk \</span><br><span class="line">        <span class="variable">$(obj)</span><span class="keyword">include</span>/tpl-autoconf.mk</span><br><span class="line">        </span><br><span class="line"><span class="section">%_config:: unconfig</span></span><br><span class="line">    @<span class="variable">$(MKCONFIG)</span> -A $(@:_config=)</span><br></pre></td></tr></table></figure>

<p>设置[mkconfig](#mkconfig 分析)脚本的路径。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(obj)</span><span class="keyword">include</span>/autoconf.mk.dep</span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(obj)</span><span class="keyword">include</span>/autoconf.mk</span><br></pre></td></tr></table></figure>

<p>导入include/autoconf.mk文件，由配置脚本根据inlcude/configs/xxx.h 头文件生成的，里面包含与开发板相关的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_SYS_TEXT_BASE=0x34800000</span><br><span class="line">CONFIG_COMMON_BOOT=&quot;&quot;console=ttySAC0,115200n8 mem=128M  &quot; MTDPARTS_DEFAULT&quot;</span><br><span class="line">CONFIG_BOOTARGS=&quot;&quot;root=/dev/mtdblock5 ubi.mtd=4 rootfstype=cramfs &quot; CONFIG_COMMON_BOOT&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(obj)</span><span class="keyword">include</span>/config.mk</span><br><span class="line"><span class="keyword">export</span> ARCH CPU BOARD VENDOR SOC</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(TOPDIR)</span>/config.mk</span><br></pre></td></tr></table></figure>

<p>导入include/config.mk文件，里面包含ARCH, BOARD, VENDOR, SOC 和 CPU 变量，这是配置过程自动生成的。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ARCH   = arm</span><br><span class="line">CPU    = armv7</span><br><span class="line">BOARD  = smdkc100</span><br><span class="line">VENDOR = samsung</span><br><span class="line">SOC    = s5pc1xx</span><br></pre></td></tr></table></figure>

<p>导入config.mk文件，里面定义编译工具配置项。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">CPP = <span class="variable">$(CC)</span> -E</span><br><span class="line">AR = <span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">NM = <span class="variable">$(CROSS_COMPILE)</span>nm</span><br><span class="line">LDR = <span class="variable">$(CROSS_COMPILE)</span>ldr</span><br><span class="line">STRIP = <span class="variable">$(CROSS_COMPILE)</span>strip</span><br><span class="line">OBJCOPY = <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP = <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line">RANLIB = <span class="variable">$(CROSS_COMPILE)</span>RANLIB</span><br><span class="line"></span><br><span class="line">LDFLAGS_u-boot += -T <span class="variable">$(obj)</span>u-boot.lds <span class="variable">$(LDFLAGS_FINAL)</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(CONFIG_SYS_TEXT_BASE)</span>,)</span><br><span class="line">LDFLAGS_u-boot += -Ttext <span class="variable">$(CONFIG_SYS_TEXT_BASE)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p><code>-Ttext</code>用 来指定uboot的链接起始地址，链接脚本也可以指定，但最终以这个为准。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> LDSCRIPT</span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_NAND_U_BOOT)</span>,y)</span><br><span class="line">        LDSCRIPT := <span class="variable">$(TOPDIR)</span>/board/<span class="variable">$(BOARDDIR)</span>/u-boot-nand.lds</span><br><span class="line">        <span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LDSCRIPT)</span>)</span>,)</span><br><span class="line">            LDSCRIPT := <span class="variable">$(TOPDIR)</span>/<span class="variable">$(CPUDIR)</span>/u-boot-nand.lds</span><br><span class="line">        <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LDSCRIPT)</span>)</span>,)</span><br><span class="line">        LDSCRIPT := <span class="variable">$(TOPDIR)</span>/board/<span class="variable">$(BOARDDIR)</span>/u-boot.lds</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LDSCRIPT)</span>)</span>,)</span><br><span class="line">        LDSCRIPT := <span class="variable">$(TOPDIR)</span>/<span class="variable">$(CPUDIR)</span>/u-boot.lds</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LDSCRIPT)</span>)</span>,)</span><br><span class="line">        LDSCRIPT := <span class="variable">$(TOPDIR)</span>/arch/<span class="variable">$(ARCH)</span>/cpu/u-boot.lds</span><br><span class="line">        <span class="comment"># We don&#x27;t expect a Makefile here</span></span><br><span class="line">        LDSCRIPT_MAKEFILE_DIR =</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LDSCRIPT)</span>)</span>,)</span><br><span class="line"><span class="variable">$(<span class="built_in">error</span> could not find linker script)</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>指定链接脚本，如果定义了 CONFIG_NAND_U_BOOT 宏，则链接脚本叫 u-boot-nand.lds，如果未定义这个宏则链接脚本叫 u-boot.lds。查找顺序为 board/, cpu_xxx/, arch/。</p>
<p>include/config.h 头文件，这个文件会被大部分c文件包含。</p>
<h2 id="u-boot-lds"><a href="#u-boot-lds" class="headerlink" title="u-boot.lds"></a>u-boot.lds</h2><p>arch/arm/cpu/u-boot.lds 是ld连接器的脚本文件，描述如何连接目标文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 指定输出可执行文件是 elf 格式,32 位 ARM 指令,小端 */</span><br><span class="line">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)</span><br><span class="line"></span><br><span class="line">/* 指定输出可执行文件的平台架构为 ARM 架构 */</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line"></span><br><span class="line">/* 指定程序的起始代码段为_start */</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x00000000;  @ 指定程序的链接地址</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);  @ 4字节对齐</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        cpu/arm920t/start.o(.text)  @ 首先编译start.S</span><br><span class="line">        *(.text)  @ 所有的其他程序的代码段以4字节对齐放在它后面</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .got : &#123; *(.got) &#125;</span><br><span class="line"></span><br><span class="line">    . = .;</span><br><span class="line">    __u_boot_cmd_start = .;  @ 把__u_boot_cmd_start赋值为当前位置，即起始位置</span><br><span class="line">    .u_boot_cmd : &#123; *(.u_boot_cmd) &#125;  @ 指定 u_boot_cmd段，把所有的uboot命令放在该段</span><br><span class="line">    __u_boot_cmd_end = .;  @ 把 __u_boot_cmd_end赋值为当前位置，即结束位置</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss (NOLOAD) : &#123; *(.bss) . = ALIGN(4); &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由.text段的编译顺序可知，uboot 首先运行的是 _start 符号处的代码，在 arch/arm/cpu/arm920t/start.S文件中定义。</p>
]]></content>
      <categories>
        <category>uboot</category>
      </categories>
  </entry>
  <entry>
    <title>交叉编译工具链命名规则</title>
    <url>/2022/09/25/tool/gcc-name/</url>
    <content><![CDATA[<p>交叉编译工具链是一个由编译器、连接器和解释器组成的综合开发环境，交叉编译工具链主要由binutils、gcc和glibc三个部分组成。有时出于减小 libc 库大小的考虑，也可以用别的 c 库来代替 glibc，例如 uClibc、dietlibc 和 newlib。</p>
<p>从授权上分为免费授权版和付费授权版。免费版目前有三大主流工具商提供，第一是GNU（提供源码，自行编译制作），第二是 Codesourcery，第三是Linora。收费版有ARM原厂提供的armcc、IAR提供的编译器等等。</p>
<p>交叉编译工具链的命名规则为：arch [-vendor] [-kernel] [-system]</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>体系架构, 如ARM, MIPS</td>
</tr>
<tr>
<td>vendor</td>
<td>工具链提供商，也可以是处理器核型号</td>
</tr>
<tr>
<td>kernel</td>
<td>目标内核：Linux和bare-metal（裸机）</td>
</tr>
<tr>
<td>system</td>
<td>库函数和目标系统：gnu，eabi，uclibc</td>
</tr>
</tbody></table>
<p>根据对操作系统的支持与否，ARM gcc可分为支持和不支持操作系统，如：</p>
<ul>
<li><p>arm-none-eabi：这个是没有操作系统的，不支持那些跟操作系统关系密切的函数如fork()。</p>
</li>
<li><p>arm-none-linux-eabi 用于Linux系统，使用Glibc。</p>
</li>
</ul>
<p>ABI(Application Binary Interface)二进制应用程序接口，描述了应用程序和操作系统之间或其他应用程序的低级接口。</p>
<p>OABI(Old Application Binary Interface)是老的ABI。</p>
<p>EABI(Embedded Application Binary Interface)是嵌入式的ABI，指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。允许使用特权指令，不需要动态链接，并且使用更紧凑的堆栈帧组织用来节省内存。</p>
<p>system中gnu的值，其实是glibc的意思。</p>
<ul>
<li>gnu      = glibc+oabi</li>
<li>gnueabi  = glibc + eabi</li>
<li>uclibc   = uclibc + oabi</li>
</ul>
<p>arm-none-eabi-gcc（ARM architecture，no vendor，not target an operating system，complies with the ARM EABI）<br>用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application），一般适合 ARM7、Cortex-M 和 Cortex-R 内核的芯片使用。</p>
<p>arm-none-linux-gnueabi-gcc(ARM architecture, no vendor, creates binaries that run on the Linux operating system, and uses the GNU EABI)主要用于基于ARM架构的Linux系统，可用于编译 ARM 架构的 u-boot、Linux内核、linux应用等。适合ARM9、ARM11、Cortex-A 内核，带有 Linux 操作系统的芯片。</p>
<p>arm-linux-gnueabi-gcc 和 arm-linux-gnueabihf-gcc两个交叉编译器分别适用于 armel 和 armhf 两个不同的架构，armel 和 armhf 这两种架构在对待浮点运算采取了不同的策略（有 fpu 的 arm 才能支持这两种浮点运算策略）。其实这两个交叉编译器只不过是 gcc 的选项 -mfloat-abi 的默认值不同：</p>
<table>
<thead>
<tr>
<th>浮点数配置</th>
<th>架构</th>
<th>对应编译器类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>soft</td>
<td>无</td>
<td>无</td>
<td>不用fpu进行浮点计算, 即使有fpu浮点运算单元也不用, 而是使用软件模式</td>
</tr>
<tr>
<td>softfp</td>
<td>armel架构</td>
<td>arm-linux-gnueabi-gcc</td>
<td>用fpu计算, 但是传参数用普通寄存器传, 这样中断的时候, 只需要保存普通寄存器, 中断负荷小, 但是参数需要转换成浮点的再计算</td>
</tr>
<tr>
<td>hard</td>
<td>armhf架构</td>
<td>arm-linux-gnueabihf-gcc</td>
<td>用fpu计算, 传参数也用fpu中的浮点寄存器传, 省去了转换, 性能最好, 但是中断负荷高</td>
</tr>
</tbody></table>
<p><strong>交叉编译器下载</strong></p>
<p>arm-none-linux-gnueabi-gcc下载：<a href="http://www.veryarm.com/">www.veryarm.com</a></p>
<p>arm-linux-gnueabihf-gcc下载：<a href="http://www.veryarm.com/">www.veryarm.com</a></p>
<p>aarch64-linux-gnu-gcc下载：<a href="http://www.veryarm.com/">www.veryarm.com</a></p>
<p>arm-none-elf-gcc下载：<a href="http://www.veryarm.com/">www.veryarm.com</a></p>
<p>arm-none-eabi-gcc下载：<a href="http://www.veryarm.com/">www.veryarm.com</a></p>
]]></content>
      <categories>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
</search>
