<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/page/15/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/net/tcp_udp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/net/tcp_udp/" class="post-title-link" itemprop="url">TCP and UDP</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:36:39" itemprop="dateModified" datetime="2022-06-08T17:36:39+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP(Transmission Control Protocol)传输层控制协议是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<ul>
<li>面向连接：只能是一对一连接，不能向多个主机发送消息，故不能广播和多播。</li>
<li>可靠的：无论网络链路怎样变化，都能保证报文到达接收端。</li>
<li>字节流：无论消息多大都可以传输，并且消息是有序的。</li>
</ul>
<p>建立一个TCP连接需要客户端与服务器端达成三个共识:</p>
<ul>
<li>Socket：由 IP 地址和端口号组成</li>
<li>序列号：保证数据包不重复、不丢弃和按序传输，用来解决乱序问题等</li>
<li>窗口大小：用来做流量控制</li>
</ul>
<p>TCP通过源地址、目的地址、源端口和目的端口可以确定一个唯一的连接。</p>
<p>服务器上TCP的最大连接数理论上等于客户端IP数 × 客户端端口数，但实际上会受到内存和socket文件描述符（ulimit配置）的限制。</p>
<p>TCP负载数据⻓度 = IP 总⻓度 - IP 首部⻓度 - TCP 首部⻓度。</p>
<p>TCP具有流量控制、超时重传、拥塞控制、数据校验、数据分片排序等特性来保证数据可靠传输。</p>
<ul>
<li>TCP 使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP 给数据分片进行排序，并使用累积确认保证数据的顺序不变和非重复</li>
<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>
<p>应用程序通过打开一个socket 来使用TCP服务，TCP管理socket 的数据传递。连接操作的第一步是在 TCP 模块处创建表示连接控制信息的头部。当 TCP 头部创建好之后， TCP 模块会将信息传递给 IP 模块并委托它发送 给服务器 。服务器根据TCP 头部中的发送方和接收方端口号可以找到要连接的套接字。</p>
<p><img src="/images/net/tcpip/tcp_head.png" alt="tcp_head"></p>
<h3 id="TCP分片"><a href="#TCP分片" class="headerlink" title="TCP分片"></a>TCP分片</h3><p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传，如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传，缺乏效率。</p>
<ul>
<li>MTU :一个网络包的最大⻓度，在以太网中一般是 1500 字节。</li>
<li>MSS :除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大⻓度。</li>
</ul>
<p><img src="/images/net/tcpip/mss.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看MTU值</span></span><br><span class="line">cat /sys/class/net/eth0/mtu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改MTU值</span></span><br><span class="line">echo &quot;1400&quot; &gt; /sys/class/net/eth0/mtu</span><br></pre></td></tr></table></figure>

<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。连接之前服务端处于 LISTEN 状态主动监听某个端口，客户端执行connect()时，将触发三次握手。</p>
<p><img src="/images/net/tcpip/tcp-link3.jpg" alt="tcp-link3"></p>
<ol>
<li><p>客户端发送连接请求报文给服务器，将SYN位置1，表示 SYN 报文。同时客户端将初始化的序号，放在包头的序列号字段里。</p>
</li>
<li><p>服务器收到客户端的 SYN 报文之后，把 SYN和ACK 标志位置1，随机初始化自己的序号，并填入序列号字段中，把客户端的 ISN + 1 作为 ACK 的值，表示同意建立连接。</p>
</li>
<li><p>客户端收到服务端 SYN 报文之后，还要回应一个应答报文，表示已经收到了服务端发的同意报文。先将 ACK 标志位置1，自身序列号+1，把服务器的 ISN + 1 作为 ACK 的值。</p>
</li>
<li><p>服务端收到客户端的 ACK，连接已建立，可以数据传输。</p>
</li>
</ol>
<p>在三次连接中，只有第三次握手是可以携带数据的，前两次握手是不可以携带数据的。可以通过<code>netstat -napt</code>命令查看TCP 的连接状态。</p>
<p>之所以需要三次握中，是因为至少需要三次才能初始化确定Socket、序列号和窗口大小等 TCP 连接信息，进而建立可靠的连接。超过3次会有延迟的历史已失效的连接。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>TCP 的连接的断开需要发送四个包，因此称为四次挥手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p>
<p><img src="/images/net/tcpip/tcp-unlink4.jpg" alt="tcp-unlink4"></p>
<ol>
<li>客户端发送 FIN 报文给服务器，将FIN位置1，随机设置序列号，请求释放从客户端到服务器的连接。</li>
<li>服务器接收到客户端发的 FIN，并回复 ACK 给客户端，将客户端的序列号值 +1 作为 ACK 的值，表明同意释放从客户端到服务器的连接。</li>
<li>客户端收到服务端回复的 ACK，，此时从客户端到服务器的连接已释放，但服务端到客户端的连接还未释放，并且客户端还可以接收数据。</li>
<li>服务端继续发送之前没发完的数据给客户端；</li>
<li>服务端发送 FIN+ACK 给客户端，指定一个序列号，请求释放从服务端到客户端的连接。发送完毕后，等待客户端的确认。就算没收到客户端的回复，过了时间也会自动释放。</li>
<li>客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端，将服务端的序列号值+1 作为 ACK 的值，表明同意释放从服务端到客户端的连接，并等待可能出现的要求重传的 ACK 包。</li>
<li>客户端等待了2MSL后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己会关闭连接。</li>
<li>服务端收到客户端的 ACK 后，释放从服务端到客户端的连接，至此连接完全关闭。</li>
</ol>
<p>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</p>
<p>释放连接时，因服务器可能还有数据需要传输给客户端，所以 ACK 和 FIN 要分开发送，先响应客户端 FIN 请求，然后数据传输，传输完成后，服务端再提出 FIN 请求。而连接时因为没有数据要传输，所以 ACK 和 SYN 可以一起发送。</p>
<p>MSL(Maximum Segment Lifetime)报文最大生存时间，它是任何报文在网络上存在的最⻓时间，超过这个时间报文将被丢弃，保证下次连接不会出现旧的连接报文，同时确保这个时间内客户端发送的最后一个 ACK 报文能够到达服务端。2MSL时间是从客户端接收到 FIN 后发送 ACK 开始计时的，如果在 TIME_WAIT 时间内，因为客户端的 ACK没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL时间将重新计时。TIME_WAIT 是2 倍的 MSL，要修改 TIME_WAIT 的时间⻓度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译内核。</p>
<h3 id="内核的TCP参数"><a href="#内核的TCP参数" class="headerlink" title="内核的TCP参数"></a>内核的TCP参数</h3><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP利用 IP 提供面向无连接的通信服务，支持一对一、一对多、多对多的交互通信。不提供复杂的控制机制，只负责发送数据包，不保证数据包是否能抵达对方，实时性和传输效率相对更好。当然UDP要实现可靠传输，就要在应用层上实现TCP 的特性。</p>
<p><img src="/images/net/tcpip/udp_head.png" alt="udp head"></p>
<ul>
<li><p>UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次</p>
</li>
<li><p>UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。</p>
</li>
<li><p>UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。</p>
</li>
<li><p>UDP 支持多播和广播。</p>
</li>
</ul>
<h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><ol>
<li>TCP 是面向连接的，传输数据前先要建立连接，UDP 是不需要连接，直接传输数据。</li>
<li>TCP 只能一对一通信，UDP 支持一对一、一对多、多对多的交互通信。</li>
<li>TCP是面向字节流的，UDP是基于数据报。</li>
<li>TCP 保证可靠，UDP 不保证可靠交付数据。</li>
<li>TCP 有拥塞控制和流量控制机制，UDP 则没有。</li>
<li>TCP 头部长度较长，而且有可变长字段，UDP 固定8字节，开销较小。</li>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，有边界，可能会丢包和乱序。</li>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。</li>
<li>TCP用于FTP 文件传输、HTTP / HTTPS。UDP用于视频、音频等多媒体通信、广播通信场景。</li>
<li>TCP 有可变长字段，所以要有头部长度字段。而 UDP 头部长度是固定的，无需多一个字段去记录 UDP头部长度。</li>
<li>TCP头部没有包长度字段，UDP头部有包长度字段。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/net/ip_mac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/net/ip_mac/" class="post-title-link" itemprop="url">IP and MAC</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:36:39" itemprop="dateModified" datetime="2022-06-08T17:36:39+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><p>IPv4 地址共32位，每 8 位作为一组，用点分十进制的表示方式，包含两部分：网络号负责标识该 IP 地址是属于哪个子网的；主机号负责标识同一子网下的不同主机。</p>
<p>子网掩码也是32bit，为1的部分表示网络号，为0的部分表示主机号，将子网掩码和IP地址相与，可以计算出网络号和主机号。主机号部分全部为0代表整个子网，主机号部分全部为1代表广播地址，向子网上所有设备发送包。</p>
<p><img src="/images/net/tcpip/ip_name.png" alt="ip_name"></p>
<p>本地回环地址127.0.0.1指的是本机地址，等效于localhost或本机IP。不会跟着网络情况的变化而变化。它代表设备的本地虚拟接口，被看作是永远不会宕掉的接口。127.0.0.1 ~ 127.255.255.254范围都是本地回环地址。作用是测试本机的网络配置，能ping通说明本机网络协议正常。</p>
<p>IP 地址分为A类、B类、C类、D类、E类，其中D类和E类没有主机号的，所以不可用于主机 IP，D类常被用于多播，E类预留未使用。</p>
<p><img src="/images/net/tcpip/ip_class.webp" alt="ip_class"></p>
<p><img src="/images/net/tcpip/ip_class.png" alt="ip_class"></p>
<h3 id="IP头"><a href="#IP头" class="headerlink" title="IP头"></a>IP头</h3><p><img src="/images/net/tcpip/ip_head.png" alt="img"></p>
<p>经过分片之后的 IP 数据，只能由目标主机进行重组，路由器并不会重组。</p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv6 地址⻓度是 128 位，以每 16 位作为一组，每组用冒号:隔开。</p>
<p>IPv6 的地址主要有以下类型地址:</p>
<ul>
<li>单播地址，用于一对一的通信</li>
<li>组播地址，用于一对多的通信</li>
<li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li>
<li>没有广播地址</li>
</ul>
<p><img src="/images/net/tcpip/ipv6.png" alt="img"></p>
<ul>
<li><p>取消了首部校验和字段。 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</p>
</li>
<li><p>取消了分片/重新组装相关字段。 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</p>
</li>
<li><p>取消选项字段。 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的下一个首部指出的位置上。删除该选项字段使的 IPv6 的首部成为固定⻓度的 40 字节。</p>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP 协议(Internet Protocol)负责在主机和网络之间寻址和路由数据包。</p>
<p>IP地址的网络地址这一部分是用于进行路由控制，路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最⻓匹配。</p>
<p>IP 模块会添加 IP 头部和 MAC 头部这两种头部。IP 头部包含目的地的 IP 地址，MAC 头部包含 MAC 地址。IP 协议会查找下一个路由器的MAC 地址，并将这个地址写入 MAC 头部中。这样一来，以太网协议就知道要将这个包发到哪一个路由器上了。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS(Domain Name System)域名服务系统，将域名网址自动解析为具体的 IP 地址。</p>
<p>查询 IP 地址时，浏览器会使用系统 Socket 库中的解析器， 向 DNS 服务器发送查询消息，然后 DNS 服务器会从域名与 IP 地址的对照表中查找相应的记录，并返回 IP 地址。客户端的查询消息包含以下 3 种信息：</p>
<ul>
<li>域名：服务器、邮件服务器(邮件地址中 @ 后面的部分)的名称。</li>
<li>Class：网络的信息标识。如今 Class 的值永远是代表互联网的 IN。</li>
<li>记录类型：表示域名对应何种类型的记录。例如，当类型为 A 时，表示域名对应的是 IP 地址；当类型为 MX 时，表示域名对应的是邮件服务器。对于不同的记录类型，服务器向客户端返回的信息也会不同。</li>
</ul>
<p><img src="/images/net/dns_msg.png" alt="dns_msg"></p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。</p>
<p>主机会通过广播发送 ARP 请求，这个包中包含了想要查询的 MAC 地址的主机 IP 地址。当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。通常操作系统会把获取的 MAC 地址缓存起来，可以使用 <code>arp -a</code> 命令来查看。</p>
<p>RARP 协议是根据 MAC 地址求 IP 地址。</p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>DHCP(Dynamic Host Configuration Protocol)动态主机配置协议。能实现自动设置 IP 地址、统一管理 IP 地址分配。DHCP 服务器分配的 IP 地址只能在租期内使用。</p>
<h4 id="udhcpc"><a href="#udhcpc" class="headerlink" title="udhcpc"></a>udhcpc</h4><p>默认的目录文件是/usr/share/udhcpc/default.script，当udhcpc 取得了IP地址之后，会把从DHCP server 得到的信息带入 script执行。</p>
<h3 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h3><p>NAT就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址。</p>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>ICMP(Internet Control Message Protocol)互联网控制报文协议，用于告知网络包传送过程中产生的错误以及各种控制信息。在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。</p>
<h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><p>被IP主机用来向本地多路广播路由器报告主机组成员的协议。</p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器是按照IP 协议传输包的设备，根据接收到的包的 IP 头部中记录的接收方 IP 地址，在路由表中进行查询，以此判断转发目标。</p>
<p>路由器已经集成了集线器和交换机的功能，俗称三层网络设备，每个端口都具有 MAC 地址和 IP 地址，只接收与自身地址匹配的包，不匹配的包则直接丢弃。</p>
<p><img src="/images/net/route_map.png" alt="img"></p>
<p>路由器忽略主机号部分，只匹配网络号。路由表的子网掩码列只是用来在匹配目标地址时告诉路由器应该匹配多少个比特。根据目标地址和子网掩码匹配到某条记录后，路由器就会将网络包交给接口列中指定的端口，并转发到网关列中指定的 IP 地址。跃点计数表示距离目标 IP 地址的距离的远近。数字越小表示距离目的地越近；数字越大表示距离目的地越远。</p>
<p>路由表中子网掩码为 0.0.0.0 的记录表示默认路由，这一行配置的网关地址被称为默认网关，无论任何地址都能匹配到这一条记录。</p>
<p>路由器优先选择主机号比特数越短，跃点计数较小的记录。如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过ICMP 消息告知发送方 。</p>
<p>路由器会更新 IP 头部中的 TTL字段。TTL 字段表示包的有效期，包每经过一个路由器的转发，这个值就会减 1，当这个值变成 0 时，就表示超过了有效期，这个包就会被丢弃。</p>
<p>对于长度大于输出端口MTU的转发包，路由器会根据IP 头部中的标志字段，确认是否可以分片。如果查询标志字段发现不能分片，那么就只能丢弃这个包，并通过ICMP 消息通知发送方。在分片中，TCP 头部及其后面的部分都是可分片的数据，每一份数据前面会加上 IP 头部。</p>
<p>路由转发和IP 模块发送包的过程是相同的，会在包前面加上 MAC 头部，也是从路由表的网关列中查找出下一个路由器的 IP 地址，如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址；如果网关为空 ，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址。然后通过 ARP 根据 IP 地址查询出 MAC 地址，然后将 MAC 地址写入 MAC 头部。</p>
<p>内网与互联网连接需要地址转换。地址转换的基本原理是在转发网络包时对 IP 头部中的 IP 地址和端口号进行改写。因为公网IP只有一个，所以要根据不同的端口号区分内网不同的私有地址，路由器会保存私有地址与端口号对应的记录。如果私有地址和端口号没有保存在对应表中，外网是无法访问私有地址的，除非手动添加记录。</p>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC 地址共有 48 bit，用来唯一标识设备，在网卡生产时写入 ROM 里的，网卡驱动程序读取并分配给 MAC模块。通过 ARP 可以查询目标路由器的 MAC 地址。</p>
<table>
<thead>
<tr>
<th align="center">bit</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>0 单播地址<br/>1 多播地址</td>
</tr>
<tr>
<td align="center">2</td>
<td>0 全局地址<br/>1 本地地址</td>
</tr>
<tr>
<td align="center">3-24</td>
<td>厂商识别码</td>
</tr>
<tr>
<td align="center">25-48</td>
<td>网卡唯一标识</td>
</tr>
</tbody></table>
<p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，其作用就是将包送达路由器。</p>
<p><img src="/images/net/tcpip/mac_head.png" alt="img"></p>
<h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>网卡驱动从 IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC 模块发送发送包的命令。MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。再将数字信息按每个比特转换成电信号，然后由 PHY信号收发模块发送出去。</p>
<p><img src="/images/net/tcpip/pack.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改MAC地址</span></span><br><span class="line">ifconfig eth0 hw ether 12:34:56:78:90:12</span><br></pre></td></tr></table></figure>

<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机将网络包原样转发到目的地，交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。交换机的 MAC 地址表主要包含两个信息:设备的 MAC 地址，和该设备连接在交换机的端口。</p>
<p>如果MAC地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。这种情况下，交换机会将包转发到除了源端口之外的所有端口。</p>
<p>交换机是基于以太网设计的，俗称二层网络设备，交换机工作在全双工模式。</p>
<p><img src="/images/net/switch.png" alt="img"></p>
<p>交换机会自行更新或删除地址表中的记录，当收到包时会将发送方 MAC 地址以及其输入端口的号码写入MAC 地址表中，当端口上的设备长时间不工作，就会删除记录。</p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃。相对地，交换机的端口不具有 MAC 地址的端口，故不会核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。</p>
<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><p>集线器是根据以太网协议工作的设备，集线器里有一张以太网协议的表，根据以太网头部中记录的目的地信息查出相应的传输方向，在子网中将网络包传输到下一个转发设备。</p>
<p>集线器将信号广播给所有连接到它网络。集线器的接口中有一个 MDI/MDI-X 切换开关，MDI 就是对 RJ-45 接口和信号收发模块进行直连接线，而 MDI-X 则是交叉接线。</p>
<p>集线器工作在半双工模式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/net/osi_tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/net/osi_tcp/" class="post-title-link" itemprop="url">OSI and TCP/IP</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:36:39" itemprop="dateModified" datetime="2022-06-08T17:36:39+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h2><ul>
<li>应用层：负责给应用程序提供统一的接口;</li>
<li>表示层：负责把数据转换成兼容另一个系统能识别的格式;</li>
<li>会话层：负责建立、管理和终止表示层实体之间的通信会话;</li>
<li>传输层：负责端到端的数据传输;</li>
<li>网络层：负责数据的路由、转发、分片;</li>
<li>数据链路层：负责数据的封帧和差错检测，以及 MAC 寻址;</li>
<li>物理层：负责把数据包转换成电信号，在物理介质中传输数据帧;</li>
</ul>
<table>
<thead>
<tr>
<th>分层</th>
<th>作用</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
<td>通过媒介传输比特，确定机械及电气规范（比特 Bit）</td>
<td>RJ45、CLOCK、IEEE802.3（中继器，集线器）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>将比特组装成帧和点到点的传递（帧 Frame）</td>
<td>PPP、FR、HDLC、VLAN、MAC（网桥，交换机）</td>
</tr>
<tr>
<td>网络层</td>
<td>负责数据包从源到宿的传递和网际互连（包 Packet）</td>
<td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td>
</tr>
<tr>
<td>运输层</td>
<td>提供端到端的可靠报文传递和错误恢复（ 段Segment）</td>
<td>TCP、UDP、SPX</td>
</tr>
<tr>
<td>会话层</td>
<td>建立、管理和终止会话（会话协议数据单元 SPDU）</td>
<td>NFS、SQL、NETBIOS、RPC</td>
</tr>
<tr>
<td>表示层</td>
<td>对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）</td>
<td>JPEG、MPEG、ASII</td>
</tr>
<tr>
<td>应用层</td>
<td>允许访问OSI环境的手段（应用协议数据单元 APDU）</td>
<td>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</td>
</tr>
</tbody></table>
<p>OSI 模型只是概念理论上的分层，并没有提供具体的实现方案，实际应用中采用的是更为简化的 TCP/IP 模型。</p>
<p><img src="/images/net/tcpip/tcp-ip-arch.webp" alt="img"></p>
<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><ul>
<li><p>应用层：负责应用程序的网络访问，通过端口号来识别各个不同的进程，向用户提供一组应用程序，比如 HTTP、DNS、FTP 等。</p>
</li>
<li><p>传输层：负责端到端的通信,比如 TCP、UDP 等。</p>
</li>
<li><p>网络层：负责网络包的封装、分片、路由、转发，比如 IP、ICMP等。</p>
</li>
<li><p>网络接口层：负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等。</p>
</li>
</ul>
<p><img src="/images/net/tcpip/tcp_ip_pack.bmp" alt="tcp_ip_pack"></p>
<h2 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h2><p>ADSL(Asymmetric Digital Subscriber Line)不对称数字用户线，是一种利用架设在电线杆上的金属电话线来进行高速通信的技术，它的上行方向(用户到互联网)和下行方向(互联网到用户)的通信速率是不对称的。</p>
<p>用户端路由器发出的网络包通过ADSL Modem调制解调器和电话线到达电话局，然后到达 ADSL 的网络运营商(即 ISP，互联网服务提供商)。</p>
<p>互联网接入路由器会在网络包前面加上 MAC 头部、PPPoE 头部、PPP 头部，然后发送给 ADSL Modem。ADSL Modem 将包拆分成信元，并调制成电信号发送给分离器。分离器负责将电话和 ADSL 的信号进行分离。</p>
<p><img src="/images/net/modem.png" alt="eth_if"></p>
<p>ADSL采用的调制方式是振幅调制(ASK)和相位调制(PSK)相结合的正交振幅调制(QAM)方式。ADSL 使用间隔为 4.3125 kHz 的上百个不同频率的波进行合成，每个波都采用正交振幅调制。</p>
<p><img src="/images/net/modem2.png" alt="eth_if"></p>
<h2 id="ppp"><a href="#ppp" class="headerlink" title="ppp"></a>ppp</h2><p>PPP (Point-to-Point Protocol)点到点协议。用户向运营商的接入点拨打电话，,电话接通后，输入用户名和密码进行登录操作。用户名和密码通过 RADIUS 协议从 RAS 发送到认证服务器，认证服务器校验这些信息是否正确。当确认无误后,认证服务器会返回 IP 地址等配置信息，为计算机分配一个公有地址。</p>
<p>PPPoE 是将 PPP 消息装入以太网包进行传输的方式。PPP 协议中没有定义以太网中的报头和 FCS 等元素，也没有定义信号的格式，因此无法直接将 PPP 消息转换成信号来发送。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/mii/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/mii/" class="post-title-link" itemprop="url">Media Independent Interface</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:36:39" itemprop="dateModified" datetime="2022-06-08T17:36:39+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MII"><a href="#MII" class="headerlink" title="MII"></a>MII</h2><p>MII（Media Independent Interface）即媒体独立接口，MII接口是MAC与PHY连接的标准接口。它是IEEE-802.3定义的以太网行业标准。MII接口提供了MAC与PHY之间、PHY与STA(Station Management)之间的互联技术，该接口支持10Mb/s与100Mb/s的数据传输速率，单向传输的数据线有4根，整个接口由14根线组成。媒体独立的意思，是指不管铜轴、光纤、电缆等媒体的变化，媒体处理的相关工作都由PHY和MAC的芯片完成。</p>
<p>MII接口主要包括四个部分。一是从MAC层到PHY层的发送数据接口，二是从PHY层到MAC层的接收数据接口，三是从PHY层到MAC层的状态指示信号，四是MAC层和PHY层之间传送控制和状态信息的MDIO接口。</p>
<p><img src="/images/net/mii/MII.jpg" alt="MII"></p>
<ul>
<li><p>TXD[3:0]：数据发送信号，共4根信号线；</p>
</li>
<li><p>TX_CLK：发送数据使用的时钟信号，对于10M位/s的数据传输，此时钟为2.5MHz，对于100M位/s的数据传输，此时钟为25MHz。</p>
</li>
<li><p>TX_ER（transmit coding error）： TX_ER同步于TX_CLK，在数据传输过程中，如果TX_ER有效超过一个时钟周期，并且此时TX_EN是有效的，则数据通道中传输的数据是无效的，没用的。注：当TX_ER有效并不影响工作在10Mb/s的PHY或者TX_EN无效时的数据传输。在MII接口的连线中，如果TX_ER信号线没有用到，必须将它下拉接地。</p>
</li>
<li><p>TX_EN：传输使能信号，此信号必需与数据前导符的起始位同步出现，并在传输完毕前一直保持。</p>
</li>
<li><p>TXD[3:0]：发送数据线，每次传输4位数据，数据在TX_EN信号有效时有效。当TX_EN信号无效时，PHY忽略传输的数据。</p>
</li>
<li><p>RX_CLK：接收数据使用的时钟信号，对于10M位/s的数据传输，此时钟为2.5MHz，对于100M位/s的数据传输，此时钟为25MHz。</p>
</li>
<li><p>RXD[3:0]：接收数据线，每次接收4位数据，数据在RX_DV信号有效时有效。当RX_EN无效，而RX_ER有效时，RXD[3:0]数据值代表特定的信息。</p>
</li>
<li><p>RX_DV：接收数据使能信号，由PHY控制，当PHY准备好数据供MAC接收时，使能该信号。此信号必需和帧数据的首位同步出现，并保持有效直到数据传输完成。在传送最后4位数据后的第一个时钟之前，此信号必需变为无效状态。为了正确的接收一个帧，有效电平不能滞后于数据线上的SFD位出现。</p>
</li>
<li><p>RX_ER：接收出错信号，保持一个或多个时钟周期(RX_CLK)的有效状态，表明MAC在接收过程中检测到错误。具体错误原因需配合RX_DV的状态及RXD[3:0]的数据值。</p>
</li>
<li><p>CRS：载波侦听信号，仅工作在半双工模式下，由PHY控制，当发送或接收的介质非空闲时，使能此信号。 PHY必需保证CRS信号在发生冲突的整个时间段内都保持有效，不需要此信号与发送/接收的时钟同步。</p>
</li>
<li><p>COL：冲突检测信号，仅工作在半双工模式下，由PHY控制，当检测到介质发生冲突时，使能此信号，并且在整个冲突的持续时间内，保持此信号有效。此信号不需要和发送/接收的时钟同步。</p>
</li>
<li><p>MDC：配置接口时钟。</p>
</li>
<li><p>MDIO：配置接口I/O，是PHY和STA之间的双向信号。 它用于在PHY和STA之间传输控制信息和状态。 控制信息由STA同步地针对MDC驱动并且由PHY同步地采样。 状态信息由PHY针对MDC同步驱动并由STA同步采样。需要1.5K电阻上拉。</p>
</li>
</ul>
<p>MII接口的类型有很多，常用的有MII、RMII、SMII、SSMII、SSSMII、GMII、RGMII、SGMII、TBI、RTBI、XGMII、XAUI、XLAUI等。</p>
<table>
<thead>
<tr>
<th></th>
<th>MII</th>
<th>RMII</th>
<th>GMII</th>
<th>RGMII</th>
<th>SMII</th>
</tr>
</thead>
<tbody><tr>
<td>传输速度</td>
<td>100/10M</td>
<td>100/10M</td>
<td>1000/100/10M</td>
<td>1000/100/10M</td>
<td>100M</td>
</tr>
<tr>
<td>单向数据线数</td>
<td>4</td>
<td>2</td>
<td>8</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>时钟速率</td>
<td>25/2.5M</td>
<td>50/5M</td>
<td>25/2.5M</td>
<td>125/25/2.5M</td>
<td>125M</td>
</tr>
</tbody></table>
<h2 id="RMII"><a href="#RMII" class="headerlink" title="RMII"></a>RMII</h2><p>RMII即Reduced MII，是简化的MII接口。连线数量由MII的16根减少为8根，对于10Mbps线速，MII的时钟速率是2.5MHz就可以了，RMII则需要5MHz；对于100Mbps线速，MII需要的时钟速率是25MHz，RMII则是50MHz。</p>
<p><img src="/images/net/mii/RMII.jpg" alt="RMII"></p>
<ul>
<li><p>TXD[1:0]：数据发送信号线，数据位宽为2</p>
</li>
<li><p>RXD[1:0]：数据接收信号线，数据位宽为2</p>
</li>
<li><p>TX_EN(Transmit Enable)：数据发送使能信号</p>
</li>
<li><p>RX_ER(Receive Error)：数据接收错误提示信号</p>
</li>
<li><p>CLK_REF：是由外部时钟源提供的50MHz参考时钟，与MII接口不同，MII接口中的接收时钟和发送时钟是分开的，而且都是由PHY芯片提供给MAC芯片的。这里需要注意的是，由于数据接收时钟是由外部晶振提供而不是由载波信号提取的，所以在PHY层芯片内的数据接收部分需要设计一个FIFO，用来协调两个不同的时钟,在发送接收的数据时提供缓冲。PHY层芯片的发送部分则不需要FIFO，它直接将接收到的数据发送到MAC就可以了。</p>
</li>
<li><p>CRS_DV：此信号是由MII接口中的RX_DV和CRS两个信号合并而成。当介质不空闲时，CRS_DV和RE_CLK相异步的方式给出。当CRS比RX_DV早结束时(即载波消失而队列中还有数据要传输时)，就会出现CRS_DV在半位元组的边界以25MHz/2.5MHz的频率在0、1之间的来回切换。因此，MAC能够从 CRS_DV中精确的恢复出RX_DV和CRS。</p>
</li>
</ul>
<p>在100Mbps速率时，TX/RX每个时钟周期采样一个数据；在10Mbps速率时，TX/RX每隔10个周期采样一个数据，因而TX/RX数据需要在数据线上保留10个周期，相当于一个数据发送10次。</p>
<p>当PHY层芯片收到有效的载波信号后，CRS_DV信号变为有效，此时如果FIFO中还没有数据，则它会发送出全0的数据给MAC，然后当FIFO中填入有效的数据帧，数据帧的开头是“101010—”交叉的前导码，当数据中出现“01”的比特时，代表正式数据传输开始，MAC芯片检测到这一变化，从而开始接收数据。</p>
<p>当外部载波信号消失后，CRS_DV会变为无效，但如果FIFO中还有数据要发送时，CRS_DV在下一周期又会变为有效，然后再无效再有效，直到FIFO中数据发送完为止。在接收过程中如果出现无效的载波信号或者无效的数据编码，则RX_ER会变为有效，表示物理层芯片接收出错。</p>
<h2 id="SMII"><a href="#SMII" class="headerlink" title="SMII"></a>SMII</h2><p>SMII即Serial MII，串行MII的意思，跟RMII相比，连线进一步减少到4根。只用一根信号线传送发送数据，一根信号线传输接受数据，所以在时钟上为了满足100的需求，它的时钟频率高达到125M，数据线里面还会传送一些控制信息。所有端口的数据收发都公用同一个外部的125M时钟。</p>
<p><img src="/images/net/mii/SMII.jpg" alt="SMII"></p>
<ul>
<li>TXD：发送数据信号，位宽为1；</li>
<li>RXD：接收数据信号，位宽为1；</li>
<li>SYNC：收发数据同步信号，每10个时钟周期置1次高电平，指示同步。</li>
<li>CLK_REF：所有端口共用的一个参考时钟，频率为125MHz，为什么100Mbps速率要用125MHz时钟？因为在每8位数据中会插入2位控制信号，请看下面介绍。</li>
</ul>
<p>TXD/RXD以10比特为一组，以SYNC为高电平来指示一组数据的开始，在SYNC变高后的10个时钟周期内，TXD上依次输出的数据是：TXD[7:0]、TX_EN、TX_ER，控制信号的含义与MII接口中的相同；RXD上依次输出的数据是：RXD[7:0]、RX_DV、CRS，RXD[7:0]的含义与RX_DV有关，当RX_DV为有效时(高电平)，RXD[7:0]上传输的是物理层接收的数据。当RX_DV为无效时(低电平)，RXD[7:0]上传输的是物理层的状态信息数据。见下表：</p>
<p><img src="/images/net/mii/SMII2.jpg" alt="img"></p>
<p>当速率为10Mbps时，每一组数据要重复10次，MAC/PHY芯片每10个周期采样一次。MAC/PHY芯片在接收到数据后会进行串/并转换。</p>
<h2 id="SSMII"><a href="#SSMII" class="headerlink" title="SSMII"></a>SSMII</h2><p>SSMII即Serial Sync MII，叫串行同步接口，跟SMII接口很类似，只是收发使用独立的参考时钟和同步时钟，不再像SMII那样收发共用参考时钟和同步时钟，传输距离比SMII更远。</p>
<p><img src="/images/net/mii/SSMII.jpg" alt="img"></p>
<h2 id="SSSMII"><a href="#SSSMII" class="headerlink" title="SSSMII"></a>SSSMII</h2><p>SSSMII即Source Sync Serial MII，叫源同步串行MII接口，SSSMII与SSMII的区别在于参考时钟和同步时钟的方向，SSMII的TX/RX参考时钟和同步时钟都是由PHY芯片提供的，而SSSMII的TX参考时钟和同步时钟是由MAC芯片提供的，RX参考时钟和同步时钟是由PHY芯片提供的，所以顾名思义叫源同步串行。</p>
<p><img src="/images/net/mii/SSSMII.jpg" alt="img"></p>
<h2 id="GMII"><a href="#GMII" class="headerlink" title="GMII"></a>GMII</h2><p>GMII(Gigabit MII)是千兆网的MII接口。GMII采用8位接口数据，工作时钟125MHz，因此传输速率可达1000Mbps。同时兼容MII所规定的10/100 Mbps工作方式。GMII接口数据结构符合IEEE 802.3-2000以太网标准。</p>
<p>与MII接口相比，GMII的数据宽度由4位变为8位，GMII接口中的控制信号如TX_ER、TX_EN、RX_ER、RX_DV、CRS和COL的作用同MII接口中的一样，发送参考时钟GTX_CLK和接收参考时钟RX_CLK的频率均为125MHz(1000Mbps/8=125MHz)。</p>
<p>发送参考时钟GTX_CLK，它和MII接口中的TX_CLK是不同的，MII接口中的TX_CLK是由PHY芯片提供给MAC芯片的，而GMII接口中的GTX_CLK是由MAC芯片提供给PHY芯片的。两者方向不一样。绝大多数GMII接口都是兼容MII接口的，所以GMII接口都有两个发送参考时钟：TX_CLK和GTX_CLK(两者方向不一样)，在用作MII模式时，使用TX_CLK和8根数据线中的4根。</p>
<p><img src="/images/net/mii/GMII.jpg" alt="GMII"></p>
<p>在千兆速率下，向PHY提供GTXCLK信号、TXD、TXEN、TXER信号与此时钟信号同步。否则在10/100Mbps速率下，PHY提供TXCLK时钟信号，其它信号与此信号同步。其工作频率为25MHz(100M网络)或2.5MHz(10M网络)。</p>
<h2 id="RGMII"><a href="#RGMII" class="headerlink" title="RGMII"></a>RGMII</h2><p>RGMII即Reduced GMII，是GMII的简化版本，将接口信号线数量从24根减少到14根，时钟频率仍旧为125MHz，TX/RX数据宽度从8为变为4位，为了保持1000Mbps的传输速率不变，RGMII接口在时钟的上升沿和下降沿都采样数据。在参考时钟的上升沿发送GMII接口中的TXD[3:0]/RXD[3:0]，在参考时钟的下降沿发送GMII接口中的TXD[7:4]/RXD[7:4]。RGMI同时也兼容100Mbps和10Mbps两种速率，此时参考时钟速率分别为25MHz和2.5MHz。</p>
<p>TX_EN信号线上传送TX_EN和TX_ER两种信息，在TX_CLK的上升沿发送TX_EN，下降沿发送TX_ER；同样的，RX_DV信号线上也传送RX_DV和RX_ER两种信息，在RX_CLK的上升沿发送RX_DV，下降沿发送RX_ER。</p>
<p><img src="/images/net/mii/RGMII.jpg" alt="RGMII"></p>
<p><img src="/images/net/mii/RGMII2.jpg" alt="img"></p>
<h2 id="SGMII"><a href="#SGMII" class="headerlink" title="SGMII"></a>SGMII</h2><p>SGMII即Serial GMII，串行GMII，收发各一对差分信号线，时钟频率625MHz，在时钟信号的上升沿和下降沿均采样，参考时钟RX_CLK由PHY提供，是可选的，主要用于MAC侧没有时钟的情况，一般情况下，RX_CLK不使用。收发都可以从数据中恢复出时钟。</p>
<p>在TXD发送的串行数据中，每8比特数据会插入TX_EN/TX_ER 两比特控制信息，同样，在RXD接收数据中，每8比特数据会插入RX_DV/RX_ER 两比特控制信息，所以总的数据速率为1.25Gbps=625Mbps*2。</p>
<p>其实，大多数MAC芯片的SGMII接口都可以配置成SerDes接口(在物理上完全兼容，只需配置寄存器即可)，直接外接光模块，而不需要PHY层芯片，此时时钟速率仍旧是625MHz，不过此时跟SGMII接口不同，SGMII接口速率被提高到1.25Gbps是因为插入了控制信息，而SerDes端口速率被提高是因为进行了8B/10B变换，本来8B/10B变换是PHY芯片的工作，在SerDes接口中，因为外面不接PHY芯片，此时8B/10B变换在MAC芯片中完成了。8B/10B变换的主要作用是扰码，让信号中不出现过长的连“0”和连“1”情况，影响时钟信息的提取，关于8B/10B变换知识，我后续会单独介绍。</p>
<p><img src="/images/net/mii/SGMII.jpg" alt="SGMII"></p>
<h2 id="TBI"><a href="#TBI" class="headerlink" title="TBI"></a>TBI</h2><p>TBI即Ten Bit Interface，接口数据位宽由GMII接口的8位增加到10位，其实，TBI接口跟GMII接口的差别不是很大，多出来的2位数据主要是因为在TBI接口下，MAC芯片在将数据发给PHY芯片之前进行了8B/10B变换(8B/10B变换本是在PHY芯片中完成的，前面已经说过了)，另外，RX_CLK+/-是从接收数据中恢复出来的半频时钟，频率为62.5MHz，RX_CLK+/-不是差分信号，而是两个独立的信号，两者之间有180度的相位差，在这两个时钟的上升沿都采样数据。RX_CLK+/-也叫伪差分信号。除掉上面说到的之外，剩下的信号都跟GMII接口中的相同。大多数芯片的TBI接口和GMII接口兼容。在用作TBI接口时，CRS和COL一般不用。</p>
<p><img src="/images/net/mii/TBI.jpg" alt="img"></p>
<h2 id="RTBI"><a href="#RTBI" class="headerlink" title="RTBI"></a>RTBI</h2><p>RTBI即Reduced TBI，简化版TBI，接口数据位宽为5bit，时钟频率为125MHz，在时钟的上升沿和下降沿都采样数据，同RGMII接口一样，TX_EN线上会传送TX_EN和TX_ER两种信息，在时钟的上升沿传TX_EN，下降沿传TX_ER；RX_DV线上传送RX_DV和RX_ER两种信息，在RX_CLK上升沿传RX_DV，下降沿传RX_ER。</p>
<p><img src="/images/net/mii/RTBI.jpg" alt="img"></p>
<h2 id="XGMII"><a href="#XGMII" class="headerlink" title="XGMII"></a>XGMII</h2><p>XGMII–10 Gigabit Media Independent Interface 即10Gb独立于媒体的接口，X对应罗马数字10。</p>
<p><img src="/images/net/mii/XGMII.jpg" alt="XGMII"></p>
<p>XGMII接口共74根连线，单端信号，采用HSTL/SSTL_2逻辑，端口电压1.5V/2.5V，由于SSTL_2的端口电压高，功耗大，现在已很少使用。</p>
<ul>
<li><p>TXD[31:0]：数据发送通道，32位并行数据。</p>
</li>
<li><p>RXD[31:0]：数据接收通道，32位并行数据。</p>
</li>
<li><p>TXC[3:0]：发送通道控制信号，TXC=0时，表示TXD上传输的是数据；TXC=1时，表示TXD上传输的是控制字符。TXC[3:0]分别对应TXD[31:24], TXD[23:16], TXD[15:8], TXD[7:0]。</p>
</li>
<li><p>RXC[3:0]：接收通道控制信号，RXC=0时，表示RXD上传输的是数据；RXC=1时，表示RXD上传输的是控制字符。RXC[3:0]分别对应RXD[31:24], RXD[23:16], RXD[15:8], RXD[7:0]。</p>
</li>
<li><p>TX_CLK：TXD和TXC的参考时钟，时钟频率156.25MHz，在时钟信号的上升沿和下降沿都采样数据。156.25MHz - 2 - 32 = 10Gbps 。</p>
</li>
<li><p>RX_CLK：RXD和RXC的参考时钟，时钟频率156.25MHz，在时钟信号的上升沿和下降沿都采样数据。</p>
</li>
</ul>
<p>HSTL即High Speed Transceiver Logic，高速发送逻辑的意思。</p>
<p>SSTL，即Stub Series Terminated Logic，短路终止逻辑，主要用于高速内存接口，SSTL目前存在两种标准，SSTL_3是3.3V标准；SSTL_2是2.5V标准。</p>
<h2 id="XAUI"><a href="#XAUI" class="headerlink" title="XAUI"></a>XAUI</h2><p>由于受电气特性的影响，XGMII接口的PCB走线最大传输距离仅有7cm，并且XGMII接口的连线数量太多，给实际应用带来不便，因此，在实际应用中，XGMII接口通常被XAUI接口代替，XAUI即10 Gigabit attachment unit interface，将XGMII集成到芯片内部，XAUI在XGMII的基础上实现了XGMII接口的物理距离扩展，将PCB走线的传输距离增加到50cm，使背板走线成为可能。</p>
<p>源端XGMII把收发32位宽度数据流分为4个独立的lane通道，每个lane通道对应一个字节，经XGXS(XGMII Extender Sublayer)完成8B/10B编码后，将4个lane分别对应XAUI的4个独立通道，XAUI端口速率为：<code>2.5Gbps - 1.25 - 4＝12.5Gbps</code>。</p>
<p><img src="/images/net/mii/XAUI.jpg" alt="img"></p>
<p>在发送端的XGXS模块中，将TXD[31:0]/ RXD[31:0],TXC[3:0]/ RXC[3:0], TX_CLK/ RX_CLK转换成串行数据从TX Lane[3:0]/ RX Lane[3:0]中发出去，在接收端的XGXS模块中，串行数据被转换成并行，并且进行时钟恢复和补偿，完成时钟去抖，经过5B/4B解码后，重新聚合成XGMII。</p>
<p>万兆以太网接口的端口速率为10Gbps，主要有XGMII和XAUI两种，另外还有HIGIG。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/rj45/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/rj45/" class="post-title-link" itemprop="url">RJ45 interface</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:36:39" itemprop="dateModified" datetime="2022-06-08T17:36:39+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以太网信号最终是通过RJ45接头接入网络的。RJ是Registered Jack的缩写，意思是注册的插座。在FCC（美国联邦通信委员会标准和规章）中RJ是描述公用电信网络的接口，计算机网络的RJ45是标准8位模块化接口的俗称。连接器由插头（8P8C接头，水晶头）和插座组成。</p>
<p>RJ45型网线插头又称水晶头，有两种连接方式，分别称作 T568A 线序和 T568B 线序。两者的主要区别是橙色和绿色双绞线进行了交换。</p>
<p>这两种标准只是在线缆颜色上有所区别，目的是在线缆侧实现交叉互连。直连线常用于异种网络之间的互连（比如计算机交换机之间），交叉线常用于同种网络之间的互联（比如计算机与之间）。</p>
<p><img src="/images/net/RJ45/RJ-45_T568AB.jpg" alt="RJ-45接线图"></p>
<p><img src="/images/net/RJ45/T568AB.bmp" alt="RJ-45接线图2"></p>
<p>交叉互连，所谓交叉是指网线的一端和另一端与 RJ45 网线插头的接法不同，一端按 T568A 线序接，另一端按 T568B 线序接，即有几根网线在另一端是先做了交叉才接到 RJ45 插头上去的，适用的场合：</p>
<ul>
<li>电脑——电脑，称对等网连接</li>
<li>集线器——集线器</li>
<li>交换机——交换机</li>
</ul>
<p>直连线互连的网线的两端均按T568B接线，适用场合：</p>
<ul>
<li>电脑——ADSL 猫</li>
<li>ADSL猫——ADSL 路由器的 WAN 口</li>
<li>电脑——ADSL 路由器的 LAN 口</li>
<li>电脑——集线器或交换机</li>
</ul>
<p>现在PHY芯片大部分具有自动交叉（auto MDI-X）的能力，它可以实现RJ-45接口的传送信号线和接收信号线的功能自动互相交换，有的PHY甚至支持一对线中的正信号和负信号的功能自动交换，这样就不必考虑选用直连网线还是交叉网线，只需要直连即可。</p>
<p><img src="/images/net/RJ45/T-568A.jpg" alt="T-568A"></p>
<p><img src="/images/net/RJ45/T-568B.jpg" alt="T-568B"></p>
<p><img src="/images/net/RJ45/RJ45-pinout.jpg" alt="RJ45-pinout"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/net/eth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/net/eth/" class="post-title-link" itemprop="url">ethernet and MAC</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:36:39" itemprop="dateModified" datetime="2022-06-08T17:36:39+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>以太网接口由MAC控制器物理层接口PHY组成。PHY整合了大量模拟硬件，而MAC是典型的全数字器件。考虑到芯片面积及模拟/数字混合架构的原因，通常，将MAC集成进微控制器而将PHY留在片外。</p>
<p><img src="/images/net/eth/eth-arch.png" alt="基本构成"></p>
<p><img src="/images/net/eth/eth-arch2.jpg" alt="cpu内部框架"></p>
<p>网卡工作在osi的最后两层，物理层和数据链路层，物理层定义了数据传送与接收所需要的电与光信号、线路状态、时钟基准、数据编码和电路等，并向数据链路层设备提供标准接口。物理层的芯片称之为PHY。数据链路层则提供寻址机构、数据帧的构建、数据差错检查、传送控制、向网络层提供标准的数据接口等功能。以太网卡中数据链路层的芯片称之为MAC控制器。很多网卡的这两个部分是做到一起的。他们之间的关系是pci总线接mac总线，mac接phy，phy接网线。</p>
<p>隔离变压器的作用是防干扰，防雷击。长距离连接的两个以太网设备，很可能不共地，地线之间有电压差，如果不隔离，电流会经网线走，网卡接口就很容易坏了。</p>
<p>RJ-45接头实现了网卡和网线的连接，10M网卡的RJ-45插口也只用了1,2,3,6四根，而100M或1000M网卡使用八根。其中100M的网络中1,2是传送数据的，3,6是接收数据的，1,2之间是一对差分信号，也就是说它们的波形一样，但是相位相差180度。</p>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC（Media Access Control），即媒体访问控制子层协议。该协议位于OSI七层协议中数据链路层的下半部分，实现了数据链路层。支持 10Mbit/s 或 100Mbit/s 两种速率。主要负责控制与连接物理层的物理介质。在发送数据的时候，MAC协议可以事先判断是否可以发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层;在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误,如果没有错误,则去掉控制信息发送至LLC层。该层协议是以太网MAC由IEEE-802.3以太网标准定义。</p>
<p><img src="/images/net/eth/mac.png" alt="OSI-MAC"></p>
<p>最新的MAC同时支持 10Mbps和100Mbps两种速率。以太网数据链路层其实包含MAC(介质访问控制)子层和LLC(逻辑链路控制)。</p>
<p>目标的MAC地址由ARP协议确定。第一次传送某个目的IP地址的数据的时候，先会发出一个ARP包，其MAC的目标地址是广播地址，因为是广播包，所有这个局域网的主机都收到了这个ARP请求。收到请求的主机将这个IP地址和自己的相比较，如果不相同就不予理会，如果相同就发出ARP响应包。这个IP地址的主机收到这个ARP请求包后回复的ARP响应。这个包里面就包括了他的MAC地址。以后的给这个IP地址的帧的目标MAC地址就被确定了。</p>
<p>IP地址和MAC地址之间的关联关系保存在主机系统里面，叫做ARP表。</p>
<p><img src="/images/net/eth/MAC.jpg" alt="MAC"></p>
<p>以太网MAC芯片的一端接计算机PCI总线，另外一端就接到PHY芯片上。CPU上有两组寄存器用与MAC。一组用户数据的收发，对应上面的DMA；一组用户MIIM，用户对PHY进行配置，两组寄存器由于都在CPU上，配置方式与其他CPU上寄存器一样，直接读写即可。数据的转发通过DMA完成。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/rootfs/rootfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/rootfs/rootfs/" class="post-title-link" itemprop="url">rootfs of file system</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:36:56" itemprop="dateModified" datetime="2022-06-08T17:36:56+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rootfs/" itemprop="url" rel="index"><span itemprop="name">rootfs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="flash文件系统"><a href="#flash文件系统" class="headerlink" title="flash文件系统"></a>flash文件系统</h2><p>flash芯片可以被划分为多个分区，各分区可以采用不同的文件系统。flash文件系统是基于MTD驱动层的，MTD(Memory Technology Device,存储技术设备)为底层硬件(闪存)和上层(文件系统)之间提供一个统一的抽象接口，专门针对各种非易失性存储器设计，因而对Flash有更好的支持、管理和基于扇区的擦除、读/写操作接口。</p>
<h3 id="jffs"><a href="#jffs" class="headerlink" title="jffs"></a>jffs</h3><p>JFFS文件系统最早是由瑞典Axis Communications公司基于Linux2.0的内核为嵌入式系统开发的文件系统。JFFS2是RedHat公司基于JFFS开发的闪存文件系 统，最初是针对RedHat公司的嵌入式产品eCos开发的嵌入式文件系统，所以JFFS2也可以用在Linux, uCLinux中。</p>
<p>Jffs2: 日志闪存文件系统版本2 (Journalling Flash FileSystem v2)</p>
<p>主要用于NOR型闪存，基于MTD驱动层，特点是：<strong>可读写</strong>的、支持数据压缩的、基于哈希表的日志型文件系统，并提供了崩溃/掉电安全保护，提供“写平衡”支持等。缺点主要是当文件系统已满或接近满时，因为垃圾收集的关系而使jffs2的运行速度大大放慢。</p>
<p>目前jffs3正在开发中。关于jffs系列文件系统的使用详细文档，可参考MTD补丁包中mtd-jffs-HOWTO.txt。</p>
<p><em>jffsx不适合用于NAND闪存</em>主要是因为NAND闪存的容量一般较大，这样导致jffs为维护日志节点所占用的内存空间迅速增大，另 外，jffsx文件系统在挂载时需要扫描整个FLASH的内容，以找出所有的日志节点，建立文件结构，对于大容量的NAND闪存会耗费大量时间。</p>
<h4 id="mkfs-jffs2"><a href="#mkfs-jffs2" class="headerlink" title="mkfs.jffs2"></a>mkfs.jffs2</h4><p>直接安装<code>mkfs.jffs2</code>工具：sudo apt-get install mtd-utils，或编译源码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install liblzo2-2 libuuid1 zlib1g liblzo2-dev uuid-dev libacl1-dev  zlib1g-dev</span><br><span class="line">./configure --prefix=/home/luo_u/usr</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><em>使用说明</em>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">./mkfs.jffs2 -v -d rootfs/ -l -s 256 -e 4096 -m none -o root.jffs2</span><br><span class="line"></span><br><span class="line">-p, --pad[=SIZE]        使用0xff填充文件系统到指定大小，不指定则只填充完最后一个擦除块</span><br><span class="line">-r, -d, --root=DIR      使用指定的目录内容构建文件系统</span><br><span class="line">-s, --pagesize=SIZE     使用指定的页大小（最大数据节点大小） (default: 4KiB)</span><br><span class="line">-e, --eraseblock=SIZE   指定擦除块的大小 (default: 64KiB)</span><br><span class="line">-c, --cleanmarker=SIZE  擦除标记的大小 (default 12)</span><br><span class="line">-m, --compr-mode=MODE   选择压缩模式(default: priortiry)</span><br><span class="line">-x, --disable-compressor=COMPRESSOR_NAME  禁用指定的压缩算法</span><br><span class="line">-X, --enable-compressor=COMPRESSOR_NAME   启用指定的压缩算法</span><br><span class="line">-y, --compressor-priority=PRIORITY:COMPRESSOR_NAME  设置压缩算法的优先级</span><br><span class="line">-L, --list-compressors  列出可用的压缩算法</span><br><span class="line">-t, --test-compression  测试压缩算法</span><br><span class="line">-n, --no-cleanmarkers   不添加擦除标记到擦除块</span><br><span class="line">-o, --output=FILE       指定输出镜像文件名称</span><br><span class="line">-l, --little-endian     创建一个小端的文件系统</span><br><span class="line">-b, --big-endian        创建一个大端的文件系统</span><br><span class="line">-q, --squash            压缩权限和设置所有文件的拥有者为root</span><br><span class="line">-U, --squash-uids       设置所有文件的拥有者为root</span><br><span class="line">-P, --squash-perms      压缩所有文件的权限</span><br><span class="line">-v  可视操作</span><br></pre></td></tr></table></figure>

<p><em>挂载分区</em>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t jffs2 /dev/mtdblock1 /mnt</span><br></pre></td></tr></table></figure>

<h3 id="yaffs"><a href="#yaffs" class="headerlink" title="yaffs"></a>yaffs</h3><p>yaffs/yaffs2(Yet Another Flash File System)是专为嵌入式系统使用NAND型闪存而设计的一种日志型文件系统。与jffs2相比，它减少了一些功能(例如不支持数 据压缩)，所以速度更快，挂载时间很短，对内存的占用较小。另外，它还是跨平台的文件系统，除了Linux和eCos，还支持WinCE, pSOS和ThreadX等。</p>
<p>yaffs/yaffs2自带NAND芯片的驱动，并且为嵌入式系统提供了直接访问文件系统的API，用户可以不使用Linux中的MTD与VFS，直接对文件系统操作。当然，yaffs也可与MTD驱动程序配合使用。</p>
<p>yaffs与yaffs2的主要区别在于，前者仅支持小页(512 Bytes) NAND闪存，后者则可支持大页(2KB) NAND闪存。同时，yaffs2在内存空间占用、垃圾回收速度、读/写速度等方面均有大幅提升。</p>
<p><a target="_blank" rel="noopener" href="https://yaffs.net/documents/how-yaffs-works">https://yaffs.net/documents/how-yaffs-works</a></p>
<h3 id="cramfs"><a href="#cramfs" class="headerlink" title="cramfs"></a>cramfs</h3><p>Cramfs(Compressed ROM File System)是Linux的创始人 Linus Torvalds参与开发的一种只读的压缩文件系统。它也基于MTD驱动程序。</p>
<p>在cramfs文件系统中，每一页(4KB)被单独压缩，可以随机页访问，其压缩比高达2:1,为嵌入式系统节省大量的Flash存储空间，使系统可通过更低容量的FLASH存储相同的文件，从而降低系统成本。</p>
<p>Cramfs文件系统以压缩方式存储，在运行时解压缩，所以不支持应用程序以XIP方式运行，所有的应用程序要求被拷到RAM里去运行，但这并 不代表比Ramfs需求的RAM空间要大一点，因为Cramfs是采用分页压缩的方式存放档案，在读取档案时，不会一下子就耗用过多的内存空间，只针对目 前实际读取的部分分配内存，尚没有读取的部分不分配内存空间，当我们读取的档案不在内存时，Cramfs文件系统自动计算压缩后的资料所存的位置，再即时 解压缩到RAM中。</p>
<p>另外，它的速度快，效率高，其只读的特点有利于保护文件系统免受破坏，提高了系统的可靠性。由于以上特性，Cramfs在嵌入式系统中应用广泛。但是它的<strong>只读</strong>属性同时又是它的一大缺陷，使得用户无法对其内容对进扩充。Cramfs映像通常是放在Flash中，但是也能放在别的文件系统里，使用loopback 设备可以把它安装别的文件系统里。</p>
<p>单个文件大小不能超过16MB、文件系统大小略大于256MB（最后一个文件允许超过256MB空间范围，即文件系统总大小不超过272MB）。CramFS的gid只保存8位，mkcramfs会简单的将gid截断保留最后8位。CramFS支持硬链接，但是被硬链接的文件引用计数不会增加。CramFS文件没有时间戳，所有文件的创建/访问时间戳都是1970年1月1日 0:00:00 GMT。CramFS的镜像只支持被同样字节对齐方式的机器创建和挂载使用，页面大小只支持4KB。</p>
<h3 id="romfs"><a href="#romfs" class="headerlink" title="romfs"></a>romfs</h3><p>传统型的Romfs文件系统是一种简单的、紧凑的、只读的文件系统，不支持动态擦写保存，按顺序存放数据，因而支持应用程序以 XIP(eXecute In Place，片内运行)方式运行，在系统运行时，节省RAM空间。uClinux系统通常采用Romfs文件系统。<br>　　<br>其他文件系统：fat/fat32也可用于实际嵌入式系统的扩展存储器(例如PDA, Smartphone, 数码相机等的SD卡)，这主要是为了更好的与最流行的Windows桌面操作系统相兼容。ext2也可以作为嵌入式Linux的文件系统，不过将它用于 FLASH闪存会有诸多弊端。</p>
<h3 id="squashfs"><a href="#squashfs" class="headerlink" title="squashfs"></a>squashfs</h3><p>SquashFS [1]  是一套基于Linux内核使用的压缩<strong>只读</strong>文件系统。该文件系统能够压缩系统内的文档,inode以及目录，文件最大支持2^64字节。<br>-　Squashfs 4.2 : 最新的版本，并适用于2.6.29版本以后的Linux内核。<br>-　Squashfs 4.1 : 支持XZ压缩，并适用于2.6.29版本以后的Linux内核。<br>-　Squashfs 3.4 : 该版本是3.X的最后一个版本，并适用于2.6.29版本之前的内核。</p>
<p>安装<code>mksquashfs</code>工具：sudo apt-get install squashfs-tools</p>
<p><em>使用说明</em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mksquashfs rootfs/usr usr.sqsh4 -noappend -comp xz</span><br></pre></td></tr></table></figure>

<p><em>挂载分区</em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t squashfs /dev/mtdblock6 /usr</span><br></pre></td></tr></table></figure>

<h3 id="RAM文件系统"><a href="#RAM文件系统" class="headerlink" title="RAM文件系统"></a>RAM文件系统</h3><h4 id="ramdisk"><a href="#ramdisk" class="headerlink" title="ramdisk"></a>ramdisk</h4><p>Ramdisk是将一部分固定大小的内存当作分区来使用。它并非一个实际的文件系统，而是一种将实际的文件系统装入内存的机制，并且可以作为根文件系统。将一些经常被访问而又不会更改的文件(如只读的根文件系统)通过Ramdisk放在内存中，可以明显地提高系统的性能。</p>
<p>在Linux的启动阶段，initrd提供了一套机制，可以将内核映像和根文件系统一起载入内存。</p>
<h4 id="ramfs-tmpfs"><a href="#ramfs-tmpfs" class="headerlink" title="ramfs/tmpfs"></a>ramfs/tmpfs</h4><p>Ramfs是Linus Torvalds开发的一种基于内存的文件系统，工作于虚拟文件系统(VFS)层，不能格式化，可以创建多个，在创建时可以指定其最大能使用的内存大 小。(实际上，VFS本质上可看成一种内存文件系统，它统一了文件在内核中的表示方式，并对磁盘文件系统进行缓冲。)</p>
<p>Ramfs/tmpfs文件系统把所有的文件都放在RAM中，所以读/写操作发生在RAM中，可以用ramfs/tmpfs来存储一些临时性或经常要修改的数据，例如/tmp和/var目录，这样既避免了对Flash存储器的读写损耗，也提高了数据读写速度。</p>
<p>Ramfs/tmpfs相对于传统的Ramdisk的不同之处主要在于：不能格式化，文件系统大小可随所含文件内容大小变化。</p>
<p>Tmpfs的一个缺点是当系统重新引导时会丢失所有数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/rootfs/buildroot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/rootfs/buildroot/" class="post-title-link" itemprop="url">buildroot</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:36:56" itemprop="dateModified" datetime="2022-06-08T17:36:56+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rootfs/" itemprop="url" rel="index"><span itemprop="name">rootfs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>下载地址：　<a target="_blank" rel="noopener" href="https://buildroot.org/">https://buildroot.org/</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">├── arch: 存放CPU架构相关的配置脚本</span><br><span class="line">├── board</span><br><span class="line">├── boot</span><br><span class="line">├── CHANGES</span><br><span class="line">├── Config.in</span><br><span class="line">├── Config.in.legacy</span><br><span class="line">├── configs: 放置开发板的一些配置参数. </span><br><span class="line">├── COPYING</span><br><span class="line">├── DEVELOPERS</span><br><span class="line">├── dl: 存放下载的源代码及应用软件的压缩包. </span><br><span class="line">├── docs: 存放相关的参考文档. </span><br><span class="line">├── fs: 放各种文件系统的源代码. </span><br><span class="line">├── linux: 存放着Linux kernel的自动构建脚本. </span><br><span class="line">├── Makefile</span><br><span class="line">├── Makefile.legacy</span><br><span class="line">├── output: 是编译出来的输出文件夹. </span><br><span class="line">│   ├── build: 存放解压后的各种软件包编译完成后的现场.</span><br><span class="line">│   ├── host: 存放着制作好的编译工具链，如gcc、arm-linux-gcc等工具.</span><br><span class="line">│   ├── images: 存放着编译好的uboot.bin, zImage, rootfs等镜像文件，可烧写到板子里, 让linux系统跑起来.</span><br><span class="line">│   ├── staging</span><br><span class="line">│   └── target: 存放Linux系统基本的目录结构，以及编译好的应用库和bin可执行文件</span><br><span class="line">├── package：下面放着应用软件的配置文件，每个应用软件的配置文件有Config.in和soft_name.mk。</span><br><span class="line">├── README</span><br><span class="line">├── support</span><br><span class="line">├── system</span><br><span class="line">└── toolchain</span><br></pre></td></tr></table></figure>

<p> Buildroot提供了构建流程的框架。开发者按照格式写脚本，提供必要的构建细节，配置整个系统，最后自动构建出你的系统。</p>
<p> package/pkg-generic.mk中通过调用同目录下的pkg-download.mk、pkg-utils.mk文件，已经帮你自动实现了下载、解压、依赖包下载编译等一系列流程。你只要需要按照格式写Makefile脚app_pkg.mk，填充下载地址，链接依赖库的名字等一些特有的构建细节即可。</p>
<p><img src="/images/rootfs/build.png" alt="构建流程框架"></p>
<p>Buildroot代码仓库默认只包含一个编译框架，真正构建rootfs需要的各种代码包是根据配置选项，在编译的时候才开始下载的。</p>
<p>通过<code>make help</code>可以看到buildroot下make的使用细节，包括对package、uclibc、busybox、linux以及文档生成等配置。</p>
<p>执行命令<code>make list-defconfigs</code>查看buildroot中支持的开发板</p>
<p>设置 toolchain 的版本和内核头文件的内核的版本</p>
<p>System configuration-&gt;Run a getty(login prompt) after boot选项中配置 TTY Port 为 ttyAMA0。否则文件系统挂载后无法进入控制台。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><strong>Target options</strong>：目标板的配置</p>
<ul>
<li><p>Target Architecture：目标架构，这里选择 ARM(little endian)，ARM小端模式</p>
</li>
<li><p>Target Binary Format：二进制格式，为 ELF</p>
</li>
<li><p>Target Architecture Variant：架构变体为 arm920t，内核类型</p>
</li>
<li><p>Target ABI：应用程序二进制接口，为EABI</p>
</li>
<li><p>Floating point strategy：浮点数的策略，选择为 Soft float</p>
</li>
<li><p>ARM instruction set：arm 汇编指令集，选择  ARM</p>
</li>
<li><p><strong>Build　options</strong></p>
</li>
</ul>
<p>主要是一些编译时用到的选项，比如dl的路径，下载代码包使用的路径，同时运行多个编译的上限，是否使能编译器缓冲区等。</p>
<p><strong>Toolchain</strong>：工具链选项</p>
<ul>
<li>Toolchain type：Buildroot提供两种方式使用toolchain<ul>
<li>external toolthain：非Buildroot提供的交叉编译器</li>
<li>Buildroot toolchain：Buildroot本身编译生成的Buildroot toolchain</li>
</ul>
</li>
<li>custom toolchain vendor name：填上S3C2440</li>
<li>C library：C库选择，选择 glibc</li>
<li>Kernel Headers：内核头文件，Linux 4.9.x kernel headers</li>
<li>glibc version：glibc版本选择，2.24</li>
<li>Binutils Version：binutils版本：2.27</li>
<li>Additional binutils options：附加的 binutils 选择，不填即可</li>
<li>GCC compiler Version：GCC版本选择，gcc 6.x</li>
<li>Additional gcc options：附件的GCC选项</li>
<li>Enable C++ support：使能C++支持，选上</li>
<li>Enable Fortran support：使能Fortran语言支持，不选</li>
<li>Enable compiler link-time-optimization support：是否支持LTO，不选</li>
<li>Enable compiler OpenMP support：是否支持OpenMP，OpenMP用于共享内存并行系统的多处理器程序设计，<br>不适合需要复杂的线程间同步和互斥的场合，OpenMp的另一个缺点是不能在非共享内存系统如计算机集群上使用。不选择</li>
<li>Enable graphite support ：是否支持graphite。Graphite是应用WEB应用的一套开源的编程接口。不选择。</li>
<li>Build cross gdb for the host：主机上运行gdb进行调试，不选</li>
<li>Copy gconv libraries：拷贝 gconv库，gconv库用于在不同字符集之间进行转换。默认不选</li>
<li>Enable MMU support：使能 MMU，S3C2440支持MMU，选上</li>
<li>Target Optimizations：不选</li>
<li>Target linker options：不选</li>
<li>Register toolchain within Eclipse Buildroot plug-in：eclipse插件支持，不选</li>
</ul>
<p><strong>System configuration</strong>：系统配置</p>
<ul>
<li>Root FS skeleton：</li>
<li>System hostname：填写JZ2440</li>
<li>System banner</li>
<li>Passwords encoding</li>
<li>Init system：系统初始化，选择 BusyBox</li>
<li>/dev management：设备文件管理，选择Dynamic using devtmpfs + mdev，即使用mdev动态加载设备节点的方式</li>
<li>Path to the permission tables：设备节点的配置表设置，一定要选择system/device_table_dev.txt，否则后面在dev目录下将不会生成各种设备节点。当然我们也可以手动的配置该文件，添加必要的节点或删除不需要的节点。</li>
<li>support extended attributes in device tables</li>
<li>Use symlinks to /usr for /bin, /sbin and /lib</li>
<li>Enable root login with password</li>
<li>Root password：进入linux控制台终端后的密码，为空则登录时不需要密码，默认登录用户名为root。</li>
<li>/bin/sh (busybox’ default shell)</li>
<li>Run a getty (login prompt) after boot：保持默认，默认为选中。<ul>
<li>TTY port：控制台打印串口</li>
<li>Baudrate ：波特率，配置为 115200</li>
<li>TERM environment variable：默认即可</li>
<li>other options to pass to getty：默认即可</li>
</ul>
</li>
<li>remount root filesystem read-write during boot</li>
<li>Network interface to configure through DHCP</li>
<li>Purge unwanted locales</li>
<li>Locales to keep</li>
<li>Generate locale data</li>
<li>Install timezone info</li>
<li>Path to the users tables</li>
<li>Root filesystem overlay directories：</li>
<li>Custom scripts to run before creating filesystem images</li>
<li>Custom scripts to run inside the fakeroot environment</li>
<li>Custom scripts to run after creating filesystem images</li>
</ul>
<p><strong>Kernel</strong>：内核配置</p>
<ul>
<li><p>Kernel version：内核版本，选择用户自定义Custom version</p>
</li>
<li><p>Kernel version：填上自己所需要的版本，4.14.12</p>
</li>
<li><p>Custom kernel patches：自定义的内核补丁</p>
</li>
<li><p>Kernel configuration：内核配置，选择 Using an in-tree defconfig file</p>
</li>
<li><p>Defconfig name：填写为 mini2440</p>
</li>
<li><p>Additional configuration fragment files：暂且不填写</p>
</li>
<li><p>Kernel binary format：内核二进制文件格式，zImage</p>
</li>
<li><p>Kernel compression format：内核压缩格式，选择gzip</p>
</li>
<li><p>Build a Device Tree Blob：设备树？暂且不填写</p>
</li>
<li><p>Install kernel image to /boot in target：暂且不填</p>
</li>
<li><p>Linux Kernel Extensions：内核扩展，默认不选择</p>
</li>
<li><p>Linux Kernel Tools：内核工具，默认不选择</p>
</li>
<li><p><strong>Target packages</strong></p>
</li>
<li><p>Filesystem images：文件系统选择，选择 yaffs2 root filesystem</p>
</li>
<li><p><strong>Bootloaders</strong></p>
</li>
<li><p>Build system：u-boot系统选择为Kconfig</p>
<ul>
<li>legacy：若是选择2015.04之前的u-boot 选择此项</li>
<li>Kconfig：2015.04之后的 u-boot 选择此项，勾选此项　　</li>
</ul>
</li>
<li><p>U-boot Version：U-boot版本，默认为 2017.01，选择为Custom version</p>
</li>
<li><p>U-Boot version：填写为2017.11</p>
</li>
<li><p>Custom U-boot patches：U-boot补丁，不添加</p>
</li>
<li><p>U-Boot configuration：U-boot配置，暂时还没有U-BOOT，所以选择为：Using an in-tree board defconfig file</p>
</li>
<li><p>Board defconfig：板子的配置，选择与架构一样的板子的默认文件，mini2440。后期再修改</p>
</li>
<li><p>U-boot needs dtc：是否需要设备树，默认，后期调试</p>
</li>
<li><p>U-boot needs OpenSSL：是否需要 OpenSSL，默认，后期调试修改</p>
</li>
<li><p>U-boot binary format：二进制文件，选择 .bin文件</p>
</li>
<li><p>produce a .ift signed image：默认</p>
</li>
<li><p>Install U-boot SPL binary image：默认</p>
</li>
<li><p>Environment image：默认</p>
</li>
<li><p><strong>Host utilities</strong></p>
</li>
<li><p><strong>Legacy config options</strong></p>
</li>
</ul>
<h2 id="编译性能"><a href="#编译性能" class="headerlink" title="编译性能"></a>编译性能</h2><p>buildroot还提供了一些命令，用于分析buildroot编译过程中耗时、依赖关系、文件系统尺寸等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Documentation:</span><br><span class="line">  manual               　 * build manual in all formats</span><br><span class="line">  manual-html          　 * build manual in HTML</span><br><span class="line">  manual-split-html      * build manual in split HTML</span><br><span class="line">  manual-pdf             * build manual in PDF</span><br><span class="line">  manual-text            * build manual in text</span><br><span class="line">  manual-epub            * build manual in ePub</span><br><span class="line">  graph-build            * generate graphs of the build times</span><br><span class="line">  graph-depends          * generate graph of the dependency tree</span><br><span class="line">  graph-size             * generate stats of the filesystem size</span><br><span class="line">  list-defconfigs        * list all defconfigs (pre-configured minimal systems)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/rootfs/busybox/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/rootfs/busybox/" class="post-title-link" itemprop="url">BusyBox</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:36:56" itemprop="dateModified" datetime="2022-06-08T17:36:56+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rootfs/" itemprop="url" rel="index"><span itemprop="name">rootfs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://busybox.net/downloads/">下载地址</a></p>
<p><a target="_blank" rel="noopener" href="https://salsa.debian.org/installer-team/busybox">https://salsa.debian.org/installer-team/busybox</a></p>
<p>修改顶层Makefile，修改交叉编译器和芯片平台：</p>
<blockquote>
<p>CROSS_COMPILE=arm-none-linux-gnueabi- ARCH=arm</p>
</blockquote>
<p><code>make defconfig</code>，busybox提供了3种配置：defconfig (缺省配置)、allyesconfig（最大配置）、 allnoconfig（最小配置）。</p>
<p><code>make menuconfig</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Busybox Settings  ---&gt;</span><br><span class="line">    Build Options  ---&gt;</span><br><span class="line">        [*]Build shared libbusybox</span><br><span class="line">        [ ] Build BusyBox as a static binary (no shared libs) (NEW)</span><br><span class="line"></span><br><span class="line">    (arm-anykav200-linux-uclibcgnueabi-) Cross compiler prefix 　//设置编译器</span><br><span class="line">        </span><br><span class="line">    Installation Options (&quot;make install&quot; behavior)  ---&gt;</span><br><span class="line">        (../rootfs) Destination path for &#x27;make install&#x27;   // 设置编译生成文件的存放路径</span><br><span class="line">        What kind of applet links to install (as soft-links)  ---&gt;　//设置生成后的命令是指向busybox的软链接</span><br><span class="line">  </span><br><span class="line">  Busybox Library Tuning  ---&gt;</span><br><span class="line">      (255) History size </span><br><span class="line">      [*]   History saving (NEW)   // 支持历史记录</span><br><span class="line">      [*]   Tab completion (NEW)   // 支持Tab补全操作</span><br></pre></td></tr></table></figure>

<p><code>make; make install</code></p>
<p>添加相应的库，用<code>readelf -d busybox</code>，查看依赖的库，将交叉编译环境下sysroot/lib目录下库拷贝到/lib。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/c/datatype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/c/datatype/" class="post-title-link" itemprop="url">c语言数据类型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:29:02" itemprop="dateModified" datetime="2022-06-08T17:29:02+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">c语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <table>
<thead>
<tr>
<th align="center">Data Type</th>
<th align="center">ILP32</th>
<th align="center">LP32</th>
<th align="center">ILP64</th>
<th align="center">LP64</th>
<th align="center">LLP64</th>
</tr>
</thead>
<tbody><tr>
<td align="center">宏定义</td>
<td align="center">_</td>
<td align="center">_</td>
<td align="center">_</td>
<td align="center"><strong>LP64</strong></td>
<td align="center"><strong>LLP64</strong></td>
</tr>
<tr>
<td align="center">平台</td>
<td align="center">Win32 API  / Unix 和 Unix 类的系统 （Linux，Mac OS X）</td>
<td align="center">Win16 API</td>
<td align="center"></td>
<td align="center">Unix 和 Unix 类的系统 （Linux，Mac OS X)</td>
<td align="center">Win64 API</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32</td>
<td align="center">16</td>
<td align="center">64</td>
<td align="center">32</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">pointer</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">32</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">64</td>
<td align="center"></td>
</tr>
</tbody></table>
<ol>
<li>格式化打印，long使用%ld或%lx，指针使用%p</li>
<li>对于long类型，常量要加L，如：long a = 1L&lt;&lt;32</li>
<li>ssize_t在32位机器上等同与int，在64位机器上等同与long，size_t是无符号型的ssize_t。</li>
<li>指针大小在32位机器上是4字节，64位是8字节。指针p+1 = p + sizeof(p指向的数据类型)。</li>
<li>int, short, long都是signed的，char可能是signed的，也可能是unsigned的，由编译器决定，一般x86上是有符号，arm上是无符号的。</li>
</ol>
<p>stdint.h 里定义了一些数据类型的别名和范围。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span>    <span class="type">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span>      <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>            <span class="type">int32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span>       <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>    <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unsigned.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>        <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>   <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>         <span class="type">uint32_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>   <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>  <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Types for `void *&#x27; pointers.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span>            <span class="type">intptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>   <span class="type">uintptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>                 <span class="type">ntptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>        <span class="type">uintptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Limits of integral types.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Minimum of signed integral types.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT8_MIN        (-128)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT16_MIN       (-32767-1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT32_MIN       (-2147483647-1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT64_MIN       (-__INT64_C(9223372036854775807)-1)</span></span><br><span class="line"><span class="comment">/* Maximum of signed integral types.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT8_MAX        (127)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT16_MAX       (32767)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT32_MAX       (2147483647)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT64_MAX       (__INT64_C(9223372036854775807))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum of unsigned integral types.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT8_MAX        (255)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT16_MAX       (65535)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT32_MAX       (4294967295U)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT64_MAX       (__UINT64_C(18446744073709551615))</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">177</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
