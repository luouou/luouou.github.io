<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/page/15/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/net/ip_mac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/net/ip_mac/" class="post-title-link" itemprop="url">IP and MAC</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 15:23:17" itemprop="dateModified" datetime="2022-06-08T15:23:17+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><p>IPv4 地址共32位，每 8 位作为一组，用点分十进制的表示方式，包含两部分：网络号负责标识该 IP 地址是属于哪个子网的；主机号负责标识同一子网下的不同主机。</p>
<p>子网掩码也是32bit，为1的部分表示网络号，为0的部分表示主机号，将子网掩码和IP地址相与，可以计算出网络号和主机号。主机号部分全部为0代表整个子网，主机号部分全部为1代表广播地址，向子网上所有设备发送包。</p>
<p><img src="/images/net/tcpip/ip_name.png" alt="ip_name"></p>
<p>本地回环地址127.0.0.1指的是本机地址，等效于localhost或本机IP。不会跟着网络情况的变化而变化。它代表设备的本地虚拟接口，被看作是永远不会宕掉的接口。127.0.0.1 ~ 127.255.255.254范围都是本地回环地址。作用是测试本机的网络配置，能ping通说明本机网络协议正常。</p>
<p>IP 地址分为A类、B类、C类、D类、E类，其中D类和E类没有主机号的，所以不可用于主机 IP，D类常被用于多播，E类预留未使用。</p>
<p><img src="/images/net/tcpip/ip_class.webp" alt="ip_class"></p>
<p><img src="/images/net/tcpip/ip_class.png" alt="ip_class"></p>
<h3 id="IP头"><a href="#IP头" class="headerlink" title="IP头"></a>IP头</h3><p><img src="/images/net/tcpip/ip_head.png" alt="img"></p>
<p>经过分片之后的 IP 数据，只能由目标主机进行重组，路由器并不会重组。</p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv6 地址⻓度是 128 位，以每 16 位作为一组，每组用冒号:隔开。</p>
<p>IPv6 的地址主要有以下类型地址:</p>
<ul>
<li>单播地址，用于一对一的通信</li>
<li>组播地址，用于一对多的通信</li>
<li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li>
<li>没有广播地址</li>
</ul>
<p><img src="/images/net/tcpip/ipv6.png" alt="img"></p>
<ul>
<li><p>取消了首部校验和字段。 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</p>
</li>
<li><p>取消了分片/重新组装相关字段。 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</p>
</li>
<li><p>取消选项字段。 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的下一个首部指出的位置上。删除该选项字段使的 IPv6 的首部成为固定⻓度的 40 字节。</p>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP 协议(Internet Protocol)负责在主机和网络之间寻址和路由数据包。</p>
<p>IP地址的网络地址这一部分是用于进行路由控制，路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最⻓匹配。</p>
<p>IP 模块会添加 IP 头部和 MAC 头部这两种头部。IP 头部包含目的地的 IP 地址，MAC 头部包含 MAC 地址。IP 协议会查找下一个路由器的MAC 地址，并将这个地址写入 MAC 头部中。这样一来，以太网协议就知道要将这个包发到哪一个路由器上了。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS(Domain Name System)域名服务系统，将域名网址自动解析为具体的 IP 地址。</p>
<p>查询 IP 地址时，浏览器会使用系统 Socket 库中的解析器， 向 DNS 服务器发送查询消息，然后 DNS 服务器会从域名与 IP 地址的对照表中查找相应的记录，并返回 IP 地址。客户端的查询消息包含以下 3 种信息：</p>
<ul>
<li>域名：服务器、邮件服务器(邮件地址中 @ 后面的部分)的名称。</li>
<li>Class：网络的信息标识。如今 Class 的值永远是代表互联网的 IN。</li>
<li>记录类型：表示域名对应何种类型的记录。例如，当类型为 A 时，表示域名对应的是 IP 地址；当类型为 MX 时，表示域名对应的是邮件服务器。对于不同的记录类型，服务器向客户端返回的信息也会不同。</li>
</ul>
<p><img src="/images/net/dns_msg.png" alt="dns_msg"></p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。</p>
<p>主机会通过广播发送 ARP 请求，这个包中包含了想要查询的 MAC 地址的主机 IP 地址。当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。通常操作系统会把获取的 MAC 地址缓存起来，可以使用 <code>arp -a</code> 命令来查看。</p>
<p>RARP 协议是根据 MAC 地址求 IP 地址。</p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>DHCP(Dynamic Host Configuration Protocol)动态主机配置协议。能实现自动设置 IP 地址、统一管理 IP 地址分配。DHCP 服务器分配的 IP 地址只能在租期内使用。</p>
<h4 id="udhcpc"><a href="#udhcpc" class="headerlink" title="udhcpc"></a>udhcpc</h4><p>默认的目录文件是/usr/share/udhcpc/default.script，当udhcpc 取得了IP地址之后，会把从DHCP server 得到的信息带入 script执行。</p>
<h3 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h3><p>NAT就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址。</p>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>ICMP(Internet Control Message Protocol)互联网控制报文协议，用于告知网络包传送过程中产生的错误以及各种控制信息。在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。</p>
<h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><p>被IP主机用来向本地多路广播路由器报告主机组成员的协议。</p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器是按照IP 协议传输包的设备，根据接收到的包的 IP 头部中记录的接收方 IP 地址，在路由表中进行查询，以此判断转发目标。</p>
<p>路由器已经集成了集线器和交换机的功能，俗称三层网络设备，每个端口都具有 MAC 地址和 IP 地址，只接收与自身地址匹配的包，不匹配的包则直接丢弃。</p>
<p><img src="/images/net/route_map.png" alt="img"></p>
<p>路由器忽略主机号部分，只匹配网络号。路由表的子网掩码列只是用来在匹配目标地址时告诉路由器应该匹配多少个比特。根据目标地址和子网掩码匹配到某条记录后，路由器就会将网络包交给接口列中指定的端口，并转发到网关列中指定的 IP 地址。跃点计数表示距离目标 IP 地址的距离的远近。数字越小表示距离目的地越近；数字越大表示距离目的地越远。</p>
<p>路由表中子网掩码为 0.0.0.0 的记录表示默认路由，这一行配置的网关地址被称为默认网关，无论任何地址都能匹配到这一条记录。</p>
<p>路由器优先选择主机号比特数越短，跃点计数较小的记录。如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过ICMP 消息告知发送方 。</p>
<p>路由器会更新 IP 头部中的 TTL字段。TTL 字段表示包的有效期，包每经过一个路由器的转发，这个值就会减 1，当这个值变成 0 时，就表示超过了有效期，这个包就会被丢弃。</p>
<p>对于长度大于输出端口MTU的转发包，路由器会根据IP 头部中的标志字段，确认是否可以分片。如果查询标志字段发现不能分片，那么就只能丢弃这个包，并通过ICMP 消息通知发送方。在分片中，TCP 头部及其后面的部分都是可分片的数据，每一份数据前面会加上 IP 头部。</p>
<p>路由转发和IP 模块发送包的过程是相同的，会在包前面加上 MAC 头部，也是从路由表的网关列中查找出下一个路由器的 IP 地址，如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址；如果网关为空 ，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址。然后通过 ARP 根据 IP 地址查询出 MAC 地址，然后将 MAC 地址写入 MAC 头部。</p>
<p>内网与互联网连接需要地址转换。地址转换的基本原理是在转发网络包时对 IP 头部中的 IP 地址和端口号进行改写。因为公网IP只有一个，所以要根据不同的端口号区分内网不同的私有地址，路由器会保存私有地址与端口号对应的记录。如果私有地址和端口号没有保存在对应表中，外网是无法访问私有地址的，除非手动添加记录。</p>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC 地址共有 48 bit，用来唯一标识设备，在网卡生产时写入 ROM 里的，网卡驱动程序读取并分配给 MAC模块。通过 ARP 可以查询目标路由器的 MAC 地址。</p>
<table>
<thead>
<tr>
<th align="center">bit</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>0 单播地址<br/>1 多播地址</td>
</tr>
<tr>
<td align="center">2</td>
<td>0 全局地址<br/>1 本地地址</td>
</tr>
<tr>
<td align="center">3-24</td>
<td>厂商识别码</td>
</tr>
<tr>
<td align="center">25-48</td>
<td>网卡唯一标识</td>
</tr>
</tbody></table>
<p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，其作用就是将包送达路由器。</p>
<p><img src="/images/net/tcpip/mac_head.png" alt="img"></p>
<h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>网卡驱动从 IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC 模块发送发送包的命令。MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。再将数字信息按每个比特转换成电信号，然后由 PHY信号收发模块发送出去。</p>
<p><img src="/images/net/tcpip/pack.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改MAC地址</span></span><br><span class="line">ifconfig eth0 hw ether 12:34:56:78:90:12</span><br></pre></td></tr></table></figure>

<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机将网络包原样转发到目的地，交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。交换机的 MAC 地址表主要包含两个信息:设备的 MAC 地址，和该设备连接在交换机的端口。</p>
<p>如果MAC地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。这种情况下，交换机会将包转发到除了源端口之外的所有端口。</p>
<p>交换机是基于以太网设计的，俗称二层网络设备，交换机工作在全双工模式。</p>
<p><img src="/images/net/switch.png" alt="img"></p>
<p>交换机会自行更新或删除地址表中的记录，当收到包时会将发送方 MAC 地址以及其输入端口的号码写入MAC 地址表中，当端口上的设备长时间不工作，就会删除记录。</p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃。相对地，交换机的端口不具有 MAC 地址的端口，故不会核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。</p>
<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><p>集线器是根据以太网协议工作的设备，集线器里有一张以太网协议的表，根据以太网头部中记录的目的地信息查出相应的传输方向，在子网中将网络包传输到下一个转发设备。</p>
<p>集线器将信号广播给所有连接到它网络。集线器的接口中有一个 MDI/MDI-X 切换开关，MDI 就是对 RJ-45 接口和信号收发模块进行直连接线，而 MDI-X 则是交叉接线。</p>
<p>集线器工作在半双工模式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/net/osi_tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/net/osi_tcp/" class="post-title-link" itemprop="url">OSI and TCP/IP</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 15:23:17" itemprop="dateModified" datetime="2022-06-08T15:23:17+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h2><ul>
<li>应用层：负责给应用程序提供统一的接口;</li>
<li>表示层：负责把数据转换成兼容另一个系统能识别的格式;</li>
<li>会话层：负责建立、管理和终止表示层实体之间的通信会话;</li>
<li>传输层：负责端到端的数据传输;</li>
<li>网络层：负责数据的路由、转发、分片;</li>
<li>数据链路层：负责数据的封帧和差错检测，以及 MAC 寻址;</li>
<li>物理层：负责把数据包转换成电信号，在物理介质中传输数据帧;</li>
</ul>
<table>
<thead>
<tr>
<th>分层</th>
<th>作用</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
<td>通过媒介传输比特，确定机械及电气规范（比特 Bit）</td>
<td>RJ45、CLOCK、IEEE802.3（中继器，集线器）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>将比特组装成帧和点到点的传递（帧 Frame）</td>
<td>PPP、FR、HDLC、VLAN、MAC（网桥，交换机）</td>
</tr>
<tr>
<td>网络层</td>
<td>负责数据包从源到宿的传递和网际互连（包 Packet）</td>
<td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td>
</tr>
<tr>
<td>运输层</td>
<td>提供端到端的可靠报文传递和错误恢复（ 段Segment）</td>
<td>TCP、UDP、SPX</td>
</tr>
<tr>
<td>会话层</td>
<td>建立、管理和终止会话（会话协议数据单元 SPDU）</td>
<td>NFS、SQL、NETBIOS、RPC</td>
</tr>
<tr>
<td>表示层</td>
<td>对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）</td>
<td>JPEG、MPEG、ASII</td>
</tr>
<tr>
<td>应用层</td>
<td>允许访问OSI环境的手段（应用协议数据单元 APDU）</td>
<td>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</td>
</tr>
</tbody></table>
<p>OSI 模型只是概念理论上的分层，并没有提供具体的实现方案，实际应用中采用的是更为简化的 TCP/IP 模型。</p>
<p><img src="/images/net/tcpip/tcp-ip-arch.webp" alt="img"></p>
<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><ul>
<li><p>应用层：负责应用程序的网络访问，通过端口号来识别各个不同的进程，向用户提供一组应用程序，比如 HTTP、DNS、FTP 等。</p>
</li>
<li><p>传输层：负责端到端的通信,比如 TCP、UDP 等。</p>
</li>
<li><p>网络层：负责网络包的封装、分片、路由、转发，比如 IP、ICMP等。</p>
</li>
<li><p>网络接口层：负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等。</p>
</li>
</ul>
<p><img src="/images/net/tcpip/tcp_ip_pack.bmp" alt="tcp_ip_pack"></p>
<h2 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h2><p>ADSL(Asymmetric Digital Subscriber Line)不对称数字用户线，是一种利用架设在电线杆上的金属电话线来进行高速通信的技术，它的上行方向(用户到互联网)和下行方向(互联网到用户)的通信速率是不对称的。</p>
<p>用户端路由器发出的网络包通过ADSL Modem调制解调器和电话线到达电话局，然后到达 ADSL 的网络运营商(即 ISP，互联网服务提供商)。</p>
<p>互联网接入路由器会在网络包前面加上 MAC 头部、PPPoE 头部、PPP 头部，然后发送给 ADSL Modem。ADSL Modem 将包拆分成信元，并调制成电信号发送给分离器。分离器负责将电话和 ADSL 的信号进行分离。</p>
<p><img src="/images/net/modem.png" alt="eth_if"></p>
<p>ADSL采用的调制方式是振幅调制(ASK)和相位调制(PSK)相结合的正交振幅调制(QAM)方式。ADSL 使用间隔为 4.3125 kHz 的上百个不同频率的波进行合成，每个波都采用正交振幅调制。</p>
<p><img src="/images/net/modem2.png" alt="eth_if"></p>
<h2 id="ppp"><a href="#ppp" class="headerlink" title="ppp"></a>ppp</h2><p>PPP (Point-to-Point Protocol)点到点协议。用户向运营商的接入点拨打电话，,电话接通后，输入用户名和密码进行登录操作。用户名和密码通过 RADIUS 协议从 RAS 发送到认证服务器，认证服务器校验这些信息是否正确。当确认无误后,认证服务器会返回 IP 地址等配置信息，为计算机分配一个公有地址。</p>
<p>PPPoE 是将 PPP 消息装入以太网包进行传输的方式。PPP 协议中没有定义以太网中的报头和 FCS 等元素，也没有定义信号的格式，因此无法直接将 PPP 消息转换成信号来发送。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/mii/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/mii/" class="post-title-link" itemprop="url">Media Independent Interface</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 15:23:17" itemprop="dateModified" datetime="2022-06-08T15:23:17+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MII"><a href="#MII" class="headerlink" title="MII"></a>MII</h2><p>MII（Media Independent Interface）即媒体独立接口，MII接口是MAC与PHY连接的标准接口。它是IEEE-802.3定义的以太网行业标准。MII接口提供了MAC与PHY之间、PHY与STA(Station Management)之间的互联技术，该接口支持10Mb/s与100Mb/s的数据传输速率，单向传输的数据线有4根，整个接口由14根线组成。媒体独立的意思，是指不管铜轴、光纤、电缆等媒体的变化，媒体处理的相关工作都由PHY和MAC的芯片完成。</p>
<p>MII接口主要包括四个部分。一是从MAC层到PHY层的发送数据接口，二是从PHY层到MAC层的接收数据接口，三是从PHY层到MAC层的状态指示信号，四是MAC层和PHY层之间传送控制和状态信息的MDIO接口。</p>
<p><img src="/images/net/mii/MII.jpg" alt="MII"></p>
<ul>
<li><p>TXD[3:0]：数据发送信号，共4根信号线；</p>
</li>
<li><p>TX_CLK：发送数据使用的时钟信号，对于10M位/s的数据传输，此时钟为2.5MHz，对于100M位/s的数据传输，此时钟为25MHz。</p>
</li>
<li><p>TX_ER（transmit coding error）： TX_ER同步于TX_CLK，在数据传输过程中，如果TX_ER有效超过一个时钟周期，并且此时TX_EN是有效的，则数据通道中传输的数据是无效的，没用的。注：当TX_ER有效并不影响工作在10Mb/s的PHY或者TX_EN无效时的数据传输。在MII接口的连线中，如果TX_ER信号线没有用到，必须将它下拉接地。</p>
</li>
<li><p>TX_EN：传输使能信号，此信号必需与数据前导符的起始位同步出现，并在传输完毕前一直保持。</p>
</li>
<li><p>TXD[3:0]：发送数据线，每次传输4位数据，数据在TX_EN信号有效时有效。当TX_EN信号无效时，PHY忽略传输的数据。</p>
</li>
<li><p>RX_CLK：接收数据使用的时钟信号，对于10M位/s的数据传输，此时钟为2.5MHz，对于100M位/s的数据传输，此时钟为25MHz。</p>
</li>
<li><p>RXD[3:0]：接收数据线，每次接收4位数据，数据在RX_DV信号有效时有效。当RX_EN无效，而RX_ER有效时，RXD[3:0]数据值代表特定的信息。</p>
</li>
<li><p>RX_DV：接收数据使能信号，由PHY控制，当PHY准备好数据供MAC接收时，使能该信号。此信号必需和帧数据的首位同步出现，并保持有效直到数据传输完成。在传送最后4位数据后的第一个时钟之前，此信号必需变为无效状态。为了正确的接收一个帧，有效电平不能滞后于数据线上的SFD位出现。</p>
</li>
<li><p>RX_ER：接收出错信号，保持一个或多个时钟周期(RX_CLK)的有效状态，表明MAC在接收过程中检测到错误。具体错误原因需配合RX_DV的状态及RXD[3:0]的数据值。</p>
</li>
<li><p>CRS：载波侦听信号，仅工作在半双工模式下，由PHY控制，当发送或接收的介质非空闲时，使能此信号。 PHY必需保证CRS信号在发生冲突的整个时间段内都保持有效，不需要此信号与发送/接收的时钟同步。</p>
</li>
<li><p>COL：冲突检测信号，仅工作在半双工模式下，由PHY控制，当检测到介质发生冲突时，使能此信号，并且在整个冲突的持续时间内，保持此信号有效。此信号不需要和发送/接收的时钟同步。</p>
</li>
<li><p>MDC：配置接口时钟。</p>
</li>
<li><p>MDIO：配置接口I/O，是PHY和STA之间的双向信号。 它用于在PHY和STA之间传输控制信息和状态。 控制信息由STA同步地针对MDC驱动并且由PHY同步地采样。 状态信息由PHY针对MDC同步驱动并由STA同步采样。需要1.5K电阻上拉。</p>
</li>
</ul>
<p>MII接口的类型有很多，常用的有MII、RMII、SMII、SSMII、SSSMII、GMII、RGMII、SGMII、TBI、RTBI、XGMII、XAUI、XLAUI等。</p>
<table>
<thead>
<tr>
<th></th>
<th>MII</th>
<th>RMII</th>
<th>GMII</th>
<th>RGMII</th>
<th>SMII</th>
</tr>
</thead>
<tbody><tr>
<td>传输速度</td>
<td>100/10M</td>
<td>100/10M</td>
<td>1000/100/10M</td>
<td>1000/100/10M</td>
<td>100M</td>
</tr>
<tr>
<td>单向数据线数</td>
<td>4</td>
<td>2</td>
<td>8</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>时钟速率</td>
<td>25/2.5M</td>
<td>50/5M</td>
<td>25/2.5M</td>
<td>125/25/2.5M</td>
<td>125M</td>
</tr>
</tbody></table>
<h2 id="RMII"><a href="#RMII" class="headerlink" title="RMII"></a>RMII</h2><p>RMII即Reduced MII，是简化的MII接口。连线数量由MII的16根减少为8根，对于10Mbps线速，MII的时钟速率是2.5MHz就可以了，RMII则需要5MHz；对于100Mbps线速，MII需要的时钟速率是25MHz，RMII则是50MHz。</p>
<p><img src="/images/net/mii/RMII.jpg" alt="RMII"></p>
<ul>
<li><p>TXD[1:0]：数据发送信号线，数据位宽为2</p>
</li>
<li><p>RXD[1:0]：数据接收信号线，数据位宽为2</p>
</li>
<li><p>TX_EN(Transmit Enable)：数据发送使能信号</p>
</li>
<li><p>RX_ER(Receive Error)：数据接收错误提示信号</p>
</li>
<li><p>CLK_REF：是由外部时钟源提供的50MHz参考时钟，与MII接口不同，MII接口中的接收时钟和发送时钟是分开的，而且都是由PHY芯片提供给MAC芯片的。这里需要注意的是，由于数据接收时钟是由外部晶振提供而不是由载波信号提取的，所以在PHY层芯片内的数据接收部分需要设计一个FIFO，用来协调两个不同的时钟,在发送接收的数据时提供缓冲。PHY层芯片的发送部分则不需要FIFO，它直接将接收到的数据发送到MAC就可以了。</p>
</li>
<li><p>CRS_DV：此信号是由MII接口中的RX_DV和CRS两个信号合并而成。当介质不空闲时，CRS_DV和RE_CLK相异步的方式给出。当CRS比RX_DV早结束时(即载波消失而队列中还有数据要传输时)，就会出现CRS_DV在半位元组的边界以25MHz/2.5MHz的频率在0、1之间的来回切换。因此，MAC能够从 CRS_DV中精确的恢复出RX_DV和CRS。</p>
</li>
</ul>
<p>在100Mbps速率时，TX/RX每个时钟周期采样一个数据；在10Mbps速率时，TX/RX每隔10个周期采样一个数据，因而TX/RX数据需要在数据线上保留10个周期，相当于一个数据发送10次。</p>
<p>当PHY层芯片收到有效的载波信号后，CRS_DV信号变为有效，此时如果FIFO中还没有数据，则它会发送出全0的数据给MAC，然后当FIFO中填入有效的数据帧，数据帧的开头是“101010—”交叉的前导码，当数据中出现“01”的比特时，代表正式数据传输开始，MAC芯片检测到这一变化，从而开始接收数据。</p>
<p>当外部载波信号消失后，CRS_DV会变为无效，但如果FIFO中还有数据要发送时，CRS_DV在下一周期又会变为有效，然后再无效再有效，直到FIFO中数据发送完为止。在接收过程中如果出现无效的载波信号或者无效的数据编码，则RX_ER会变为有效，表示物理层芯片接收出错。</p>
<h2 id="SMII"><a href="#SMII" class="headerlink" title="SMII"></a>SMII</h2><p>SMII即Serial MII，串行MII的意思，跟RMII相比，连线进一步减少到4根。只用一根信号线传送发送数据，一根信号线传输接受数据，所以在时钟上为了满足100的需求，它的时钟频率高达到125M，数据线里面还会传送一些控制信息。所有端口的数据收发都公用同一个外部的125M时钟。</p>
<p><img src="/images/net/mii/SMII.jpg" alt="SMII"></p>
<ul>
<li>TXD：发送数据信号，位宽为1；</li>
<li>RXD：接收数据信号，位宽为1；</li>
<li>SYNC：收发数据同步信号，每10个时钟周期置1次高电平，指示同步。</li>
<li>CLK_REF：所有端口共用的一个参考时钟，频率为125MHz，为什么100Mbps速率要用125MHz时钟？因为在每8位数据中会插入2位控制信号，请看下面介绍。</li>
</ul>
<p>TXD/RXD以10比特为一组，以SYNC为高电平来指示一组数据的开始，在SYNC变高后的10个时钟周期内，TXD上依次输出的数据是：TXD[7:0]、TX_EN、TX_ER，控制信号的含义与MII接口中的相同；RXD上依次输出的数据是：RXD[7:0]、RX_DV、CRS，RXD[7:0]的含义与RX_DV有关，当RX_DV为有效时(高电平)，RXD[7:0]上传输的是物理层接收的数据。当RX_DV为无效时(低电平)，RXD[7:0]上传输的是物理层的状态信息数据。见下表：</p>
<p><img src="/images/net/mii/SMII2.jpg" alt="img"></p>
<p>当速率为10Mbps时，每一组数据要重复10次，MAC/PHY芯片每10个周期采样一次。MAC/PHY芯片在接收到数据后会进行串/并转换。</p>
<h2 id="SSMII"><a href="#SSMII" class="headerlink" title="SSMII"></a>SSMII</h2><p>SSMII即Serial Sync MII，叫串行同步接口，跟SMII接口很类似，只是收发使用独立的参考时钟和同步时钟，不再像SMII那样收发共用参考时钟和同步时钟，传输距离比SMII更远。</p>
<p><img src="/images/net/mii/SSMII.jpg" alt="img"></p>
<h2 id="SSSMII"><a href="#SSSMII" class="headerlink" title="SSSMII"></a>SSSMII</h2><p>SSSMII即Source Sync Serial MII，叫源同步串行MII接口，SSSMII与SSMII的区别在于参考时钟和同步时钟的方向，SSMII的TX/RX参考时钟和同步时钟都是由PHY芯片提供的，而SSSMII的TX参考时钟和同步时钟是由MAC芯片提供的，RX参考时钟和同步时钟是由PHY芯片提供的，所以顾名思义叫源同步串行。</p>
<p><img src="/images/net/mii/SSSMII.jpg" alt="img"></p>
<h2 id="GMII"><a href="#GMII" class="headerlink" title="GMII"></a>GMII</h2><p>GMII(Gigabit MII)是千兆网的MII接口。GMII采用8位接口数据，工作时钟125MHz，因此传输速率可达1000Mbps。同时兼容MII所规定的10/100 Mbps工作方式。GMII接口数据结构符合IEEE 802.3-2000以太网标准。</p>
<p>与MII接口相比，GMII的数据宽度由4位变为8位，GMII接口中的控制信号如TX_ER、TX_EN、RX_ER、RX_DV、CRS和COL的作用同MII接口中的一样，发送参考时钟GTX_CLK和接收参考时钟RX_CLK的频率均为125MHz(1000Mbps/8=125MHz)。</p>
<p>发送参考时钟GTX_CLK，它和MII接口中的TX_CLK是不同的，MII接口中的TX_CLK是由PHY芯片提供给MAC芯片的，而GMII接口中的GTX_CLK是由MAC芯片提供给PHY芯片的。两者方向不一样。绝大多数GMII接口都是兼容MII接口的，所以GMII接口都有两个发送参考时钟：TX_CLK和GTX_CLK(两者方向不一样)，在用作MII模式时，使用TX_CLK和8根数据线中的4根。</p>
<p><img src="/images/net/mii/GMII.jpg" alt="GMII"></p>
<p>在千兆速率下，向PHY提供GTXCLK信号、TXD、TXEN、TXER信号与此时钟信号同步。否则在10/100Mbps速率下，PHY提供TXCLK时钟信号，其它信号与此信号同步。其工作频率为25MHz(100M网络)或2.5MHz(10M网络)。</p>
<h2 id="RGMII"><a href="#RGMII" class="headerlink" title="RGMII"></a>RGMII</h2><p>RGMII即Reduced GMII，是GMII的简化版本，将接口信号线数量从24根减少到14根，时钟频率仍旧为125MHz，TX/RX数据宽度从8为变为4位，为了保持1000Mbps的传输速率不变，RGMII接口在时钟的上升沿和下降沿都采样数据。在参考时钟的上升沿发送GMII接口中的TXD[3:0]/RXD[3:0]，在参考时钟的下降沿发送GMII接口中的TXD[7:4]/RXD[7:4]。RGMI同时也兼容100Mbps和10Mbps两种速率，此时参考时钟速率分别为25MHz和2.5MHz。</p>
<p>TX_EN信号线上传送TX_EN和TX_ER两种信息，在TX_CLK的上升沿发送TX_EN，下降沿发送TX_ER；同样的，RX_DV信号线上也传送RX_DV和RX_ER两种信息，在RX_CLK的上升沿发送RX_DV，下降沿发送RX_ER。</p>
<p><img src="/images/net/mii/RGMII.jpg" alt="RGMII"></p>
<p><img src="/images/net/mii/RGMII2.jpg" alt="img"></p>
<h2 id="SGMII"><a href="#SGMII" class="headerlink" title="SGMII"></a>SGMII</h2><p>SGMII即Serial GMII，串行GMII，收发各一对差分信号线，时钟频率625MHz，在时钟信号的上升沿和下降沿均采样，参考时钟RX_CLK由PHY提供，是可选的，主要用于MAC侧没有时钟的情况，一般情况下，RX_CLK不使用。收发都可以从数据中恢复出时钟。</p>
<p>在TXD发送的串行数据中，每8比特数据会插入TX_EN/TX_ER 两比特控制信息，同样，在RXD接收数据中，每8比特数据会插入RX_DV/RX_ER 两比特控制信息，所以总的数据速率为1.25Gbps=625Mbps*2。</p>
<p>其实，大多数MAC芯片的SGMII接口都可以配置成SerDes接口(在物理上完全兼容，只需配置寄存器即可)，直接外接光模块，而不需要PHY层芯片，此时时钟速率仍旧是625MHz，不过此时跟SGMII接口不同，SGMII接口速率被提高到1.25Gbps是因为插入了控制信息，而SerDes端口速率被提高是因为进行了8B/10B变换，本来8B/10B变换是PHY芯片的工作，在SerDes接口中，因为外面不接PHY芯片，此时8B/10B变换在MAC芯片中完成了。8B/10B变换的主要作用是扰码，让信号中不出现过长的连“0”和连“1”情况，影响时钟信息的提取，关于8B/10B变换知识，我后续会单独介绍。</p>
<p><img src="/images/net/mii/SGMII.jpg" alt="SGMII"></p>
<h2 id="TBI"><a href="#TBI" class="headerlink" title="TBI"></a>TBI</h2><p>TBI即Ten Bit Interface，接口数据位宽由GMII接口的8位增加到10位，其实，TBI接口跟GMII接口的差别不是很大，多出来的2位数据主要是因为在TBI接口下，MAC芯片在将数据发给PHY芯片之前进行了8B/10B变换(8B/10B变换本是在PHY芯片中完成的，前面已经说过了)，另外，RX_CLK+/-是从接收数据中恢复出来的半频时钟，频率为62.5MHz，RX_CLK+/-不是差分信号，而是两个独立的信号，两者之间有180度的相位差，在这两个时钟的上升沿都采样数据。RX_CLK+/-也叫伪差分信号。除掉上面说到的之外，剩下的信号都跟GMII接口中的相同。大多数芯片的TBI接口和GMII接口兼容。在用作TBI接口时，CRS和COL一般不用。</p>
<p><img src="/images/net/mii/TBI.jpg" alt="img"></p>
<h2 id="RTBI"><a href="#RTBI" class="headerlink" title="RTBI"></a>RTBI</h2><p>RTBI即Reduced TBI，简化版TBI，接口数据位宽为5bit，时钟频率为125MHz，在时钟的上升沿和下降沿都采样数据，同RGMII接口一样，TX_EN线上会传送TX_EN和TX_ER两种信息，在时钟的上升沿传TX_EN，下降沿传TX_ER；RX_DV线上传送RX_DV和RX_ER两种信息，在RX_CLK上升沿传RX_DV，下降沿传RX_ER。</p>
<p><img src="/images/net/mii/RTBI.jpg" alt="img"></p>
<h2 id="XGMII"><a href="#XGMII" class="headerlink" title="XGMII"></a>XGMII</h2><p>XGMII–10 Gigabit Media Independent Interface 即10Gb独立于媒体的接口，X对应罗马数字10。</p>
<p><img src="/images/net/mii/XGMII.jpg" alt="XGMII"></p>
<p>XGMII接口共74根连线，单端信号，采用HSTL/SSTL_2逻辑，端口电压1.5V/2.5V，由于SSTL_2的端口电压高，功耗大，现在已很少使用。</p>
<ul>
<li><p>TXD[31:0]：数据发送通道，32位并行数据。</p>
</li>
<li><p>RXD[31:0]：数据接收通道，32位并行数据。</p>
</li>
<li><p>TXC[3:0]：发送通道控制信号，TXC=0时，表示TXD上传输的是数据；TXC=1时，表示TXD上传输的是控制字符。TXC[3:0]分别对应TXD[31:24], TXD[23:16], TXD[15:8], TXD[7:0]。</p>
</li>
<li><p>RXC[3:0]：接收通道控制信号，RXC=0时，表示RXD上传输的是数据；RXC=1时，表示RXD上传输的是控制字符。RXC[3:0]分别对应RXD[31:24], RXD[23:16], RXD[15:8], RXD[7:0]。</p>
</li>
<li><p>TX_CLK：TXD和TXC的参考时钟，时钟频率156.25MHz，在时钟信号的上升沿和下降沿都采样数据。156.25MHz - 2 - 32 = 10Gbps 。</p>
</li>
<li><p>RX_CLK：RXD和RXC的参考时钟，时钟频率156.25MHz，在时钟信号的上升沿和下降沿都采样数据。</p>
</li>
</ul>
<p>HSTL即High Speed Transceiver Logic，高速发送逻辑的意思。</p>
<p>SSTL，即Stub Series Terminated Logic，短路终止逻辑，主要用于高速内存接口，SSTL目前存在两种标准，SSTL_3是3.3V标准；SSTL_2是2.5V标准。</p>
<h2 id="XAUI"><a href="#XAUI" class="headerlink" title="XAUI"></a>XAUI</h2><p>由于受电气特性的影响，XGMII接口的PCB走线最大传输距离仅有7cm，并且XGMII接口的连线数量太多，给实际应用带来不便，因此，在实际应用中，XGMII接口通常被XAUI接口代替，XAUI即10 Gigabit attachment unit interface，将XGMII集成到芯片内部，XAUI在XGMII的基础上实现了XGMII接口的物理距离扩展，将PCB走线的传输距离增加到50cm，使背板走线成为可能。</p>
<p>源端XGMII把收发32位宽度数据流分为4个独立的lane通道，每个lane通道对应一个字节，经XGXS(XGMII Extender Sublayer)完成8B/10B编码后，将4个lane分别对应XAUI的4个独立通道，XAUI端口速率为：<code>2.5Gbps - 1.25 - 4＝12.5Gbps</code>。</p>
<p><img src="/images/net/mii/XAUI.jpg" alt="img"></p>
<p>在发送端的XGXS模块中，将TXD[31:0]/ RXD[31:0],TXC[3:0]/ RXC[3:0], TX_CLK/ RX_CLK转换成串行数据从TX Lane[3:0]/ RX Lane[3:0]中发出去，在接收端的XGXS模块中，串行数据被转换成并行，并且进行时钟恢复和补偿，完成时钟去抖，经过5B/4B解码后，重新聚合成XGMII。</p>
<p>万兆以太网接口的端口速率为10Gbps，主要有XGMII和XAUI两种，另外还有HIGIG。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/rj45/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/rj45/" class="post-title-link" itemprop="url">RJ45 interface</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 15:23:17" itemprop="dateModified" datetime="2022-06-08T15:23:17+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以太网信号最终是通过RJ45接头接入网络的。RJ是Registered Jack的缩写，意思是注册的插座。在FCC（美国联邦通信委员会标准和规章）中RJ是描述公用电信网络的接口，计算机网络的RJ45是标准8位模块化接口的俗称。连接器由插头（8P8C接头，水晶头）和插座组成。</p>
<p>RJ45型网线插头又称水晶头，有两种连接方式，分别称作 T568A 线序和 T568B 线序。两者的主要区别是橙色和绿色双绞线进行了交换。</p>
<p>这两种标准只是在线缆颜色上有所区别，目的是在线缆侧实现交叉互连。直连线常用于异种网络之间的互连（比如计算机交换机之间），交叉线常用于同种网络之间的互联（比如计算机与之间）。</p>
<p><img src="/images/net/RJ45/RJ-45_T568AB.jpg" alt="RJ-45接线图"></p>
<p><img src="/images/net/RJ45/T568AB.bmp" alt="RJ-45接线图2"></p>
<p>交叉互连，所谓交叉是指网线的一端和另一端与 RJ45 网线插头的接法不同，一端按 T568A 线序接，另一端按 T568B 线序接，即有几根网线在另一端是先做了交叉才接到 RJ45 插头上去的，适用的场合：</p>
<ul>
<li>电脑——电脑，称对等网连接</li>
<li>集线器——集线器</li>
<li>交换机——交换机</li>
</ul>
<p>直连线互连的网线的两端均按T568B接线，适用场合：</p>
<ul>
<li>电脑——ADSL 猫</li>
<li>ADSL猫——ADSL 路由器的 WAN 口</li>
<li>电脑——ADSL 路由器的 LAN 口</li>
<li>电脑——集线器或交换机</li>
</ul>
<p>现在PHY芯片大部分具有自动交叉（auto MDI-X）的能力，它可以实现RJ-45接口的传送信号线和接收信号线的功能自动互相交换，有的PHY甚至支持一对线中的正信号和负信号的功能自动交换，这样就不必考虑选用直连网线还是交叉网线，只需要直连即可。</p>
<p><img src="/images/net/RJ45/T-568A.jpg" alt="T-568A"></p>
<p><img src="/images/net/RJ45/T-568B.jpg" alt="T-568B"></p>
<p><img src="/images/net/RJ45/RJ45-pinout.jpg" alt="RJ45-pinout"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/net/eth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/net/eth/" class="post-title-link" itemprop="url">ethernet and MAC</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 15:23:17" itemprop="dateModified" datetime="2022-06-08T15:23:17+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>以太网接口由MAC控制器物理层接口PHY组成。PHY整合了大量模拟硬件，而MAC是典型的全数字器件。考虑到芯片面积及模拟/数字混合架构的原因，通常，将MAC集成进微控制器而将PHY留在片外。</p>
<p><img src="/images/net/eth/eth-arch.png" alt="基本构成"></p>
<p><img src="/images/net/eth/eth-arch2.jpg" alt="cpu内部框架"></p>
<p>网卡工作在osi的最后两层，物理层和数据链路层，物理层定义了数据传送与接收所需要的电与光信号、线路状态、时钟基准、数据编码和电路等，并向数据链路层设备提供标准接口。物理层的芯片称之为PHY。数据链路层则提供寻址机构、数据帧的构建、数据差错检查、传送控制、向网络层提供标准的数据接口等功能。以太网卡中数据链路层的芯片称之为MAC控制器。很多网卡的这两个部分是做到一起的。他们之间的关系是pci总线接mac总线，mac接phy，phy接网线。</p>
<p>隔离变压器的作用是防干扰，防雷击。长距离连接的两个以太网设备，很可能不共地，地线之间有电压差，如果不隔离，电流会经网线走，网卡接口就很容易坏了。</p>
<p>RJ-45接头实现了网卡和网线的连接，10M网卡的RJ-45插口也只用了1,2,3,6四根，而100M或1000M网卡使用八根。其中100M的网络中1,2是传送数据的，3,6是接收数据的，1,2之间是一对差分信号，也就是说它们的波形一样，但是相位相差180度。</p>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC（Media Access Control），即媒体访问控制子层协议。该协议位于OSI七层协议中数据链路层的下半部分，实现了数据链路层。支持 10Mbit/s 或 100Mbit/s 两种速率。主要负责控制与连接物理层的物理介质。在发送数据的时候，MAC协议可以事先判断是否可以发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层;在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误,如果没有错误,则去掉控制信息发送至LLC层。该层协议是以太网MAC由IEEE-802.3以太网标准定义。</p>
<p><img src="/images/net/eth/mac.png" alt="OSI-MAC"></p>
<p>最新的MAC同时支持 10Mbps和100Mbps两种速率。以太网数据链路层其实包含MAC(介质访问控制)子层和LLC(逻辑链路控制)。</p>
<p>目标的MAC地址由ARP协议确定。第一次传送某个目的IP地址的数据的时候，先会发出一个ARP包，其MAC的目标地址是广播地址，因为是广播包，所有这个局域网的主机都收到了这个ARP请求。收到请求的主机将这个IP地址和自己的相比较，如果不相同就不予理会，如果相同就发出ARP响应包。这个IP地址的主机收到这个ARP请求包后回复的ARP响应。这个包里面就包括了他的MAC地址。以后的给这个IP地址的帧的目标MAC地址就被确定了。</p>
<p>IP地址和MAC地址之间的关联关系保存在主机系统里面，叫做ARP表。</p>
<p><img src="/images/net/eth/MAC.jpg" alt="MAC"></p>
<p>以太网MAC芯片的一端接计算机PCI总线，另外一端就接到PHY芯片上。CPU上有两组寄存器用与MAC。一组用户数据的收发，对应上面的DMA；一组用户MIIM，用户对PHY进行配置，两组寄存器由于都在CPU上，配置方式与其他CPU上寄存器一样，直接读写即可。数据的转发通过DMA完成。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/rootfs/rootfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/rootfs/rootfs/" class="post-title-link" itemprop="url">rootfs of file system</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 15:23:17" itemprop="dateModified" datetime="2022-06-08T15:23:17+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rootfs/" itemprop="url" rel="index"><span itemprop="name">rootfs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="flash文件系统"><a href="#flash文件系统" class="headerlink" title="flash文件系统"></a>flash文件系统</h2><p>flash芯片可以被划分为多个分区，各分区可以采用不同的文件系统。flash文件系统是基于MTD驱动层的，MTD(Memory Technology Device,存储技术设备)为底层硬件(闪存)和上层(文件系统)之间提供一个统一的抽象接口，专门针对各种非易失性存储器设计，因而对Flash有更好的支持、管理和基于扇区的擦除、读/写操作接口。</p>
<h3 id="jffs"><a href="#jffs" class="headerlink" title="jffs"></a>jffs</h3><p>JFFS文件系统最早是由瑞典Axis Communications公司基于Linux2.0的内核为嵌入式系统开发的文件系统。JFFS2是RedHat公司基于JFFS开发的闪存文件系 统，最初是针对RedHat公司的嵌入式产品eCos开发的嵌入式文件系统，所以JFFS2也可以用在Linux, uCLinux中。</p>
<p>Jffs2: 日志闪存文件系统版本2 (Journalling Flash FileSystem v2)</p>
<p>主要用于NOR型闪存，基于MTD驱动层，特点是：<strong>可读写</strong>的、支持数据压缩的、基于哈希表的日志型文件系统，并提供了崩溃/掉电安全保护，提供“写平衡”支持等。缺点主要是当文件系统已满或接近满时，因为垃圾收集的关系而使jffs2的运行速度大大放慢。</p>
<p>目前jffs3正在开发中。关于jffs系列文件系统的使用详细文档，可参考MTD补丁包中mtd-jffs-HOWTO.txt。</p>
<p><em>jffsx不适合用于NAND闪存</em>主要是因为NAND闪存的容量一般较大，这样导致jffs为维护日志节点所占用的内存空间迅速增大，另 外，jffsx文件系统在挂载时需要扫描整个FLASH的内容，以找出所有的日志节点，建立文件结构，对于大容量的NAND闪存会耗费大量时间。</p>
<h4 id="mkfs-jffs2"><a href="#mkfs-jffs2" class="headerlink" title="mkfs.jffs2"></a>mkfs.jffs2</h4><p>直接安装<code>mkfs.jffs2</code>工具：sudo apt-get install mtd-utils，或编译源码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install liblzo2-2 libuuid1 zlib1g liblzo2-dev uuid-dev libacl1-dev  zlib1g-dev</span><br><span class="line">./configure --prefix=/home/luo_u/usr</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><em>使用说明</em>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">./mkfs.jffs2 -v -d rootfs/ -l -s 256 -e 4096 -m none -o root.jffs2</span><br><span class="line"></span><br><span class="line">-p, --pad[=SIZE]        使用0xff填充文件系统到指定大小，不指定则只填充完最后一个擦除块</span><br><span class="line">-r, -d, --root=DIR      使用指定的目录内容构建文件系统</span><br><span class="line">-s, --pagesize=SIZE     使用指定的页大小（最大数据节点大小） (default: 4KiB)</span><br><span class="line">-e, --eraseblock=SIZE   指定擦除块的大小 (default: 64KiB)</span><br><span class="line">-c, --cleanmarker=SIZE  擦除标记的大小 (default 12)</span><br><span class="line">-m, --compr-mode=MODE   选择压缩模式(default: priortiry)</span><br><span class="line">-x, --disable-compressor=COMPRESSOR_NAME  禁用指定的压缩算法</span><br><span class="line">-X, --enable-compressor=COMPRESSOR_NAME   启用指定的压缩算法</span><br><span class="line">-y, --compressor-priority=PRIORITY:COMPRESSOR_NAME  设置压缩算法的优先级</span><br><span class="line">-L, --list-compressors  列出可用的压缩算法</span><br><span class="line">-t, --test-compression  测试压缩算法</span><br><span class="line">-n, --no-cleanmarkers   不添加擦除标记到擦除块</span><br><span class="line">-o, --output=FILE       指定输出镜像文件名称</span><br><span class="line">-l, --little-endian     创建一个小端的文件系统</span><br><span class="line">-b, --big-endian        创建一个大端的文件系统</span><br><span class="line">-q, --squash            压缩权限和设置所有文件的拥有者为root</span><br><span class="line">-U, --squash-uids       设置所有文件的拥有者为root</span><br><span class="line">-P, --squash-perms      压缩所有文件的权限</span><br><span class="line">-v  可视操作</span><br></pre></td></tr></table></figure>

<p><em>挂载分区</em>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t jffs2 /dev/mtdblock1 /mnt</span><br></pre></td></tr></table></figure>

<h3 id="yaffs"><a href="#yaffs" class="headerlink" title="yaffs"></a>yaffs</h3><p>yaffs/yaffs2(Yet Another Flash File System)是专为嵌入式系统使用NAND型闪存而设计的一种日志型文件系统。与jffs2相比，它减少了一些功能(例如不支持数 据压缩)，所以速度更快，挂载时间很短，对内存的占用较小。另外，它还是跨平台的文件系统，除了Linux和eCos，还支持WinCE, pSOS和ThreadX等。</p>
<p>yaffs/yaffs2自带NAND芯片的驱动，并且为嵌入式系统提供了直接访问文件系统的API，用户可以不使用Linux中的MTD与VFS，直接对文件系统操作。当然，yaffs也可与MTD驱动程序配合使用。</p>
<p>yaffs与yaffs2的主要区别在于，前者仅支持小页(512 Bytes) NAND闪存，后者则可支持大页(2KB) NAND闪存。同时，yaffs2在内存空间占用、垃圾回收速度、读/写速度等方面均有大幅提升。</p>
<p><a target="_blank" rel="noopener" href="https://yaffs.net/documents/how-yaffs-works">https://yaffs.net/documents/how-yaffs-works</a></p>
<h3 id="cramfs"><a href="#cramfs" class="headerlink" title="cramfs"></a>cramfs</h3><p>Cramfs(Compressed ROM File System)是Linux的创始人 Linus Torvalds参与开发的一种只读的压缩文件系统。它也基于MTD驱动程序。</p>
<p>在cramfs文件系统中，每一页(4KB)被单独压缩，可以随机页访问，其压缩比高达2:1,为嵌入式系统节省大量的Flash存储空间，使系统可通过更低容量的FLASH存储相同的文件，从而降低系统成本。</p>
<p>Cramfs文件系统以压缩方式存储，在运行时解压缩，所以不支持应用程序以XIP方式运行，所有的应用程序要求被拷到RAM里去运行，但这并 不代表比Ramfs需求的RAM空间要大一点，因为Cramfs是采用分页压缩的方式存放档案，在读取档案时，不会一下子就耗用过多的内存空间，只针对目 前实际读取的部分分配内存，尚没有读取的部分不分配内存空间，当我们读取的档案不在内存时，Cramfs文件系统自动计算压缩后的资料所存的位置，再即时 解压缩到RAM中。</p>
<p>另外，它的速度快，效率高，其只读的特点有利于保护文件系统免受破坏，提高了系统的可靠性。由于以上特性，Cramfs在嵌入式系统中应用广泛。但是它的<strong>只读</strong>属性同时又是它的一大缺陷，使得用户无法对其内容对进扩充。Cramfs映像通常是放在Flash中，但是也能放在别的文件系统里，使用loopback 设备可以把它安装别的文件系统里。</p>
<p>单个文件大小不能超过16MB、文件系统大小略大于256MB（最后一个文件允许超过256MB空间范围，即文件系统总大小不超过272MB）。CramFS的gid只保存8位，mkcramfs会简单的将gid截断保留最后8位。CramFS支持硬链接，但是被硬链接的文件引用计数不会增加。CramFS文件没有时间戳，所有文件的创建/访问时间戳都是1970年1月1日 0:00:00 GMT。CramFS的镜像只支持被同样字节对齐方式的机器创建和挂载使用，页面大小只支持4KB。</p>
<h3 id="romfs"><a href="#romfs" class="headerlink" title="romfs"></a>romfs</h3><p>传统型的Romfs文件系统是一种简单的、紧凑的、只读的文件系统，不支持动态擦写保存，按顺序存放数据，因而支持应用程序以 XIP(eXecute In Place，片内运行)方式运行，在系统运行时，节省RAM空间。uClinux系统通常采用Romfs文件系统。<br>　　<br>其他文件系统：fat/fat32也可用于实际嵌入式系统的扩展存储器(例如PDA, Smartphone, 数码相机等的SD卡)，这主要是为了更好的与最流行的Windows桌面操作系统相兼容。ext2也可以作为嵌入式Linux的文件系统，不过将它用于 FLASH闪存会有诸多弊端。</p>
<h3 id="squashfs"><a href="#squashfs" class="headerlink" title="squashfs"></a>squashfs</h3><p>SquashFS [1]  是一套基于Linux内核使用的压缩<strong>只读</strong>文件系统。该文件系统能够压缩系统内的文档,inode以及目录，文件最大支持2^64字节。<br>-　Squashfs 4.2 : 最新的版本，并适用于2.6.29版本以后的Linux内核。<br>-　Squashfs 4.1 : 支持XZ压缩，并适用于2.6.29版本以后的Linux内核。<br>-　Squashfs 3.4 : 该版本是3.X的最后一个版本，并适用于2.6.29版本之前的内核。</p>
<p>安装<code>mksquashfs</code>工具：sudo apt-get install squashfs-tools</p>
<p><em>使用说明</em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mksquashfs rootfs/usr usr.sqsh4 -noappend -comp xz</span><br></pre></td></tr></table></figure>

<p><em>挂载分区</em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t squashfs /dev/mtdblock6 /usr</span><br></pre></td></tr></table></figure>

<h3 id="RAM文件系统"><a href="#RAM文件系统" class="headerlink" title="RAM文件系统"></a>RAM文件系统</h3><h4 id="ramdisk"><a href="#ramdisk" class="headerlink" title="ramdisk"></a>ramdisk</h4><p>Ramdisk是将一部分固定大小的内存当作分区来使用。它并非一个实际的文件系统，而是一种将实际的文件系统装入内存的机制，并且可以作为根文件系统。将一些经常被访问而又不会更改的文件(如只读的根文件系统)通过Ramdisk放在内存中，可以明显地提高系统的性能。</p>
<p>在Linux的启动阶段，initrd提供了一套机制，可以将内核映像和根文件系统一起载入内存。</p>
<h4 id="ramfs-tmpfs"><a href="#ramfs-tmpfs" class="headerlink" title="ramfs/tmpfs"></a>ramfs/tmpfs</h4><p>Ramfs是Linus Torvalds开发的一种基于内存的文件系统，工作于虚拟文件系统(VFS)层，不能格式化，可以创建多个，在创建时可以指定其最大能使用的内存大 小。(实际上，VFS本质上可看成一种内存文件系统，它统一了文件在内核中的表示方式，并对磁盘文件系统进行缓冲。)</p>
<p>Ramfs/tmpfs文件系统把所有的文件都放在RAM中，所以读/写操作发生在RAM中，可以用ramfs/tmpfs来存储一些临时性或经常要修改的数据，例如/tmp和/var目录，这样既避免了对Flash存储器的读写损耗，也提高了数据读写速度。</p>
<p>Ramfs/tmpfs相对于传统的Ramdisk的不同之处主要在于：不能格式化，文件系统大小可随所含文件内容大小变化。</p>
<p>Tmpfs的一个缺点是当系统重新引导时会丢失所有数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/rootfs/buildroot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/rootfs/buildroot/" class="post-title-link" itemprop="url">buildroot</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 15:23:17" itemprop="dateModified" datetime="2022-06-08T15:23:17+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rootfs/" itemprop="url" rel="index"><span itemprop="name">rootfs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>下载地址：　<a target="_blank" rel="noopener" href="https://buildroot.org/">https://buildroot.org/</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">├── arch: 存放CPU架构相关的配置脚本</span><br><span class="line">├── board</span><br><span class="line">├── boot</span><br><span class="line">├── CHANGES</span><br><span class="line">├── Config.in</span><br><span class="line">├── Config.in.legacy</span><br><span class="line">├── configs: 放置开发板的一些配置参数. </span><br><span class="line">├── COPYING</span><br><span class="line">├── DEVELOPERS</span><br><span class="line">├── dl: 存放下载的源代码及应用软件的压缩包. </span><br><span class="line">├── docs: 存放相关的参考文档. </span><br><span class="line">├── fs: 放各种文件系统的源代码. </span><br><span class="line">├── linux: 存放着Linux kernel的自动构建脚本. </span><br><span class="line">├── Makefile</span><br><span class="line">├── Makefile.legacy</span><br><span class="line">├── output: 是编译出来的输出文件夹. </span><br><span class="line">│   ├── build: 存放解压后的各种软件包编译完成后的现场.</span><br><span class="line">│   ├── host: 存放着制作好的编译工具链，如gcc、arm-linux-gcc等工具.</span><br><span class="line">│   ├── images: 存放着编译好的uboot.bin, zImage, rootfs等镜像文件，可烧写到板子里, 让linux系统跑起来.</span><br><span class="line">│   ├── staging</span><br><span class="line">│   └── target: 存放Linux系统基本的目录结构，以及编译好的应用库和bin可执行文件</span><br><span class="line">├── package：下面放着应用软件的配置文件，每个应用软件的配置文件有Config.in和soft_name.mk。</span><br><span class="line">├── README</span><br><span class="line">├── support</span><br><span class="line">├── system</span><br><span class="line">└── toolchain</span><br></pre></td></tr></table></figure>

<p> Buildroot提供了构建流程的框架。开发者按照格式写脚本，提供必要的构建细节，配置整个系统，最后自动构建出你的系统。</p>
<p> package/pkg-generic.mk中通过调用同目录下的pkg-download.mk、pkg-utils.mk文件，已经帮你自动实现了下载、解压、依赖包下载编译等一系列流程。你只要需要按照格式写Makefile脚app_pkg.mk，填充下载地址，链接依赖库的名字等一些特有的构建细节即可。</p>
<p><img src="/images/rootfs/build.png" alt="构建流程框架"></p>
<p>Buildroot代码仓库默认只包含一个编译框架，真正构建rootfs需要的各种代码包是根据配置选项，在编译的时候才开始下载的。</p>
<p>通过<code>make help</code>可以看到buildroot下make的使用细节，包括对package、uclibc、busybox、linux以及文档生成等配置。</p>
<p>执行命令<code>make list-defconfigs</code>查看buildroot中支持的开发板</p>
<p>设置 toolchain 的版本和内核头文件的内核的版本</p>
<p>System configuration-&gt;Run a getty(login prompt) after boot选项中配置 TTY Port 为 ttyAMA0。否则文件系统挂载后无法进入控制台。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><strong>Target options</strong>：目标板的配置</p>
<ul>
<li><p>Target Architecture：目标架构，这里选择 ARM(little endian)，ARM小端模式</p>
</li>
<li><p>Target Binary Format：二进制格式，为 ELF</p>
</li>
<li><p>Target Architecture Variant：架构变体为 arm920t，内核类型</p>
</li>
<li><p>Target ABI：应用程序二进制接口，为EABI</p>
</li>
<li><p>Floating point strategy：浮点数的策略，选择为 Soft float</p>
</li>
<li><p>ARM instruction set：arm 汇编指令集，选择  ARM</p>
</li>
<li><p><strong>Build　options</strong></p>
</li>
</ul>
<p>主要是一些编译时用到的选项，比如dl的路径，下载代码包使用的路径，同时运行多个编译的上限，是否使能编译器缓冲区等。</p>
<p><strong>Toolchain</strong>：工具链选项</p>
<ul>
<li>Toolchain type：Buildroot提供两种方式使用toolchain<ul>
<li>external toolthain：非Buildroot提供的交叉编译器</li>
<li>Buildroot toolchain：Buildroot本身编译生成的Buildroot toolchain</li>
</ul>
</li>
<li>custom toolchain vendor name：填上S3C2440</li>
<li>C library：C库选择，选择 glibc</li>
<li>Kernel Headers：内核头文件，Linux 4.9.x kernel headers</li>
<li>glibc version：glibc版本选择，2.24</li>
<li>Binutils Version：binutils版本：2.27</li>
<li>Additional binutils options：附加的 binutils 选择，不填即可</li>
<li>GCC compiler Version：GCC版本选择，gcc 6.x</li>
<li>Additional gcc options：附件的GCC选项</li>
<li>Enable C++ support：使能C++支持，选上</li>
<li>Enable Fortran support：使能Fortran语言支持，不选</li>
<li>Enable compiler link-time-optimization support：是否支持LTO，不选</li>
<li>Enable compiler OpenMP support：是否支持OpenMP，OpenMP用于共享内存并行系统的多处理器程序设计，<br>不适合需要复杂的线程间同步和互斥的场合，OpenMp的另一个缺点是不能在非共享内存系统如计算机集群上使用。不选择</li>
<li>Enable graphite support ：是否支持graphite。Graphite是应用WEB应用的一套开源的编程接口。不选择。</li>
<li>Build cross gdb for the host：主机上运行gdb进行调试，不选</li>
<li>Copy gconv libraries：拷贝 gconv库，gconv库用于在不同字符集之间进行转换。默认不选</li>
<li>Enable MMU support：使能 MMU，S3C2440支持MMU，选上</li>
<li>Target Optimizations：不选</li>
<li>Target linker options：不选</li>
<li>Register toolchain within Eclipse Buildroot plug-in：eclipse插件支持，不选</li>
</ul>
<p><strong>System configuration</strong>：系统配置</p>
<ul>
<li>Root FS skeleton：</li>
<li>System hostname：填写JZ2440</li>
<li>System banner</li>
<li>Passwords encoding</li>
<li>Init system：系统初始化，选择 BusyBox</li>
<li>/dev management：设备文件管理，选择Dynamic using devtmpfs + mdev，即使用mdev动态加载设备节点的方式</li>
<li>Path to the permission tables：设备节点的配置表设置，一定要选择system/device_table_dev.txt，否则后面在dev目录下将不会生成各种设备节点。当然我们也可以手动的配置该文件，添加必要的节点或删除不需要的节点。</li>
<li>support extended attributes in device tables</li>
<li>Use symlinks to /usr for /bin, /sbin and /lib</li>
<li>Enable root login with password</li>
<li>Root password：进入linux控制台终端后的密码，为空则登录时不需要密码，默认登录用户名为root。</li>
<li>/bin/sh (busybox’ default shell)</li>
<li>Run a getty (login prompt) after boot：保持默认，默认为选中。<ul>
<li>TTY port：控制台打印串口</li>
<li>Baudrate ：波特率，配置为 115200</li>
<li>TERM environment variable：默认即可</li>
<li>other options to pass to getty：默认即可</li>
</ul>
</li>
<li>remount root filesystem read-write during boot</li>
<li>Network interface to configure through DHCP</li>
<li>Purge unwanted locales</li>
<li>Locales to keep</li>
<li>Generate locale data</li>
<li>Install timezone info</li>
<li>Path to the users tables</li>
<li>Root filesystem overlay directories：</li>
<li>Custom scripts to run before creating filesystem images</li>
<li>Custom scripts to run inside the fakeroot environment</li>
<li>Custom scripts to run after creating filesystem images</li>
</ul>
<p><strong>Kernel</strong>：内核配置</p>
<ul>
<li><p>Kernel version：内核版本，选择用户自定义Custom version</p>
</li>
<li><p>Kernel version：填上自己所需要的版本，4.14.12</p>
</li>
<li><p>Custom kernel patches：自定义的内核补丁</p>
</li>
<li><p>Kernel configuration：内核配置，选择 Using an in-tree defconfig file</p>
</li>
<li><p>Defconfig name：填写为 mini2440</p>
</li>
<li><p>Additional configuration fragment files：暂且不填写</p>
</li>
<li><p>Kernel binary format：内核二进制文件格式，zImage</p>
</li>
<li><p>Kernel compression format：内核压缩格式，选择gzip</p>
</li>
<li><p>Build a Device Tree Blob：设备树？暂且不填写</p>
</li>
<li><p>Install kernel image to /boot in target：暂且不填</p>
</li>
<li><p>Linux Kernel Extensions：内核扩展，默认不选择</p>
</li>
<li><p>Linux Kernel Tools：内核工具，默认不选择</p>
</li>
<li><p><strong>Target packages</strong></p>
</li>
<li><p>Filesystem images：文件系统选择，选择 yaffs2 root filesystem</p>
</li>
<li><p><strong>Bootloaders</strong></p>
</li>
<li><p>Build system：u-boot系统选择为Kconfig</p>
<ul>
<li>legacy：若是选择2015.04之前的u-boot 选择此项</li>
<li>Kconfig：2015.04之后的 u-boot 选择此项，勾选此项　　</li>
</ul>
</li>
<li><p>U-boot Version：U-boot版本，默认为 2017.01，选择为Custom version</p>
</li>
<li><p>U-Boot version：填写为2017.11</p>
</li>
<li><p>Custom U-boot patches：U-boot补丁，不添加</p>
</li>
<li><p>U-Boot configuration：U-boot配置，暂时还没有U-BOOT，所以选择为：Using an in-tree board defconfig file</p>
</li>
<li><p>Board defconfig：板子的配置，选择与架构一样的板子的默认文件，mini2440。后期再修改</p>
</li>
<li><p>U-boot needs dtc：是否需要设备树，默认，后期调试</p>
</li>
<li><p>U-boot needs OpenSSL：是否需要 OpenSSL，默认，后期调试修改</p>
</li>
<li><p>U-boot binary format：二进制文件，选择 .bin文件</p>
</li>
<li><p>produce a .ift signed image：默认</p>
</li>
<li><p>Install U-boot SPL binary image：默认</p>
</li>
<li><p>Environment image：默认</p>
</li>
<li><p><strong>Host utilities</strong></p>
</li>
<li><p><strong>Legacy config options</strong></p>
</li>
</ul>
<h2 id="编译性能"><a href="#编译性能" class="headerlink" title="编译性能"></a>编译性能</h2><p>buildroot还提供了一些命令，用于分析buildroot编译过程中耗时、依赖关系、文件系统尺寸等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Documentation:</span><br><span class="line">  manual               　 * build manual in all formats</span><br><span class="line">  manual-html          　 * build manual in HTML</span><br><span class="line">  manual-split-html      * build manual in split HTML</span><br><span class="line">  manual-pdf             * build manual in PDF</span><br><span class="line">  manual-text            * build manual in text</span><br><span class="line">  manual-epub            * build manual in ePub</span><br><span class="line">  graph-build            * generate graphs of the build times</span><br><span class="line">  graph-depends          * generate graph of the dependency tree</span><br><span class="line">  graph-size             * generate stats of the filesystem size</span><br><span class="line">  list-defconfigs        * list all defconfigs (pre-configured minimal systems)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/rootfs/busybox/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/rootfs/busybox/" class="post-title-link" itemprop="url">BusyBox</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 15:23:17" itemprop="dateModified" datetime="2022-06-08T15:23:17+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rootfs/" itemprop="url" rel="index"><span itemprop="name">rootfs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://busybox.net/downloads/">下载地址</a></p>
<p><a target="_blank" rel="noopener" href="https://salsa.debian.org/installer-team/busybox">https://salsa.debian.org/installer-team/busybox</a></p>
<p>修改顶层Makefile，修改交叉编译器和芯片平台：</p>
<blockquote>
<p>CROSS_COMPILE=arm-none-linux-gnueabi- ARCH=arm</p>
</blockquote>
<p><code>make defconfig</code>，busybox提供了3种配置：defconfig (缺省配置)、allyesconfig（最大配置）、 allnoconfig（最小配置）。</p>
<p><code>make menuconfig</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Busybox Settings  ---&gt;</span><br><span class="line">    Build Options  ---&gt;</span><br><span class="line">        [*]Build shared libbusybox</span><br><span class="line">        [ ] Build BusyBox as a static binary (no shared libs) (NEW)</span><br><span class="line"></span><br><span class="line">    (arm-anykav200-linux-uclibcgnueabi-) Cross compiler prefix 　//设置编译器</span><br><span class="line">        </span><br><span class="line">    Installation Options (&quot;make install&quot; behavior)  ---&gt;</span><br><span class="line">        (../rootfs) Destination path for &#x27;make install&#x27;   // 设置编译生成文件的存放路径</span><br><span class="line">        What kind of applet links to install (as soft-links)  ---&gt;　//设置生成后的命令是指向busybox的软链接</span><br><span class="line">  </span><br><span class="line">  Busybox Library Tuning  ---&gt;</span><br><span class="line">      (255) History size </span><br><span class="line">      [*]   History saving (NEW)   // 支持历史记录</span><br><span class="line">      [*]   Tab completion (NEW)   // 支持Tab补全操作</span><br></pre></td></tr></table></figure>

<p><code>make; make install</code></p>
<p>添加相应的库，用<code>readelf -d busybox</code>，查看依赖的库，将交叉编译环境下sysroot/lib目录下库拷贝到/lib。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/c/datatype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/c/datatype/" class="post-title-link" itemprop="url">c data type</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：19:48:47" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <table>
<thead>
<tr>
<th align="center">Data Type</th>
<th align="center">ILP32</th>
<th align="center">LP32</th>
<th align="center">ILP64</th>
<th align="center">LP64</th>
<th align="center">LLP64</th>
</tr>
</thead>
<tbody><tr>
<td align="center">宏定义</td>
<td align="center">_</td>
<td align="center">_</td>
<td align="center">_</td>
<td align="center"><strong>LP64</strong></td>
<td align="center"><strong>LLP64</strong></td>
</tr>
<tr>
<td align="center">平台</td>
<td align="center">Win32 API  / Unix 和 Unix 类的系统 （Linux，Mac OS X）</td>
<td align="center">Win16 API</td>
<td align="center"></td>
<td align="center">Unix 和 Unix 类的系统 （Linux，Mac OS X)</td>
<td align="center">Win64 API</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32</td>
<td align="center">16</td>
<td align="center">64</td>
<td align="center">32</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">pointer</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">32</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">64</td>
<td align="center"></td>
</tr>
</tbody></table>
<ol>
<li>格式化打印，long使用%ld或%lx，指针使用%p</li>
<li>对于long类型，常量要加L，如：long a = 1L&lt;&lt;32</li>
<li>ssize_t在32位机器上等同与int，在64位机器上等同与long，size_t是无符号型的ssize_t。</li>
<li>指针大小在32位机器上是4字节，64位是8字节。指针p+1 = p + sizeof(p指向的数据类型)。</li>
<li>int, short, long都是signed的，char可能是signed的，也可能是unsigned的，由编译器决定，一般x86上是有符号，arm上是无符号的。</li>
</ol>
<p>stdint.h 里定义了一些数据类型的别名和范围。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span>    <span class="type">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span>      <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>            <span class="type">int32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span>       <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>    <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unsigned.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>        <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>   <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>         <span class="type">uint32_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>   <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>  <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Types for `void *&#x27; pointers.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span>            <span class="type">intptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>   <span class="type">uintptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>                 <span class="type">ntptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>        <span class="type">uintptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Limits of integral types.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Minimum of signed integral types.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT8_MIN        (-128)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT16_MIN       (-32767-1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT32_MIN       (-2147483647-1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT64_MIN       (-__INT64_C(9223372036854775807)-1)</span></span><br><span class="line"><span class="comment">/* Maximum of signed integral types.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT8_MAX        (127)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT16_MAX       (32767)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT32_MAX       (2147483647)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT64_MAX       (__INT64_C(9223372036854775807))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum of unsigned integral types.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT8_MAX        (255)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT16_MAX       (65535)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT32_MAX       (4294967295U)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> UINT64_MAX       (__UINT64_C(18446744073709551615))</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/media/audio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/media/audio/" class="post-title-link" itemprop="url">audio</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 15:23:17" itemprop="dateModified" datetime="2022-06-08T15:23:17+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/audio/" itemprop="url" rel="index"><span itemprop="name">audio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="声音"><a href="#声音" class="headerlink" title="声音"></a>声音</h3><p>声音三要素：音调、响度、音色。<br>-　音调：声音的高低，由频率决定，频率越高音调越高。<br>-　响度：又称音量、音强，由振幅和距离声源的距离决定。<br>-　音色：又称音品，由发声物体本身材料、结构决定。</p>
<p>分贝用于度量声音强度，单位是dB。</p>
<p><img src="/images/media/audio/dB.png" alt="分贝"></p>
<h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>采样率（sample rate）表示单位时间内对声音信号的采样次数，单位Hz。在当今的主流采集卡上，采样频率一般共分为 22.05KHz、44.1KHz、48KHz三个等级，对于高于48KHz的采样频率人耳已无法辨别出来了。</p>
<p><img src="/images/media/audio/sample_rate.png" alt="采样率"></p>
<h3 id="位深度"><a href="#位深度" class="headerlink" title="位深度"></a>位深度</h3><p>位深度也叫采样位数就是采样值用多少位0和1来表示，也叫采样精度，代表取样中对声音强度记录的精细程度。音频的位深度决定动态范围。采样声波时，为每个采样指定最接近原始声波振幅的振幅值。较高的位深度可提供更多可能的振幅值，产生更大的动态范围、更低的噪声基准和更高的保真度。</p>
<p><img src="/images/media/audio/bit_deep.png" alt="位深"></p>
<h3 id="声道"><a href="#声道" class="headerlink" title="声道"></a>声道</h3><p>声道（channel）分为单声道mono；立体声stereo；还可以是多声道，叫环绕立体声。如果是单声道的文件，采样数据按时间的先后顺序依次存入。如果是双声道的文件，采样数据按时间先后顺序交叉的存入。</p>
<p><img src="/images/media/audio/pcm.png" alt="PCM格式"></p>
<h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><p>比特率（bitrate）也叫码率，表示压缩编码后每秒的音频数据量大小。比特率 = 采样率 x 采样精度 x 声道数（单位kbps，这里的k为1000）</p>
<h3 id="音频帧"><a href="#音频帧" class="headerlink" title="音频帧"></a>音频帧</h3><p>音频数据是流式的，本身没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的。</p>
<h3 id="码率模式"><a href="#码率模式" class="headerlink" title="码率模式"></a>码率模式</h3><p>VBR（VariableBitrate）动态比特率。也就是没有固定的比特率，压缩软件在压缩时根据音频数据即时确定使用什么比特率。这是新发展的算法，他们将一首歌的复杂部分用高Bitrate编码，简单部分用低Bitrate编码。主意虽然不错，可惜新编码器的VBR算法很差，音质与CBR相去甚远。幸运的是， Lame完美地优化了VBR算法，使之成为MP3的最佳编码模式。这是以质量为前提兼顾文件大小的方式时推荐的编码模式。</p>
<p>ABR（Average Bitrate）平均比特率，是VBR的一种插值参数。Lame针对CBR不佳的文件体积比和VBR生成文件大小不定的特点独创了这种编码模式。ABR也被称为“Safe VBR”，它是在指定的平均Bitrate内，以每50帧（30帧约1秒）为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量。举例来说，当指定用192kbps ABR对一段wav文件进行编码时，Lame会将该文件的85%用192kbps固定编码，然后对剩余15%进行动态优化：复杂部分用高于192kbps 来编码、简单部分用低于192kbps来编码。与192kbps CBR相比，192kbps ABR在文件大小上相差不多，音质却提高不少。ABR编码在速度上是VBR编码的2到3倍，在128-256kbps范围内质量要好于CBR。可以做为 VBR和CBR的一种折衷选择。</p>
<p>CBR（ConstantBitrate），常数比特率，指文件从头到尾都是一种位速率。相对于VBR和ABR来讲，它压缩出来的文件体积很大，但音质却不会有明显的提高。</p>
<h2 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h2><p>根据编码方式的不同，音频编码技术分为三种：波形编码、参数编码和混合编码。波形编码的话音质量高，但编码速率也很高；参数编码的编码速率很低，产生的合成语音的音质不高；混合编码使用参数编码技术和波形编码技术，编码速率和音质介于它们之间。</p>
<p> PCM 即脉冲编码调制(Pulse Code Modulation)。 在PCM 过程中，将输入的模拟信号进行采样、量化和编码，用二进制进行编码的数来代表模拟信号的幅度；接收端再将这些编码还原为原来的模拟信号。</p>
<h3 id="音频数据格式"><a href="#音频数据格式" class="headerlink" title="音频数据格式"></a>音频数据格式</h3><p>PCM数据是最原始的音频数据完全无损，所以PCM数据虽然音质优秀但体积庞大，为了解决这个问题先后诞生了一系列的音频格式，这些音频格式运用不同的方法对音频数据进行压缩，其中有无损压缩（WAV，PCM，ALS，TAK，WavPack　ALAC、APE、FLAC）和有损压缩（MP3、AAC、OGG、WMA）两种。</p>
<h4 id="WAV"><a href="#WAV" class="headerlink" title="WAV"></a>WAV</h4><p>WAV是WaveFom的简写，也称为波形文件，可直接存储声音波形。WAV格式支持MSADPCM、CCITT A律、CCITT μ律和其他压缩算法，支持多种音频位数、采样频率和声道；但其文件尺寸较大，多用于存储简短的声音片段</p>
<h4 id="MIDI"><a href="#MIDI" class="headerlink" title="MIDI"></a>MIDI</h4><p>MIDI是Musical InstrumentDigital Interface的缩写，又称作乐器数字接口，是数字音乐/电子合成乐器的统一国际标准。它定义了计算机音乐程序、数字合成器及其它电子设备交换音乐信号的方式，规定了不同厂家的电子乐器与计算机连接的电缆和硬件及设备间数据传输的协议，可以模拟多种乐器的声音。MIDI文件就是MIDI格式的文件，在MIDI文件中存储的是一些指令。把这些指令发送给声卡，由声卡按照指令将声音合成出来。</p>
<h4 id="WMA"><a href="#WMA" class="headerlink" title="WMA"></a>WMA</h4><p>Windows Media Audio是微软公司开发的一种声音文件格式，也叫波形声音文件，压缩率低。 所需频宽 320～112kbps（压缩10～12倍），当Bitrate小于128K时，WMA最为出色且编码后得到的音频文件很小 ，当Bitrate大于128K时，WMA音质损失过大。WMA标准不开放。</p>
<h4 id="MP1"><a href="#MP1" class="headerlink" title="MP1"></a>MP1</h4><p>MPEG-1 audio layer 1声音压缩编码是国际上第一个高保真声音数据压缩的国际标准，编码简单，用于数字盒式录音磁带，2声道，VCD中使用的音频压缩方案就是MPEG-1层Ⅰ。所需频宽：384kbps（压缩4倍）。压缩方式相对时域压缩技术而言要复杂得多，同时编码效率、声音质量也大幅提高，编码延时相应增加。可以达到“完全透明”的声音质量（EBU音质标准）。</p>
<h4 id="MUSICAM"><a href="#MUSICAM" class="headerlink" title="MUSICAM"></a>MUSICAM</h4><p>MPEG-1 audio layer 2（MP2），所需频宽：256～192kbps（压缩6～8倍），算法复杂度中等，用于数字音频广播(DAB)和VCD等，2声道，而MUSICAM由于其适当的复杂程度和优秀的声音质量，在数字演播室、DAB、DVB等数字节目的制作、交换、存储、传送中得到广泛应用。</p>
<h4 id="MP3"><a href="#MP3" class="headerlink" title="MP3"></a>MP3</h4><p>MP3全称是动态影像专家压缩标准音频层面3（Moving Picture Experts Group Audio Layer III）。是一种有损压缩的音频格式，设计这种格式的目的就是为了大幅度的减小音频的数据量，它舍弃PCM音频数据中人类听觉不敏感的部分。所需频宽：128～112kbps（压缩10～12倍），编码复杂，用于互联网上的高质量声音的传输，如MP3音乐压缩10倍，2声道。MP3是在综合MUSICAM和ASPEC的优点的基础上提出的混合压缩技术，在当时的技术条件下，MP3的复杂度显得相对较高，编码不利于实时，但由于MP3在低码率条件下高水准的声音质量，使得它成为软解压及网络广播的宠儿。优点：压缩比高，适合用于互联网上的传播，缺点：MP3在128KBitrate及以下时，会出现明显的高频丢失。</p>
<p>所谓的MP3也就是指的是MPEG标准中的音频部分，也就是MPEG音频层。根据压缩质量和编码处理的不同分为3层，分别对应mp1/mp2/mp3这3种声音文件。需要提醒大家注意的地方是：MPEG音频文件的压缩是一种有损压缩，MPEG3音频编码具有10：1~12：1的高压缩率，同时基本保持低音频部分不失真，但是牺牲了声音文件中12KHz到16KHz高音频这部分的质量来换取文件的尺寸，相同长度的音乐文件，用*.mp3格式来储存，一般只有*.wav文件的1/10，而音质要次于CD格式或WAV格式的声音文件。由于其文件尺寸小，音质好;所以在它问世之初还没有什么别的音频格式可以与之匹敌，因而为*.mp3格式的发展提供了良好的条件。</p>
<p>MP3格式中的数据通常由两部分组成，一部分为ID3用来存储歌名、演唱者、专辑、音轨数等信息，另一部分为音频数据。音频数据部分以帧(frame)为单位存储，每个音频都有自己的帧头，如图所示就是一个MP3文件帧结构图（图片同样来自互联网）。MP3中的每一个帧都有自己的帧头，其中存储了采样率等解码必须的信息，所以每一个帧都可以独立于文件存在和播放，这个特性加上高压缩比使得MP3文件成为了音频流播放的主流格式。帧头之后存储着音频数据，这些音频数据是若干个PCM数据帧经过压缩算法压缩得到的，对CBR的MP3数据来说每个帧中包含的PCM数据帧是固定的，而VBR是可变的。</p>
<p><img src="/images/media/audio/mp3_format.webp" alt="mp3文件格式"></p>
<h4 id="AAC"><a href="#AAC" class="headerlink" title="AAC"></a>AAC</h4><p>AAC实际上是高级音频编码(Advanced Audio Coding–AAC)的缩写。AAC是由Fraunhofer IIS-A、杜比和AT&amp;T共同开发的一种音频格式，它是MPEG-2规范的一部分。成为继MPEG-2音频标准（ISO/IEC13818-3）之后的新一代音频压缩标准。制定者：MPEG，所需频宽：96-128 kbps。</p>
<p>AAC所采用的运算法则与MP3的运算法则有所不同，AAC通过结合其他的功能来提高编码效率。AAC的音频算法在压缩能力上远远超过了以前的一些压缩算法。它还同时支持多达48个音轨、15个低频音轨、更多种采样率和比特率、多种语言的兼容能力、更高的解码效率。总之，AAC可以在比MP3文件缩小30%的前提下提供更好的音质。</p>
<p>AAC支持多声道，可提供1到48路之间任意数目的音频声道组合、包括15路低频效果声道、配音/多语音声道，以及15路数据。它可同时传送16套节目，每套节目的音频及数据结构可任意规定。最高支持96KHz的采样频率。</p>
<p>AAC主要可能的应用范围集中在因特网网络传播、数字音频广播，包括卫星直播和数字AM、以及数字电视及影院系统等方面。AAC使用了一种非常灵活的熵编码核心去传输编码频谱数据。具有48个主要音频通道，16 个低频增强通道，16 个集成数据流, 16 个配音，16 种编排。</p>
<h4 id="GSM-AMR"><a href="#GSM-AMR" class="headerlink" title="GSM-AMR"></a>GSM-AMR</h4><p>GSM-ASM(Adaptive Multi-Rate)是一种广泛使用在GPRS和W-CDMA网络上的音频标准。在规范ETSI GSM06.90中对GSM-AMR进行了定义。AMR语音编码是GSM 2+和WCDMA的默认编码标准，是第三代无线通讯系统的语音编码标准。GSM-AMR标准基于ACELP（代数激励线性预测）编码。它能在广泛的传输条件下提供高品质的语音效果。制定者：飞利浦，所需频宽：8Kbps(4.75 Kbps~12.2 Kbps)，可以对语音进行替换和消音，平滑噪音，支持间断式传输，对语音进行动态侦查。能在各种网络条件下提供优质的语音效果。</p>
<h4 id="EVRC"><a href="#EVRC" class="headerlink" title="EVRC"></a>EVRC</h4><p>Enhanced Variable Rate Coder，增强型可变速率编码器广泛使用于CDMA网络。EVRC标准遵循规范TIA IS-127的内容。EVRC编码基于RCELP（松弛码激励线性预测）标准。该编码可以以Rate 1（171bits/packet），Rate 1/2（80bits/packet）或是Rate 1/8（16bits/packet）的容量进行操作。在要求下，它也能产生空包（0bits/packet）。制定者：Qualcomm，所需频宽：8Kbps或13Kbps，支持三种码率（9.6 Kbps, 4.8 Kbps 和 1.2 Kbps），噪声抑制，邮件过滤。能在各种网络条件下提供优质的语音效果。</p>
<h4 id="ADPCM"><a href="#ADPCM" class="headerlink" title="ADPCM"></a>ADPCM</h4><p>ADPCM(adaptive difference pulse code modulation，　自适应差分PCM)综合了APCM的自适应特性和DPCM系统的差分特性，是一种性能比较好的波形编码。它的核心想法是利用自适应的思想改变量化阶的大小，即使用小的量化阶(step-size)去编码小的差值，使用大的量化阶去编码大的差值；使用过去的样本值估算下一个输入样本的预测值，使实际样本值和预测值之间的差值总是最小。针对 16bit (或者更高) 声音波形数据的一种有损压缩算法, 它将声音流中每次采样的 16bit 数据以 4bit 存储, 所以压缩比 1:4. 而压缩/解压缩算法非常的简单, 所以是一种低空间消耗,高质量声音获得的好途径。制定者：ITU-T，所需频宽：32Kbps，优点：算法复杂度低，压缩比小（CD音质&gt;400kbps），编解码延时最短。，缺点：声音质量一般</p>
<h4 id="MP3Pro"><a href="#MP3Pro" class="headerlink" title="MP3Pro"></a>MP3Pro</h4><p>MP3Pro是由瑞典Coding科技公司开发的，其中包含了两大技术：一是来自于Coding科技公司所特有的解码技术，二是由MP3的专利持有者法国汤姆森多媒体公司和德国Fraunhofer集成电路协会共同研究的一项译码技术。MP3Pro可以在基本不改变文件大小的情况下改善原先的MP3音乐音质。它能够在用较低的比特率压缩音频文件的情况下，最大程度地保持压缩前的音质。</p>
<h4 id="RealAudio"><a href="#RealAudio" class="headerlink" title="RealAudio"></a>RealAudio</h4><p>RealAudio是由Real Networks公司推出的一种文件格式，最大的特点就是可以实时传输音频信息，尤其是在网速较慢的情况下，仍然可以较为流畅地传送数据，因此RealAudio主要适用于网络上的在线播放。现在的RealAudio文件格式主要有RA(RealAudio)、RM（RealMedia，RealAudio G2）、RMX(RealAudio Secured)等三种，这些文件的共同性在于随着网络带宽的不同而改变声音的质量，在保证大多数人听到流畅声音的前提下，令带宽较宽敞的听众获得较好的音质。</p>
<p>RA采用的是有损压缩技术，由于它的压缩比相当高，因此音质相对较差，但是文件也是最小的，因此在高压缩比条件下表现好，但若在中、低压缩比条件下时，表现却反而不及其他同类型档案格式了。此外RA可以随网络带宽的不同而改变声音质量，以使用户在得到流畅声音的前提下，尽可能高地提高声音质量。由于RA格式的这些特点，因此特别适合在网络传输速度较低的互联网上使用，互联网上许多的网络电台、音乐网站的歌曲试听都在使用这种音频格式。</p>
<h4 id="Ogg-Vorbis"><a href="#Ogg-Vorbis" class="headerlink" title="Ogg Vorbis"></a>Ogg Vorbis</h4><p>Ogg Vorbis 是一种新的音频压缩格式，类似于MP3等现有的音乐格式。但有一点不同的是，它是完全免费、开放和没有专利限制的。Vorbis 是这种音频压缩机制的名字，而Ogg则是一个计划的名字，该计划意图设计一个完全开放性的多媒体系统。VORBIS也是有损压缩，但通过使用更加先进的声学模型去减少损失，因此，同样位速率(Bit Rate)编码的OGG与MP3相比听起来更好一些。</p>
<h4 id="APE"><a href="#APE" class="headerlink" title="APE"></a>APE</h4><p>APE是Monkey’s Audio提供的一种无损压缩格式,是一种无损压缩音频格式,在音质不降低的前提下，大小压缩到传统无损格式 WAV 文件的一半,而且可以无须解压而直接播放。APE的采样率最高可达1400kbps，接近于音乐CD格式。</p>
<h4 id="FLAC"><a href="#FLAC" class="headerlink" title="FLAC"></a>FLAC</h4><p>FLAC即是Free Lossless AudioCodec的缩写，是一套著名的自由音频无损压缩编码，其特点是无损压缩。</p>
<h2 id="音频处理"><a href="#音频处理" class="headerlink" title="音频处理"></a>音频处理</h2><p>音频处理是指对PCM数据进行处理，从而达到想要的效果。对音频编码前的PCM数据进行处理叫音频前处理，主要用于语音中，来去除各种干扰，使声音更清晰，主要有回声消除、噪声抑制、增益控制等。对音频解码后的PCM数据进行处理叫音频后处理，主要用于音乐中，来产生各种音效，使音乐更动听，主要有均衡器、混响等。</p>
<h3 id="重采样"><a href="#重采样" class="headerlink" title="重采样"></a>重采样</h3><p>音频输入和音频输出模块支持对音频数据实施重采样。如果启用 AI 重采样功能，内部将会先执行重采样处理，再返回处理后的数据。如果启用了 AO 重采样功能，则音频数据在发送给 AO 之前，内部先执行重采样处理，处理完成后再发送给 AO 通道进行播放。重采样仅支持处理单声道。</p>
<h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><p>ANR 为语音降噪（ Audio Noise Reduction ）模块，主要工作在需要去除外界噪声，保<br>留语音输入的场景下。与 RNR 算法比起来， ANR 更讲究噪声处理的干净程度。 ANR 会滤除一些环境声音，主要保留语音数据，并会带来一定的细节丢失。所以 ANR 算法更适用于 NVR 和 IPC<br>场景。在这两个场景下，我们更希望能够着重保留人声，滤除其他噪声。</p>
<h3 id="RNR"><a href="#RNR" class="headerlink" title="RNR"></a>RNR</h3><p>RNR 为录音噪声消除（ Record Noise Reduction ）模块，主要工作在需要去除环境噪声，但保留小信号输入的场景下。与 ANR 算法比起来， RNR 更讲究细节输入（小信号）的保留度， RNR 会在降噪的同时保留小信号的输入，所以降噪力度会低一点，但能更多的保留现场声音，真实还原场景，适用于运动 DV 场景。</p>
<h3 id="AEC"><a href="#AEC" class="headerlink" title="AEC"></a>AEC</h3><p>AEC 为回声抵消（ Acoustic Echo Cancellation ）模块，主要工作在需要进行去除回声的<br>场景下：如 IPC 对讲，远端语音数据在 AO 设备上播放，此时在本地通过 MIC 采集语<br>音数据，它支持消除录制的语音数据中的 AO 设备播放的声音（回声）。</p>
<h3 id="AGC"><a href="#AGC" class="headerlink" title="AGC"></a>AGC</h3><p>AGC 为自动增益控制（ Auto Gain Control ）模块，主要负责增益控制输出电平，在声音输入音量有大小变化时，能将输出音量控制在比较一致的范围内，主要工作在需要保证声音不至于过大或过小的场景下。AGC 更多起到的作用是放大输入源的声音，以保证音源过小时，经过算法处理后的声音依然很大。</p>
<h3 id="DRC"><a href="#DRC" class="headerlink" title="DRC"></a>DRC</h3><p>DRC 为动态压缩控制（ Dynamic Range Control ）模块，负责控制输出电平，将输出增益控制在一个范围，主要工作在需要保证声音不至于过大或过小的场景下。DRC 与 AGC 作用相似，但算法实现及调节力度不同。其配合 RNR 使用在运动 DV 场景，与 AEC/ANR 互斥。</p>
<h3 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h3><p>HDR 为高动态范围（ High Dynamic Range ）模块，主要用于 Codec 输入音量控制，通过动态调节 Codec 增益控制 Codec 音量在合理范围内，保证声音不至于过大或过小。</p>
<h3 id="HPF"><a href="#HPF" class="headerlink" title="HPF"></a>HPF</h3><p>HPF 为高通滤波（ high-pass filte ）模块，主要负责去除低频噪声。</p>
<h3 id="PEQ"><a href="#PEQ" class="headerlink" title="PEQ"></a>PEQ</h3><p>PEQ 为参量均衡器（ Parameter Equalizer ）模块，主要对音频数据进行均衡处理，以调节音频数据中各频段声音的增益。PEQ 与 EQ 均为均衡处理器，但是 PEQ 调节方式更灵活，适用于运动 DV 场景。</p>
<h3 id="EQ"><a href="#EQ" class="headerlink" title="EQ"></a>EQ</h3><p>EQ 模块为均衡处理器（ Equalizer ）模块，主要对音频数据进行均衡处理，以调节音频数据中各频段声音的增益。</p>
<p>均衡器的调整方法：</p>
<ul>
<li>超低音： 20Hz-40Hz，适当时声音强而有力。能控制雷声、低音鼓、管风琴和贝司的声音。过度提升会使音乐变得混浊不清</li>
<li>低音： 40Hz-150Hz，是声音的基础部份，其能量占整个音频能量的70%，是表现音乐风格的重要成份。适当时，低音张弛得宜，声音丰满柔和，不足时声音单薄，150Hz，过度提升时会使声音发闷，明亮度下降，鼻音增强</li>
<li>中低音： 150Hz-500Hz，是声音的结构部分，人声位于这个位置，不足时，演唱声会被音乐淹没，声音软而无力，适当提升时会感到浑厚有力，提高声音的力度和响度。提升过度时会使低音变得生硬，300Hz处过度提升3-6dB，如再加上混响，则会严重影响声音的清晰度</li>
<li>中音： 500Hz-2KHz，包含大多数乐器的低次谐波和泛音，是小军鼓和打击乐器的特征音。适当时声音透彻明亮，不足时声音朦胧。过度提升时会产生类似电话的声音</li>
<li>中高音： 2KHz-5KHz，是弦乐的特征音（拉弦乐的弓与弦的摩搡声，弹拔乐的手指触弦的声音某）。不足时声音的穿透力下降，过强时会掩蔽语言音节的识别</li>
<li>高音： 7KHz-8KHz，是影响声音层次感的频率。过度提升会使短笛、长笛声音突出，语言的齿音加重和音色发毛</li>
<li>极高音： 8KHz-10KHz 合适时，三角铁和立*的金属感通透率高，沙钟的节奏清晰可辨。过度提升会使声音不自然，易烧毁高频单元。</li>
</ul>
<h2 id="耳机插头"><a href="#耳机插头" class="headerlink" title="耳机插头"></a>耳机插头</h2><p><img src="/images/media/audio/hp1.png" alt="耳机插头"></p>
<p><img src="/images/media/audio/hp2.png" alt="耳机插头"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">176</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
