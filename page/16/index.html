<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/16/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/shell/" class="post-title-link" itemprop="url">shell</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell/" itemprop="url" rel="index"><span itemprop="name">shell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>unset 命令用于取消变量或取消变量赋值。</p>
<p><code>$?</code> 可以来检查前一命令的结束状态。如果是 0，说明前一个命令执行成功，否则执行失败。</p>
<p>反引号将命令括起来执行。格式：`pwd`，可以得到这个命令的返回值。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [表达式]; then </span><br><span class="line">    ...</span><br><span class="line">else </span><br><span class="line">    ...</span><br><span class="line">fi </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>整数比较</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-eq 等于，如: if [ &quot;$a&quot; -eq &quot;$b&quot; ]   </span><br><span class="line">-ne 不等于，如: if [ &quot;$a&quot; -ne &quot;$b&quot; ]   </span><br><span class="line">-gt 大于，如: if [ &quot;$a&quot; -gt &quot;$b&quot; ]   </span><br><span class="line">-ge 大于等于，如: if [ &quot;$a&quot; -ge &quot;$b&quot; ]   </span><br><span class="line">-lt 小于，如: if [ &quot;$a&quot; -lt &quot;$b&quot; ]   </span><br><span class="line">-le 小于等于，如: if [ &quot;$a&quot; -le &quot;$b&quot; ]   </span><br><span class="line">&lt;   小于(需要双括号)，如: ((&quot;$a&quot; &lt; &quot;$b&quot;))   </span><br><span class="line">&lt;=  小于等于(需要双括号)，如: ((&quot;$a&quot; &lt;= &quot;$b&quot;))   </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">  大于(需要双括号)，如: ((<span class="string">&quot;<span class="variable">$a</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$b</span>&quot;</span>))</span>   </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">=  大于等于(需要双括号)，如: ((<span class="string">&quot;<span class="variable">$a</span>&quot;</span> &gt;= <span class="string">&quot;<span class="variable">$b</span>&quot;</span>))</span>   </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符串比较</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">= 等于，如: if [ &quot;$a&quot; = &quot;$b&quot; ]   </span><br><span class="line">== 等于，如: if [ &quot;$a&quot; == &quot;$b&quot; ]，与=等价 </span><br><span class="line">!= 不等于，if [ &quot;$a&quot; != &quot;$b&quot; ]</span><br><span class="line">&lt; 小于，如：</span><br><span class="line">  if [[ &quot;$a&quot; &lt; &quot;$b&quot; ]]</span><br><span class="line">  if [ &quot;$a&quot; \&lt; &quot;$b&quot; ]         #在[]结构中需要对&lt;进行转义</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">大于，如：</span></span><br><span class="line">  if [[ &quot;$a&quot; &gt; &quot;$b&quot; ]]</span><br><span class="line">  if [ &quot;$a&quot; \&gt; &quot;$b&quot; ]         #在[]结构中需要对&gt;进行转义</span><br><span class="line">-z 字符串为null，即长度为0</span><br><span class="line">-n 字符串不为null，即长度不为0</span><br></pre></td></tr></table></figure>

<p><strong>比较两个字符串是否相等的办法</strong></p>
<blockquote>
<p>if [ “$test”x = “test”x ]; then</p>
</blockquote>
<p>这里的关键有几点：</p>
<ol>
<li>使用单个等号，等号两边各有一个空格。</li>
<li>注意到”$test”x最后的x，这是特意安排的，因为当$test为空的时候，上面的表达式就变成了x = testx，显然是不相等的。而如果没有这个x，表达式就会报错：[: =: unary operator expected。</li>
</ol>
<p><strong>==的功能在<code>[[]]</code>和<code>[]</code>中的行为是不同的</strong></p>
<ul>
<li>[[ $a == z* ]]   # 如果$a以”z”开头(模式匹配)那么将为true</li>
<li>[[ $a == “z*” ]] # 如果$a等于z*(字符匹配),那么结果为true</li>
<li>[ $a == z* ] # File globbing 和word splitting将会发生</li>
<li>[ “$a” == “z” ] # 如果$a等于z(字符匹配),那么结果为true</li>
</ul>
<h2 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h2><p>任何输入到这个“设备”的数据都将被直接丢弃。最常用的用法是把不需要的输出重定向到这个文件。</p>
<ul>
<li>禁止标准输出，文件内容丢失，而不会输出到标准输出</li>
</ul>
<blockquote>
<p>cat $filename &gt;/dev/null</p>
</blockquote>
<ul>
<li>禁止标准错误</li>
</ul>
<blockquote>
<p>cat $filename 2&gt;/dev/null</p>
</blockquote>
<ul>
<li>禁止标准输出和标准错误的输出</li>
</ul>
<blockquote>
<p>cat $filename 2&gt;/dev/null &gt;/dev/null</p>
</blockquote>
<blockquote>
<p>cat $filename &amp;&gt;/dev/null</p>
</blockquote>
<ul>
<li>清空文件的内容</li>
</ul>
<blockquote>
<p>cat /dev/null &gt; /var/log/messages</p>
</blockquote>
<ul>
<li>隐藏cookie而不再使用</li>
</ul>
<blockquote>
<p>ln -s /dev/null ~/.netscape/cookies</p>
</blockquote>
<h2 id="dev-zero"><a href="#dev-zero" class="headerlink" title="/dev/zero"></a>/dev/zero</h2><p>是一个伪文件，但它实际上产生连续不断的null的流（二进制的零流，而不是ASCII型的）。写入它的输出会丢失不见，/dev/zero主要的用处是用来创建一个指定长度用于初始化的空文件，像临时交换文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/nfs_tftp_samb_ssh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/nfs_tftp_samb_ssh/" class="post-title-link" itemprop="url">install ssh samba nfs tftp service</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>SSH(Secure Shell)，是建立在应用层和传输层基础上的安全协议，可以通过网络登录远程系统，能够有效防<br>止远程管理过程中的信息泄露问题。</p>
<p>1.安装ssh服务</p>
<blockquote>
<p>sudo apt-get install openssh-server</p>
</blockquote>
<p>2.启动ssh服务</p>
<blockquote>
<p>sudo service ssh start</p>
</blockquote>
<h2 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h2><p>1.安装Samba</p>
<blockquote>
<p>sudo apt-get install samba samba-common</p>
</blockquote>
<p>2.创建分享目录，配置samba，修改<code>/etc/samba/smb.conf</code>，用<code>testparm</code>命令检查配置文件的语法错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">    allow insecure wide links = yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[homes]</span><br><span class="line">    create mask = 0775</span><br><span class="line">        directory mask = 0775</span><br><span class="line">        valid users = %S</span><br><span class="line">        read only = no</span><br><span class="line">        writable = yes</span><br><span class="line">        browseable = no</span><br><span class="line">        follow symlinks = yes</span><br><span class="line">        wide links = yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[share]</span><br><span class="line">    comment = share folder</span><br><span class="line">        path = /share</span><br><span class="line">        create mask = 0777</span><br><span class="line">        directory mask = 0777</span><br><span class="line">        read only = no</span><br><span class="line">        writable = yes</span><br><span class="line">        public = yes</span><br><span class="line">        browseable = yes</span><br></pre></td></tr></table></figure>

<p>3.添加登入共享文件夹的用户名和密码，其中用户名必须为linux中的用户。</p>
<blockquote>
<p>sudo smbpasswd -a root</p>
</blockquote>
<p>4.重启samba服务</p>
<blockquote>
<p>service smbd restart</p>
</blockquote>
<h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2><p>NFS(Network File-System)网络文件系统，可以通过网络让不同机器、不同系统之间可以实现文件共享。</p>
<p>1.安装nfs相关软件</p>
<blockquote>
<p>sudo apt-get install nfs-kernel-server nfs-common</p>
</blockquote>
<p>2.修改配置，添加共享目录，<code>sudo vim /etc/exports</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/nfsroot *(rw,sync,no_root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>/nfsroot  ：共享的目录</p>
</li>
<li><p>*：指定哪些用户可以访问，<br>*所有可以ping同该主机的用户；</p>
</li>
</ul>
<p>192.168.1.* 指定网段，在该网段中的用户可以挂载；<br>192.168.1.12 只有该用户能挂载；</p>
<ul>
<li>(ro,sync,no_root_squash)： 权限，<br>ro : 只读；<br>rw : 读写；<br>sync : 数据同步写入内存和硬盘；<br>no_root_squash: 不降低root用户的权限；</li>
</ul>
<p>3.创建共享目录，并设置目录权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /nfsroot</span><br><span class="line">sudo chmod -R 777 /nfsroot</span><br><span class="line">sudo chown –R nobody /nfsroot</span><br></pre></td></tr></table></figure>

<p>4.重新启动nfs服务</p>
<blockquote>
<p>sudo service nfs-kernel-server restart</p>
</blockquote>
<p>5.挂载自测</p>
<blockquote>
<p>mount -t nfs localhost:/nfsroot ~/test -o nolock</p>
</blockquote>
<h2 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h2><p>TFTP(Trivial File Transfer Protocol,简单文件传输协议)是用来在客户机和服务器之间进行简单文件传输的协议。</p>
<p>1.安装tftp服务</p>
<blockquote>
<p>sudo apt-get install xinetd tftp tftpd</p>
</blockquote>
<p>2.新建/etc/xinetd.d/tftp配置文件，指定的用户和tftp服务器根路径，若不存在，则需创建该目录，并设置访问权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">service tftp</span><br><span class="line">&#123;</span><br><span class="line">    socket_type = dgram</span><br><span class="line">    wait = yes </span><br><span class="line">    user = luou</span><br><span class="line">    protocol = udp </span><br><span class="line">    server = /usr/sbin/in.tftpd</span><br><span class="line">    server_args = -s /tftp</span><br><span class="line">    disable = no</span><br><span class="line">    per_source = 11</span><br><span class="line">    cps =100 2</span><br><span class="line">    flags =IPv4</span><br></pre></td></tr></table></figure>

<p>3.重启xinetd服务</p>
<blockquote>
<p>sudo /etc/init.d/xinetd restart</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/linux_file_mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/linux_file_mode/" class="post-title-link" itemprop="url">linux file mode</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。</p>
<p>w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。</p>
<p>x(execute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。</p>
<p>s或S（SUID,Set UID）：使文件在执行时临时拥有文件所有者的权限。在设置s权限时文件属主、属组必须先设置x权限，否则s权限不能生效。当我们ls -l时看到rwS，大写S说明s权限未生效。passwd便是个设置了SUID的程序，普通用户无读写/etc/shadow文件的权限也可以修改自己的密码。</p>
<p>t或T（Sticky）：t权限一般只用在目录上，任何的用户都能够在这个目录下创建文档，但只能删除自己创建的文档，这就对任何用户能写的目录下的用户文档启到了保护的作用。可通过<code>chmod +t</code>  <code>chmod -t</code>  <code>chmod 1777</code>来设置。</p>
<p>i不可修改权限。通过<code>chattr +i</code>  <code>chattr -i</code>来设置，用<code>lsattr</code>命令查看。</p>
<p>a只追加权限， 对于日志系统很好用，让目标文件只能追加，不能删除，而且不能通过编辑器追加。通过<code>chattr +a</code>  <code>chattr -a</code>来设置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/linux_etc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/linux_etc/" class="post-title-link" itemprop="url">linux /etc/passwd config</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h2><p>/etc/passwd该文件对所有用户可读。文件中的每个用户都有一个对应的记录行，记录着这个用户的一下基本属性，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<p><strong>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</strong></p>
<ul>
<li>用户名(login_name):是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</li>
<li>口令(passwd):一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</li>
<li>用户标识号(UID):是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。取值范围是0-65535。0是超级用户root的标识号，1-99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</li>
<li>组标识号(GID):字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。</li>
<li>注释性描述(users):字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</li>
<li>主目录(home_directory):也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</li>
<li>登录Shell(Shell):用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</li>
</ul>
<h2 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h2><p>/etc/shadow文件中的记录行与/etc/passwd中的一一对应，是passwd文件的一个影子。它由pwconv命令根据/etc/passwd中的数据自动产生。但是/etc/shadow文件只有系统管理员才能够进行修改和查看。</p>
<p><strong>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</strong></p>
<ol>
<li>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</li>
<li>“口令”字段存放的是加密后的用户口令字，格式为<code>$id$salt$hashed</code>，则表示该用户密码正常。其中<code>$id$</code>的id表示密码的加密算法，<code>$salt$</code>是加密时使用的salt，hashed才是真正的密码部分。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果为空，则对应用户没有口令，登录时不需要口令；</span><br><span class="line">* 代表帐号被锁定；</span><br><span class="line">!! 表示这个密码已经过期了；</span><br><span class="line">$1$ 是用MD5加密；</span><br><span class="line">$2a$ 是用Blowfish加密；</span><br><span class="line">$2y$ 是另一算法长度的Blowfish</span><br><span class="line">$5$ 是用 SHA-256加密；</span><br><span class="line">$6$ 表示SHA-512算法</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCOLinux中，这个时间起点是1970年1月1日。</li>
<li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li>
<li>“最大时间间隔”指的是口令保持有效的最大天数。</li>
<li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
<h2 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h2><ul>
<li>组名：组的名称，可以将其视为与数值型组标识符相对应的人类可读(符号)标识符。</li>
<li>组密码：这里的 “x” 仅仅是密码标识，真正加密后的组密码默认保存在 /etc/gshadow 文件中。</li>
<li>组 ID (GID)：该组的数值型 ID。正常情况下,对应于组 ID 号 0，只定义一个名为 root的组。</li>
<li>用户列表：属于该组的用户名列表,之间以逗号分隔。</li>
</ul>
<h2 id="省略密码验证"><a href="#省略密码验证" class="headerlink" title="省略密码验证"></a>省略密码验证</h2><p>把/etc/passwd中的<code>root:x:0:0:root:/root:/bin/bash</code>，改为<code>root::0:0:root:/root:/bin/bash</code>，就可以了，就是去掉了里面的x，这样root用户就不用密码了。其他用户也一样。</p>
<h2 id="省略输入用户名"><a href="#省略输入用户名" class="headerlink" title="省略输入用户名"></a>省略输入用户名</h2><p>修改/etc/inittab</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1:2345:respawn:/sbin/agetty tty1 9600</span><br><span class="line">2:2345:respawn:/sbin/agetty tty2 9600</span><br><span class="line">3:2345:respawn:/sbin/agetty tty3 9600</span><br><span class="line">4:2345:respawn:/sbin/agetty tty4 9600</span><br><span class="line">5:2345:respawn:/sbin/agetty tty5 9600</span><br><span class="line">6:2345:respawn:/sbin/agetty tty6 9600</span><br></pre></td></tr></table></figure>

<p>表示系统可以有六个控制台，可以用ALT+(F1~F6)来切换。而/sbin/agetty就是一个登陆验证程序，执行它，会提示用户输入用户名和密码，然后启动一个指定的shell（在passwd文件中指定的）。所以，我们只需将其修改为不执行agettty，而是执行自己编写的一个脚本，就可以跳过用户名和密码的输入。修改如下：</p>
<blockquote>
<p>1:2345:respawn:/bin/autologin tty1 9600</p>
</blockquote>
<p>autologin脚本内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">/bin/login -f root</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/waitqueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/waitqueue/" class="post-title-link" itemprop="url">waitqueue</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/" itemprop="url" rel="index"><span itemprop="name">dev</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>阻塞操作是指在执行设备操作时，若不能获得资源，则挂起的进程进入休眠状态，直到等待的条件被满足，而非阻塞操作是直接返回，并不挂起。</p>
<p>等待队列用来同步对系统资源的访问，可实现进程阻塞。</p>
<h2 id="waitqueue"><a href="#waitqueue" class="headerlink" title="waitqueue"></a>waitqueue</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">void</span> *private;</span><br><span class="line">    <span class="type">wait_queue_func_t</span> func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>定义等待队列头</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init_waitqueue_head(&amp;<span class="built_in">queue</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAIT_QUEUE_HEAD(name) \</span></span><br><span class="line"><span class="meta">    wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)</span></span><br></pre></td></tr></table></figure>

<p><strong>定义等待队列</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAITQUEUE(name, tsk)                    \</span></span><br><span class="line"><span class="meta">    wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)</span></span><br></pre></td></tr></table></figure>

<p><strong>添加/移除等待队列到等待队列头</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> fastcall <span class="title function_">add_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span> *wait)</span>;</span><br><span class="line"><span class="type">void</span> fastcall <span class="title function_">remove_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span> *wait)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>等待事件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*有条件等待*/</span></span><br><span class="line">wait_event(<span class="built_in">queue</span>, condition)</span><br><span class="line">wait_event_interruptible(<span class="built_in">queue</span>, condition)</span><br><span class="line">wait_event_timeout(<span class="built_in">queue</span>, condition, timeout)</span><br><span class="line">wait_event_interruptible_timeout(<span class="built_in">queue</span>, condition, timeout)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*无条件等待 */</span></span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">sleep_on</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span>;</span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">interruptible_sleep_on</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span>;</span><br></pre></td></tr></table></figure>

<p>sleep_on()函数将目前进程的状态置成 TASK_UNINTERRUPTIBLE，并定义一个等待队列，之后把它附属到等待队列头 q，直到资源可获得，q引导的等待队列被唤醒。</p>
<p>interruptible_sleep_on()将进程的状态置成TASK_INTERRUPTIBLE，能被等待队列或者信号唤醒。</p>
<p><strong>唤醒队列</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="type">wait_queue_head_t</span> *<span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up_interruptible</span><span class="params">(<span class="type">wait_queue_head_t</span> *<span class="built_in">queue</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>wake_up()应该与 wait_event()或 wait_event_timeout()成对使用，而 wake_up_interruptible()则应与 wait_event_interruptible()或 wait_event_interruptible_timeout()成对使用。</p>
<p>wake_up()可唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 的进程，而 wake_up_interruptible()只能唤醒处于 TASK_INTERRUPTIBLE 的进程。</p>
<p><strong>进程状态切换</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING        0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE    2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __set_current_state(state_value)            \</span></span><br><span class="line"><span class="meta">    do &#123; current-&gt;state = (state_value); &#125; while (0)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_current_state(state_value)      \</span></span><br><span class="line"><span class="meta">    set_mb(current-&gt;state, (state_value))</span></span><br></pre></td></tr></table></figure>

<p>内核中使用<code>set_current_state()</code>函数或<code>__add_current_state()</code>函数来实现目前进程状态的改变，直接采用<code>current-&gt;state = TASK_UNINTERRUPTIBLE</code>类似的赋值语句也行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 改变进程状态为睡眠 */</span></span><br><span class="line">__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">schedule(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) <span class="comment">//如果是被信号唤醒</span></span><br><span class="line">&#123;</span><br><span class="line">    ret = -ERESTARTSYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是非阻塞访问，设备忙时，直接返回-EAGAIN。如果是阻塞访问，需要进行状态切换，通过调用schedule()函数来调度其他进程执行。唤醒后，需通过 signal_pending(current) 判断是否是信号唤醒，如果是则返回-ERESTARTSYS。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/lock/" class="post-title-link" itemprop="url">atomic mutex_lock semaphore</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/" itemprop="url" rel="index"><span itemprop="name">dev</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p>原子操作是一种不可以被打断的操作，需要硬件的支持。</p>
<p><strong>原子整形操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> counter;</span><br><span class="line">&#125; <span class="type">atomic_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义原子变量, 并初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_set</span><span class="params">(<span class="type">atomic_t</span> *v, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">atomic_t</span> v = ATOMIC_INIT(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">atomic_read</span>(<span class="type">atomic_t</span> *v);  <span class="comment">// 获取原子变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*原子变量进行加减操作,并返回新的值*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_add_return</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atomic_sub_return</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*原子变量自增/自减*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_inc(v)     (void) atomic_add_return(1, v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_dec(v)     (void) atomic_sub_return(1, v)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 原子变量增加减少 i */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_add(i, v)  (void) atomic_add_return(i, v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_sub(i, v)  (void) atomic_sub_return(i, v)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*原子变量执行自增、自减和减操作，测试其是否为0，为0返回true，否则返回 false*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_inc_and_test(v)  (atomic_add_return(1, v) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_dec_and_test(v)  (atomic_sub_return(1, v) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*原子变量自增自减操作,并返回新的值*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_inc_return(v)    (atomic_add_return(1, v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_dec_return(v)    (atomic_sub_return(1, v))</span></span><br></pre></td></tr></table></figure>

<p><strong>原子位操作</strong></p>
<p>原子位操作，可对数据的每一位进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置addr地址的第nr位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除addr地址的第nr位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*对addr地址的第nr位进行反置*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回addr地址的第nr位*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*先返回addr地址的第nr位，再执行相应bit操作*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_set_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_clear_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_and_change_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="type">const</span> volatil <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁(spin lock)是一种对临界资源进行互斥访问的手段。自旋锁主要针对SMP或单CPU但内核可抢占的情况，可以保证临界区不受别的CPU和本CPU 内的抢占进程打扰，但受到中断和底半部的影响。</p>
<p>自旋锁是一种<strong>忙等待</strong>，如果得不到锁，则会自旋在那里，不会引起调用者睡眠，因此只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。自旋锁锁定期间不能调用可能引起进程调度的函数，也不能递归使用，只允许一个持有者。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化自旋锁*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_init</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获得自旋锁*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尝试获得自旋锁，如果能立即获得锁，它获得锁并返回真；否则立即返回假，不再自旋*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">spin_trylock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*释放自旋锁*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上锁并关中断*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_irq</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解锁并开中断*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock_irq</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上锁并关底半部*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_bh</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解锁并开底半部*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock_bh</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure>

<p>自旋锁一般这样被使用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义一个自旋锁，然后初始化*/</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line">spin_lock_init(&amp;lock);</span><br><span class="line"></span><br><span class="line">spin_lock (&amp;lock); </span><br><span class="line">    <span class="comment">/* 临界区*/</span></span><br><span class="line">spin_unlock (&amp;lock); </span><br></pre></td></tr></table></figure>

<h3 id="读写自旋锁"><a href="#读写自旋锁" class="headerlink" title="读写自旋锁"></a>读写自旋锁</h3><p>读写自旋锁(rwlock)只能有1个写操作，但允许并发读。</p>
<h3 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h3><p>顺序锁(seqlock)是对读写锁的一种优化，读执行单元不必等待写执行单元完成写操作，写执行单元也不需要等待所有读执行单元完成读操作，写执行单元与写执行单元之间仍然是互斥的。如果读执行单元在读操作期间，写执行单元已经发生了写操作，那么读执行单元必须重新读取数据，以便确保得到的数据是完整的。</p>
<p>顺序锁要求被保护的共享资源不含有指针，因为写执行单元可能使得指针失效，但读执行单元如果正要访问该指针，将导致oops。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量(semaphore)是一种用于保护临界区的方法，只有得到信号量的进程才能执行临界区代码。当获取不到信号量时，进程会将自身加入一个等待队列中去<strong>睡眠</strong>，当信号量释放后才被唤醒。</p>
<p>信号量的实现依赖于自旋锁和等待队列，为了保证信号量结构存取的原子性，在多CPU中需要自旋锁来互斥。</p>
<p>信号量是进程级的，会导致进程睡眠，睡眠需要进程上下文切换，开销也很大，因此只有当进程占用资源时间较长时，用信号量比较好。在中断或软中断情况下，因为不能被睡眠，所以不能用信号量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span>      lock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化信号量，一般为1*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获得信号量，它会导致睡眠,因此不能在中断上下文使用*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*能被信号打断，信号会导致该函数返回非0*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_interruptible</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尝试获得信号量，如果能够立刻获得，它就获得该信号量并返回0,否则返回非0值。它不会导致调用者睡眠，可以在中断上下文使用*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_trylock</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*释放信号量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br></pre></td></tr></table></figure>

<p>信号量根据count的値，设定可以允许有多少个进程持有这个信号量，一个持有者的信号量叫互斥信号量，多个持有者的信号量叫计数信号量。</p>
<p>使用down_interruptible()获取信号量时，要对返回值进行检查，如果非0要立即返回-ERESTARTSYS。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (down_interruptible(&amp;sem)) </span><br><span class="line">    <span class="keyword">return</span> -ERESTARTSYS;</span><br></pre></td></tr></table></figure>

<h3 id="读写信号量"><a href="#读写信号量" class="headerlink" title="读写信号量"></a>读写信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> &#123;</span></span><br><span class="line">    __s32           activity;</span><br><span class="line">    <span class="type">spinlock_t</span>      wait_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化读写信号量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_rwsem</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读信号量获取*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down_read</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">down_read_trylock</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读信号量释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_read</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写信号量获取*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down_write</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">down_write_trylock</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写信号量释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_write</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="完成量"><a href="#完成量" class="headerlink" title="完成量"></a>完成量</h2><p>完成量用于内核线程间的同步。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> done;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化完成量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_completion</span><span class="params">(<span class="keyword">struct</span> completion *x)</span>;</span><br><span class="line">DECLARE_COMPLETION(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*等待完成量被唤醒*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait_for_completion</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*唤醒完成量*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">complete</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">complete_all</span><span class="params">(<span class="keyword">struct</span> completion *c)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>        count; <span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line">    <span class="type">spinlock_t</span>      wait_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_SMP)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *name;</span><br><span class="line">    <span class="type">void</span>            *magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>  <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*互斥体并初始化*/</span></span><br><span class="line">mutex_init(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取互斥体*/</span></span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_lock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span>;</span><br><span class="line"><span class="type">int</span> __sched <span class="title function_">mutex_lock_interruptible</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span>;</span><br><span class="line"><span class="type">int</span> __sched <span class="title function_">mutex_trylock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*释放互斥体*/</span></span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_unlock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/cdev/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/cdev/" class="post-title-link" itemprop="url">char device</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/" itemprop="url" rel="index"><span itemprop="name">dev</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>字符设备是一个顺序的数据流设备，对设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。不具备缓冲区，所以对字符设备的读写是实时的。</p>
<p>创建一个字符设备的步骤：</p>
<ol>
<li>申请然后注册设备号。</li>
<li>实例一个cdev结构体。</li>
<li>实现字符设备的文件操作函数，然后用cdev_init()函数初始化cdev。</li>
<li>使用cdev_add()函数添加设备号。以上几步也可以直接用register_chrdev函数代替。</li>
<li>使用device_create()函数在/dev/下创建设备节点。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">register_chrdev_region(chardev-&gt;devno, <span class="number">1</span>, CHARDEV_DEV_NAME);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">alloc_chrdev_region(&amp;chardev-&gt;devno, <span class="number">0</span>, <span class="number">1</span>, CHARDEV_DEV_NAME);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">cdev_init(&amp;chardev-&gt;cdev, &amp;chardev_fops);</span><br><span class="line">chardev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_add(&amp;chardev-&gt;cdev, chardev-&gt;devno, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在/sys/class/目录下创建设备 */</span></span><br><span class="line">chardev-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, CHARDEV_DEV_NAME);</span><br><span class="line"></span><br><span class="line">device_create(chardev-&gt;class, <span class="literal">NULL</span>, chardev-&gt;devno, <span class="literal">NULL</span>, CHARDEV_DEV_NAME);</span><br></pre></td></tr></table></figure>

<p>卸载设备时，需要将之前创建的cdev、设备号、设备结点一并销毁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cdev_del(&amp;chardev-&gt;cdev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 销毁设备节点 */</span></span><br><span class="line">device_destroy(chardev-&gt;class, chardev-&gt;devno);</span><br><span class="line"></span><br><span class="line">class_destroy(chardev-&gt;class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注销设备号*/</span></span><br><span class="line">unregister_chrdev_region(chardev-&gt;devno, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">cdev</span>;</span></span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="type">int</span> err = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配请求的设备号范围。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cd = __register_chrdev_region(major, <span class="number">0</span>, <span class="number">256</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(cd))<span class="comment">/* 设备号冲突，返回。 */</span></span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(cd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为设备驱动程序分配一个新的cdev结构 */</span></span><br><span class="line">    cdev = cdev_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化cdev结构 */</span></span><br><span class="line">    cdev-&gt;owner = fops-&gt;owner;</span><br><span class="line">    cdev-&gt;ops = fops;</span><br><span class="line">    kobject_set_name(&amp;cdev-&gt;kobj, <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="keyword">for</span> (s = <span class="built_in">strchr</span>(kobject_name(&amp;cdev-&gt;kobj),<span class="string">&#x27;/&#x27;</span>); s; s = <span class="built_in">strchr</span>(s, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">        *s = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将设备添加到设备驱动模型中 */</span></span><br><span class="line">    cdev_add(cdev, MKDEV(cd-&gt;major, <span class="number">0</span>), <span class="number">256</span>);</span><br><span class="line">    cd-&gt;cdev = cdev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> major ? <span class="number">0</span> : cd-&gt;major;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unregister_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">    cd = __unregister_chrdev_region(major, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">if</span> (cd &amp;&amp; cd-&gt;cdev)</span><br><span class="line">        cdev_del(cd-&gt;cdev);</span><br><span class="line">    kfree(cd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h2><p>设备号分为主设备号和次设备号，主设备号用来标识设备类型，次设备号用来区分同类型的设备，分别为dev_t的高12位和低20位。inode 结构i_rdev 字段包含设备号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS   20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORMASK   ((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*分解出主设备号*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR(dev)    ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*分解出次设备号*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINOR(dev)    ((unsigned int) ((dev) &amp; MINORMASK))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*合成dev_t*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,mi)  (((ma) &lt;&lt; MINORBITS) | (mi))</span></span><br></pre></td></tr></table></figure>

<p>设备号可以是动态分配，也可以是静态注册，如果是静态注册，需要避免与系统现有的设备号不冲突，内核Documents 目录下的devices.txt 文件，里面描述了linux设备号的分配情况，可供参考。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 静态注册，设备号已知 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 动态注册，设备号未知 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注销设备号*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>可以通过读取/proc/devices文件获取字符设备和块设备的设备号信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Character devices:</span><br><span class="line">  4 tty</span><br><span class="line">  5 /dev/tty</span><br><span class="line">  5 /dev/console</span><br><span class="line"> 10 misc</span><br><span class="line"> 13 input</span><br><span class="line"> 89 i2c</span><br><span class="line">180 usb</span><br><span class="line">249 watchdog</span><br><span class="line">250 rtc</span><br><span class="line">254 gpiochip</span><br><span class="line"></span><br><span class="line">Block devices:</span><br><span class="line">259 blkext</span><br><span class="line">  7 loop</span><br><span class="line">  8 sd</span><br><span class="line">  9 md</span><br><span class="line"> 11 sr</span><br><span class="line"> 65 sd</span><br></pre></td></tr></table></figure>

<h2 id="cdev结构体"><a href="#cdev结构体" class="headerlink" title="cdev结构体"></a>cdev结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span> <span class="comment">/* 内嵌的 kobject 对象 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> <span class="comment">/*所属模块*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">/*文件操作结构体*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev; <span class="comment">/*设备号*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count; /引用计数*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/kernel/char/cdev-file_ops.png" alt="cdev-file_ops"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cdev *<span class="title function_">cdev_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span> =</span> kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cdev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        INIT_LIST_HEAD(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">        kobject_init(&amp;p-&gt;kobj, &amp;ktype_cdev_dynamic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">    INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">    kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">    cdev-&gt;ops = fops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    p-&gt;dev = dev;</span><br><span class="line">    p-&gt;count = count;</span><br><span class="line"></span><br><span class="line">    error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line">             exact_match, exact_lock, p);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    kobject_get(p-&gt;kobj.parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_unmap(p-&gt;dev, p-&gt;count);</span><br><span class="line">    kobject_put(&amp;p-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_put</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span> =</span> p-&gt;owner;</span><br><span class="line">        kobject_put(&amp;p-&gt;kobj);</span><br><span class="line">        module_put(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h2><p>class_create()在/sys/class/目录下创建设备类。再调用 device_create()函数来在/dev目录下创建相应的设备节点。当加载模块时，用户空间中的udev会自动去/sysfs下寻找对应的类从而创建设备节点。</p>
<p><code>udevadm info</code>命令可以查看/dev下的设备节点信息。可以通过<code>mknod</code>命令来手动创建设备节点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mknod [选项] name &#123;bcp&#125; major minor</span><br><span class="line"></span><br><span class="line">选项： </span><br><span class="line">-Z：设置安全的上下文;</span><br><span class="line">-m：设置权限模式;</span><br><span class="line">-help：显示帮助信息;</span><br><span class="line">--version：显示版本信息;</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">b 创建块设备;</span><br><span class="line">c 创建字符设备;</span><br><span class="line">p 创建命名管道;</span><br></pre></td></tr></table></figure>

<h2 id="file结构体"><a href="#file结构体" class="headerlink" title="file结构体"></a>file结构体</h2><p>file 结构体代表一个打开的设备文件，每个打开的文件在内核空间都关联一个struct file，在打开文件时创建，在文件关闭后释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">f_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>  *<span class="title">f_dentry</span>;</span> <span class="comment">// 文件对应的目录项结构，可用filp-&gt;f_dentry-&gt;d_inode的方式来访问索引节点结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span>         *<span class="title">f_vfsmnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span> <span class="comment">// 文件相关的操作</span></span><br><span class="line">    <span class="type">atomic_t</span>  f_count; <span class="comment">// 文件对象的引用计数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>   f_flags; <span class="comment">// 文件标志，如O_RONLY、O_NONBLOCK和O_SYNC</span></span><br><span class="line">    <span class="type">mode_t</span>   f_mode; <span class="comment">// 文件模式，FMODE_READ和FMODE_WRITE分别表示读写权限</span></span><br><span class="line">    <span class="type">int</span>   f_error;</span><br><span class="line">    <span class="type">loff_t</span>   f_pos; <span class="comment">// 当前的读写位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span> <span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  f_uid, f_gid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> <span class="title">f_ra</span>;</span></span><br><span class="line">    <span class="type">size_t</span>   f_maxcount;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  f_version;</span><br><span class="line">    <span class="type">void</span>   *f_security;</span><br><span class="line">    <span class="type">void</span>   *private_data;  <span class="comment">// 文件私有数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">f_ep_links</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span>  f_ep_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h2><p>file_operations 是对设备操作的抽象结构体，应用程序和VFS之间的接口是系统调用，而VFS与磁盘文件系统以及普通设备之间的接口是file_operations 结构体成员函数。应用程序进行open、write、read、close等系统调用，最终都会引起file_operations 结构体对应函数的调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">    <span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="inode结构体"><a href="#inode结构体" class="headerlink" title="inode结构体"></a>inode结构体</h2><p>inode结构体用来记录文件的物理上的信息，包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等信息。一个文件可以对应多个file结构，但只有一个inode 结构。它是Linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">umode_t</span>         i_mode;  <span class="comment">/* inode 的权限 */</span></span><br><span class="line">    <span class="type">uid_t</span>           i_uid;   <span class="comment">/* inode 拥有者的 id */</span></span><br><span class="line">    <span class="type">gid_t</span>           i_gid;   <span class="comment">/* inode 所属的群组 id */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>   *<span class="title">i_op</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>  *<span class="title">i_sb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">spinlock_t</span>          i_lock; <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       i_state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">i_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       dirtied_when;   <span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>   <span class="title">i_hash</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_wb_list</span>;</span>  <span class="comment">/* backing dev IO list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_lru</span>;</span>      <span class="comment">/* inode LRU list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_dentry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">i_rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   i_ino;</span><br><span class="line">    <span class="type">atomic_t</span>        i_count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    i_nlink;</span><br><span class="line">    <span class="type">dev_t</span>           i_rdev;  <span class="comment">/* 若是设备文件,此字段将记录设备的设备号 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    i_blkbits;</span><br><span class="line">    u64             i_version;</span><br><span class="line">    <span class="type">loff_t</span>          i_size;  <span class="comment">/* inode 所代表的文件大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_atime</span>;</span> <span class="comment">/* inode 最近一次的存取时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_mtime</span>;</span> <span class="comment">/* inode 最近一次的修改时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">i_ctime</span>;</span> <span class="comment">/* inode 的产生时间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">blkcnt_t</span>        i_blocks;  <span class="comment">/* inode 所使用的 block 数,一个 block为512 byte */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  i_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">i_alloc_sem</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span> <span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_lock</span>    *<span class="title">i_flock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span>  <span class="comment">/*若是块设备,为其对应的 block_device 结构体指针*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>     *<span class="title">i_cdev</span>;</span>  <span class="comment">/*若是字符设备,为其对应的 cdev 结构体指针*/</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">void</span>            *i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>应用程序每打开一个设备文件，就会产生一个inode节点，通过结点的i_cdev字段找到cdev结构体，再通过cdev的ops指针，就能找到设备的操作函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">light_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 获得设备结构体指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">light_dev</span> *<span class="title">dev</span> =</span> container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> light_dev, cdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 让设备结构体作为设备的私有信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">light_object</span> *<span class="title">obj</span> =</span> kmalloc(<span class="keyword">sizeof</span> (<span class="keyword">struct</span> light_object), GFP_KERNEL);</span><br><span class="line">    filp-&gt;private_data = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">light_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">light_object</span> *<span class="title">obj</span> =</span> (<span class="keyword">struct</span> light_object *)file-&gt;private_data;</span><br><span class="line">    kfree(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">light_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, </span></span><br><span class="line"><span class="params">    <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chardev_object</span> *<span class="title">obj</span> =</span> file-&gt;private_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inode节点的i_devices 成员和cdev的 list 相关联，这样文件就和字符设备绑定了，操作文件就等同在操作设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode * inode, <span class="keyword">struct</span> file * filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_add(&amp;inode-&gt;i_devices, &amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">    cdev_put(new);</span><br><span class="line"></span><br><span class="line">    filp-&gt;f_op = fops_get(p-&gt;ops);</span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_op-&gt;open) &#123;</span><br><span class="line">        lock_kernel();</span><br><span class="line">        ret = filp-&gt;f_op-&gt;open(inode,filp);</span><br><span class="line">        unlock_kernel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">def_chr_fops</span> =</span> &#123;</span><br><span class="line">    .open = chrdev_open,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_special_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">umode_t</span> mode, <span class="type">dev_t</span> rdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    inode-&gt;i_mode = mode;</span><br><span class="line">    <span class="keyword">if</span> (S_ISCHR(mode)) &#123;</span><br><span class="line">        inode-&gt;i_fop = &amp;def_chr_fops;</span><br><span class="line">        inode-&gt;i_rdev = rdev;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">chardev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, </span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chardev_object</span> *<span class="title">dev</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> xxx:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            printk(KERN_WARNING <span class="string">&quot;cmd invalid\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> - EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ioctl() 函数的cmd参数是自定义的IO控制命令，用于设备驱动区别应用程序的请求内容，大小为32位，分为4个域：</p>
<ul>
<li><p><strong>bit[31:30]</strong>: 区别读写命令，值可能是 <code>_IOC_NONE</code> 表示无数据传输，<code>_IOC_READ</code> (读)， <code>_IOC_WRITE</code> (写) ， <code>_IOC_READ|_IOC_WRITE</code> (双向)。</p>
</li>
<li><p><strong>bit[29:15]</strong>: 数据大小，表示 ioctl() 中的 arg 变量传送的内存大小。</p>
</li>
<li><p><strong>bit[20:8]</strong>: 魔数，这个值用以与其它设备驱动程序的 ioctl 命令进行区别，魔数范围为 0~255 。通常用英文字符 “A” ~ “Z” 或者 “a” ~ “z” 来表示。</p>
</li>
<li><p><strong>bit[7:0]</strong>: 区别序号，是命令的顺序序号。</p>
</li>
</ul>
<p>Doucumention/ioctl-number.txt文件中罗列了内核所使用的幻数，自己选择的幻数要避免和内核冲突。内核定义了 <code>_IO()</code> , <code>_IOR()</code> , <code>IOW()</code> 和 <code>_IOWR()</code> 4 个宏用来来辅助生成上面的 cmd 。注意cmd不能为2。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序数（number）字段的字位宽度，8bits</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRBITS      8 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPEBITS    8 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZEBITS    14 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIRBITS     2 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         _IOC_NRMASK        ((1 &lt;&lt; _IOC_NRBITS)-1)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         _IOC_TYPEMASK   ((1 &lt;&lt; _IOC_TYPEBITS)-1) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         _IOC_SIZEMASK     ((1 &lt;&lt; _IOC_SIZEBITS)-1)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         _IOC_DIRMASK      ((1 &lt;&lt; _IOC_DIRBITS)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        _IOC_NRSHIFT       0  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        _IOC_TYPESHIFT   (_IOC_NRSHIFT+_IOC_NRBITS) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        _IOC_SIZESHIFT    (_IOC_TYPESHIFT+_IOC_TYPEBITS) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        _IOC_DIRSHIFT      (_IOC_SIZESHIFT+_IOC_SIZEBITS)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NONE     0U  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_WRITE   1U   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_READ     2U </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*_IOC 宏将dir，type，nr，size四个参数组合成一个cmd参数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC(dir,type,nr,size) \</span></span><br><span class="line"><span class="meta">       (((dir)  &lt;&lt; _IOC_DIRSHIFT) | \</span></span><br><span class="line"><span class="meta">        ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span></span><br><span class="line"><span class="meta">        ((nr)   &lt;&lt; _IOC_NRSHIFT) | \</span></span><br><span class="line"><span class="meta">        ((size) &lt;&lt; _IOC_SIZESHIFT))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造无参数的命令编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO(type,nr)          _IOC(_IOC_NONE,(type),(nr),0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造从驱动程序中读取数据的命令编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR(type,nr,size)    _IOC(_IOC_READ,(type),(nr),sizeof(size)) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于向驱动程序写入数据命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW(type,nr,size)    _IOC(_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于双向传输</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR(type,nr,size)   _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从命令参数中解析出数据方向，即写进还是读出</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr)    (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从命令参数中解析出幻数type</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr)   (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从命令参数中解析出序数number</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr)           (((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从命令参数中解析出用户数据大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr)     (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_IN            (_IOC_WRITE &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_OUT         (_IOC_READ &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_INOUT     ((_IOC_WRITE|_IOC_READ) &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_MASK      (_IOC_SIZEMASK &lt;&lt; _IOC_SIZESHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_SHIFT      (_IOC_SIZESHIFT)</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/clang-format/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/clang-format/" class="post-title-link" itemprop="url">config of clang-format</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>vscode安装的C/C++插件就自带了clang-format工具，可以很方便的格式化代码，只需将配置文件.clang-format放到工程目录下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto</span></span><br><span class="line"><span class="attr">Language:</span> <span class="string">Cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预定义样式： LLVM、Google、Chromium、Mozilla、WebKit、Microsoft</span></span><br><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">LLVM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tab宽度</span></span><br><span class="line"><span class="attr">TabWidth:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩进宽度</span></span><br><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问说明符(public、private等)的偏移</span></span><br><span class="line"><span class="attr">AccessModifierOffset:</span> <span class="number">-4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)</span></span><br><span class="line"><span class="attr">AlignAfterOpenBracket:</span> <span class="string">Align</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续赋值时，对齐所有等号</span></span><br><span class="line"><span class="attr">AlignConsecutiveAssignments:</span> <span class="string">AcrossEmptyLines</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续位域</span></span><br><span class="line"><span class="attr">AlignConsecutiveBitFields:</span> <span class="string">Consecutive</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续声明时，对齐所有声明的变量名</span></span><br><span class="line"><span class="attr">AlignConsecutiveDeclarations:</span> <span class="string">AcrossEmptyLines</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续对齐的尾随的注释</span></span><br><span class="line"><span class="attr">AlignTrailingComments:</span> <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># AlignEscapedNewlines: Right</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 左对齐逃脱换行(使用反斜杠换行)的反斜杠</span></span><br><span class="line"><span class="comment"># #AlignEscapedNewlinesLeft: true</span></span><br><span class="line"><span class="comment"># # 水平对齐二元和三元表达式的操作数</span></span><br><span class="line"><span class="comment"># AlignOperands: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 允许函数声明的所有参数在放在下一行</span></span><br><span class="line"><span class="comment"># AllowAllParametersOfDeclarationOnNextLine: false</span></span><br><span class="line"><span class="comment"># # 允许短的块放在同一行</span></span><br><span class="line"><span class="comment"># AllowShortBlocksOnASingleLine: true</span></span><br><span class="line"><span class="comment"># # 允许短的case标签放在同一行</span></span><br><span class="line"><span class="comment"># AllowShortCaseLabelsOnASingleLine: true</span></span><br><span class="line"><span class="comment"># # 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All</span></span><br><span class="line"><span class="comment"># AllowShortFunctionsOnASingleLine: Empty</span></span><br><span class="line"><span class="comment"># # 允许短的if语句保持在同一行</span></span><br><span class="line"><span class="comment"># AllowShortIfStatementsOnASingleLine: false</span></span><br><span class="line"><span class="comment"># # 允许短的循环保持在同一行</span></span><br><span class="line"><span class="comment"># AllowShortLoopsOnASingleLine: false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 总是在定义返回类型后换行(deprecated)</span></span><br><span class="line"><span class="comment"># AlwaysBreakAfterDefinitionReturnType: None</span></span><br><span class="line"><span class="comment"># # 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数), </span></span><br><span class="line"><span class="comment"># #   AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)</span></span><br><span class="line"><span class="comment"># AlwaysBreakAfterReturnType: None</span></span><br><span class="line"><span class="comment"># # 总是在多行string字面量前换行</span></span><br><span class="line"><span class="comment"># AlwaysBreakBeforeMultilineStrings: false</span></span><br><span class="line"><span class="comment"># # 总是在template声明后换行</span></span><br><span class="line"><span class="comment"># AlwaysBreakTemplateDeclarations: false</span></span><br><span class="line"><span class="comment"># # false表示函数实参要么都在同一行，要么都各自一行</span></span><br><span class="line"><span class="comment"># BinPackArguments: true</span></span><br><span class="line"><span class="comment"># # false表示所有形参要么都在同一行，要么都各自一行</span></span><br><span class="line"><span class="comment"># BinPackParameters: false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)</span></span><br><span class="line"><span class="comment"># BreakBeforeBinaryOperators: None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似), </span></span><br><span class="line"><span class="comment">#   Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似), </span></span><br><span class="line"><span class="comment">#   Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom</span></span><br><span class="line"><span class="comment">#   注：这里认为语句块也属于函数</span></span><br><span class="line"><span class="attr">BreakBeforeBraces:</span> <span class="string">Custom</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 在三元运算符前换行</span></span><br><span class="line"><span class="comment"># BreakBeforeTernaryOperators: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效</span></span><br><span class="line"><span class="attr">BraceWrapping:</span></span><br><span class="line">  <span class="comment"># class定义后面</span></span><br><span class="line">  <span class="attr">AfterClass:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#   # 控制语句后面</span></span><br><span class="line"><span class="comment">#   AfterControlStatement: false</span></span><br><span class="line"><span class="comment">#   # enum定义后面</span></span><br><span class="line"><span class="comment">#   AfterEnum: false</span></span><br><span class="line"><span class="comment">#   # 函数定义后面</span></span><br><span class="line"><span class="comment">#   AfterFunction: true</span></span><br><span class="line"><span class="comment">#   # 命名空间定义后面</span></span><br><span class="line"><span class="comment">#   AfterNamespace: false</span></span><br><span class="line"><span class="comment">#   # ObjC定义后面</span></span><br><span class="line"><span class="comment">#   AfterObjCDeclaration: false</span></span><br><span class="line"><span class="comment">#   # struct定义后面</span></span><br><span class="line"><span class="comment">#   AfterStruct: true</span></span><br><span class="line"><span class="comment">#   # union定义后面</span></span><br><span class="line"><span class="comment">#   AfterUnion: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#   AfterExternBlock: false</span></span><br><span class="line"><span class="comment">#   # catch之前</span></span><br><span class="line"><span class="comment">#   BeforeCatch: true</span></span><br><span class="line"><span class="comment">#   # else之前</span></span><br><span class="line"><span class="comment">#   BeforeElse: true</span></span><br><span class="line"><span class="comment">#   # 缩进大括号</span></span><br><span class="line"><span class="comment">#   IndentBraces: false</span></span><br><span class="line"><span class="comment">#   SplitEmptyFunction: true</span></span><br><span class="line"><span class="comment">#   SplitEmptyRecord: true</span></span><br><span class="line"><span class="comment">#   SplitEmptyNamespace: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 在构造函数的初始化列表的逗号前换行</span></span><br><span class="line"><span class="comment"># BreakConstructorInitializersBeforeComma: false</span></span><br><span class="line"><span class="comment"># BreakConstructorInitializers: BeforeColon</span></span><br><span class="line"><span class="comment"># # 每行字符的限制，0表示没有限制</span></span><br><span class="line"><span class="comment"># ColumnLimit: 120</span></span><br><span class="line"><span class="comment"># # 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变</span></span><br><span class="line"><span class="comment"># CommentPragmas: &#x27;^ IWYU pragma:&#x27;</span></span><br><span class="line"><span class="comment"># CompactNamespaces: false</span></span><br><span class="line"><span class="comment"># # 构造函数的初始化列表要么都在同一行，要么都各自一行</span></span><br><span class="line"><span class="comment"># ConstructorInitializerAllOnOneLineOrOnePerLine: false</span></span><br><span class="line"><span class="comment"># # 构造函数的初始化列表的缩进宽度</span></span><br><span class="line"><span class="comment"># ConstructorInitializerIndentWidth: 4</span></span><br><span class="line"><span class="comment"># # 延续的行的缩进宽度</span></span><br><span class="line"><span class="comment"># ContinuationIndentWidth: 4</span></span><br><span class="line"><span class="comment"># # 去除C++11的列表初始化的大括号&#123;后和&#125;前的空格</span></span><br><span class="line"><span class="comment"># Cpp11BracedListStyle: true</span></span><br><span class="line"><span class="comment"># # 继承最常用的指针和引用的对齐方式</span></span><br><span class="line"><span class="comment"># DerivePointerAlignment: false</span></span><br><span class="line"><span class="comment"># # 关闭格式化</span></span><br><span class="line"><span class="comment"># DisableFormat: false</span></span><br><span class="line"><span class="comment"># # 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)</span></span><br><span class="line"><span class="comment"># ExperimentalAutoDetectBinPacking: false</span></span><br><span class="line"><span class="comment"># # 需要被解读为foreach循环而不是函数调用的宏</span></span><br><span class="line"><span class="comment"># ForEachMacros: [ foreach, Q_FOREACH, BOOST_FOREACH ]</span></span><br><span class="line"><span class="comment"># # 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，</span></span><br><span class="line"><span class="comment"># #   可以定义负数优先级从而保证某些#include永远在最前面</span></span><br><span class="line"><span class="comment"># IncludeCategories: </span></span><br><span class="line"><span class="comment">#   - Regex: &#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27;</span></span><br><span class="line"><span class="comment">#     Priority: 2</span></span><br><span class="line"><span class="comment">#   - Regex: &#x27;^(&lt;|&quot;(gtest|isl|json)/)&#x27;</span></span><br><span class="line"><span class="comment">#     Priority: 3</span></span><br><span class="line"><span class="comment">#   - Regex: &#x27;.*&#x27;</span></span><br><span class="line"><span class="comment">#     Priority: 1</span></span><br><span class="line"><span class="comment"># # 缩进case标签</span></span><br><span class="line"><span class="comment"># IndentCaseLabels: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># IndentPPDirectives:  AfterHash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 函数返回类型换行时，缩进函数声明或函数定义的函数名</span></span><br><span class="line"><span class="comment"># IndentWrappedFunctionNames: false</span></span><br><span class="line"><span class="comment"># # 保留在块开始处的空行</span></span><br><span class="line"><span class="comment"># KeepEmptyLinesAtTheStartOfBlocks: false</span></span><br><span class="line"><span class="comment"># # 开始一个块的宏的正则表达式</span></span><br><span class="line"><span class="comment"># MacroBlockBegin: &#x27;&#x27;</span></span><br><span class="line"><span class="comment"># # 结束一个块的宏的正则表达式</span></span><br><span class="line"><span class="comment"># MacroBlockEnd: &#x27;&#x27;</span></span><br><span class="line"><span class="comment"># # 连续空行的最大数量</span></span><br><span class="line"><span class="comment"># MaxEmptyLinesToKeep: 1</span></span><br><span class="line"><span class="comment"># # 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All</span></span><br><span class="line"><span class="comment"># NamespaceIndentation: Inner</span></span><br><span class="line"><span class="comment"># # 使用ObjC块时缩进宽度</span></span><br><span class="line"><span class="comment"># ObjCBlockIndentWidth: 4</span></span><br><span class="line"><span class="comment"># # 在ObjC的@property后添加一个空格</span></span><br><span class="line"><span class="comment"># ObjCSpaceAfterProperty: false</span></span><br><span class="line"><span class="comment"># # 在ObjC的protocol列表前添加一个空格</span></span><br><span class="line"><span class="comment"># ObjCSpaceBeforeProtocolList: true</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 在call(后对函数调用换行的penalty</span></span><br><span class="line"><span class="comment"># PenaltyBreakBeforeFirstCallParameter: 19</span></span><br><span class="line"><span class="comment"># # 在一个注释中引入换行的penalty</span></span><br><span class="line"><span class="comment"># PenaltyBreakComment: 300</span></span><br><span class="line"><span class="comment"># # 第一次在&lt;&lt;前换行的penalty</span></span><br><span class="line"><span class="comment"># PenaltyBreakFirstLessLess: 120</span></span><br><span class="line"><span class="comment"># # 在一个字符串字面量中引入换行的penalty</span></span><br><span class="line"><span class="comment"># PenaltyBreakString: 1000</span></span><br><span class="line"><span class="comment"># # 对于每个在行字符数限制之外的字符的penalty</span></span><br><span class="line"><span class="comment"># PenaltyExcessCharacter: 1000000</span></span><br><span class="line"><span class="comment"># # 将函数的返回类型放到它自己的行的penalty</span></span><br><span class="line"><span class="comment"># PenaltyReturnTypeOnItsOwnLine: 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SpaceAroundPointerQualifiers: Before</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指针和引用的对齐: Left, Right, Middle</span></span><br><span class="line"><span class="comment"># PointerAlignment: Right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 允许重新排版注释</span></span><br><span class="line"><span class="comment"># ReflowComments: true</span></span><br><span class="line"><span class="comment"># # 允许排序#include</span></span><br><span class="line"><span class="comment"># SortIncludes: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 在C风格类型转换后添加空格</span></span><br><span class="line"><span class="comment"># SpaceAfterCStyleCast: false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># SpaceAfterTemplateKeyword: true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在赋值运算符之前添加空格</span></span><br><span class="line"><span class="comment"># SpaceBeforeAssignmentOperators: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开圆括号之前添加一个空格: Never, ControlStatements, Always</span></span><br><span class="line"><span class="comment"># SpaceBeforeParens: ControlStatements</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在空的圆括号中添加空格</span></span><br><span class="line"><span class="comment"># SpaceInEmptyParentheses: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在尾随的注释前添加的空格数(只适用于//)</span></span><br><span class="line"><span class="comment"># SpacesBeforeTrailingComments: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在尖括号的&lt;后和&gt;前添加空格</span></span><br><span class="line"><span class="comment"># SpacesInAngles: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格</span></span><br><span class="line"><span class="comment"># SpacesInContainerLiterals: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在C风格类型转换的括号中添加空格</span></span><br><span class="line"><span class="comment"># SpacesInCStyleCastParentheses: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在圆括号的(后和)前添加空格</span></span><br><span class="line"><span class="comment"># SpacesInParentheses: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响</span></span><br><span class="line"><span class="comment"># SpacesInSquareBrackets: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 标准: Cpp03, Cpp11, Auto</span></span><br><span class="line"><span class="comment"># Standard: Cpp11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, Always</span></span><br><span class="line"><span class="comment"># UseTab: Never</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/bus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/bus/" class="post-title-link" itemprop="url">bus device driver</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux内核分别使用 bus_type、device_driver 和 device 来描述总线、驱动和设备，这三个结构体定义于 include/linux/device.h 头文件中。</p>
<h2 id="bus"><a href="#bus" class="headerlink" title="bus"></a>bus</h2><p>在linux设备模型中，总线用 bus_type 结构体表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsystem</span> <span class="title">subsys</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">drivers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span>    *<span class="title">bus_attrs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">dev_attrs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> *<span class="title">drv_attrs</span>;</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv);</span><br><span class="line">    <span class="type">int</span> (*hotplug) (<span class="keyword">struct</span> device *dev, <span class="type">char</span> **envp, </span><br><span class="line">                    <span class="type">int</span> num_envp, <span class="type">char</span> *buffer, <span class="type">int</span> buffer_size);</span><br><span class="line">    <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> device *dev, <span class="type">pm_message_t</span> state);</span><br><span class="line">    <span class="type">int</span> (*resume)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>match()成员函数将分开注册的设备和驱动捆绑在一起。</p>
<h3 id="bus-register"><a href="#bus-register" class="headerlink" title="bus_register()"></a>bus_register()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bus_register</span><span class="params">(<span class="keyword">struct</span> bus_type *bus)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> retval;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span> =</span> &amp;bus-&gt;lock_key;</span><br><span class="line"></span><br><span class="line">   priv = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> subsys_private), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">   priv-&gt;bus = bus;</span><br><span class="line">   bus-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">   BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">   retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, bus-&gt;name);</span><br><span class="line"></span><br><span class="line">   priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class="line">   priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">   priv-&gt;drivers_autoprobe = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line"></span><br><span class="line">   retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line"></span><br><span class="line">   priv-&gt;devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, <span class="literal">NULL</span>, &amp;priv-&gt;subsys.kobj);</span><br><span class="line">   priv-&gt;drivers_kset = kset_create_and_add(<span class="string">&quot;drivers&quot;</span>, <span class="literal">NULL</span>, &amp;priv-&gt;subsys.kobj);</span><br><span class="line"></span><br><span class="line">   INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">   __mutex_init(&amp;priv-&gt;mutex, <span class="string">&quot;subsys mutex&quot;</span>, key);</span><br><span class="line">   klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">   klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   retval = add_probe_files(bus);</span><br><span class="line"></span><br><span class="line">   retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bus-attribute"><a href="#bus-attribute" class="headerlink" title="bus_attribute"></a>bus_attribute</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>   <span class="title">attr</span>;</span></span><br><span class="line">   <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> bus_type *bus, <span class="type">char</span> *buf);</span><br><span class="line">   <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> bus_type *bus, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUS_ATTR(_name, _mode, _show, _store)   \</span></span><br><span class="line"><span class="meta">   struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bus_create_file</span><span class="params">(<span class="keyword">struct</span> bus_type *bus, <span class="keyword">struct</span> bus_attribute *attr)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bus_remove_file</span><span class="params">(<span class="keyword">struct</span> bus_type *bus, <span class="keyword">struct</span> bus_attribute *attr)</span></span><br></pre></td></tr></table></figure>

<p>可用BUS_ATTR宏来初始化一个 bus_attribute 结构体。调用 bus_create_file() 函数创建总线属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">show_bus_version</span><span class="params">(<span class="keyword">struct</span> bus_type *bus, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">snprintf</span>(buf, PAGE_SIZE, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;revision: 1.0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">BUS_ATTR</span><span class="params">(version, S_IRUGO, show_bus_version, <span class="literal">NULL</span>)</span>;</span><br><span class="line"></span><br><span class="line">bus_create_file(&amp;my_bus_type, &amp;bus_attr_version)</span><br></pre></td></tr></table></figure>

<h2 id="device"><a href="#device" class="headerlink" title="device"></a>device</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>  *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_private</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>  *init_name; <span class="comment">/* initial name of the device */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>  <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span>  <span class="comment">/* type of bus device is on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span> <span class="comment">/* which driver has allocated this device */</span></span><br><span class="line">    <span class="type">void</span>  *platform_data; <span class="comment">/* Platform specific data, device core doesn&#x27;t touch it */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_info</span> <span class="title">power</span>;</span></span><br><span class="line">    u64  *dma_mask;</span><br><span class="line">    u64  coherent_dma_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_dma_parameters</span> *<span class="title">dma_parms</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dma_pools</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dma_coherent_mem</span> *<span class="title">dma_mem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line">    <span class="type">dev_t</span>   devt; <span class="comment">/* dev_t, creates the sysfs &quot;dev&quot; */</span></span><br><span class="line">    <span class="type">spinlock_t</span>  devres_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">devres_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span>  *<span class="keyword">class</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span> <span class="comment">/* optional groups */</span></span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="device-register"><a href="#device-register" class="headerlink" title="device_register()"></a>device_register()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">device_register</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">   device_initialize(dev);</span><br><span class="line">   <span class="keyword">return</span> device_add(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">device_initialize</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">   dev-&gt;kobj.kset = devices_kset;</span><br><span class="line">   kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype);</span><br><span class="line">   INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);</span><br><span class="line">   mutex_init(&amp;dev-&gt;mutex);</span><br><span class="line">   lockdep_set_novalidate_class(&amp;dev-&gt;mutex);</span><br><span class="line">   spin_lock_init(&amp;dev-&gt;devres_lock);</span><br><span class="line">   INIT_LIST_HEAD(&amp;dev-&gt;devres_head);</span><br><span class="line">   device_pm_init(dev);</span><br><span class="line">   set_dev_node(dev, <span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">   INIT_LIST_HEAD(&amp;dev-&gt;msi_list);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   INIT_LIST_HEAD(&amp;dev-&gt;links.consumers);</span><br><span class="line">   INIT_LIST_HEAD(&amp;dev-&gt;links.suppliers);</span><br><span class="line">   dev-&gt;links.status = DL_DEV_NO_DRIVER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">device_add</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">class_interface</span> *<span class="title">class_intf</span>;</span></span><br><span class="line">   <span class="type">int</span> error = -EINVAL;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">glue_dir</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   dev = get_device(dev);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!dev-&gt;p) &#123;</span><br><span class="line">      error = device_private_init(dev);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (dev-&gt;init_name) &#123;</span><br><span class="line">      dev_set_name(dev, <span class="string">&quot;%s&quot;</span>, dev-&gt;init_name);</span><br><span class="line">      dev-&gt;init_name = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* subsystems can specify simple device enumeration */</span></span><br><span class="line">   <span class="keyword">if</span> (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)</span><br><span class="line">      dev_set_name(dev, <span class="string">&quot;%s%u&quot;</span>, dev-&gt;bus-&gt;dev_name, dev-&gt;id);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!dev_name(dev)) &#123;</span><br><span class="line">      error = -EINVAL;</span><br><span class="line">      <span class="keyword">goto</span> name_error;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   parent = get_device(dev-&gt;parent);</span><br><span class="line">   kobj = get_device_parent(dev, parent);</span><br><span class="line">   <span class="keyword">if</span> (kobj)</span><br><span class="line">      dev-&gt;kobj.parent = kobj;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* use parent numa_node */</span></span><br><span class="line">   <span class="keyword">if</span> (parent &amp;&amp; (dev_to_node(dev) == NUMA_NO_NODE))</span><br><span class="line">      set_dev_node(dev, dev_to_node(parent));</span><br><span class="line"></span><br><span class="line">   error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* notify platform of device entry */</span></span><br><span class="line">   error = device_platform_notify(dev, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">   error = device_create_file(dev, &amp;dev_attr_uevent);</span><br><span class="line"></span><br><span class="line">   error = device_add_class_symlinks(dev);</span><br><span class="line">   error = device_add_attrs(dev);</span><br><span class="line">   error = bus_add_device(dev);</span><br><span class="line">   error = dpm_sysfs_add(dev);</span><br><span class="line">   device_pm_add(dev);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (MAJOR(dev-&gt;devt)) &#123;</span><br><span class="line">      error = device_create_file(dev, &amp;dev_attr_dev);</span><br><span class="line"></span><br><span class="line">      error = device_create_sys_dev_entry(dev);</span><br><span class="line"></span><br><span class="line">      devtmpfs_create_node(dev);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">      blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">                    BUS_NOTIFY_ADD_DEVICE, dev);</span><br><span class="line"></span><br><span class="line">   kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</span><br><span class="line">   bus_probe_device(dev);</span><br><span class="line">   <span class="keyword">if</span> (parent)</span><br><span class="line">      klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</span><br><span class="line">                &amp;parent-&gt;p-&gt;klist_children);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (dev-&gt;class) &#123;</span><br><span class="line">      mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">      <span class="comment">/* tie the class to the device */</span></span><br><span class="line">      klist_add_tail(&amp;dev-&gt;knode_class,</span><br><span class="line">                &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* notify any interfaces that the device is here */</span></span><br><span class="line">      list_for_each_entry(class_intf,</span><br><span class="line">                &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)</span><br><span class="line">         <span class="keyword">if</span> (class_intf-&gt;add_dev)</span><br><span class="line">            class_intf-&gt;add_dev(dev, class_intf);</span><br><span class="line">      mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="device-attribute"><a href="#device-attribute" class="headerlink" title="device_attribute"></a>device_attribute</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>   <span class="title">attr</span>;</span></span><br><span class="line">   <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">         <span class="type">char</span> *buf);</span><br><span class="line">   <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">          <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_ATTR(_name, _mode, _show, _store) \</span></span><br><span class="line"><span class="meta">   struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *attr)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr)</span></span><br></pre></td></tr></table></figure>

<h2 id="device-driver"><a href="#device-driver" class="headerlink" title="device_driver"></a>device_driver</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 驱动程序的名称 */</span></span><br><span class="line">    <span class="type">char</span>   *name;</span><br><span class="line">    <span class="comment">/* 指向总线描述符的指针。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>  *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 禁止卸载设备驱动程序的信号量。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">unload_sem</span>;</span></span><br><span class="line">    <span class="comment">/* 内嵌kobject */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>  <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="comment">/* 驱动程序所支持的所有设备组成的链表的首部。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">devices</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 驱动程序所在模块（如果有的话） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>   *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 探测设备的方法 */</span></span><br><span class="line">    <span class="type">int</span> (*probe) (<span class="keyword">struct</span> device *dev);</span><br><span class="line">    <span class="comment">/* 移走设备的方法（检测设备驱动程序是否可以控制该设备） */</span></span><br><span class="line">    <span class="type">int</span>  (*remove) (<span class="keyword">struct</span> device *dev);</span><br><span class="line">    <span class="comment">/* 设备断电时调用的方法。 */</span></span><br><span class="line">    <span class="type">void</span> (*shutdown) (<span class="keyword">struct</span> device *dev);</span><br><span class="line">    <span class="comment">/* 设备置于低功率状态时所调用的方法 */</span></span><br><span class="line">    <span class="type">int</span> (*suspend) (<span class="keyword">struct</span> device *dev, u32 state, u32 level);</span><br><span class="line">    <span class="comment">/* 设备恢复正常状态时所调用的方法 */</span></span><br><span class="line">    <span class="type">int</span> (*resume) (<span class="keyword">struct</span> device *dev, u32 level);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="driver-register"><a href="#driver-register" class="headerlink" title="driver_register()"></a>driver_register()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">driver_register</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> ret;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">other</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||</span><br><span class="line">       (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||</span><br><span class="line">       (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))</span><br><span class="line">      printk(KERN_WARNING <span class="string">&quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span></span><br><span class="line">         <span class="string">&quot;bus_type methods\n&quot;</span>, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">   other = driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line"></span><br><span class="line">   ret = bus_add_driver(drv);</span><br><span class="line"></span><br><span class="line">   ret = driver_add_groups(drv, drv-&gt;groups);</span><br><span class="line"></span><br><span class="line">   kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="driver-attribute"><a href="#driver-attribute" class="headerlink" title="driver_attribute"></a>driver_attribute</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">   <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device_driver *driver, <span class="type">char</span> *buf);</span><br><span class="line">   <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device_driver *driver, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_ATTR(_name, _mode, _show, _store)   \</span></span><br><span class="line"><span class="meta">struct driver_attribute driver_attr_##_name =      \</span></span><br><span class="line"><span class="meta">   __ATTR(_name, _mode, _show, _store)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">driver_create_file</span><span class="params">(<span class="keyword">struct</span> device_driver *drv, <span class="type">const</span> <span class="keyword">struct</span> driver_attribute *attr)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">driver_remove_file</span><span class="params">(<span class="keyword">struct</span> device_driver *drv, <span class="keyword">struct</span> driver_attribute *attr)</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/imx280_kerenl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/imx280_kerenl/" class="post-title-link" itemprop="url">imx280内核编译</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/imx280/" itemprop="url" rel="index"><span itemprop="name">imx280</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>原厂提供的是v2.6.35.3版本的内核，在编译之前要先准备好交叉编译和mkimage打包镜像工具。</p>
<p>将内核压缩包解压到宿主机上，cd到内核根目录，先是配置内核的.config文件，首次编译先使用默认的即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-fsl-linux-gnueabi- EasyARM-iMX280A_defconfig</span><br></pre></td></tr></table></figure>

<p>接着是开始编译内核镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-fsl-linux-gnueabi- zImage -j16</span><br></pre></td></tr></table></figure>

<p>这里可能会出现编译错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Can&#x27;t use &#x27;defined(@array)&#x27; (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373.</span><br><span class="line">make[1]: *** [kernel/timeconst.h] Error 255</span><br><span class="line">make: *** [kernel] Error 2</span><br></pre></td></tr></table></figure>

<p>这是因为主机上的perl版本与pl脚本语法不匹配的原因，修改pl脚本即可</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        @val = @&#123;$canned_values&#123;$hz&#125;&#125;;</span><br><span class="line"><span class="deletion">-       if (!defined(@val)) &#123;</span></span><br><span class="line"><span class="addition">+       if (!@val) &#123;</span></span><br><span class="line">                @val = compute_values($hz);</span><br><span class="line">        &#125;</span><br><span class="line">        output($hz, @val);</span><br></pre></td></tr></table></figure>

<p>修改之后，继续编译，最终在arch/arm/boot/目录生成zImage镜像。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
