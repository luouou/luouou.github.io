<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/page/19/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/19/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/kernel_arch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/kernel_arch/" class="post-title-link" itemprop="url">Linux Kernel Architecture</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-06 16:10:49" itemprop="dateModified" datetime="2022-10-06T16:10:49+08:00">2022-10-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux的内核是一种宏内核，主要有以下特征：</p>
<ul>
<li>支持动态加载内核模块</li>
<li>支持对称多处理（SMP）</li>
<li>支持抢占，允许内核运行的任务有优先执行的能力</li>
<li>不区分线程和进程</li>
</ul>
<h2 id="linux系统结构"><a href="#linux系统结构" class="headerlink" title="linux系统结构"></a>linux系统结构</h2><img src="/images/kernel/kernel/linux_arch.jpeg" alt="Unix/Linux系统分层结构" style="zoom: 33%;" />

<p><img src="/images/kernel/kernel/linux-arch.webp" alt="Linux系统层次结构"></p>
<p>最上面是用户空间，这是用户应用程序执行的地方。用户空间之下是内核空间，GNU C Library （glibc）也位于这里，它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。</p>
<p>Linux 内核可以进一步划分成三层，最上面是系统调用接口，之下是内核代码，是与处理器体系结构无关的通用代码，最下面是依赖于特定处理器体系结构的代码，称为 BSP（Board Support Package）。</p>
<h2 id="内核架构"><a href="#内核架构" class="headerlink" title="内核架构"></a>内核架构</h2><p><img src="/images/kernel/kernel/kernel_struct.webp" alt="linux内核架构"></p>
<p>Linux内核的主要组件有：系统调用接口、进程调度、内存管理、虚拟文件系统、网络协议栈、进程间通信、设备驱动程序和硬件架构的相关代码。</p>
<p>LXR (Linux Cross Reference)是一个内核的源代码浏览工具，<a target="_blank" rel="noopener" href="http://lxr.linux.no/%E3%80%82">http://lxr.linux.no/。</a></p>
<p><img src="/images/kernel/kernel/linux_kernel_map.svg" alt="Linux kernel map"></p>
<p><a target="_blank" rel="noopener" href="https://makelinux.github.io/kernel/map/">https://makelinux.github.io/kernel/map/</a></p>
<h3 id="目录详解"><a href="#目录详解" class="headerlink" title="目录详解"></a>目录详解</h3><table>
<thead>
<tr>
<th align="left">目录 / 文件名</th>
<th align="left">源码功能简介</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>特定体系结构的代码</td>
</tr>
<tr>
<td>block</td>
<td>块设备I/O层</td>
</tr>
<tr>
<td>crypo</td>
<td>加密API</td>
</tr>
<tr>
<td>certs</td>
<td>与证书相关。</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核源码文档</td>
</tr>
<tr>
<td>drivers</td>
<td>设备驱动程序</td>
</tr>
<tr>
<td>firmware</td>
<td>使用某些驱动程序而需要的设备固件</td>
</tr>
<tr>
<td>fs</td>
<td>VFS和各种文件系统</td>
</tr>
<tr>
<td>include</td>
<td>内核头文件</td>
</tr>
<tr>
<td>init</td>
<td>内核引导和初始化</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>核心子系统，如调度程序</td>
</tr>
<tr>
<td>lib</td>
<td>同样内核函数</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理子系统和VM</td>
</tr>
<tr>
<td>net</td>
<td>网络子系统</td>
</tr>
<tr>
<td>samples</td>
<td>示例，示范代码</td>
</tr>
<tr>
<td>scripts</td>
<td>编译内核所用的脚本</td>
</tr>
<tr>
<td>security</td>
<td>Linux 安全模块</td>
</tr>
<tr>
<td>sound</td>
<td>语音子系统</td>
</tr>
<tr>
<td>usr</td>
<td>早期用户空间代码（所谓的initramfs）</td>
</tr>
<tr>
<td>tools</td>
<td>在Linux开发中有用的工具</td>
</tr>
<tr>
<td>virt</td>
<td>虚拟化基础结构</td>
</tr>
<tr>
<td>COPYING</td>
<td>许可和授权信息。</td>
</tr>
<tr>
<td>CREDITS</td>
<td>贡献者列表。</td>
</tr>
</tbody></table>
<h2 id="drivers目录"><a href="#drivers目录" class="headerlink" title="drivers目录"></a>drivers目录</h2><p><strong>accessibility</strong>  这些驱动提供支持一些辅助设备。在Linux 3.9.4中，这个文件夹中只有一个驱动就是盲文设备驱动。</p>
<p><strong>acpi</strong>  高级配置和电源接口（ACPI : Advanced Configuration and Power Interface）驱动用来管理电源使用。</p>
<p><strong>amba</strong>  高级微控制器总线架构（AMBA : Advanced Microcontroller Bus Architecture）是与片上系统（SoC）的管理和互连的协议。SoC是一块包含许多或所有必要的计算机组件的芯片。这里的AMBA驱动让内核能够运行在这上面。</p>
<p><strong>ata</strong>  该目录包含PATA和SATA设备的驱动程序。串行ATA（SATA）是一种连接主机总线适配器到像硬盘那样的存储器的计算机总线接口。并行ATA（PATA）用于连接存储设备，如硬盘驱动器，软盘驱动器，光盘驱动器的标准。PATA就是我们所说的IDE。</p>
<p><strong>atm</strong>  异步通信模式(ATM : Asynchronous Transfer Mode)是一种通信标准。这里有各种接到PCI桥的驱动(他们连接到PCI总线)和以太网控制器(控制以太网通信的集成电路芯片)。</p>
<p><strong>auxdisplay</strong>  这个文件夹提供了三个驱动。LCD 帧缓存（framebuffer）驱动、LCD控制器驱动和一个LCD驱动。这些驱动用于管理液晶显示器 —— 液晶显示器会在按压时显示波纹。注意:按压会损害屏幕,所以请不要用力戳LCD显示屏。</p>
<p><strong>base</strong>  这是个重要的目录包含了固件、系统总线、虚拟化能力等基本的驱动。</p>
<p><strong>bcma</strong>  这些驱动用于使用基于AMBA协议的总线。AMBA是由博通公司开发。</p>
<p><strong>block</strong>  这些驱动提供对块设备的支持，像软驱、SCSI磁带、TCP网络块设备等等。</p>
<p><strong>bluetooth</strong>  蓝牙是一种安全的无线个人区域网络标准(PANs)。蓝牙驱动就在这个文件夹，它允许系统使用各种蓝牙设备。例如，一个蓝牙鼠标不用电缆，并且计算机有一个电子狗(小型USB接收器)。Linux系统必须能够知道进入电子狗的信号，否则蓝牙设备无法工作。</p>
<p><strong>bus</strong>  这个目录包含了三个驱动。一个转换ocp接口协议到scp协议。一个是设备间的互联驱动，第三个是用于处理互联中的错误处理。</p>
<p><strong>cdrom</strong>  这个目录包含两个驱动。一个是cd-rom，包括DVD和CD的读写。第二个是gd-rom(只读GB光盘)，GD光盘是1.2GB容量的光盘，这像一个更大的CD或者更小的DVD。GD通常用于世嘉游戏机中。</p>
<p><strong>char</strong>  字符设备驱动就在这里。字符设备每次传输数据传输一个字符。这个文件夹里的驱动包括打印机、PS3闪存驱动、东芝SMM驱动和随机数发生器驱动等。</p>
<p><strong>clk</strong>  这些驱动用于系统时钟。</p>
<p><strong>clocksource</strong>  这些驱动用于作为定时器的时钟。</p>
<p><strong>connector</strong>  这些驱动使内核知道当进程fork并使用proc连接器更改UID(用户ID)、GID(组ID)和SID(会话ID)。内核需要知道什么时候进程fork(CPU中运行多个任务)并执行。否则,内核可能会低效管理资源。</p>
<p><strong>cpufreq</strong>  这些驱动改变CPU的电源能耗。</p>
<p><strong>cpuidle</strong>  这些驱动用来管理空闲的CPU。一些系统使用多个CPU，其中一个驱动可以让这些CPU负载相当。</p>
<p><strong>crypto</strong>  这些驱动提供加密功能。</p>
<p><strong>dca</strong>  直接缓存访问（DCA ： Direct Cache Access）驱动允许内核访问CPU缓存。CPU缓存就像CPU内置的RAM。CPU缓存的速度比RAM更快。然而,CPU缓存的容量比RAM小得多。CPU在这个缓存系统上存储了最重要的和执行的代码。</p>
<p><strong>devfreq</strong>  这个驱动程序提供了一个通用的动态电压和频率调整(DVFS ： Generic Dynamic Voltage and Frequency Scaling)框架，可以根据需要改变CPU频率来节约能源。这就是所谓的CPU节能。</p>
<p><strong>dio</strong>  数字输入/输出（DIO ：Digital Input/Output）总线驱动允许内核可以使用DIO总线。</p>
<p><strong>dma</strong>  直接内存访问(DMA)驱动允许设备无需CPU直接访问内存。这减少了CPU的负载。</p>
<p><strong>edac</strong>  错误检测和校正（ Error Detection And Correction）驱动帮助减少和纠正错误。</p>
<p><strong>eisa</strong>  扩展工业标准结构总线（Extended Industry Standard Architecture）驱动提供内核对EISA总线的支持。</p>
<p><strong>extcon</strong>  外部连接器（EXTernal CONnectors）驱动用于检测设备插入时的变化。例如，extcon会检测用户是否插入了USB驱动器。</p>
<p><strong>firewire</strong>  这些驱动用于控制苹果制造的类似于USB的火线设备。</p>
<p><strong>firmware</strong>  这些驱动用于和像BIOS(计算机的基本输入输出系统固件)这样的设备的固件通信。BIOS用于启动操作系统和控制硬件与设备的固件。一些BIOS允许用户超频CPU。超频是使CPU运行在一个更快的速度。CPU速度以MHz(百万赫兹)或GHz衡量。一个3.7 GHz的CPU的的速度明显快于一个700Mhz的处理器。</p>
<p><strong>gpio</strong>  通用输入/输出(GPIO ：General Purpose Input/Output)是可由用户控制行为的芯片的管脚。这里的驱动就是控制GPIO。</p>
<p><strong>gpu</strong>  这些驱动控制VGA、GPU和直接渲染管理(DRM ：Direct Rendering Manager )。VGA是640*480的模拟计算机显示器或是简化的分辨率标准。GPU是图形处理器。DRM是一个Unix渲染系统。</p>
<p><strong>hid</strong>  这驱动用于对USB人机界面设备的支持。</p>
<p><strong>hsi</strong>  这个驱动用于内核访问像Nokia N900这样的蜂窝式调制解调器。</p>
<p><strong>hv</strong>  这个驱动用于提供Linux中的键值对(KVP ：Key Value Pair)功能。</p>
<p><strong>hwmon</strong>  硬件监控驱动用于内核读取硬件传感器上的信息。比如，CPU上有个温度传感器。那么内核就可以追踪温度的变化并相应地调节风扇的速度。</p>
<p><strong>hwspinlock</strong>  硬件转锁驱动允许系统同时使用两个或者更多的处理器，或使用一个处理器上的两个或更多的核心。</p>
<p><strong>i2c</strong>  I2C驱动可以使计算机用I2C协议处理主板上的低速外设。系统管理总线(SMBus ：System Management Bus)驱动管理SMBus,这是一种用于轻量级通信的two-wire总线。</p>
<p><strong>ide</strong>  这些驱动用来处理像CDROM和硬盘这些PATA/IDE设备。</p>
<p><strong>idle</strong>  这个驱动用来管理Intel处理器的空闲功能。</p>
<p><strong>iio</strong>  工业I/O核心驱动程序用来处理数模转换器或模数转换器。</p>
<p><strong>infiniband</strong>  Infiniband是在企业数据中心和一些超级计算机中使用的一种高性能的端口。这个目录中的驱动用来支持Infiniband硬件。</p>
<p><strong>input</strong>  这里包含了很多驱动，这些驱动都用于输入处理，包括游戏杆、鼠标、键盘、游戏端口（旧式的游戏杆接口）、遥控器、触控、耳麦按钮和许多其他的驱动。如今的操纵杆使用USB端口，但是在上世纪80、90年代，操纵杆是插在游戏端口的。</p>
<p><strong>iommu</strong>  输入/输出内存管理单元(IOMMU ：Input/Output Memory Management Unit)驱动用来管理内存管理单元中的IOMMU。IOMMU连接DMA IO总线到内存上。IOMMU是设备在没有CPU帮助下直接访问内存的桥梁。这有助于减少处理器的负载。</p>
<p><strong>ipack</strong>  Ipack代表的是IndustryPack。 这个驱动是一个虚拟总线,允许在载体和夹板之间操作。</p>
<p><strong>irqchip</strong>  这些驱动程序允许硬件的中断请求(IRQ)发送到处理器，暂时挂起一个正在运行的程序而去运行一个特殊的程序（称为一个中断处理程序）。</p>
<p><strong>isdn</strong>  这些驱动用于支持综合业务数字网(ISDN)，这是用于同步数字传输语音、视频、数据和其他网络服务使用传统电话网络的电路的通信标准。</p>
<p><strong>leds</strong>  用于LED的驱动。</p>
<p><strong>lguest</strong>  lguest用于管理客户机系统的中断。中断是CPU被重要任务打断的硬件或软件信号。CPU接着给硬件或软件一些处理资源。</p>
<p><strong>macintosh</strong>  苹果设备的驱动在这个文件夹里。</p>
<p><strong>mailbox</strong>  这个文件夹(pl320-pci)中的驱动用于管理邮箱系统的连接。</p>
<p><strong>md</strong>  多设备驱动用于支持磁盘阵列，一种多块硬盘间共享或复制数据的系统。</p>
<p><strong>media</strong>  媒体驱动提供了对收音机、调谐器、视频捕捉卡、DVB标准的数字电视等等的支持。驱动还提供了对不同通过USB或火线端口插入的多媒体设备的支持。</p>
<p><strong>memory</strong>  支持内存的重要驱动。</p>
<p><strong>memstick</strong>  这个驱动用于支持Sony记忆棒。</p>
<p><strong>message</strong>  这些驱动用于运行LSI Fusion MPT(一种消息传递技术)固件的LSI PCI芯片/适配器。LSI大规模集成，这代表每片芯片上集成了几万晶体管、</p>
<p><strong>mfd</strong>  多用途设备(MFD)驱动提供了对可以提供诸如电子邮件、传真、复印机、扫描仪、打印机功能的多用途设备的支持。这里的驱动还给MFD设备提供了一个通用多媒体通信端口(MCP)层。</p>
<p><strong>misc</strong>  这个目录包含了不适合在其他目录的各种驱动。就像光线传感器驱动。</p>
<p><strong>mmc</strong>  MMC卡驱动用于处理用于MMC标准的闪存卡。</p>
<p><strong>mtd</strong>  内存技术设备(MTD ：Memory technology devices)驱动程序用于Linux和闪存的交互，这就就像一层闪存转换层。其他块设备和字符设备的驱动程序不会以闪存设备的操作方式来做映射。尽管USB记忆卡和SD卡是闪存设备，但它们不使用这个驱动，因为他们隐藏在系统的块设备接口后。这个驱动用于新型闪存设备的通用闪存驱动器驱动。</p>
<p><strong>net</strong>  网络驱动提供像AppleTalk、TCP和其他的网络协议。这些驱动也提供对调制解调器、USB 2.0的网络设备、和射频设备的支持。</p>
<p><strong>nfc</strong>  这个驱动是德州仪器的共享传输层之间的接口和NCI核心。</p>
<p><strong>ntb</strong>  不透明的桥接驱动提供了在PCIe系统的不透明桥接。PCIe是一种高速扩展总线标准。</p>
<p><strong>nubus</strong>  NuBus是一种32位并行计算总线。用于支持苹果设备。</p>
<p><strong>of</strong>  此驱动程序提供设备树中创建、访问和解释程序的OF助手。</p>
<p><strong>oprofile</strong>  这个驱动用于从驱动到用户空间进程(运行在用户态下的应用)评测整个系统。这帮助开发人员找到性能问题—-性能分析机制-是用于 Linux 的若干种评测和性能监控工具中的一种</p>
<p><strong>parisc</strong>  这些驱动用于HP生产的PA-RISC架构设备。PA-RISC是一种特殊指令集的处理器。</p>
<p><strong>parport</strong>  并口驱动提供了Linux下的并口支持。</p>
<p><strong>pci</strong>  这些驱动提供了PCI总线服务。</p>
<p><strong>pcmcia</strong>  这些是笔记本的pc卡驱动</p>
<p><strong>pinctrl</strong>  这些驱动用来处理引脚控制设备。引脚控制器可以禁用或启用I/O设备。</p>
<p><strong>platform</strong> 这个文件夹包含了不同的计算机平台的驱动像Acer、Dell、Toshiba、IBM、Intel、Chrombooks等等。</p>
<p><strong>pnp</strong>  即插即用驱动允许用户在插入一个像USB的设备后可以立即使用而不必手动配置设备。</p>
<p><strong>power</strong>  电源驱动使内核可以测量电池电量，检测充电器和进行电源管理。</p>
<p><strong>pps</strong>  Pulse-Per-Second驱动用来控制电流脉冲速率。这用于计时。</p>
<p><strong>ps3</strong>  这是Sony的游戏控制台驱动- PlayStation3。</p>
<p><strong>ptp</strong>  图片传输协议(PTP)驱动支持一种从数码相机中传输图片的协议。</p>
<p><strong>pwm</strong>  脉宽调制(PWM)驱动用于控制设备的电流脉冲。主要用于控制像CPU风扇。</p>
<p><strong>rapidio</strong>  RapidIO驱动用于管理RapidIO架构，它是一种高性能分组交换，用于电路板上交互芯片的交互技术，也用于互相使用底板的电路板。</p>
<p><strong>regulator</strong>  校准驱动用于校准电流、温度、或其他可能系统存在的校准硬件。—-用于控制系统中某些设备的电压电流供应</p>
<p><strong>remoteproc</strong>  这些驱动用来管理远程处理器。</p>
<p><strong>rpmsg</strong>  这个驱动用来控制支持大量驱动的远程处理器通讯总线(rpmsg)。这些总线提供消息传递设施,促进客户端驱动程序编写自己的连接协议消息。—-该基础架构允许主处理器上的 Linux 操作系统管理远程处理器上远程软件环境的生命周期和通信-用于在 AMP 环境中的操作系统之间实现 IPC 的 rpmsg 组件和 API</p>
<p><strong>rtc</strong>  实时时钟(RTC)驱动使内核可以读取时钟。</p>
<p><strong>s390</strong>  用于31/32位的大型机架构的驱动。</p>
<p><strong>sbus</strong>  用于管理基于SPARC的总线驱动。</p>
<p><strong>scsi</strong>  允许内核使用SCSI标准外围设备。例如,Linux将在与SCSI硬件传输数据时使用SCSI驱动。</p>
<p><strong>sfi</strong> 简单固件接口(SFI)驱动允许固件发送信息表给操作系统。这些表的数据称为SFI表。</p>
<p><strong>sh</strong>  该驱动用于支持SuperHway总线。</p>
<p><strong>sn</strong>  该驱动用于支持IOC3串口。</p>
<p><strong>spi</strong>  这些驱动处理串行设备接口总线(SPI)，它是一个在在全双工下运行的同步串行数据链路标准,。全双工是指两个设备可以同一时间同时发送和接收信息。双工指的是双向通信。设备在主/从模式下通信(取决于设备配置)。</p>
<p><strong>ssb</strong>  ssb(Sonics Silicon Backplane)驱动提供对在不同芯片和嵌入式设备上使用的迷你总线的支持。</p>
<p><strong>staging</strong>  该目录含有许多子目录。这里所有的驱动还需要在加入主内核前经过更多的开发工作。</p>
<p><strong>target</strong>  SCSI设备驱动</p>
<p><strong>tc</strong>  这些驱动用于TURBOchannel，TURBOchannel是数字设备公司开发的32位开放总线。这主要用于DEC工作站。</p>
<p><strong>thermal</strong>  thermal驱动使CPU保持较低温度。—Linux温控框架</p>
<p><strong>tty</strong>  tty驱动用于管理物理终端连接。</p>
<p><strong>uio</strong>  该驱动允许用户编译运行在用户空间而不是内核空间的驱动。这使用户驱动不会导致内核崩溃。—–运行在用户空间的IO技术</p>
<p><strong>usb</strong>  USB设备允许内核使用USB端口。闪存驱动和记忆卡已经包含了固件和控制器,所以这些驱动程序允许内核使用USB接口和与USB设备。</p>
<p><strong>uwb</strong>  Ultra-WideBand驱动用来管理短距离，高带宽通信的超低功耗的射频设备</p>
<p><strong>vfio</strong>  允许设备访问用户空间的VFIO驱动。用户态驱动框架。</p>
<p><strong>vhost</strong>  这是用于宿主内核中的virtio服务器驱动。用于虚拟化中。</p>
<p><strong>video</strong>  这是用来管理显卡和监视器的视频驱动。</p>
<p><strong>virt</strong>  这些驱动用来虚拟化。</p>
<p><strong>virtio</strong>  这个驱动用来在虚拟PCI设备上使用virtio设备。用于虚拟化中。</p>
<p><strong>vlynq</strong>  这个驱动控制着由德州仪器开发的专有接口。这些都是宽带产品，像WLAN和调制解调器，VOIP处理器，音频和数字媒体信号处理芯片。</p>
<p><strong>vme</strong>  WMEbus最初是为摩托罗拉68000系列处理器开发的总线标准</p>
<p><strong>w1</strong>  这些驱动用来控制one-wire总线。</p>
<p><strong>watchdog</strong>  该驱动管理看门狗定时器，这是一个可以用来检测和恢复异常的定时器。</p>
<p><strong>xen</strong>  该驱动是Xen管理程序系统。这是个允许用户运行多个操作系统在一台计算机的软件或硬件。这意味着xen的代码将允许用户在同一时间的一台计算机上运行两个或更多的Linux系统。用户也可以在Linux上运行Windows、Solaris、FreeBSD、或其他操作系统。</p>
<p><strong>zorro</strong>  该驱动提供Zorro Amiga总线支持。</p>
<p>Documentation/CodingStyle 文件描 述 了 Linux 内 核 对 编 码 风 格 的 要 求，内 核 下 的scripts/checkpatch.pl 脚本可以检查代码风格。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/lcd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/lcd/" class="post-title-link" itemprop="url">液晶显示器原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a>LCD</h3><p>液晶（Liquid Crystal）是一种介于液态与结晶态之间的一种物质状态的高分子材料。液晶具有双折射性，使得能对偏振光选择性透过。</p>
<p>LCD是英文Liquid Crystal Display 的简称，指的是液晶显示屏。主要有TFT、UFB、TFD、STN等几种类型。其构造包括塑料球、玻璃球、边框胶、玻璃基板、上偏光片、定向层、液晶、导电ITO图案、导通点、IPO电极和下偏光片。</p>
<p><img src="/images/lcd/LCD-struct.jpeg" alt="TN"></p>
<p>两块偏光板相互垂直时光线就完全无法通过，液晶显示器就是在上下两片栅栏之间互垂直的偏光板之间充满液晶，利用电场控制液晶分子产生扭曲，从而对穿越其中的光线进行有规则的折射，来改变光的行进方向，如此一来，不同的电场大小，就会形成不同颜色。</p>
<p>因为液晶材料本身并不发光，所以在显示屏两边都设有作为光源的灯管，而在液晶显示屏背面有一块背光板和反光膜，背光板是由荧光物质组成的可以发射光线，其作用主要是提供均匀的背景光源。</p>
<p>液晶显示的原理基于液晶的透光率随其所施电压大小而变化的特性。当光通过下偏振片后，变成线性偏振光，偏振方向与偏振片振动方向一致，与上下玻璃基板上面液晶分子排列顺序一致。当光通过液晶层时，由于受液晶折射，线性偏振光被分解为两束光。又由于这两束光传播速度不同（相位相同），因而当两束光合成后，必然使振光的振动方向发生变化。通过液晶层的光，则被逐渐扭曲。当光达到上偏振片时，其光轴振动方向被扭曲了90度，且与上偏振片的振动方向保持一致。这样，光线通过上偏振片形成亮场。加上电压以后，液晶在电场作用下取向，扭曲消失。这时，通过下偏振片的线性偏振光，在液晶层不再旋转，无法通过上偏振片而形成暗场。可见液晶本身不发光，在外光源的调制下，才能显示，在整个显示过程中，液晶起到一个电压控制的光阀作用。</p>
<p>LCD依据驱动方式可分为静态驱动、简单矩阵驱动以及主动<br>矩阵驱动 3 种。其中简单矩阵型又可再细分扭转向列型(TN)和超扭转式向列型(STN)两种，而主动矩阵型则以薄膜式晶体管型(TFT)为主流。</p>
<p>NW(Normally white)是指当液晶面板不施加电压时，面板是亮的画面。另外一种， 液晶面板不施加电压时，面板无法透光, 看起来是黑色的，就称之为NB(Normally black)。</p>
<p><strong>可视角度</strong>指的是使用者能从不一样的方位清晰地看见荧幕上所有显示内容的角度。液晶显示器的可视角度左右对称，而上下则不一定对称。当背光源的入射光通过偏光板、液晶及取向膜后，输出光便具备了特定的方向特性。假如从一个非常斜的角度观看一个全白的画面，我们可能会看到黑色或是色彩失真。一般来说，上下角度要小于或等于左右角度。现在有些厂商就开发出各种广视角技术，试图改善液晶显示器的视角特性，如：IPS(In Plane Switching)、MVA(Multidomain Vertical Alignment)、TN+FILM。</p>
<h3 id="TFT"><a href="#TFT" class="headerlink" title="TFT"></a>TFT</h3><h2 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h2><p>OLED是Organic Light-Emitting Diode 的简称，中文名是有机发光二极管。</p>
<p>不同于LCD需要通过背光板照射才能显示，OLED是自发光。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/mipi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/mipi/" class="post-title-link" itemprop="url">mipi接口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:56:37" itemprop="dateModified" datetime="2022-06-08T17:56:37+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MIPI (Mobile Industry Processor Interface) 是2003年由ARM, Nokia, ST ,TI等公司成立的一个联盟，目的是把手机内部的接口如摄像头、显示屏接口、射频/基带接口等标准化，从而减少手机设计的复杂程度和增加设计灵活性。</p>
<p>MIPI联盟下面有不同的WorkGroup，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI、显示接口DSI、射频接口DigRF、麦克风 /喇叭接口SLIMbus等。统一接口标准的好处是手机厂商根据需要可以从市面上灵活选择不同的芯片和模组，更改设计和功能时更加快捷方便。下图是按照 MIPI的规划下一代智能手机的内部架构。</p>
<p><img src="/images/mipi/MIPI-Protocol-865x1024.png" alt="img"></p>
<h2 id="MIPI规范"><a href="#MIPI规范" class="headerlink" title="MIPI规范"></a>MIPI规范</h2><p>已经完成和正在计划中的规范如下:<br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MIPI#cite_note-Working_Groups:_Overview-1">https://zh.wikipedia.org/wiki/MIPI#cite_note-Working_Groups:_Overview-1</a></p>
<table>
<thead>
<tr>
<th><strong>工作组</strong></th>
<th><strong>规范名称</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Camera工作组</td>
<td>MIPI Camera Serial Interface 2 (MIPI CSI-2) v2.0 (March 2017)MIPI Camera Serial Interface 3 (MIPI CSI-3) v1.1 (March 2014)MIPI Camera Command Set (MIPI CCS) v1.0 (October 2017)</td>
</tr>
<tr>
<td>Device Descriptor Block工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>DigRF工作组</td>
<td>DigRF Baseband/RF Digital Interface Specification v4 (Feb. 2014)</td>
</tr>
<tr>
<td>Display工作组</td>
<td>DBI-2DPI-2DSI-2 v1.0 (January 2016)DCS</td>
</tr>
<tr>
<td>高速同步接口工作组</td>
<td>HSI 1.0</td>
</tr>
<tr>
<td>接口管理框架工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>低速多点连接工作组</td>
<td>SLIMbus v2.0 (August 2015)SoundWire v1.1 (August 2016)</td>
</tr>
<tr>
<td>NAND软件工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>物理层工作组</td>
<td>C-PHY v1.2 (March 2017)D-PHY v2.1 (March 2017)M-PHY v4.1 (March 2017)</td>
</tr>
<tr>
<td>软件工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>系统电源管理工作组</td>
<td>SPMI v2.0 (August 2012)</td>
</tr>
<tr>
<td>检测与调试工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>统一协议工作组</td>
<td>UniPro 1 point-to-point v1.61 (October 2015)PIE</td>
</tr>
</tbody></table>
<h3 id="DSI-CSI"><a href="#DSI-CSI" class="headerlink" title="DSI/CSI"></a>DSI/CSI</h3><p>MIPI是一个比较新的标准，其规范也在不断修改和改进，目前比较成熟的接口应用有DSI(显示接口)和CSI（摄像头接口）。CSI/DSI分别是指其承载的是针对Camera或Display应用，都有复杂的协议结构。以DSI为例，其协议层结构如下：</p>
<p><img src="/images/mipi/MIPI-DSI.png" alt="img"></p>
<p>CSI/DSI的物理层（Phy Layer）由专门的WorkGroup负责制定，其目前的标准是D-PHY。D-PHY采用1对源同步的差分时钟和1～4对差分数据线来进行数据传输。数据传输采用DDR方式，即在时钟的上下边沿都有数据传输。</p>
<p>D-PHY的物理层支持HS(High Speed)和LP(Low Power)两种工作模式。HS模式下采用低压差分信号，功耗较大，但是可以传输很高的数据速率（数据速率为80M～1Gbps）； LP模式下采用单端信号，数据速率很低（&lt;10Mbps），但是相应的功耗也很低。两种模式的结合保证了MIPI总线在需要传输大量数据（如图像） 时可以高速传输，而在不需要大数据量传输时又能够减少功耗。</p>
<p><img src="/images/mipi/MIPI-DPHY.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/100476927">https://zhuanlan.zhihu.com/p/100476927</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/sensor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/sensor/" class="post-title-link" itemprop="url">sensor</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-11 17:33:30" itemprop="dateModified" datetime="2022-09-11T17:33:30+08:00">2022-09-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Sensor 将从 lens 上传导过来的光线转换为电信号，再经过内部AD转换为数字信号。每个pixel像素点只能感受R、G、B中的一种，因此每个像素点中存放的数据是单色光，像素表示的就是有多少个感光点，每个感光点只能感应一种光，这些最原始的感光数据我们称为RAW Data。Raw Data数据要经过ISP的处理才能还原出三原色，也就是说如果一个像素点感应为R值，那么ISP会根据该感光点周围的G、B的值，通过插值和特效处理等，计算出该R点的G、B值，这样该点的RGB就被还原了。目前常用的sensor有两种，一种是CCD（电荷耦合）；一种是CMOS（金属氧化物导体）。</p>
<ul>
<li>CCD（Charge Coupled Device），电荷耦合器件传感器：使用一种高感光度的半导体材料制成，能把光线转变成电荷，通过模数转换器芯片转换成电信号。CCD由许多独立的感光单位组成，通常以百万像素为单位。当CCD表面受到光照时，每个感光单位都会将电荷反映在组件上，所有的感光单位产生的信号加在一起，就构成了一幅完整的图像。CCD传感器以日本厂商为主导，全球市场上有90%被日本厂商垄断，索尼、松下、夏普是龙头。</li>
<li>CMOS（Complementary Metal-Oxide Semiconductor），互补性氧化金属半导体：主要是利用硅和锗做成的半导体，使其在CMOS上共存着带N(-)和P(+)级的半导体，这两个互补效应所产生的电流可以被处理芯片记录并解读成影像。CMOS传感器主要以美国、韩国和中国台湾为主导，主要生产厂家是美国的OmnVison、Agilent、Micron，中国台湾的锐像、原相、泰视等，韩国的三星、现代。</li>
</ul>
<h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>ISP 是图像信号处理器（Image Sensor Processor）。一般用来处理Image Sensor（图像传感器）的输出数据，如做AE（自动曝光）、AGC（自动增益控制）、AWB（自动白平衡）、色彩校正、Lens Shading、Gamma 校正、祛除坏点、Auto Black Level、Auto White Level 等等功能的处理。</p>
<h3 id="AE"><a href="#AE" class="headerlink" title="AE"></a>AE</h3><p>自动曝光（Auto Exposure），根据外界光线的强弱自动调整曝光量和增益，防止曝光过度或者不足。AE 算法的主要调控对象一般是光圈、sensor增益（包含模拟增益和数字增益）、ISP数字增益这三个参数。</p>
<p>影响曝光的因素有曝光时间；光圈大小；Sensor的ISO感光度。</p>
<p>帧曝光时间Ft和帧率f的关系为：f = 1 / Ft，曝光时间的计算方法由sensor厂商提供。</p>
<p>EV曝光值（exposure value），摄影技术中定义的曝光值参数，代表能够给出同样曝光的所有相机光圈组合。它的定义是：$EV = \log(N^2 \div t)$<br>其中N是光圈的f-stop值；t是曝光时间，单位为秒。</p>
<p>EV0 对应于ISO100，曝光时间为1秒，光圈为f/1.0，以及与之等效的所有曝光组合，这些组合可以使18%的中性灰卡在所处光照条件下获得合适的曝光。因此曝光值主要体现了拍摄场景的亮度，同时在一定程度上也能反映相机的灵敏度。</p>
<p>曝光值每增加1称为增加一挡曝光，也就是将曝光量减半，比如将曝光时间或光圈面积减半，因此可以从EV0出发，按照光圈、快门加倍或减半的方式推导出其余的曝光档位，一般常用的档位在-6~20之间。</p>
<p>如果已知使画面正确曝光的EV值，则可以在下表中选择一个合适的曝光时间+光圈组合。举例来说，假设已知某拍摄场景正确曝光需要EV2，在固定ISO100的前提下，光圈和快门组合只能在（1s,f/2），（1/2s,f/1.4），（1/4s,f/1）这三个方案中选择一个。</p>
<p><img src="/images/sensor/v2-c02e83e125e4c8ef22e1ed881274f0a0_b.jpg" alt="img"></p>
<p>下表给出了EV0~EV20的典型场景。<br><img src="/images/sensor/v2-6e533fff18f0d918e10799c77da24350_b.jpg" alt="img"></p>
<p>下表给出了更完整的EV数据，同时包含了ISO，光圈和快门值<br><img src="/images/sensor/v2-fdcf59270dee877d6e1b9d79bf9c625f_b.jpg" alt="img"></p>
<p>光圈、快门、增益都可以影响画面亮度，但是这三者在效能上并不是完全等价的。摄影领域常用一个曝光三角形来形象地阐释三者之间的关系。<br><img src="/images/sensor/v2-af09e43949d8c5d8dc36214597209286_b.jpg" alt="img"></p>
<p>光圈（aperture）的副作用主要是影响景深。快门的副作用主要是影响运动模糊。一般而言，当曝光时间大于15ms时，画面中速度大于40km/h的车辆就会开始变模糊。当曝光时间大于30ms时，画面中走动的人就会变模糊。因此拍摄对象的预期移动速度基本上决定了曝光时间的上限。增益的副作用主要表现为画面噪声，尤其是数字增益会引入较大的噪声，显著降低图像质量。<br><img src="/images/sensor/v2-ed7c2425f86f43612ef449e0bff2ce4a_b.jpg" alt="img"></p>
<h3 id="AWB"><a href="#AWB" class="headerlink" title="AWB"></a>AWB</h3><p>色温随可见光的光谱成分变化而变化，在低色温光源下，白色物体偏红，在高色温光源下，白色物体偏蓝。人眼可根据大脑的记忆判断，识别物体的真实颜色，AWB（自动白平衡调整Auto White Balance ） 算法的功能是降低外界光源对物体真实颜色的影响，使得我们采集的颜色信息转变为在理想日光光源下的无偏色信息。要求在不同色温环境下，照白色的物体，屏幕中的图像应也是白色的。</p>
<ul>
<li><p>色温的定义：将黑体从绝对零度开始加温，当温度升高到一定程度时候，黑体便辐射出可见光，其光谱成份以及给人的感觉也会着温度的不断升高发生相应的变化。于是，就把黑体辐射一定色光的温度定为发射相同色光光源的色温。</p>
</li>
<li><p>白平衡：在不同色温的光源下，白色在传感器中的响应会偏蓝或偏红。白平衡算法通过调整 R, G, B 三个颜色通道的强度，使白色真实呈现。</p>
</li>
</ul>
<h3 id="3DNR"><a href="#3DNR" class="headerlink" title="3DNR"></a>3DNR</h3><p>2D降噪：只在2维空间域上进行降噪处理。对一个像素将其与周围像素平均，平均后噪声降低，但缺点是会造成画面模糊，特别是物体边缘部分。因此对这种算法的改进主要是进行边缘检测，边缘部分的像素不用来进行模糊。</p>
<p>3D降噪即3D DNR（3D Digital Noise Reducer），通过对比相邻的几帧图像，将图像信号中不重叠的噪波自动滤出。目前比较普遍的是进行Y/C分离，即从视频信号中将亮度信号（Y）和颜色信号（C）分离，然后对Y信号，C信号进行3维数字降噪。3D降噪增添了时域处理，因此变为3维。和2D降噪的不同在于，2D降噪只考虑一帧图像，而3D降噪进一步考虑帧与帧之间的时域关系，对每个像素进行时域上的平均，故计算量大，耗时更长。</p>
<h3 id="BLC"><a href="#BLC" class="headerlink" title="BLC"></a>BLC</h3><p>BLC（Black Level Correction）/ Black Level Compensate (OBC) ：黑电平校正。黑电平是在没有外界光线输入时，理想情况下像素值应该是0，但是实际中因为sensor暗电流作用仍会输出的亮度值。ISP 需要减去这个亮度值（这一个值会受到AWBGain，CCM，Gamma的影响）。</p>
<h3 id="LSC"><a href="#LSC" class="headerlink" title="LSC"></a>LSC</h3><p>LSC（Lens Shading Correction）/Color Shading ：阴影校正。Lens Shading是由于镜片从边缘到中心对入射光线的反射程度不同，镜头中心接收的光强大，边缘接收的光强较少， 造成图像从中心到边缘亮度逐渐变暗。Color Shading是由于Lens从中心到边缘，其R、G、B变暗的速率不一样，总体表现就是Gb/Gr像素值差异较大，两个像素之间有细微纹理。</p>
<h3 id="CCM"><a href="#CCM" class="headerlink" title="CCM"></a>CCM</h3><p>CCM（Color Correction Matrix/ DSC color calibration）：颜色校正矩阵。sensor 对光谱的响应在 RGB 各分量上与人眼对光谱的响应通常是有偏差的，拍摄color checker24色板，将相机拍摄图片值与色板标准值之间进行对比，得出一组能将拍摄值校正到最接近标准值的3x3矩阵。通常通过一个色彩校正矩阵对所有相机拍摄的图片进行颜色校正，使图像与人眼视觉在色彩上保持一致。</p>
<p><img src="/images/sensor/image-20200221200943546.png" alt="image-20200221200943546"><br>m<del>RR</del> + m<del>RG</del> + m<del>RB</del> = 256<br>m<del>GR</del> + m<del>GG</del> + m<del>GB</del> = 256<br>m<del>BR</del> + m<del>BG</del> + m<del>BB</del> = 256</p>
<p>（2）DPC/BPD（Defect Pixel Correction/Bad Pixel Detect）：坏点校正/坏点检测。相机中成像坏点一般是白色或者黑色的点，和周围像素点的差异明显。</p>
<p>（3）FPN（Fix Pattern Noise）：固定模式噪声。由于CMOS每个感光二极体旁都搭配一个ADC 放大器，如果以百万像素计，那么就需要百万个以上的 ADC 放大器，但是每个像素结构中的光电二极管的尺寸、掺杂浓度、生产过程中的沾污以及MOS场效应管的参数的偏差等都会造成像素输出信号的变化。对于给定的单个像素它是固定的。通常消除固定模式噪声采用“双采样降噪”方法，这是CMOS 感光器件特有的一种降噪方式。在光线较暗的环境下使用时，画面会有明显的噪声，这时通过对景物进行两次不同曝光率和敏感度的采样，然后将两次采样的结果进行综合处理，就可以有效解决低照度下的图像噪声问题。</p>
<p>（5）Flare offset：光学上称Flare也叫stray light,耀斑补偿。镜片的表面反射或镜筒、反光镜组的内面所引起的反射光，到达底面后造成画面整体或一部份产生了雾蒙，降低了图像的鲜锐度。镜片的镀膜及内面防反射处理的加强，固然可以大幅度地减少光斑，但被摄体的状况并不相同，不可能完全消除。</p>
<p>因此，在相机里面设计都是黑色的，且其内侧表明设计都是粗糙的，目前就是为了减小flare。flare如何修正？做直方图，然后每阶的亮度都往下降，这样是否会影响颜色呢？因此，flare一定要是在linear domain去做，不能在RGB domain去做。</p>
<p>（9）DM（Demosaicing/Color Filter Array Interpolation/CFA插值）：CMOS Sensor出来的RawData是Bayer格式的图像，每个像素只有一个通道的信息。DM是将Bayer格式的图像恢复成每个像素用RGB三通道表示的方式。DM的主要依据是图像在平滑的局部区域，各分量的ratio是相等的。插值算法的好坏会影响图片的细节，如摩尔纹。</p>
<p>（12）EE（Edge Enhancement/Edge Sharpening）：锐化，边缘增强。通过滤波器获取图像的高频分量，按照一定的比例将高频部分和原图进行加权求和获取锐化后的图像。</p>
<p>（13）DRC/HDR（Dynamic Range Compression/ High-Dynamic Range）：宽动态。高动态图像的拍摄出来的结果通常会有，亮部太亮，暗部太暗的问题。DRC是调整图像暗部亮度使之变亮，调整亮部亮度使之变暗，而且保持图像的对比度。</p>
<p>（14）PCA/VDE：Hue，Saturation，Contrast，Brightness调试。单独针对Hue，Saturation，Contrast，Brightness各图像分量进行调节。</p>
<p>（15）Histogram：直方图均衡化。重新分布图片的亮度。使图片的亮度分布更加均匀。</p>
<p>（16）FlashLight Control：闪光灯控制</p>
<p>（17）Cross talk：Optical cross-talk是当主光线进光角度过大，导致光线不能有效地进入本像素的Microlens内，而是进入相邻像素单元或其他无效区域内的现象。</p>
<p>Electric cross-talk：相邻单元之间的光生少数载流子通过衬底扩散和漏电相互影响造成相邻单元的现象。</p>
<p>上述原因导致结果都是图像在对角线上相邻两个像素的Gr和Gb value差异较大而产生不平滑的纹理状。</p>
<p>（18）Gradation Control（GDC）：可能是对图像数据精度进行的操作</p>
<p>（19）Scaler：对图像进行缩放，缩放的过程中采样和插值直接影响图像的细节质量。</p>
<p>（20）Adaptive tone scale：(这个没有办法处理多种场景)进来的影像，根据histogram，可以调节，让其明暗亮度的曲线比较好看。因此，它最重要的就是histogram equalization，其关键是在哪个domain去做。目前我们的做法应该是在L*做histogram，但只做edge的histogram，这样就ok了。</p>
<p>（21）Dynamic Range Compression：就是把暗的地方变亮一些，亮的地方变暗一些。AE的主要目的是避免亮度饱和的pixels，其余exposure的pixel可以通过DRC校准回来。</p>
<h2 id="Iris"><a href="#Iris" class="headerlink" title="Iris"></a>Iris</h2><p>光圈是镜头上的一个组件，由机械或电压控制，可通过控制通光孔的开合程度，控制进光量的大小，光圈的进光量与其f值的平方成反比。DC-Iris不能精确定位，P-Iris能精确定位。</p>
<p>计量光学系统的通光量时使用f-stop作为计量单位，f-stop = f （镜头焦距）/ D（光圈孔径），f-stop值越大表示光圈孔径越小，常用的f-stop值一般在1.4~22之间,如下图所示。<br><img src="/images/sensor/v2-910b34243ef1be1dfba55f6f564290a0_720w.jpg" alt="img"></p>
<p>由于f-stop反比于光圈孔径，根据圆面积公式S=πD^2/4，镜头的实际通光量与f-stop的平方成反比，它们之间名义上的对应关系如下。<br><img src="/images/sensor/v2-907684804fe2f746a039be86ab42a9cf_720w.jpg" alt="img"></p>
<p>一般来说，光圈f值从f1.8<del>f22较常见， 其中 f1.8</del>f5.4，室内用得多一些；而f5.0以上室外用得多，暗场景一般使用最小的f值光圈以获得较大的通光量。</p>
<p>曝光表示的是照片所记录的光量多少，单位是EV。控制照片的明暗程度。曝光由光圈、快门速度、ISO感光度这三大要素来决定。开大光圈、降低快门速度、提升ISO感光度可以增加曝光。</p>
<p>快门速度指的是拍摄时照片曝光的时间。是控制曝光的三大要素之一。快门速度越高，曝光量越小，容易把照片拍暗。阳光过于强烈的室外可以使用高速快门获得恰当曝光。同时，快门速度越高越能定格高速运动的被摄体，防止手抖动。相反，快门速度越低，曝光量越大，容易将暗处拍亮。同时，运动被摄体越容易拍模糊，也容易产生手抖动。可以利用低速快门进行长时间曝光，通过被摄体抖动进行摄影表现，比如拍摄星轨等。</p>
<p>光圈是镜头上的小孔，可通过开大缩小来控制镜头的通光量。是控制曝光的三大要素之一。光圈值用F表示，F值越小光圈越大，小于F2.8的光圈一般被称为大光圈。光圈越大照片的曝光量也越大，有利于将暗处拍亮，或提升快门速度防止手抖动、定格运动被摄体。光圈大的时候，景深（照片中清晰的范围）也会变小，合焦面之外的虚化增大，可利用虚化营造柔美表现。相反，光圈越小照片的曝光量越小，景深则增大。可获得画面整体清晰的泛焦效果。但要注意快门速度可能降低。</p>
<p>ISO感光度原本是胶片时代，指代胶片上的感光材料对光线敏感程度的指标。是控制曝光的三大要素之一。数码时代，图像感应器取代了胶片，光信号要在图像感应器上转换为电信号才能记录为照片。提高ISO感光度相当于图像感应器对光信号进行电子增幅，对微弱光线增幅，可以把暗处拍亮。但因为是电子增幅，高感光度下会出现噪点，影响画质。相机的标准感光度为ISO 100。使用相对低的感光度不会出现噪点，但光线不够强的时候，可能需要大光圈或低速快门来增加曝光量。相同曝光量下，提高ISO感光度可以提升快门速度，定格运动被摄体或抑制手抖动。</p>
<p>测光模式<br>测光指的是相机对拍摄画面的明暗程度进行测量，以此为基准决定曝光。相机的测光模式一般有评价测光、局部测光、点测光、中央重点平均测光。最通常的测光模式是评价测光。评价测光将画面分成多个区域并分别进行测光估算出画面亮度的平均值，同时还会结合所用自动对焦点位置的信息综合考虑合焦被摄体的亮度，在大多数场景下，评价测光能够获得基本合适的曝光。其他几种测光模式则是以画面中央部分的亮度为基础来计算曝光。</p>
<p>曝光补偿<br>相机的自动曝光会倾向于将画面拍得不太暗也不太亮的中间亮度。所以在拍摄本身很黑或很白的被摄体时容易将其拍得发灰，不是肉眼所见的亮度。当相机的自动曝光无法获得所需画面亮度时，可以通过曝光补偿手动调节亮度，获得想要的明暗效果。相机曝光补偿的范围一般是±3EV，可以1/3级为单位调节。负向补偿照片变暗，正向补偿照片变亮。如现场很难判断补偿程度，可以结合自动包围曝光一次拍摄3张亮度不同照片选出理想的一张。</p>
<p>焦距指的是镜头中心到图像感应器的距离。单位是mm表。焦距直接反应的是镜头的视角，即镜头能够收入多大范围的画面。焦距越短收入的画面范围越大，焦距越长收入的画面范围越小。</p>
<p>被摄体的颜色会受环境光源的影响而产生偏色。AWB（自动白平衡）用于调节照片颜色，令白色能够还原为白色。</p>
<p>虚化<br>对焦后，画面中对上焦的合焦面是清晰的，从合焦面开始向前及向后的部分，成像会逐渐模糊。这种模糊就是虚化，虚化也被称为焦外。虚化与景深直接相关，影响虚化大小的要素是光圈、镜头焦距、拍摄距离（相机与被摄体之间的距离）。光圈越大（光圈值越小）虚化越大，此外镜头焦距越长，拍摄距离越近虚化也越大。作为摄影的表现手法，虚化又分为前景虚化及背景虚化。</p>
<h3 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h3><p>对焦后，画面中以合焦面为中心，向前及向后看起来清晰锐利的范围就是景深，也被称为焦内。景深与虚化直接相关，景深的大小由光圈、镜头焦距、拍摄距离（相机与被摄体之间的距离）这三个要素决定。光圈越小（光圈值越大）、镜头焦距越短、拍摄距离越远，相应景深就越大，照片整体越清晰，趋向于泛焦效果。相反的，光圈越大、镜头焦距越长、拍摄距离越近，相应景深就越小，合焦面前后更容易虚化，被摄体与背景趋于分离。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/usb_if/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/usb_if/" class="post-title-link" itemprop="url">usb接口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 18:03:15" itemprop="dateModified" datetime="2022-06-08T18:03:15+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/usb/usb-if2.png" alt="usb接口"></p>
<p><img src="/images/usb/usb-if3.png" alt="usb接口"></p>
<p><img src="/images/usb/usb_if.bmp" alt="usb接口"></p>
<p><img src="/images/usb/usb-if.png" alt="usb接口"></p>
<p>标准USB接口使用标记为D+(绿线)和D-(白线) 的双绞线传输，它们各自使用半双工的差分信号并协同工作，以抵消长导线的电磁干扰。</p>
<p>Mini USB接口把第4针作为ID线，用来标识身份，mini-A插头的ID引脚接地，而mini-B插头悬空。<strong>USB OTG根据ID线状态判断是主机还是从机，接地为主机，悬空为从机</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/usb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/usb/" class="post-title-link" itemprop="url">usb协议</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 18:03:22" itemprop="dateModified" datetime="2022-06-08T18:03:22+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="USB规范"><a href="#USB规范" class="headerlink" title="USB规范"></a>USB规范</h2><p>USB最初是由英特尔与微软公司倡导发起，其最大的特点是支持热插拔(Hot plug)和即插即用(Plug&amp;Play)。</p>
<p><strong>电压范围4.75 ~ 5.25V</strong>，普通USB接口<strong>最大提供500mA电流</strong>，USB符号后有一个“+”号的，输出电流可达1A。</p>
<p><strong>一个USB主控制器最多可连接127个设备，各设备之间的距离不超过5米</strong>。</p>
<table>
<thead>
<tr>
<th align="left">USB版本</th>
<th align="left">速率称号</th>
<th align="left">传输速率</th>
<th align="left">理论速度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">USB 3.2</td>
<td align="left">超高速+  Super-Speed+</td>
<td align="left">20Gbps</td>
<td align="left">2560MB/s</td>
</tr>
<tr>
<td align="left">USB 3.1 Gen2</td>
<td align="left">超高速+  Super-Speed+</td>
<td align="left">10Gbps</td>
<td align="left">1280MB/s</td>
</tr>
<tr>
<td align="left">USB 3.1 Gen1</td>
<td align="left">超高速 Super-Speed</td>
<td align="left">5Gbps</td>
<td align="left">640MB/s</td>
</tr>
<tr>
<td align="left">USB 2.0</td>
<td align="left">高速 Hi-Speed</td>
<td align="left">480Mbps</td>
<td align="left">60MB/s</td>
</tr>
<tr>
<td align="left">USB 1.1</td>
<td align="left">全速 Full-Speed</td>
<td align="left">12Mbps</td>
<td align="left">1.5MB/s</td>
</tr>
<tr>
<td align="left">USB 1.0</td>
<td align="left">低速 Low-Speed</td>
<td align="left">1.5Mbps</td>
<td align="left">0.192MB/s</td>
</tr>
</tbody></table>
<p>USB2.0 支持 3 种传输速度:低速模式(1.5Mb/s)、全速模式(12Mb/s)和高速模式(480Mb/s)。在低速和全速模式中，采用的是电压传输模式；高速模式下，是电流传输模式。</p>
<p>USB2.0 规范要求集线器必须支持高速模式，USB2.0 设备则没有这个要求。一个高速的上行收发器不能支持低速信号传输模式。而 USB2.0 下行收发器必须支持高速、全速和低速模式。</p>
<h3 id="插入检测机制"><a href="#插入检测机制" class="headerlink" title="插入检测机制"></a>插入检测机制</h3><p>在 USB 集线器的每个下游端口的 D+和 D-上，分别接了一个 15kΩ的下拉电阻。当集线器端口没有设备插入时，输入端被这两个下拉电阻拉到了低电平。而在USB 设备端，在 D+或者 D-上，接了一个 1.5kΩ的上拉电阻到 3.3V 的电源。<strong>对于高速设备和全速设备，上拉电阻接在 D+上；低速设备，上拉电阻接在 D-上</strong>。</p>
<p>当设备插入到集线器时，接了上拉电阻的数据线的电压由 1.5kΩ的上拉电阻和 15kΩ的下拉电阻分压，大概 3V 左右。这是一个高电平信号。集线器检测到该状态后就上报给 Host控制器，这样就检测到设备插入。通过检测高电平的数据线是 D+还是 D-来判断设备是什么速度类型。</p>
<p>高速设备会首先被判断为全速设备，然后通过集线器和设备两者确认，切换到高速模式下。高速模式下是电流传输模式，此时需要把 D+的上拉电阻断开。</p>
<h2 id="USB结构"><a href="#USB结构" class="headerlink" title="USB结构"></a>USB结构</h2><p><img src="/images/usb/bus-topology.png" alt="usb拓扑结构"></p>
<p>USB是一种主从结构的系统，主机叫做Host，从机叫做设备。USB的设计为非对称式的，它由一个主机(host)控制器和若干通过集线器设备以树形连接的设备组成。以根集线器为起点，最多支持7层，也就是说在USB系统中最多允许5个hub级联。一个USB主控制器最多连接127个设备，这是因为协议规定每个USB设备具有一个7bit的地址，地址0是保留给未初始化的设备使用。</p>
<h3 id="USB-Host"><a href="#USB-Host" class="headerlink" title="USB Host"></a>USB Host</h3><p>主机具有一个或多个usb主控制器和根集线器(root hub)。主控制器负责数据处理。根集线器则提供一个连接主控制器与设备之间的接口和通道，它集成在主机控制器里，不占用地址。</p>
<p>Host 主要负责:</p>
<ul>
<li>检测 USB 设备拔插</li>
<li>管理 Host 和 Device 之间的控制流、数据流</li>
<li>收集 USB 总线状态和活动数据信息</li>
<li>为连入 USB 总线的设备供电</li>
</ul>
<h3 id="USB-Device"><a href="#USB-Device" class="headerlink" title="USB Device"></a>USB Device</h3><p>USB 设备通过 HUB 连接到 USB 总线上，此时 HUB 上的接入点称为端口(Port)。连接到 Hub 上的设备可能是单个设备，也可以是复合设备(Compound<br>Device)。每一个 USB 设备提供不同的功能，又被称作 Function。</p>
<p>USB 设备支持热插拔。USB 设备通过 HUB 连接到 USB 总线。Hub 有一个状态位，标记 USB 设备是插入还是拔出。Host 会查询 Hub 端口的状态位，当检测到设备插入时，Host 将使能该 Hub 对应的 port，并通过默认地址(0)从设备控制管道为设备分配地址。当一个设备从 Hub 的某个 port 拔出时，Hub 将禁能该 port 并报告给 Host。</p>
<p>从 USB 系统角度而言，一个逻辑上的 USB 设备是一个端点的集合。分组的端点构成一个接口(Interface)。USB 系统通过管道来管理接口，通过 Host 上的 Buffer 和 USB 设备上的端点来请求数据。 Host Controller 打包数据并将数据包发送出去。</p>
<h3 id="USB-Hub"><a href="#USB-Hub" class="headerlink" title="USB Hub"></a>USB Hub</h3><p>USB集线器是一种可以对原有的USB口在数量上进行扩展的设备。hub提供了设备连接检测和设备移除检测的能力，并给各下行端口供电。 可以单独使能下行端口，不同端口可以工作在不同的速度等级。</p>
<h2 id="USB通信协议"><a href="#USB通信协议" class="headerlink" title="USB通信协议"></a>USB通信协议</h2><h3 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h3><p>数据在 USB 线里传送是低位在前高位在后。USB 采用 NRZI(非归零编码)对发送的数据包进行编码，即:输入数据 0，编码成“电平翻转”；输入数据 1，编码成“电平保持”。</p>
<p><img src="/images/usb/NRZI.png" alt="NRZI编码"></p>
<p>USB提供了4 种传输方式：</p>
<ul>
<li>控制(Control)传输方式。双向传输，数据量通常较小，主要用来进行查询、配置和给 USB 设备发送通用的命令。</li>
<li>同步(Synchronization)传输方式。提供了确定的带宽和间隔时间，它被用于时间严格并具有较强容错性的流数据传输，或者用于要求恒定的数据传送率的即时应用。例如进行语音业务传输时，使用同步传输方式是很好的选择</li>
<li>中断(Interrupt)传输方式。传送是单向的，对于 USB 主机而言，只有输入。中断传输方式主要用于定时查询设备是否有中断数据要传送，该传输方式应用在少量的、分散的、不可预测的数据传输场合，键盘、游戏杆和鼠标属于这一类型。</li>
<li>批量(Bulk)传输方式。主要应用在没有带宽和间隔时间要求的批量数据的传送和接收，它要求保证传输打印机和扫描仪属于这种类型。</li>
</ul>
<h2 id="USB协议"><a href="#USB协议" class="headerlink" title="USB协议"></a>USB协议</h2><p>USB 是一种轮询总线，由 Host 发起所有的数据传输。总线传输包含 3 个包(packet)。每个传输都由 Host 先发出令牌包(Token Packet)，明确传输类型、传输方向、USB 设备地址和端点号。对应地址的 USB 设备接收并解析包。一次传输可以由 Host 发向设备，也可以由设备发送至 Host，方向由令牌包说明。</p>
<h3 id="USB数据包"><a href="#USB数据包" class="headerlink" title="USB数据包"></a>USB数据包</h3><ul>
<li><strong>USB数据包格式</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">偏移量</th>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">HeaderChksum</td>
<td align="center">1</td>
<td align="center">利用添加包头进行效验，不包括包头本身的校验。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">HeaderSize</td>
<td align="center">1</td>
<td align="center">包头的大小，包括可用的字符串。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Signature</td>
<td align="center">2</td>
<td align="center">数据值为0x1234</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">VendorID</td>
<td align="center">2</td>
<td align="center">USB提供商的ID</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">ProductID</td>
<td align="center">2</td>
<td align="center">USB产品ID</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">ProductVersion</td>
<td align="center">1</td>
<td align="center">产品版本号</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">FirmwareVersion</td>
<td align="center">1</td>
<td align="center">固件版本号</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">USB属性</td>
<td align="center">1</td>
<td align="center">USB Attribute: Bit 0：如果设为1，包头包括以下三个字符串：语言、制造商、产品字符串；如果设为0，包头不包括任何字符串。 Bit 2：如果设为1，设备自带电源；如果设为0，无自带电源。 Bit 3：如果设为1，设备可以通过总线供电；如果设为0，无法通过总线供电。 Bits 1 and 4—7：保留。</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">最大电力</td>
<td align="center">1</td>
<td align="center">设备需要的最大电力，以2mA为单位。</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">设备属性</td>
<td align="center">1</td>
<td align="center">Device Attributes: Bit 0：如果设为1，CPU运行在24 MHz；如果设为0，CPU运行在12 MHz。 Bit 3：如果设为1，设备的EEPROM可以支持400 MHz；如果设为0，不支持400 MHz。 Bits 1, 2 and 4 … 7：保留。</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">WPageSize</td>
<td align="center">1</td>
<td align="center">I2C的最大写入页面大小</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">数据类型</td>
<td align="center">1</td>
<td align="center">该数值定义设备是软件EEPROM还是硬件EEPROM。0x02：硬件EEPROM 其它数值无效。</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">RpageSize</td>
<td align="center">1</td>
<td align="center">I2C最大读取页面大小。如果值为0，整个负载大小由一个I2C读取设备读取。</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">PayLoadSize</td>
<td align="center">2</td>
<td align="center">如果将EEPROM作为软件EEPROM使用，表示软件的大小；除此之外该值都是0。</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Language string</td>
<td align="center">4</td>
<td align="center">语言字符串。以标准USB字符串格式表示。（非必要字段）</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Manufacture string</td>
<td align="center">…</td>
<td align="center">制造商字符串。以标准USB字符串格式表示。（非必要字段）</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Product string</td>
<td align="center">…</td>
<td align="center">产品字符串，以标准USB字符串格式表示。（非必要字段）</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Application Code</td>
<td align="center">…</td>
<td align="center">表示应用代码。以标准USB字符串格式表示。（非必要字段）</td>
</tr>
</tbody></table>
<h2 id="USB设备"><a href="#USB设备" class="headerlink" title="USB设备"></a>USB设备</h2><h3 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h3><p>依附在总线上的设备可以是需要特定的驱动程序的完全定制的设备，也可能属于某个设备类别。这些类别定义设备的行为和接口描述符，这样一个驱动程序可能用于所有此种类别的设备。一般操作系统都为支持这些设备类别，为其提供通用驱动程序。设备分类由USB设计论坛设备工作组决定，并分配ID。</p>
<p>如果一个设备类型属于整个设备，该设备的描述符的bDeviceClass域保存类别ID；如果它这是设备的一个接口，其ID保存在接口描述符的bInterfaceClass域。他们都占用一个字节，所以最多有253种设备类别。（0x00和0xFF保留）。当bDeviceClass设为0x00，操作系统会检查每个接口的bInterfaceClass以确定其类别。</p>
<p>常用设备类别和ID有：<br>|  ID  |       设备        |                             例子                             |<br>| :–: | :—————:| :———————————————————-: |<br>| 0x00 | 保留值       |                              无                              |<br>| 0x01 | 音效设备      |                             声卡                             |<br>| 0x02 | USB通信控制设备   |                  网卡、调制解调器、串列端口                   |<br>| 0x03 | 人机界面设备(HID)  |                          键盘、鼠标                          |<br>| 0x05 | 物理接口设备      |        控制杆    |<br>| 0x06 | 静止图像捕捉设备  | 影像扫描仪、Picture Transfer Protocol |<br>| 0x07 |  打印设备        |        打印机      |<br>| 0x08 | 大容量访问设备    | U盘、移动硬盘、存储卡读卡器、数字相机 |<br>| 0x09 | 集线器       |                            集线器                            |<br>| 0x0A | 通信设备      | 调制解调器、网络卡、ISD、传真 |<br>| 0x0B | 智能卡设备     |                            读卡器                            |<br>| 0x0E | 影像设备    |      摄像头   |<br>| 0xE0 | 无线传输设备   |          蓝牙   |<br>| 0xFE | 特殊的应用    |                       红外线资料桥接器                       |<br>| 0xFF | 定制设备      |                                                              |</p>
<h3 id="lsusb"><a href="#lsusb" class="headerlink" title="lsusb"></a>lsusb</h3><p>显示本机的usb设备列表，可以显示出usb的详细信息，包括设备的读取速度和描述符。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-v</td>
<td>告诉lsusb详细显示所示设备的详细信息。这包括设备当前速度的配置描述符。如果可用，类描述符将显示USB设备类，包括集线器、音频、HID、通信和芯片卡。</td>
</tr>
<tr>
<td>-s [[bus]:][devnum]</td>
<td>显示指定总线和设备号的设备信息，总线和设备号用十进制标识。格式：lsusb –s 00:01</td>
</tr>
<tr>
<td>-d [vendor]:[product]</td>
<td>显示指定厂商和产品编号的设备，用十六进制表示编号。格式：lsusb –d 8086:</td>
</tr>
<tr>
<td>-D</td>
<td>显示指定设备文件的设备信息，例如：<code>lsusb –D /proc/bus/usb/001/001</code>。只有root用户才可以使用这个选项</td>
</tr>
<tr>
<td>-t</td>
<td>以树状结构显示</td>
</tr>
<tr>
<td>-V</td>
<td>指令版本信息</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/modbus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/modbus/" class="post-title-link" itemprop="url">modbus协议</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:57:34" itemprop="dateModified" datetime="2022-06-08T17:57:34+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Modbus"><a href="#Modbus" class="headerlink" title="Modbus"></a>Modbus</h2><p>Modbus协议是一种广泛应用于工业控制领域的通用通讯协议，使用的是主从通讯技术，即由主设备主动查询和操作从设备。通讯物理接口可以选用串口（包括RS232、RS485和RS422），也可以选择以太网口。有三种通信方式：</p>
<ul>
<li>以太网：对应的通信模式是MODBUS TCP/IP。</li>
<li>异步串行传输（各种介质如有线RS-232-/422/485/；光纤、无线等），对应的通信模式是MODBUS RTU或MODBUS ASCII。</li>
<li>高速令牌传递网络：对应的通信模式是Modbus PLUS</li>
</ul>
<h3 id="ASCII模式"><a href="#ASCII模式" class="headerlink" title="ASCII模式"></a>ASCII模式</h3><p><img src="/images/uart/Modbus-frame-structure-ASCII-mode.jpg" alt="Modbus帧结构-ASCII模式"></p>
<p>在ASCII模式下，消息以冒号（:）字符（ASCII码 3AH）开始，以回车换行符结束（ASCII码 0DH,0AH）。其它域可以使用的传输字符是十六进制的0…9,A…F。网络上的设备不断侦测“:”字符，当有一个冒号接收到时，每个设备都解码地址域来判断是否发给自己的。消息中字符间发送的时间间隔最长不能超过1秒，否则接收的设备将认为传输错误。</p>
<p>错误检测域包含两个ASCII字符，使用LRC（纵向冗长检测）方法对消息内容计算得出的，不包括开始的冒号符及回车换行符。</p>
<h3 id="RTU模式"><a href="#RTU模式" class="headerlink" title="RTU模式"></a>RTU模式</h3><p><img src="/images/uart/RTU.bmp" alt="RTU报文帧"></p>
<p><img src="/images/uart/1.5T.jpg" alt="img"></p>
<p>RTU模式规定消息发送至少要以3.5个字符时间的停顿间隔开始。至少3.5个字符时间的停顿标定了消息的结束。消息帧内字节间隔为1.5个字符时间。</p>
<p>从设备的地址范围是1~247，地址0是用作广播地址。主设备通过将要联络的从设备的地址放入消息中的地址域来选通从设备。当从设备发送回应消息时，它把自己的地址放入回应的地址域中，以便主设备知道是哪一个设备作出回应。</p>
<h3 id="功能码"><a href="#功能码" class="headerlink" title="功能码"></a>功能码</h3><p>Modbus的操作对象有四种：线圈、离散输入、输入寄存器、保持寄存器。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>线圈</td>
<td>1bit，ON或OFF，可读可写，有效的地址范围是1-9999</td>
</tr>
<tr>
<td>离散量</td>
<td>1bit，ON或OFF，只读，有效地址范围是10001-19999</td>
</tr>
<tr>
<td>输入寄存器</td>
<td>16位的寄存器，只读，可以用作模拟量或16位打包输入点，有效地址范围是30001-39999</td>
</tr>
<tr>
<td>保持寄存器</td>
<td>16位的寄存器，可读可写，既可以是一个模拟量或16位打包输入点，也可以是模拟量或16位打包输出点，有效地址范围是40001-49999</td>
</tr>
</tbody></table>
<p>Modbus的功能码有：</p>
<table>
<thead>
<tr>
<th>功能码</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>读线圈状态</td>
<td>读位（读N个bit）—读从机线圈寄存器，位操作</td>
</tr>
<tr>
<td>02</td>
<td>读输入离散量</td>
<td>读位（读N个bit）—读离散输入寄存器，位操作</td>
</tr>
<tr>
<td>03</td>
<td>读多个寄存器</td>
<td>读整型、字符型、状态字、浮点型（读N个words）—读保持寄存器，字节操作</td>
</tr>
<tr>
<td>04</td>
<td>读输入寄存器</td>
<td>读整型、状态字、浮点型（读N个words）—读输入寄存器，字节操作</td>
</tr>
<tr>
<td>05</td>
<td>写单个线圈</td>
<td>写位（写一个bit）—写线圈寄存器，位操作</td>
</tr>
<tr>
<td>06</td>
<td>写单个保持寄存器</td>
<td>写整型、字符型、状态字、浮点型（写一个word）—写保持寄存器，字节操作</td>
</tr>
<tr>
<td>07</td>
<td>读取异常状态</td>
<td>取得8个内部线圈的通断状态，这8个线圈的地址由控制器决定，用户逻辑可以将这些线圈定义，以说明从机状态，短报文适宜于迅速读取状态</td>
</tr>
<tr>
<td>08</td>
<td>回送诊断校验</td>
<td>把诊断校验报文送从机，以对通信处理进行评鉴</td>
</tr>
<tr>
<td>09</td>
<td>编程（只用于484）</td>
<td>使主机模拟编程器作用，修改PC从机逻辑</td>
</tr>
<tr>
<td>0A</td>
<td>控询（只用于484）</td>
<td>可使主机与一台正在执行长程序任务从机通信，探询该从机是否已完成其操作任务，仅在含有功能码9的报文发送后，本功能码才发送</td>
</tr>
<tr>
<td>0B</td>
<td>读取事件计数</td>
<td>可使主机发出单询问，并随即判定操作是否成功，尤其是该命令或其他应答产生通信错误时</td>
</tr>
<tr>
<td>0C</td>
<td>读取通讯事件记录</td>
<td>可是主机检索每台从机的ModBus事务处理通信事件记录。如果某项事务处理完成，记录会给出有关错误</td>
</tr>
<tr>
<td>0D</td>
<td>编程（184/384/484/584）</td>
<td>可使主机模拟编程器功能修改PC从机逻辑</td>
</tr>
<tr>
<td>0E</td>
<td>探询（184/384/484/584）</td>
<td>可使主机与正在执行任务的从机通信，定期控询该从机是否已完成其程序操作，仅在含有功能13的报文发送后，本功能码才得发送</td>
</tr>
<tr>
<td>0F</td>
<td>写多个线圈</td>
<td>可以写多个线圈—强置一串连续逻辑线圈的通断</td>
</tr>
<tr>
<td>10</td>
<td>写多个保持寄存器</td>
<td>写多个保持寄存器—把具体的二进制值装入一串连续的保持寄存器</td>
</tr>
<tr>
<td>11</td>
<td>报告从机标识</td>
<td>可使主机判断编址从机的类型及该从机运行指示灯的状态</td>
</tr>
<tr>
<td>12</td>
<td>（884和MICRO84）</td>
<td>可使主机模拟编程功能，修改PC状态逻辑</td>
</tr>
<tr>
<td>13</td>
<td>重置通信链路</td>
<td>发生非可修改错误后，是从机复位于已知状态，可重置顺序字节</td>
</tr>
<tr>
<td>14</td>
<td>读取通用参数（584L）</td>
<td>显示扩展存储文件中的数据信息</td>
</tr>
<tr>
<td>15</td>
<td>写入通用参数（584L）</td>
<td>把通用参数写入扩展存储文件</td>
</tr>
<tr>
<td>16~40</td>
<td>保留做扩展功能备用</td>
<td></td>
</tr>
<tr>
<td>41~48</td>
<td>保留以备用户功能所用</td>
<td>留作用户功能的扩展编码</td>
</tr>
<tr>
<td>49~77</td>
<td>非法功能</td>
<td></td>
</tr>
<tr>
<td>78~7F</td>
<td>保留</td>
<td>留作内部作用</td>
</tr>
<tr>
<td>80~FF</td>
<td>保留</td>
<td>用于异常应答</td>
</tr>
</tbody></table>
<p>常用功能码如下：</p>
<table>
<thead>
<tr>
<th>功能码</th>
<th>名称</th>
<th>功能</th>
<th>对应的地址类型</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>读线圈状态</td>
<td>读位（读N个bit）—读从机线圈寄存器，位操作</td>
<td>0x</td>
</tr>
<tr>
<td>02</td>
<td>读输入离散量</td>
<td>读位（读N个bit）—读离散输入寄存器，位操作</td>
<td>1x</td>
</tr>
<tr>
<td>03</td>
<td>读多个寄存器</td>
<td>读整型、字符型、状态字、浮点型（读N个words）—读保持寄存器，字节操作</td>
<td>4X</td>
</tr>
<tr>
<td>04</td>
<td>读输入寄存器</td>
<td>读整型、状态字、浮点型（读N个words）—读输入寄存器，字节操作</td>
<td>3x</td>
</tr>
<tr>
<td>05</td>
<td>写单个线圈</td>
<td>写位（写一个bit）—写线圈寄存器，位操作</td>
<td>0x</td>
</tr>
<tr>
<td>06</td>
<td>写单个保持寄存器</td>
<td>写整型、字符型、状态字、浮点型（写一个word）—写保持寄存器，字节操作</td>
<td>4x</td>
</tr>
<tr>
<td>0F</td>
<td>写多个线圈</td>
<td>写位（写n个bit）—强置一串连续逻辑线圈的通断</td>
<td>0x</td>
</tr>
<tr>
<td>10</td>
<td>写多个保持寄存器</td>
<td>写整形、字符型、状态字、浮点型（写n个word）—把具体的二进制值装入一串连续的保持寄存器</td>
<td>4x</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/spi-bus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/spi-bus/" class="post-title-link" itemprop="url">spi总线</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:55:21" itemprop="dateModified" datetime="2022-06-08T17:55:21+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SPI(Serial Peripheral Interface)串行外设接口是一种用于芯片通信的串行同步传输总线协议，最初由Motorola在2000年提出。</p>
<ul>
<li><p>SPI允许传输单个bit数据，甚至允许暂停，因为SCK时钟线由主控设备控制，当没有时钟跳变时，从设备不采集或传送数据。</p>
</li>
<li><p>支持全双工通信，每个从设备需要独立的使能信号。</p>
</li>
<li><p>推挽输出的驱动性能相比开漏输出信号完整性更好，支持高速应用（100MHz以上）。</p>
</li>
<li><p>协议支持字长不限于8bits，可根据应用特点灵活选择消息字长。</p>
</li>
<li><p>相比I2C和SMbus节省上拉电阻，不需要仲裁机制。</p>
</li>
<li><p>没有寻址机制，只能靠设备片选选择不同从设备，故没有数据流控制和应答机制。</p>
</li>
<li><p>SPI没有规定最大传输速率，通常能达到10Mbps。</p>
</li>
</ul>
<p><strong>Dual SPI</strong>是针对SPI Flash而言，不是针对所有SPI外设。对于SPI Flash，全双工并不常用，因此修改了mosi和miso的用法，使其工作在半双工，能够加倍传输数据。也就是说对于Dual SPI Flash，可以发送一个命令字节进入dual mode，这样mosi变成SIO0，mosi变成SIO1，这样一个时钟周期内就能传输2个bit数据。</p>
<p><strong>Qual SPI</strong>也是针对SPI Flash，Qual SPI 在Dual SPI基础上增加了两根线（SIO2、SIO3），目的是一个时钟内能传输4个bit数据。</p>
<h2 id="信号定义"><a href="#信号定义" class="headerlink" title="信号定义"></a>信号定义</h2><p><strong>MOSI</strong>：主设备数据输出，从设备数据输入。</p>
<p><strong>MISO</strong>：主设备数据输入，从设备数据输出。</p>
<p><strong>SCLK</strong>：时钟信号，由主设备产生。</p>
<p><strong>CS/SS</strong>：片选，从设备使能信号，由主设备控制。</p>
<p>SPI总线定义两个及以上设备间的数据传输，提供时钟的设备为主设备，接收时钟的设备为从设备。片选信号SS通常低电平有效。SPI数据传输原理是基于主从设备内部移位寄存器的数据交换。在主设备SCK的控制下，待传数据由各自设备的数据寄存器传输到移位寄存器，再通过MOSI和MISO信号线完成主从设备间的数据交换。</p>
<p><img src="/images/spi/spi_ms_mod_reg.png" alt="spi框图"></p>
<h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p>SPI有4种操作模式，每种模式由一对参数决定，主从设备必须使用相同的工作参数，才能正常工作。</p>
<p>CPOL时钟极性(clock polarity)，决定时钟空闲时的电平为高或低，对于SPI数据传输格式没有显著影响。</p>
<ul>
<li>0 : 时钟高电平时有效，空闲时为低。</li>
<li>1 : 时钟低电平时有效，空闲时为高。</li>
</ul>
<p>CPHA时钟相位(clock phase)，定义时钟脉冲在哪条边沿转换输出信号，哪条边沿采样输入信号。</p>
<ul>
<li>0 : 数据采样发生在时钟奇数边沿。</li>
<li>1 : 数据采样发生在时钟偶数边沿。</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>Mode 0</td>
<td>SCLK 空闲是为低电平，数据在上升沿有效</td>
</tr>
<tr>
<td>Mode 1</td>
<td>SCLK 空闲是为低电平，数据在下降沿有效</td>
</tr>
<tr>
<td>Mode 2</td>
<td>SCLK 空闲是为高电平，数据在下降沿有效</td>
</tr>
<tr>
<td>Mode 3</td>
<td>SCLK 空闲是为高电平，数据在上升沿有效</td>
</tr>
</tbody></table>
<p><img src="/images/spi/4mode.png" alt="4种模式"></p>
<p><img src="/images/spi/timing_diagram.png" alt="时序"></p>
<h2 id="多个从设备"><a href="#多个从设备" class="headerlink" title="多个从设备"></a>多个从设备</h2><ul>
<li><strong>片选方式</strong></li>
</ul>
<p>每个从设备都需要单独的片选信号，主设备每次只能选择其中一个从设备进行通信。因为所有从设备的SCK、MOSI、MISO都是连在一起的，未被选中从设备的MISO要表现为高阻状态以避免数据传输错误。由于每个设备都需要单独的片选信号，如果需要的片选信号过多，可以使用译码器产生所有的片选信号。</p>
<p><img src="/images/spi/multiple-slaves.png" alt="主设备以片选方式控制多个从设备"></p>
<ul>
<li><strong>菊花链方式</strong></li>
</ul>
<p>数据信号经过主从设备所有的移位寄存器构成闭环。数据通过主设备发送（绿色线）经过从设备返回（蓝色线）到主设备。在这种方式下，片选和时钟同时接到所有从设备。</p>
<p>菊花链式连接常用于仅需主设备发送数据而不需要接收返回数据的场合，如LED驱动器。在这种应用下，主设备MISO可以不连。如果需要接收从设备的返回数据，则需要连接主设备的MISO形成闭环。同样地，切记要发送足够多的接收指令以确保数据移位送达主设备。</p>
<p><img src="/images/spi/multiple-slaves2.png" alt="主设备以菊花链方式控制多个从设备"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/i2c-bus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/i2c-bus/" class="post-title-link" itemprop="url">i2c总线</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:56:48" itemprop="dateModified" datetime="2022-06-08T17:56:48+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a target="_blank" rel="noopener" href="https://www.i2c-bus.org/">https://www.i2c-bus.org/</a></p>
<p>I2C总线(Inter Integrated-Circuit)是由PHILIPS公司在上世纪80年代发明的一种电路板级串行总线标准，通过时钟线SCL和数据线SDA即可完成主从机的单工通信，广泛应用于电路板级的内部通信。</p>
<ul>
<li><p>总线上的所有设备通过软件寻址且具有唯一的地址。</p>
</li>
<li><p>总线上所有器件都具有自动应答功能，保证数据传输的正确性；</p>
</li>
<li><p>主机和从机的区别在于对SCL的发送权，只有主机才能发送SCL；</p>
</li>
<li><p>I2C数据传输速率有标准模式(100 kbps)、快速模式(400 kbps)和高速模式(3.4 Mbps)。</p>
</li>
</ul>
<p><img src="/images/i2c/i2c-bus.png" alt=" I2C连接示意图"></p>
<p>I2C总线上所有器件的SDA、SCL引脚输出驱动都为漏极开路结构，因此SDA和SCL可以被拉低为低电平，但是不能被驱动为高电平，低电平输出电压最大为0.4V，上拉电阻一般为4.7KΩ。通过外接上拉电阻实现总线上所有节点SDA、SCL信号的线与逻辑关系。<strong>线与</strong>的意思是只要总线上有一个设备输出底电平，总线信号就会被拉底。线与的作用在于可以实现总线的仲裁控制，总线的控制权会交给最后一个输出低电平的设备，其它设备(输出为高)通过检测总线上的电平状态(表现为低)，对比与自己输出状态不一致，则自动退出对总线的控制请求。</p>
<p>漏极开路/集电极开路的缺点是对于一个距离长的数据线，信号传输速率得不到有效保证。更长的走线对于输出驱动器表现为更大的容性负载，等效容性负载C和信号线的上拉电阻R构成RC振荡器。RC越大，意味着反射和振荡越强，从而影响总线的信号完整性。所以I2C总线允许挂载最多的设备数量取决于总线上最大电容值，一般为400pf(Hs模式100pf)。</p>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><p><img src="/images/i2c/i2c-data.webp" alt="数据序列"></p>
<h3 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h3><p>协议没有规定I2C逻辑1和0的电平值。每传输一比特数据SDA，对应产生一个时钟脉冲SCL。<strong>SCL为高时，SDA不允许变化；只有在SCL为低时，SDA才可以变化</strong>。</p>
<p><img src="/images/i2c/bit.png" alt="位的传输"></p>
<h3 id="开始-结束条件"><a href="#开始-结束条件" class="headerlink" title="开始/结束条件"></a>开始/结束条件</h3><p>如果I2C总线空闲，那么SCL和SDA信号线将都为高电平。<strong>在SCL为高电平时，将SDA由高到低电平跳变，作为起始信号，SDA由低到高电平跳变，作为结束信号</strong>。</p>
<p><img src="/images/i2c/start-stop.png" alt="开始和结束条件"></p>
<p>开始/结束条件总是由主机发起的。主机发出开始条件后，总线处于忙的状态；主机发出结束条件后，总线处于空闲状态。如果两个主机在同一时刻都希望获得总线的所有权，那么谁先将SDA拉低，谁就赢得了总线的控制权。</p>
<p>当所有数据都发送完成时，主设备需要产生一个停止信号，告诉从设备自己已经操作完成。停止信号在SDA置于低电平时，将SCL拉高并保持高电平，然后将SDA拉高。在正常传输数据过程中，当SCL处于高电平时，SDA上的值不应该变化，防止意外产生一个停止信号。</p>
<p>在操作中，如果主机发出重复开始条件而非结束条件，则总线仍处于忙的状态。也就是说重复开始条件和开始条件在功能上是相同的。</p>
<h3 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h3><p>在地址帧发送之后，就可以开始传输数据了。主设备负责产生时钟，并且在时钟上升沿之前准备好数据。每个数据帧8bits，数据帧的数量可以是任意的，直到产生停止条件。每一帧数据传输之后，接收方就需要回复一个ACK或NACK。数据传输过程中，<strong>先发送高位，再发送低位</strong>。</p>
<p>如果在数据传输过程中，从机如果没有准备好接收或发送下一个字节（比如内部中断需要处理等），它可以通过拉低SCL强制主机进入等待状态。直到从机释放SCL，主机才开始下一个字节的发送或接收。</p>
<p><img src="/images/i2c/tu4.png" alt="I2C总线的数据传输"></p>
<h3 id="应答"><a href="#应答" class="headerlink" title="应答"></a>应答</h3><p><img src="/images/i2c/ack.png" alt="I2C总线的数据应答"></p>
<p>当主设备发送完地址帧之后，在应答时钟周期内，会放弃SDA总线控制权，让从设备获得SDA控制权，这样从设备才能通过将SDA拉低通知发送器数据已被成功接收。此时从设备应该在第9个时钟脉冲之前回复一个ACK以表示接收正常。SCL为高的时候，SDA数据才是有效的，因此接收器发送ACK时，要保证SCL为高的同时，SDA为低电平；建立和保持时间也要满足规范要求。</p>
<p>如果在第9个时钟周期，SDA为高，表明接收设备无应答（NACK）。主机可以据此发出结束条件命令结束此次传输，或发起重传请求重新传输数据。有5种情况可能导致无应答：</p>
<ul>
<li>总线上没有报文中所指定地址的设备不存在。</li>
<li>接收器件尚未准备好与主机的通信。</li>
<li>接收器件无法解析读取的数据。</li>
<li>接收器件无法收取更多的数据，比如程序或者芯片内置缓冲区已经满了。</li>
<li>主机作为接收器时，在读取从机发出的最后一个字节数据后，发出NACK通知从发送器释放数据线SDA，以便主机发起结束或重传指令。</li>
</ul>
<p>主机作为发送器和接收器在写和读情况下的数据格式：</p>
<h3 id="重复开始信号"><a href="#重复开始信号" class="headerlink" title="重复开始信号"></a>重复开始信号</h3><p>主设备可以发起多个开始信号来完成数据的传输，只要不发停止信号，总线上的其他主设备就不能占据这条总线，有时候发送完一组数据后，希望重新发数据，所以就有了重复开始信号。重复的开始信号为，SDA在SCL低电平时拉高，然后SCL拉高。重复开始条件的传输时序如下图所示：</p>
<p><img src="/images/i2c/restart.jpg" alt="重复开始条件的传输时序"></p>
<h2 id="时钟同步和仲裁"><a href="#时钟同步和仲裁" class="headerlink" title="时钟同步和仲裁"></a>时钟同步和仲裁</h2><p>I2C的一大特点是可以在同一条总线上接多个主机，当两个及以上的主机同时发起传输请求时，需要通过某种机制确定哪个主机获得总线的使用权；另外，每个主机都独立产生时钟，时钟速率可能千差万别，这也需要某种机制解决时钟速率不一致的问题。这种机制就是时钟同步（Clock Synchronization）和仲裁（Arbitration）。在单主机的I2C系统中，不需要时钟同步和仲裁。</p>
<h3 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h3><p>每个I2C的主机内部都有两个计数器，分别计数SCL上高电平和低电平的时间。如果总线上只有一个主机，则这两个计数器的值取决于系统时钟速率。当多个主机存在时，不同设备的计数器速度可能不一致，因此涉及时钟同步的概念。</p>
<p>时钟同步是通过I2C接口的“线与”逻辑实现的。SCL信号线由高变低时，所有连接在SCL上的主机都开始计数低电平的时间（低电平计数器复位），由线与的逻辑可知：只有当SCL总线上所有主机的时钟输出端都为高时，SCL总线才会由低变高。SCL的低电平时间由总线上低电平时间最长的主机决定。时钟端口先跳变为高的其它主机进入等待状态。这样所有主机的时钟输出和SCL线上的状态保持相同；当SCL由低变高后，所有主机（高电平计数器）开始计数SCL高电平的时间；最早由高跳变到低的主机再次将SCL拉低。通过这种方式产生的同步时钟：其低电平时间是所有主机时钟中最长的低电平时间，其高电平时间是所有主机时钟中最短的高电平时间。</p>
<p><img src="/images/i2c/clock_sync.png" alt="仲裁阶段的时钟同步"></p>
<h3 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h3><p>当总线上有一个以上的主机时，协议通过仲裁的方法确定哪个主机获得总线的使用权。从机不参与仲裁的过程。</p>
<p>当总线处于空闲状态时，在最小的保持时间内，多个主机都可能发起开始条件在总线上传输数据。仲裁用来判断哪个主机的传输可以正常进行。</p>
<p>仲裁是按位进行的。仲裁开始时，对于每一位数据，SCL为高时，每个主机都检测SDA上的数据是否和自己发送的数据相同。可能需要进行多个位的比较，主机才开始检测到SDA上数据和自己发送的不一致。实际上，只要SDA上的数据和主机发送的数据一致，这些主机就可以将数据一致发送下去。当主机发送为HIGH，检测SDA上电平却为LOW，那么该主机就在仲裁中失去主控权，并将其SDA输出关闭。余下的主机获得总线控制权并继续数据的传输。如图8，当主机1在检测到SDA数据和它自身的输出DATA1不一致时，将自动关闭DATA1的输出，停止向总线上发送数据。</p>
<p>由此可见，在仲裁过程中胜出的主机是没有丢失数据的。在仲裁中失去总线控制权的主机在本次字节传输结束后继续产生时钟，并在总线空闲时开始上次数据的重传。如果同一个器件可以工作在主从两种模式，它在仲裁过程中失去总线控制权，那么有可能是仲裁胜出的主机将要访问该器件，该器件应该立即切换到从机模式。</p>
<p><img src="/images/i2c/arbitration.png" alt="两个主机的仲裁过程"></p>
<p>从上面的原理分析可知，I2C不存在核心主机，是没有优先级的概念的。总线的控制权仅取决于主机在SDA上的竞争（SDA包含地址和数据）。</p>
<p>在仲裁过程中，存在以下未定条件会导致不可预期的结果：</p>
<ul>
<li>主机1在主机2发送数据的过程中发出重复开始条件</li>
<li>主机1在主机2发送数据的过程中发出结束条件</li>
<li>主机1在主机发出结束条件的过程中发出重复开始条件</li>
</ul>
<h3 id="时钟拉伸"><a href="#时钟拉伸" class="headerlink" title="时钟拉伸"></a>时钟拉伸</h3><p>如果主设备发送的速度比从设备接收的速度快，因为是同步传输，可能就会出现问题，这时候，从设备可以通过控制时钟线，要求主设备线暂停传输，这就叫时钟拉伸(clock stretching)。</p>
<p>时钟拉伸通过拉低SCL延迟数据的传输。从机在主机释放SCL后，将SCL主动拉低并保持，此时主机停止在SCL上产生脉冲以及在SDA上发送数据，直到slave释放SCL，让SCL变成高电平。之后，主机便可以继续正常的数据传输了。可见时钟拉伸实际上是利用了时钟同步的机制，只是时钟由从机产生。</p>
<p>时钟拉伸是可选功能，实际上许多从机不包括SCL驱动器，因此也无法拉伸时钟。</p>
<p>包含时钟拉伸的I2C数据传输时序图为：</p>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><h3 id="7位地址"><a href="#7位地址" class="headerlink" title="7位地址"></a>7位地址</h3><p>7位从机地址，其高4位为设备类型地址，由生产厂家制定，低3位为器件引脚定义地址，由使用者定义。</p>
<p>8位地址的第0位是数据方向控制位：为0表示主机写数据，1表示主机读数据。</p>
<p>主机发送结束条件（P）终止一次传输。主机也可以通过发起重复开始条件（Sr）进行一次新的传输，而不需要先产生结束条件（P）。在一次传输过程中，可能存在多种读写组合，包括：</p>
<ul>
<li>主机作为发送，向从机发送（写）数据，传输的方向不变；</li>
</ul>
<p><img src="/images/i2c/tu10.png" alt="7位地址主发从收模式"></p>
<ul>
<li>主机发送开始条件（S）以及其后的第一个字节，立即改为从总线上读取状态。收到从机的应答（ACK）后，主机由主发模式切换到主收模式，从机由从收模式切换到从发模式。第一个应答是从机发出的。主机先发送NACK，再发送结束条件（P）结束本次传输；</li>
</ul>
<p><img src="/images/i2c/tu11.png" alt="主机在第一个字节后立即读取从机内容"></p>
<p><img src="/images/i2c/tu12.png" alt="混合模式"></p>
<h3 id="10位地址"><a href="#10位地址" class="headerlink" title="10位地址"></a>10位地址</h3><p>任何I2C设备都有一个7位地址，理论上，现实中只能有127种不同的IIC设备。实际上，已有IIC的设备种类远远多于这个限制，在一条总线上出现相同的地址的IIC设备的概率相当高。为了突破这个限制，很多设备使用了双重地址，7位地址加引脚地址。IIC 标准也预知了这种限制，提出10位的地址方案。</p>
<p>在10-bit地址的I2C系统中，需要两帧来传输slave的地址。第一个帧的前<strong>5个bit固定为b11110</strong>，后接slave地址的高2位，第8位仍然是R/W位，接着是一个ACK位，然后再发送另外8bit的地址，发送完后从设备会给出应答。</p>
<p><img src="/images/i2c/10-addr.bmp" alt="10位地址"></p>
<p><img src="/images/i2c/tu13.png" alt="主发送器寻址从接收器"></p>
<p>主接收器读取10位地址的从发送器发送的数据。数据传送方向在第二个R/W后发生改变。如图15所示，A2之前的操作和主发送器向从接收器写数据没有区别。通过Sr，匹配地址的从机得知它就是被寻址的设备，接下来从机检测Sr后的七个比特是否和先前START后的七比特一致（1111 0XX），并检测第八位（R/W）是否为1。如果是，则从机据此判断它被寻址并将要作为发送器往总线上发送数据，此时从机产生响应A3。从机一直占用总线，直到接收到STOP或Sr指向另一个从机地址。收到Sr信号后，所有从机都会对比Sr后第一个字节的前七位（1111 0XX），并检测该字节的第八位（R/W）。对于10位地址设备R/W=1，对于7位地址设备，地址（1111 0XX）不匹配，因此这些设备都不会响应Sr，不会被寻址。</p>
<p><img src="/images/i2c/tu14.png" alt="主接收器寻址从发送器"></p>
<h3 id="保留地址"><a href="#保留地址" class="headerlink" title="保留地址"></a>保留地址</h3><table>
<thead>
<tr>
<th align="left">设备地址</th>
<th align="left">读写位</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0000 000</td>
<td align="left">0</td>
<td align="left">广播地址</td>
</tr>
<tr>
<td align="left">0000 000</td>
<td align="left">1</td>
<td align="left">启动字节</td>
</tr>
<tr>
<td align="left">0000 001</td>
<td align="left">X</td>
<td align="left">CBUS 地址</td>
</tr>
<tr>
<td align="left">0000 010</td>
<td align="left">X</td>
<td align="left">预留给不同的总线格式</td>
</tr>
<tr>
<td align="left">0000 011</td>
<td align="left">X</td>
<td align="left">预留未来扩展使用</td>
</tr>
<tr>
<td align="left">0000 1XX</td>
<td align="left">1</td>
<td align="left">Hs-mode 主代码</td>
</tr>
<tr>
<td align="left">1111 1XX</td>
<td align="left">1</td>
<td align="left">设备 ID</td>
</tr>
<tr>
<td align="left">1111 0XX</td>
<td align="left">X</td>
<td align="left">10 位从地址</td>
</tr>
</tbody></table>
<h3 id="通用广播地址"><a href="#通用广播地址" class="headerlink" title="通用广播地址"></a>通用广播地址</h3><p>通用广播地址是为了寻址总线上所有设备。如果一个设备不需要使用广播功能，可以不响应广播。如果设备需要使用广播功能，则它在检测到广播地址后发送响应，并作为从接收器读取总线上发送的数据。主机不知道总线上有多少从机发送响应。总线上所有可以响应广播的从机读取广播地址后的第二个及后面的字节。不能处理这些广播数据的从机通过不发送响应的方式忽略它。同样地，如果有一个或一个以上的从机发送响应，则主机就检测不到总线上其它没有响应的设备。广播消息的含义总是定义在第二个字节。</p>
<p><img src="/images/i2c/tu15.png" alt="广播消息格式"></p>
<p>有两种可能情况：</p>
<ul>
<li>最低位“B”为0</li>
<li>最低位“B”为1</li>
</ul>
<p><strong>“B”为0</strong>，第二个字节包括以下定义：</p>
<ul>
<li><strong>0000 0110（06h）</strong>：复位并通过硬件写内容到从机的可编程部分。所有可以响应此类广播的从机，收到此两字节后，进行复位并进入它们地址的可编程部分。注意确保设备在加电后不会将SDA或SCL拉低，因为这些低电平会阻塞总线；</li>
<li><strong>0000 0100（04h）</strong>：通过硬件写内容到从机的可编程部分，作用类似（06h），但设备不会复位；</li>
<li><strong>0000 0000（00h）</strong>：这个不应该作为第二个字节用。</li>
</ul>
<p>编程时序参考相应设备的DATASHEET。</p>
<p><strong>“B”为1</strong>，两字节广播定义为“硬件广播”。主机（如键盘扫描器）在编程后，可以发送既定的从机地址到总线上，构成两字节序列的“硬件广播”。既然主机可能并不知道总线上从机的地址，它只能通过硬件广播的方式，将自身地址通知给系统。</p>
<p><img src="/images/i2c/tu16.png" alt="主发送器的数据传输格式"></p>
<p>硬件广播的第二个字节的前七位包括主机的地址。总线上的智能设备如微控制器，读取此地址并接收主机发送的其它信息。如果主机也可以作为从机使用，则以上读取的主机地址实际上也就是（切换主从模式后的）从机地址。</p>
<p>在系统中，一种可能是系统复位后设备由主机发送模式切换到从机接收模式，这时由系统主机先告诉硬件主机数据应送往的从机地址，这样当硬件主机发送数据时就可以直接向指定从机地址发送数据了。</p>
<p><strong>软件复位</strong></p>
<p>通用广播地址0000 0000后发送0000 0110（06h）可以使总线上设备进入复位过程。该功能是可选的，所有预留该功能的设备在收到该两字节序列（00 06h）后，开始响应（复位），并进入它们地址的可编程部分。注意确保设备在加电后不会将SDA或SCL拉低，因为这些低电平会阻塞总线。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/uart-bus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/uart-bus/" class="post-title-link" itemprop="url">串口通信协议</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-05 17:04:27" itemprop="dateModified" datetime="2022-07-05T17:04:27+08:00">2022-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p>UART通用异步接收器/发送。传输数据包由起始位、数据帧、奇偶校验位和停止位组成。</p>
<p><img src="/images/uart/uart.png" alt="img"></p>
<p><strong>起始位</strong></p>
<p>当不传输数据时，UART数据传输线通常保持高电压电平。若要开始数据传输，发送UART会将传输线从高电平拉到低电平并保持1个时钟周期。当接收UART检测到高到低电压跃迁时，便开始以波特率对应的频率读取数据帧中的位。</p>
<p><strong>数据帧</strong></p>
<p>数据帧包含所传输的实际数据，如果使用奇偶校验位，数据帧长度可以是5 - 8位。如果不使用奇偶校验位，数据帧长度可以是9位。低位先发送。</p>
<p><strong>校验</strong></p>
<p>通过奇偶校验位，接收器就可以判断传输期间是否有数据发生改变，当奇偶校验位与数据匹配时，则认为传输未出错。</p>
<ul>
<li>奇校验(odd parity)：让传输的数据（包含校验位）中1的个数是否为奇数，即如果传输字节中1的个数是偶数，则校验位就要为1，否则为0。</li>
<li>偶校验(even parity)：传输的数据（包含校验位）中1的个数是否为偶数，即如果传输字节中1的个数是偶数，则校验位就要为0，否则为0。</li>
<li>1校验(mark parity): 校验位始终为1。</li>
<li>0校验(space parity): 校验位始终为0。</li>
</ul>
<p><strong>停止位</strong></p>
<p>表示一帧数据的结束，发送端将数据传输线从低电压驱动到高电压并保持1、1.5、2bit的时间。</p>
<p>波特率：意思是每秒传输这么多个比特位数(bit)。</p>
<p>1、当为奇数校验：”A”字符的8个bit位中有两个1,那么奇偶校验位为1才能满足1的个数为奇数(奇校验)。图-1的波形就是这种情况。<br>2、当为偶数校验：”A”字符的8个bit位中有两个1,那么奇偶校验位为0才能满足1的个数为偶数(偶校验)。<br>此位还可以去除，即不需要奇偶校验位。</p>
<h2 id="RS232"><a href="#RS232" class="headerlink" title="RS232"></a>RS232</h2><p>RS232是串口的一个标准，RS232是负逻辑电平，它定义+5 ~ +12V为低电平，而-12 ~ -5V为高电平。</p>
<ul>
<li>最大传输距离 50 米。</li>
<li>传输速率较低，在异步传输时，波特率为 20Kbps。</li>
<li>只允许一对一通信。</li>
</ul>
<p><img src="/images/uart/RS232.webp" alt="img"><br><img src="/images/uart/max3232.png" alt="max3232"></p>
<h2 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a>RS485</h2><p>RS-232接口只能点对点的通信，不能实现联网功能，于是一个新的标准RS-485产生了。RS-485使用一对双绞线采用差分传输方式，由于是差分通信，因此数据的接收和发送数据不能同时进行，只能工作在半双工模式，常用于总线网。</p>
<ul>
<li>电气特性：逻辑1以两线间的电压差为+2 ~ 6V表示；逻辑0以两线间的电压差为-2 ~ 6V表示。</li>
<li>最大的通信距离约为1200米（9600bps 时），实际上可达 3000 米。</li>
<li>最大传输速率为10Mb/s。</li>
<li>RS-485总线一般最大支持32个节点。</li>
</ul>
<p><img src="/images/uart/max485.png" alt="MAX485"></p>
<p>为了提高RS485的抗干扰性能，需要在靠近MAX485的AB引脚之间并接一个100 ~ 1K的电阻。</p>
<h2 id="RS422"><a href="#RS422" class="headerlink" title="RS422"></a>RS422</h2><p>RS-422（EIA RS-422-A Standard）是Apple的Macintosh计算机的串口连接标准。有4根信号线：两根发送，两根接收。由于RS-422 的收与发是分开的，所以可以全双工，适用于两个站之间通信，星型网、环网，不可用于总线网。</p>
<ul>
<li>最大传输距离为1219米，最大传输速率为10Mb/s。</li>
<li>最多可接10个节点。</li>
<li>支持点对多的双向通信。</li>
</ul>
<p><img src="/images/uart/RS-xxx.webp" alt="RS-xxx"></p>
<h2 id="帧协议"><a href="#帧协议" class="headerlink" title="帧协议"></a>帧协议</h2><p><img src="/images/uart/uart-protocol.jpg" alt="img"></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.analog.com/cn/analog-dialogue/articles/uart-a-hardware-communication-protocol.html">https://www.analog.com/cn/analog-dialogue/articles/uart-a-hardware-communication-protocol.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">218</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
