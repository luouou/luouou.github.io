<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/pc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/pc/" class="post-title-link" itemprop="url">计算机组成原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h2><p><strong>计算机由控制器、存储器、运算器、输入设备和输出设备5个部件组成</strong>。</p>
<p>度量计算机性能的指标有响应时间和吞吐率，<strong>响应时间</strong>是指完成一个任务所需的总时间，<strong>吞吐率</strong>表示单位时间内完成的任务数量。</p>
<p>集成电路主要用的是CMOS，其主要能耗来源是晶体管开头过程中产生的动态能耗，其値取决于每个晶体管的负载电容和工作电压：能耗 = 负载电容 x 电压^2^ 。每个晶体管需要的功耗是一个翻转能耗和开头频率的乘积： 功耗 = 负载电容 x 电压^2^ x 开头频率。</p>
<h2 id="计算机设计思想"><a href="#计算机设计思想" class="headerlink" title="计算机设计思想"></a>计算机设计思想</h2><ol>
<li>面向摩尔定律的设计，摩尔定律是指单芯片上的集成度每18 -24月翻一番。设计者必须预测其设计完成时的工艺水平。</li>
<li>使用抽象简化设计，用抽象表示不同的设计层次，在高层次中看不到低层次的细节。</li>
<li>加速大概率事件远比优化小概率事件更能提高性能。</li>
<li>并行执行提高性能。</li>
<li>通过流水线提高性能。</li>
<li>通过预测提高性能。</li>
<li>通过使用冗余部件提高系统的可靠性。比如汽车的备用轮胎。</li>
<li>存储器层次结构，较快的存储器靠近处理器。</li>
</ol>
<h2 id="存储器结构"><a href="#存储器结构" class="headerlink" title="存储器结构"></a>存储器结构</h2><h3 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h3><p>冯·诺依曼结构，又称为普林斯顿体系结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。取指令和取操作数都在同一总线上，通过分时复用的方式进行；缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。由于程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同。</p>
<p><img src="/images/cpu/Princeton.jpg" alt="img"></p>
<h3 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h3><p>哈佛结构是一种将程序指令存储和数据存储分开的存储器结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问，目的是为了减轻程序运行时的访存瓶颈。</p>
<p><img src="/images/cpu/Harvard.jpg" alt="img"></p>
<p>哈佛结构的中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据。程序指令储存和数据储存分开，数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度。</p>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p><strong>原码</strong>：用第一位表示符号，其余位表示值，负数符号位为1。</p>
<p><strong>反码</strong>：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p>
<p><strong>补码</strong>：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p><strong>移码</strong>：将符号位取反的补码（不区分正负）。</p>
<p>原码使数字有了正负概念，但是计算不正确，正负相加不等于0，而且存在+0和-0。反码解决了正负相加不等于0的问题。为了追求连续性和唯一性，补码修复了存在两个0编码的问题，而且还能够多表示一个最低数，所以1个字节能表示的范围为[-128, 127]。</p>
<p>用[0000 0000]表示0, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p>
<blockquote>
<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>
</blockquote>
<h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><h4 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h4><p><img src="/images/pc/float_mem.jpg" alt="浮点表示"></p>
<ul>
<li>第一段 占 1bit，表示符号位。0代表正数，1代表负数。</li>
<li>第二段 占 8bits，表示指数。代称为 E(Exponent)。</li>
<li>第三段 占 23bits，表示尾数。代称为 M(Mantissa)。</li>
</ul>
<p>浮点数在计算机存储使用二进制科学计数法。如小数 78.375，符号位为0，指数为6，尾数是001110011。</p>
<blockquote>
<p>整数部分：(78)<del>10</del> = (100 1110)<del>2</del><br>小数部分：(0.375)<del>10</del>　=　3/8 = 1/4 + 1/8 = 2^-2^ + 2^-3^ = (0.01)<del>2</del> + (0.001)<del>2</del> = (0.011)<del>2</del><br>(78.375)<del>10</del> = (1001110.011)<del>2</del> = 1.001110011 * 2^6^</p>
</blockquote>
<p>对于 int 和 float 变量类型不能使用强制类型转换，要通过float指针来转换。</p>
<h4 id="浮点加法"><a href="#浮点加法" class="headerlink" title="浮点加法"></a>浮点加法</h4><h4 id="浮点乘法"><a href="#浮点乘法" class="headerlink" title="浮点乘法"></a>浮点乘法</h4><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>时钟周期也叫振荡周期或晶振周期，即晶振的单位时间发出的脉冲数。是计算机中最基本的、最小的时间单位。</p>
<p>机器周期：在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。8051单片机的机器周期由6个状态周期组成，也就是说一个机器周期=6个状态周期=12个时钟周期。机器周期也是单片机定时器和计数器的时间基准。例如一个单片机选择了12MHZ晶振，那么当定时器的数值加1时，实际经过的时间就是1us。</p>
<p>指令周期是执行一条指令所需要的时间，一般由若干个机器周期组成。指令不同，所需的机器周期数也不同。</p>
<p>系统时钟就是CPU指令运行的频率，系统时钟由晶振或内部RC产生。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/cpu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/cpu/" class="post-title-link" itemprop="url">各种处理器介绍</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/cpu/cpu.jpg" alt="img"></p>
<p>cpu内部由控制器、运算器、寄存器、时钟4部分组成。</p>
<h2 id="处理器架构"><a href="#处理器架构" class="headerlink" title="处理器架构"></a>处理器架构</h2><h3 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a>CISC</h3><p>CISC（Complex Instruction Set Computer，复杂指令集计算机）是一种微处理器指令集架构（ISA），每个指令可执行若干低阶操作，诸如从内存读取、储存、和计算操作，全部集于单一指令之中。CISC特点：</p>
<ul>
<li>指令系统庞大，指令功能复杂，指令格式、寻址方式多；</li>
<li>绝大多数指令需多个机器周期完成；</li>
<li>各种指令都可访问存储器；</li>
<li>采用微程序控制；</li>
<li>有专用寄存器，少量；</li>
<li>难以用优化编译技术生成高效的目标代码程序；</li>
</ul>
<p>在CISC指令集的各种指令中，大约有20%的指令会被反复使用，占整个程序代码的80%。而余下的80%的指令却不经常使用，在程序设计中只占20%。</p>
<h3 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h3><p>RISC（Reduced Instruction Set Computer，精简指令集计算机）对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。它能够以更快的速度执行操作。现在的RISC指令集也达到数百条，运行周期也不再固定。RISC设计的根本原则—针对流水线化的处理器优化。RISC特点：</p>
<ul>
<li>统一指令编码（例如，所有指令中的op-code永远位于同样的位元位置、等长指令），可快速解译；</li>
<li>泛用的暂存器，所有暂存器可用于所有内容，以及编译器设计的单纯化（不过暂存器中区分了整数和浮点数）；</li>
<li>单纯的寻址模式（复杂寻址模式以简单计算指令序列取代）；</li>
<li>硬件中支援少数资料型别（例如，一些CISC电脑中存有处理字节字串的指令。这在RISC电脑中不太可能出现）。</li>
<li>　所有计算都要在寄存器中完成。而寄存器和内存的通信则由单独的指令完成。</li>
<li>有非常多的通用寄存器，并采用了重叠寄存器窗口和寄存器堆等技术使寄存器资源得到充分的利用。</li>
</ul>
<p>**[区别]**：</p>
<p>CISC和RISC是当前CPU的两种架构。它们的区别在于不同的CPU设计理念和方法。早期的CPU全部是CISC架构，它的设计目的是用最少的机器语言指令来完成所需的计算任务。它们的差异主要有：</p>
<ol>
<li><p>指令系统：RISC设计者把主要精力放在那些经常使用的指令上，尽量使它们具有简单高效的特色。对不常用的功能，常通过组合指令来完成。因此，在RISC机器上实现特殊功能时，效率可能较低。但可以利用流水技术和超标量技术加以改进和弥补。而CISC计算机的指令系统比较丰富，有专用指令来完成特定的功能。因此，处理特殊任务效率较高。</p>
</li>
<li><p>存储器操作：RISC对存储器操作有限制，使控制简单化；而CISC机器的存储器操作指令多，操作直接。</p>
</li>
<li><p>程序：RISC汇编语言程序一般需要较大的内存空间，实现特殊功能时程序复杂，不易设计；而CISC汇编语言程序编程相对简单，科学计算及复杂操作的程序社设计相对容易，效率较高。</p>
</li>
<li><p>中断：RISC机器在一条指令执行的适当地方可以响应中断；而CISC机器是在一条指令执行结束后响应中断。</p>
</li>
<li><p>CPU：RISCCPU包含有较少的单元电路，因而面积小、功耗低；而CISCCPU包含有丰富的电路单元，因而功能强、面积大、功耗大。</p>
</li>
<li><p>设计周期：RISC微处理器结构简单，布局紧凑，设计周期短，且易于采用最新技术；CISC微处理器结构复杂，设计周期长。</p>
</li>
<li><p>用户使用：RISC微处理器结构简单，指令规整，性能容易把握，易学易用；CISC微处理器结构复杂，功能强大，实现特殊功能容易。</p>
</li>
<li><p>应用范围：由于RISC指令系统的确定与特定的应用领域有关，故RISC机器更适合于专用机；而CISC机器则更适合于通用机。</p>
</li>
</ol>
<h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><p>x86或80x86是英特尔首先开发制造的一种微处理器体系结构的泛称。该系列较早期的处理器名称是以数字来表示，并以“86”作为结尾，包括Intel 8086、80186、80286、80386以及80486，因此其架构被称为“x86”。成为了个人电脑的标准平台</p>
<p>x86架构于1978年推出的Intel 8086中央处理器中首度出现，它是从Intel 8008处理器中发展而来的，而8008则是发展自Intel 4004的。8086在三年后为IBM PC所选用，之后x86便，成为了历来最成功的CPU架构。</p>
<p>8086是16位元处理器；直到1985年32位元的80386的开发，这个架构都维持是16位元。接着一系列的处理器表示了32位元架构的细微改进，推出了数种的扩充，直到2003年AMD对于这个架构发展了64位元的扩充，并命名为AMD64。后来Intel也推出了与之兼容的处理器，并命名为Intel 64。两者一般被统称为x86-64或x64，开创了x86的64位时代。</p>
<p>x86架构是重要地可变指令长度的CISC。字组（word, 4字节）长度的内存存取允许不对齐内存位址，字组是以低位字节在前的顺序储存在内存中。向后相容性一直都是在x86架构的发展背后一股驱动力量。但在较新的微架构中，x86处理器会把x86指令转换为更像RISC的微指令再予执行，从而获得可与RISC比拟的超标量性能，而仍然保持向前兼容。</p>
<p>X86指令集只有8个通用寄存器。所以，CISC的CPU执行是大多数时间是在访问存储器中的数据，而不是寄存器中的。这就拖慢了整个系统的速度。</p>
<h3 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h3><p>ARM架构（进阶精简指令集机器（AdvancedRISC Machine），是一个32位RISC处理器架构，广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。</p>
<p>ARM采用的RISC体系最大特点是指令长度固定，指令格式种类少，寻址方式种类少，大多数是简单指令且都能在一个时钟周期内完成，易于设计超标量与流水线，寄存器数量多，大量操作在寄存器之间进行，因此有较快运行速度。</p>
<p>ARM指令集的特点：</p>
<ul>
<li>体积小，低功耗，低成本，高性能；</li>
<li>支持 Thumb（16位）/ARM（32位）双指令集，能很好的兼容8位/16位器件；</li>
<li>大量使用寄存器，指令执行速度更快，大多数数据操作都在寄存器中完成；</li>
<li>寻址方式灵活简单，执行效率高；</li>
<li>指令长度固定，流水线处理方式</li>
</ul>
<h3 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h3><p>MIPS架构（无内部互锁流水级的微处理器，Microprocessorwithout Interlocked Pipeline Stages），是一种采取精简指令集的处理器架构，1981年出现，由MIPS科技公司开发并授权，广泛被使用在许多电子产品、网络设备、个人娱乐装置与商业装置上。其机制是尽量利用软件办法避免流水线中的数据相关问题。它最早是在80年代初期由斯坦福大学Hennessy教授领导的研究小组研制出来的。MIPS公司的R系列就是在此基础上开发的RISC工业产品的微处理器。这些系列产品为很多计算机公司采用构成各种工作站和计算机系统。</p>
<p>MIPS是出现最早的商业RISC架构芯片之一。MIPS的系统结构及设计理念比较先进，强调软硬件协同提高性能，同时简化硬件设计。</p>
<p>**[ARM与MIPS对比]**：</p>
<p>MIPS架构的优势：</p>
<ol>
<li><p>MIPS支持64bit指令和操作，ARM目前只到32bit。</p>
</li>
<li><p>MIPS有专门的除法器，可以执行除法指令。</p>
</li>
<li><p>MIPS的内核寄存器比ARM多一倍，所以同样的性能下MIPS的功耗会比ARM更低，同样功耗下性能比ARM更高。</p>
</li>
<li><p>MIPS指令比ARM稍微多一点，稍微灵活一点。</p>
</li>
<li><p>ARM很昂贵，而且不能随意自行更改内核。而MIPS就要开放的多了。</p>
</li>
</ol>
<p>MIPS架构的不足：</p>
<ol>
<li><p>MIPS的内存地址起始有问题，这导致了MIPS在内存和cache的支持方面都有限制，现在的MIPS处理器单内核面对高容量内存时有问题</p>
</li>
<li><p>MIPS今后的发展方向是并行线程，类似INTEL的超线程，而ARM未来的发展方向是物理多核，目前看来物理多核占优。由此来看，我国的龙芯向多核发展还是颇具远见的。</p>
</li>
<li><p>MIPS虽然结构更加简单，但是到现在还是顺序单发射，ARM已经进化到了乱序双发射，甚至NV的丹佛已经是乱序三发射了。</p>
</li>
</ol>
<h2 id="各种处理器"><a href="#各种处理器" class="headerlink" title="各种处理器"></a>各种处理器</h2><p>DSP – Digital Signal Processor，是一种专用于数字信号处理的微处理器。内部采用程序和数据分开的哈佛结构，具有专门的硬件乘法器，广泛采用流水线操作，提供特殊的DSP指令，可以用来快速的实现各种数字信号处理算法。功耗更低。</p>
<p>FPGA – Field－Programmable Gate Array，现场可编程门阵列。</p>
<p>APU – Accelerated Processing Unit, 加速处理器，AMD公司推出加速图像处理芯片产品。</p>
<p>BPU – Brain Processing Unit, 地平线公司主导的嵌入式处理器架构。</p>
<p>CPU – Central Processing Unit，中央处理器。CPU主要包括控制器、运算器，其中还包括高速缓冲存储器及实现它们之间联系的数据、控制的总线。主要功能为处理指令、执行操作、控制时间、处理数据。</p>
<p>DPU – Deep learning Processing Unit, 深度学习处理器，最早由国内深鉴科技提出；另说有Dataflow Processing Unit 数据流处理器， Wave Computing 公司提出的AI架构；Data storage Processing Unit，深圳大普微的智能固态硬盘处理器。</p>
<p>FPU – Floating Processing Unit 浮点计算单元，通用处理器中的浮点运算模块。</p>
<p>GPU – Graphics Processing Unit，图形处理单元，采用多线程SIMD架构，为图形处理而生。它是显卡的处理器，专为执行复杂的数学和几何计算而设计的，这些计算是图形渲染所必需的。</p>
<p>HPU – Holographics Processing Unit 全息图像处理器， 微软出品的全息计算芯片与设备。</p>
<p>IPU – Intelligence Processing Unit， Deep Mind投资的Graphcore公司出品的AI处理器产品。</p>
<p>MCU – Microcontroller Unit，微控制单元，又称单片机，是把CPU的频率与规格做适当缩减，并将内存、计数器、USB、A/D转换、UART、PLC、DMA等周边接口，甚至LCD驱动电路都整合在单一芯片上，形成芯片级的计算机。</p>
<p>NPU – Neural Network Processing Unit，神经网络处理单元，是基于神经网络算法与加速的新型处理器总称。</p>
<p>RPU – Radio Processing Unit, 无线电处理器， Imagination Technologies 公司推出的集合集Wifi/蓝牙/FM/处理器为单片的处理器。</p>
<p>TPU – Tensor Processing Unit 张量处理器， Google 公司推出的为机器学习而定制的芯片，经过了专门深度机器学习方面的训练，它有更高效能（每瓦计算能力）。目前一代TPU面向Inference，二代面向训练。</p>
<p>VPU – Vector Processing Unit 矢量处理器，Intel收购的Movidius公司推出的图像处理与人工智能的专用芯片的加速计算核心。</p>
<p>WPU – Wearable Processing Unit， 可穿戴处理器，Ineda Systems公司推出的可穿戴片上系统产品，包含GPU/MIPS CPU等IP。</p>
<p>XPU – 百度与Xilinx公司在2017年Hotchips大会上发布的FPGA智能云加速，含256核。</p>
<p>ZPU – Zylin Processing Unit, 由挪威Zylin 公司推出的一款32位开源处理器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/memory/" class="post-title-link" itemprop="url">memory and disk</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p><strong>ROM</strong> (Read Only Memory)程序存储器，在掉电之后仍然可以保持数据，用于存储各种固化程序和数据。</p>
<p><strong>PROM</strong> (Programmable ROM，可编程ROM)，写入时，烧录器通过高电压在芯片内永久地烧断或者建立内部连接（熔丝或反熔丝），因此只能一次编程。</p>
<p><strong>EPROM</strong> (Erasable Programmable ROM，可擦去可编程ROM)，使用紫外线照射此类型的ROM可以抹去其中的数据。</p>
<p><strong>EEPROM</strong> (Electrically Erasable Programmable ROM，电可擦去可编程ROM)，使用电来对其进行擦写，常用于电脑系统的BIOS。</p>
<h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p><strong>RAM</strong> (Random Access Memory)随机访问存储器，存储单元的内容可按照需要随机取出或存入，且存取的速度与存储单元的位置无关。在掉电之后就丢失数据，主要用来存储程序中用到的变量。随机存储器主要分两种：静态随机存储器SRAM和动态随机存储器DRAM。</p>
<p><strong>DRAM</strong> (Dynamic RAM/DRAM)动态随机存储器，DRAM保留数据的时间很短，需要周期性地刷新。计算机内存就是DRAM的。</p>
<p>DRAM利用MOS管的栅电容上的电荷来存储信息，存储单元存储的是0还是1取决于电容是否有电荷，有电荷代表1，无电荷代表0。由于栅极会漏电，所以每隔一定的时间就需要一个刷新机构给这些栅电容补充电荷，这个就叫动态刷新。刷新操作定期对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电；若电量小于1/2，则认为其代表0，并把电容放电，以此来保持数据的连续性。</p>
<p><strong>SRAM</strong> (Static Random-Access Memory)静态随机存取存储器，只要保持通电，里面储存的数据就可以一直保持，对任何数据访问的时间都是固定的。SRAM的优点是只要器件不掉电，存储内容就不丢失，工作速度快。缺点是集成度低、功耗大、价格高。CPU Cache采用的就是这种技术。</p>
<h2 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h2><p>Flash 存储器（FLASH EEPROM）又称闪存，快闪。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备EEPROM的性能，还不会断电丢失数据同时可以快速读取数据。它于EEPROM的最大区别是，FLASH按扇区操作，而EEPROM按照字节操作。FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因此适合用于做程序存储器。</p>
<p>flash是非易失存储器，可以对称为块的存储器单元块进行擦写和再编程。任何flash器件的写入操作只能在空或已擦除的单元内进行，所以在进行写入操作之前必须先执行擦除。擦除的过程就是把所有位都写为1的过程，块内的所有字节变为0xFF。擦除是以块为单位进行的。</p>
<h3 id="Nor-Flash"><a href="#Nor-Flash" class="headerlink" title="Nor Flash"></a>Nor Flash</h3><p>Nor Flash支持随机访问，具有XIP（eXecute In Place）特性，可以像普通ROM一样执行程序。所存储的内容可以直接映射到 CPU 地址空间，不需要拷贝到 RAM 中即可被 CPU 访问。容量小，读操作快，但擦除和写操作慢，块大小范围：64~128KB。NOR flash带有SRAM接口，有足够的地址引脚来寻址，可以很容易地存取其内部的每一个字节。</p>
<p>Nor Flash根据数据传输的位数可以分为并行（Parallel，即地址线和数据线直接和处理器相连）和串行（SPI，即通过SPI接口和处理器相连）。早期Norflash的接口是parallel的形式，即把数据线和地址线并排与IC的管脚连接。但是后来发现不同容量的Norflash不能硬件上兼容（数据线和地址线的数量不一样），并且封装比较大，占用了较大的PCB板位置，后来逐渐被串行接口的SPI Norflash所取代，至于现在说起NOR flash都直接以SPI flash来代称。</p>
<p>spi flash 接口定义：</p>
<ul>
<li>Standard SPI: CLK, /CS, DI, DO, /WP, /Hold</li>
<li>Dual SPI: CLK, /CS, IO0, IO1, /WP, /Hold</li>
<li>Quad SPI: CLK, /CS, IO0, IO1, IO2, IO3</li>
</ul>
<h3 id="Nand-Flash"><a href="#Nand-Flash" class="headerlink" title="Nand Flash"></a>Nand Flash</h3><p>Nand Flash是串行接口，容量大，擦除和写都快。块大小范围：8~64KB。没有采取内存的随机读取技术，读和写操作都采用512字节的块。</p>
<p>Nor的读速度比Nand稍快一些，Nand的写入速度比Nor快很多。</p>
<p>Nand闪存中每个块的最大擦写次数是一百万次，而Nor的擦写次数是十万次。</p>
<p><img src="/images/memory/nor_nand.jpg" alt="nor_nand"></p>
<p>由于Flash固有的电器特性，在读写数据过程中会偶然产生1位或几位数据错误，即位反转。Nand Flash发生位反转的几率要远大于Nor Flash。位反转无法避免，因此使用 Nand Flash 的同时，应采用错误探测/错误更正(EDC/ECC)算法。</p>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘(Hard Disk Drive，HDD)靠磁性盘片记录二进制数据。</p>
<p><img src="/images/memory/disk/hdd.jpg" alt="img"></p>
<p>Track Sector：磁道扇面      Head：磁头      Actuator Arm：悬浮磁臂。</p>
<p>当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道(Track)。划分分区时，分区大小必须以磁道为参考，一个分区必须包含一个或多个整数磁道，不能只占半个磁道。也就是说如果磁盘有两个磁道，最多只能分成2个分区。</p>
<p>在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面(Cylinder)。</p>
<p>磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区(Sector)。硬盘的第一个扇区，叫做引导扇区。磁盘上数据读写的最小单位。</p>
<p>硬盘片的盘面上有一层涂得很薄的磁性材料。写入数据时，通电的磁头会形成磁场，在磁性材料层上留下一个一个小磁化区，每个被磁化的区域代表二进制的1。读取数据时，磁头扫过磁化区的时候能感受到微小的磁场变化。</p>
<p>操作系统内核中的文件管理系统会将硬盘的扇区组合成<strong>簇</strong>(Data Cluster)，操作系统会记录文件所在簇的编号(文件数据分布在哪几个扇区)，方便查找并读写。</p>
<p>机械硬盘通过磁头读取旋转的盘片来传输数据，而盘片的转速RPM(Round Per Minute，每分钟的转数)直接决定了硬盘读取和写入数据的速度。目前主流的机械硬盘，转速在6000~7500RPM左右。磁盘在写入数据时，会使用磁盘缓存暂时存储数据。</p>
<p><strong>磁盘缓存</strong>(Disk Cache)，就是将下载到的数据先保存于系统为软件分配的内存空间中，当保存到内存池中的数据达到一个程度时，便将数据保存到硬盘中。这样可以减少实际的磁盘操作，有效的保护磁盘免于重复的读写操作而导致的损坏。目前主流的500G机械硬盘大都装载64MB的缓存。</p>
<p>硬盘的主控芯片主要负责：</p>
<ul>
<li>控制磁头的读取</li>
<li>温度检测</li>
<li>为操作系统的文件管理系统提供逻辑接口</li>
<li>负责纠错，磁头读写时会使用磁信号，而磁信号的误码率非常高，大约每记录0.6KB的数据就会出现一个bit的错误。</li>
<li>负责将数据从RAM/硬盘缓存写入，或者将硬盘读出的数据写回RAM。</li>
</ul>
<h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>RAID(独立硬盘冗余阵列，Redundant Array of Independent Disks)，简称磁盘阵列。利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或数据冗余，或是两者同时提升。</p>
<ul>
<li><strong>RAID0</strong></li>
</ul>
<p>RAID0 是一种非常简单的的方式，它将多块磁盘组合在一起形成一个大容量的存储。当我们要写数据的时候，会将数据分为N份，以独立的方式实现N块磁盘的读写，那么这N份数据会同时并发的写到磁盘中，读写性能理论上是单块磁盘的N倍。</p>
<p>但RAID0的问题是，它并不提供数据校验或冗余备份，因此一旦某块磁盘损坏了，数据就直接丢失，无法恢复了。因此RAID0就不可能用于高要求的业务中，但可以用在对可靠性要求不高，对读写性能要求高的场景中。</p>
<ul>
<li><strong>RAID1</strong></li>
</ul>
<p>RAID1 是磁盘阵列中单位成本最高的一种方式。因为它的原理是在往磁盘写数据的时候，将同一份数据无差别的写两份到磁盘，分别写到工作磁盘和镜像磁盘，对数据做了冗余备份，但它的实际空间使用率只有50%了，是一种比较昂贵的方案。</p>
<ul>
<li><strong>RAID3</strong></li>
</ul>
<p>RAID3的方式是：将数据按照RAID0的形式，分成多份同时写入多块磁盘，但是还会另外留出一块磁盘用于写奇偶校验码，一旦某一块磁盘坏掉了，就可以利用那块校验码磁盘去恢复数据。但是由于任何数据的写入都会要去更新这块磁盘，导致这块磁盘的读写是最频繁的，也就非常的容易损坏。</p>
<ul>
<li><strong>RAID5</strong></li>
</ul>
<p>RAID5对RAID3进行了改进，是一种存储性能、数据安全、存储成本兼顾的方案。</p>
<p>在RAID5模式中，不再需要用单独的磁盘写校验码了。它把校验码信息分布到各个磁盘上。例如，总共有N块磁盘，那么会将要写入的数据分成N份，并发的写入到N块磁盘中，同时还将数据的校验码信息也写入到这N块磁盘中，数据与对应的校验码信息必须得分开存储在不同的磁盘上。一旦某一块磁盘损坏了，就可以用剩下的数据和对应的奇偶校验码信息去恢复损坏的数据。</p>
<p><img src="/images/memory/disk/RAID5.jpg" alt="img"></p>
<p>RAID5的方式，最少需要三块磁盘来组建磁盘阵列，允许最多同时坏一块磁盘。如果有两块磁盘同时损坏了，那数据就无法恢复了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/usb_if/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/usb_if/" class="post-title-link" itemprop="url">usb接口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/usb/" itemprop="url" rel="index"><span itemprop="name">usb</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/usb/usb-if2.png" alt="usb接口"></p>
<p><img src="/images/usb/usb-if3.png" alt="usb接口"></p>
<p><img src="/images/usb/usb_if.bmp" alt="usb接口"></p>
<p><img src="/images/usb/usb-if.png" alt="usb接口"></p>
<p>标准USB接口使用标记为D+(绿线)和D-(白线) 的双绞线传输，它们各自使用半双工的差分信号并协同工作，以抵消长导线的电磁干扰。</p>
<p>Mini USB接口把第4针作为ID线，用来标识身份，mini-A插头的ID引脚接地，而mini-B插头悬空。<strong>USB OTG根据ID线状态判断是主机还是从机，接地为主机，悬空为从机</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/usb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/usb/" class="post-title-link" itemprop="url">usb协议</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/usb/" itemprop="url" rel="index"><span itemprop="name">usb</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="USB规范"><a href="#USB规范" class="headerlink" title="USB规范"></a>USB规范</h2><p>USB最初是由英特尔与微软公司倡导发起，其最大的特点是支持热插拔(Hot plug)和即插即用(Plug&amp;Play)。</p>
<p><strong>电压范围4.75 ~ 5.25V</strong>，普通USB接口<strong>最大提供500mA电流</strong>，USB符号后有一个“+”号的，输出电流可达1A。</p>
<p><strong>一个USB主控制器最多可连接127个设备，各设备之间的距离不超过5米</strong>。</p>
<table>
<thead>
<tr>
<th align="left">USB版本</th>
<th align="left">速率称号</th>
<th align="left">传输速率</th>
<th align="left">理论速度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">USB 3.2</td>
<td align="left">超高速+  Super-Speed+</td>
<td align="left">20Gbps</td>
<td align="left">2560MB/s</td>
</tr>
<tr>
<td align="left">USB 3.1 Gen2</td>
<td align="left">超高速+  Super-Speed+</td>
<td align="left">10Gbps</td>
<td align="left">1280MB/s</td>
</tr>
<tr>
<td align="left">USB 3.1 Gen1</td>
<td align="left">超高速 Super-Speed</td>
<td align="left">5Gbps</td>
<td align="left">640MB/s</td>
</tr>
<tr>
<td align="left">USB 2.0</td>
<td align="left">高速 Hi-Speed</td>
<td align="left">480Mbps</td>
<td align="left">60MB/s</td>
</tr>
<tr>
<td align="left">USB 1.1</td>
<td align="left">全速 Full-Speed</td>
<td align="left">12Mbps</td>
<td align="left">1.5MB/s</td>
</tr>
<tr>
<td align="left">USB 1.0</td>
<td align="left">低速 Low-Speed</td>
<td align="left">1.5Mbps</td>
<td align="left">0.192MB/s</td>
</tr>
</tbody></table>
<p>USB2.0 支持 3 种传输速度:低速模式(1.5Mb/s)、全速模式(12Mb/s)和高速模式(480Mb/s)。在低速和全速模式中，采用的是电压传输模式；高速模式下，是电流传输模式。</p>
<p>USB2.0 规范要求集线器必须支持高速模式，USB2.0 设备则没有这个要求。一个高速的上行收发器不能支持低速信号传输模式。而 USB2.0 下行收发器必须支持高速、全速和低速模式。</p>
<h3 id="插入检测机制"><a href="#插入检测机制" class="headerlink" title="插入检测机制"></a>插入检测机制</h3><p>在 USB 集线器的每个下游端口的 D+和 D-上，分别接了一个 15kΩ的下拉电阻。当集线器端口没有设备插入时，输入端被这两个下拉电阻拉到了低电平。而在USB 设备端，在 D+或者 D-上，接了一个 1.5kΩ的上拉电阻到 3.3V 的电源。<strong>对于高速设备和全速设备，上拉电阻接在 D+上；低速设备，上拉电阻接在 D-上</strong>。</p>
<p>当设备插入到集线器时，接了上拉电阻的数据线的电压由 1.5kΩ的上拉电阻和 15kΩ的下拉电阻分压，大概 3V 左右。这是一个高电平信号。集线器检测到该状态后就上报给 Host控制器，这样就检测到设备插入。通过检测高电平的数据线是 D+还是 D-来判断设备是什么速度类型。</p>
<p>高速设备会首先被判断为全速设备，然后通过集线器和设备两者确认，切换到高速模式下。高速模式下是电流传输模式，此时需要把 D+的上拉电阻断开。</p>
<h2 id="USB结构"><a href="#USB结构" class="headerlink" title="USB结构"></a>USB结构</h2><p><img src="/images/usb/bus-topology.png" alt="usb拓扑结构"></p>
<p>USB是一种主从结构的系统，主机叫做Host，从机叫做设备。USB的设计为非对称式的，它由一个主机(host)控制器和若干通过集线器设备以树形连接的设备组成。以根集线器为起点，最多支持7层，也就是说在USB系统中最多允许5个hub级联。一个USB主控制器最多连接127个设备，这是因为协议规定每个USB设备具有一个7bit的地址，地址0是保留给未初始化的设备使用。</p>
<h3 id="USB-Host"><a href="#USB-Host" class="headerlink" title="USB Host"></a>USB Host</h3><p>主机具有一个或多个usb主控制器和根集线器(root hub)。主控制器负责数据处理。根集线器则提供一个连接主控制器与设备之间的接口和通道，它集成在主机控制器里，不占用地址。</p>
<p>Host 主要负责:</p>
<ul>
<li>检测 USB 设备拔插</li>
<li>管理 Host 和 Device 之间的控制流、数据流</li>
<li>收集 USB 总线状态和活动数据信息</li>
<li>为连入 USB 总线的设备供电</li>
</ul>
<h3 id="USB-Device"><a href="#USB-Device" class="headerlink" title="USB Device"></a>USB Device</h3><p>USB 设备通过 HUB 连接到 USB 总线上，此时 HUB 上的接入点称为端口(Port)。连接到 Hub 上的设备可能是单个设备，也可以是复合设备(Compound<br>Device)。每一个 USB 设备提供不同的功能，又被称作 Function。</p>
<p>USB 设备支持热插拔。USB 设备通过 HUB 连接到 USB 总线。Hub 有一个状态位，标记 USB 设备是插入还是拔出。Host 会查询 Hub 端口的状态位，当检测到设备插入时，Host 将使能该 Hub 对应的 port，并通过默认地址(0)从设备控制管道为设备分配地址。当一个设备从 Hub 的某个 port 拔出时，Hub 将禁能该 port 并报告给 Host。</p>
<p>从 USB 系统角度而言，一个逻辑上的 USB 设备是一个端点的集合。分组的端点构成一个接口(Interface)。USB 系统通过管道来管理接口，通过 Host 上的 Buffer 和 USB 设备上的端点来请求数据。 Host Controller 打包数据并将数据包发送出去。</p>
<h3 id="USB-Hub"><a href="#USB-Hub" class="headerlink" title="USB Hub"></a>USB Hub</h3><p>USB集线器是一种可以对原有的USB口在数量上进行扩展的设备。hub提供了设备连接检测和设备移除检测的能力，并给各下行端口供电。 可以单独使能下行端口，不同端口可以工作在不同的速度等级。</p>
<h2 id="USB通信协议"><a href="#USB通信协议" class="headerlink" title="USB通信协议"></a>USB通信协议</h2><h3 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h3><p>数据在 USB 线里传送是低位在前高位在后。USB 采用 NRZI(非归零编码)对发送的数据包进行编码，即:输入数据 0，编码成“电平翻转”；输入数据 1，编码成“电平保持”。</p>
<p><img src="/images/usb/NRZI.png" alt="NRZI编码"></p>
<p>USB提供了4 种传输方式：</p>
<ul>
<li>控制(Control)传输方式。双向传输，数据量通常较小，主要用来进行查询、配置和给 USB 设备发送通用的命令。</li>
<li>同步(Synchronization)传输方式。提供了确定的带宽和间隔时间，它被用于时间严格并具有较强容错性的流数据传输，或者用于要求恒定的数据传送率的即时应用。例如进行语音业务传输时，使用同步传输方式是很好的选择</li>
<li>中断(Interrupt)传输方式。传送是单向的，对于 USB 主机而言，只有输入。中断传输方式主要用于定时查询设备是否有中断数据要传送，该传输方式应用在少量的、分散的、不可预测的数据传输场合，键盘、游戏杆和鼠标属于这一类型。</li>
<li>批量(Bulk)传输方式。主要应用在没有带宽和间隔时间要求的批量数据的传送和接收，它要求保证传输打印机和扫描仪属于这种类型。</li>
</ul>
<h2 id="USB协议"><a href="#USB协议" class="headerlink" title="USB协议"></a>USB协议</h2><p>USB 是一种轮询总线，由 Host 发起所有的数据传输。总线传输包含 3 个包(packet)。每个传输都由 Host 先发出令牌包(Token Packet)，明确传输类型、传输方向、USB 设备地址和端点号。对应地址的 USB 设备接收并解析包。一次传输可以由 Host 发向设备，也可以由设备发送至 Host，方向由令牌包说明。</p>
<h3 id="USB数据包"><a href="#USB数据包" class="headerlink" title="USB数据包"></a>USB数据包</h3><ul>
<li><strong>USB数据包格式</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">偏移量</th>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">HeaderChksum</td>
<td align="center">1</td>
<td align="center">利用添加包头进行效验，不包括包头本身的校验。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">HeaderSize</td>
<td align="center">1</td>
<td align="center">包头的大小，包括可用的字符串。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Signature</td>
<td align="center">2</td>
<td align="center">数据值为0x1234</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">VendorID</td>
<td align="center">2</td>
<td align="center">USB提供商的ID</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">ProductID</td>
<td align="center">2</td>
<td align="center">USB产品ID</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">ProductVersion</td>
<td align="center">1</td>
<td align="center">产品版本号</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">FirmwareVersion</td>
<td align="center">1</td>
<td align="center">固件版本号</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">USB属性</td>
<td align="center">1</td>
<td align="center">USB Attribute: Bit 0：如果设为1，包头包括以下三个字符串：语言、制造商、产品字符串；如果设为0，包头不包括任何字符串。 Bit 2：如果设为1，设备自带电源；如果设为0，无自带电源。 Bit 3：如果设为1，设备可以通过总线供电；如果设为0，无法通过总线供电。 Bits 1 and 4—7：保留。</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">最大电力</td>
<td align="center">1</td>
<td align="center">设备需要的最大电力，以2mA为单位。</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">设备属性</td>
<td align="center">1</td>
<td align="center">Device Attributes: Bit 0：如果设为1，CPU运行在24 MHz；如果设为0，CPU运行在12 MHz。 Bit 3：如果设为1，设备的EEPROM可以支持400 MHz；如果设为0，不支持400 MHz。 Bits 1, 2 and 4 … 7：保留。</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">WPageSize</td>
<td align="center">1</td>
<td align="center">I2C的最大写入页面大小</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">数据类型</td>
<td align="center">1</td>
<td align="center">该数值定义设备是软件EEPROM还是硬件EEPROM。0x02：硬件EEPROM 其它数值无效。</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">RpageSize</td>
<td align="center">1</td>
<td align="center">I2C最大读取页面大小。如果值为0，整个负载大小由一个I2C读取设备读取。</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">PayLoadSize</td>
<td align="center">2</td>
<td align="center">如果将EEPROM作为软件EEPROM使用，表示软件的大小；除此之外该值都是0。</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Language string</td>
<td align="center">4</td>
<td align="center">语言字符串。以标准USB字符串格式表示。（非必要字段）</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Manufacture string</td>
<td align="center">…</td>
<td align="center">制造商字符串。以标准USB字符串格式表示。（非必要字段）</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Product string</td>
<td align="center">…</td>
<td align="center">产品字符串，以标准USB字符串格式表示。（非必要字段）</td>
</tr>
<tr>
<td align="center">0xxx</td>
<td align="center">Application Code</td>
<td align="center">…</td>
<td align="center">表示应用代码。以标准USB字符串格式表示。（非必要字段）</td>
</tr>
</tbody></table>
<h2 id="USB设备"><a href="#USB设备" class="headerlink" title="USB设备"></a>USB设备</h2><h3 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h3><p>依附在总线上的设备可以是需要特定的驱动程序的完全定制的设备，也可能属于某个设备类别。这些类别定义设备的行为和接口描述符，这样一个驱动程序可能用于所有此种类别的设备。一般操作系统都为支持这些设备类别，为其提供通用驱动程序。设备分类由USB设计论坛设备工作组决定，并分配ID。</p>
<p>如果一个设备类型属于整个设备，该设备的描述符的bDeviceClass域保存类别ID；如果它这是设备的一个接口，其ID保存在接口描述符的bInterfaceClass域。他们都占用一个字节，所以最多有253种设备类别。（0x00和0xFF保留）。当bDeviceClass设为0x00，操作系统会检查每个接口的bInterfaceClass以确定其类别。</p>
<p>常用设备类别和ID有：<br>|  ID  |       设备        |                             例子                             |<br>| :–: | :—————:| :———————————————————-: |<br>| 0x00 | 保留值       |                              无                              |<br>| 0x01 | 音效设备      |                             声卡                             |<br>| 0x02 | USB通信控制设备   |                  网卡、调制解调器、串列端口                   |<br>| 0x03 | 人机界面设备(HID)  |                          键盘、鼠标                          |<br>| 0x05 | 物理接口设备      |        控制杆    |<br>| 0x06 | 静止图像捕捉设备  | 影像扫描仪、Picture Transfer Protocol |<br>| 0x07 |  打印设备        |        打印机      |<br>| 0x08 | 大容量访问设备    | U盘、移动硬盘、存储卡读卡器、数字相机 |<br>| 0x09 | 集线器       |                            集线器                            |<br>| 0x0A | 通信设备      | 调制解调器、网络卡、ISD、传真 |<br>| 0x0B | 智能卡设备     |                            读卡器                            |<br>| 0x0E | 影像设备    |      摄像头   |<br>| 0xE0 | 无线传输设备   |          蓝牙   |<br>| 0xFE | 特殊的应用    |                       红外线资料桥接器                       |<br>| 0xFF | 定制设备      |                                                              |</p>
<h3 id="lsusb"><a href="#lsusb" class="headerlink" title="lsusb"></a>lsusb</h3><p>显示本机的usb设备列表，可以显示出usb的详细信息，包括设备的读取速度和描述符。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-v</td>
<td>告诉lsusb详细显示所示设备的详细信息。这包括设备当前速度的配置描述符。如果可用，类描述符将显示USB设备类，包括集线器、音频、HID、通信和芯片卡。</td>
</tr>
<tr>
<td>-s [[bus]:][devnum]</td>
<td>显示指定总线和设备号的设备信息，总线和设备号用十进制标识。格式：lsusb –s 00:01</td>
</tr>
<tr>
<td>-d [vendor]:[product]</td>
<td>显示指定厂商和产品编号的设备，用十六进制表示编号。格式：lsusb –d 8086:</td>
</tr>
<tr>
<td>-D</td>
<td>显示指定设备文件的设备信息，例如：<code>lsusb –D /proc/bus/usb/001/001</code>。只有root用户才可以使用这个选项</td>
</tr>
<tr>
<td>-t</td>
<td>以树状结构显示</td>
</tr>
<tr>
<td>-V</td>
<td>指令版本信息</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/modbus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/modbus/" class="post-title-link" itemprop="url">modbus协议</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/modbus/" itemprop="url" rel="index"><span itemprop="name">modbus</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Modbus"><a href="#Modbus" class="headerlink" title="Modbus"></a>Modbus</h2><p>Modbus协议是一种广泛应用于工业控制领域的通用通讯协议，使用的是主从通讯技术，即由主设备主动查询和操作从设备。通讯物理接口可以选用串口（包括RS232、RS485和RS422），也可以选择以太网口。有三种通信方式：</p>
<ul>
<li>以太网：对应的通信模式是MODBUS TCP/IP。</li>
<li>异步串行传输（各种介质如有线RS-232-/422/485/；光纤、无线等），对应的通信模式是MODBUS RTU或MODBUS ASCII。</li>
<li>高速令牌传递网络：对应的通信模式是Modbus PLUS</li>
</ul>
<h3 id="ASCII模式"><a href="#ASCII模式" class="headerlink" title="ASCII模式"></a>ASCII模式</h3><p><img src="/images/uart/Modbus-frame-structure-ASCII-mode.jpg" alt="Modbus帧结构-ASCII模式"></p>
<p>在ASCII模式下，消息以冒号（:）字符（ASCII码 3AH）开始，以回车换行符结束（ASCII码 0DH,0AH）。其它域可以使用的传输字符是十六进制的0…9,A…F。网络上的设备不断侦测“:”字符，当有一个冒号接收到时，每个设备都解码地址域来判断是否发给自己的。消息中字符间发送的时间间隔最长不能超过1秒，否则接收的设备将认为传输错误。</p>
<p>错误检测域包含两个ASCII字符，使用LRC（纵向冗长检测）方法对消息内容计算得出的，不包括开始的冒号符及回车换行符。</p>
<h3 id="RTU模式"><a href="#RTU模式" class="headerlink" title="RTU模式"></a>RTU模式</h3><p><img src="/images/uart/RTU.bmp" alt="RTU报文帧"></p>
<p><img src="/images/uart/1.5T.jpg" alt="img"></p>
<p>RTU模式规定消息发送至少要以3.5个字符时间的停顿间隔开始。至少3.5个字符时间的停顿标定了消息的结束。消息帧内字节间隔为1.5个字符时间。</p>
<p>从设备的地址范围是1~247，地址0是用作广播地址。主设备通过将要联络的从设备的地址放入消息中的地址域来选通从设备。当从设备发送回应消息时，它把自己的地址放入回应的地址域中，以便主设备知道是哪一个设备作出回应。</p>
<h3 id="功能码"><a href="#功能码" class="headerlink" title="功能码"></a>功能码</h3><p>Modbus的操作对象有四种：线圈、离散输入、输入寄存器、保持寄存器。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>线圈</td>
<td>1bit，ON或OFF，可读可写，有效的地址范围是1-9999</td>
</tr>
<tr>
<td>离散量</td>
<td>1bit，ON或OFF，只读，有效地址范围是10001-19999</td>
</tr>
<tr>
<td>输入寄存器</td>
<td>16位的寄存器，只读，可以用作模拟量或16位打包输入点，有效地址范围是30001-39999</td>
</tr>
<tr>
<td>保持寄存器</td>
<td>16位的寄存器，可读可写，既可以是一个模拟量或16位打包输入点，也可以是模拟量或16位打包输出点，有效地址范围是40001-49999</td>
</tr>
</tbody></table>
<p>Modbus的功能码有：</p>
<table>
<thead>
<tr>
<th>功能码</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>读线圈状态</td>
<td>读位（读N个bit）—读从机线圈寄存器，位操作</td>
</tr>
<tr>
<td>02</td>
<td>读输入离散量</td>
<td>读位（读N个bit）—读离散输入寄存器，位操作</td>
</tr>
<tr>
<td>03</td>
<td>读多个寄存器</td>
<td>读整型、字符型、状态字、浮点型（读N个words）—读保持寄存器，字节操作</td>
</tr>
<tr>
<td>04</td>
<td>读输入寄存器</td>
<td>读整型、状态字、浮点型（读N个words）—读输入寄存器，字节操作</td>
</tr>
<tr>
<td>05</td>
<td>写单个线圈</td>
<td>写位（写一个bit）—写线圈寄存器，位操作</td>
</tr>
<tr>
<td>06</td>
<td>写单个保持寄存器</td>
<td>写整型、字符型、状态字、浮点型（写一个word）—写保持寄存器，字节操作</td>
</tr>
<tr>
<td>07</td>
<td>读取异常状态</td>
<td>取得8个内部线圈的通断状态，这8个线圈的地址由控制器决定，用户逻辑可以将这些线圈定义，以说明从机状态，短报文适宜于迅速读取状态</td>
</tr>
<tr>
<td>08</td>
<td>回送诊断校验</td>
<td>把诊断校验报文送从机，以对通信处理进行评鉴</td>
</tr>
<tr>
<td>09</td>
<td>编程（只用于484）</td>
<td>使主机模拟编程器作用，修改PC从机逻辑</td>
</tr>
<tr>
<td>0A</td>
<td>控询（只用于484）</td>
<td>可使主机与一台正在执行长程序任务从机通信，探询该从机是否已完成其操作任务，仅在含有功能码9的报文发送后，本功能码才发送</td>
</tr>
<tr>
<td>0B</td>
<td>读取事件计数</td>
<td>可使主机发出单询问，并随即判定操作是否成功，尤其是该命令或其他应答产生通信错误时</td>
</tr>
<tr>
<td>0C</td>
<td>读取通讯事件记录</td>
<td>可是主机检索每台从机的ModBus事务处理通信事件记录。如果某项事务处理完成，记录会给出有关错误</td>
</tr>
<tr>
<td>0D</td>
<td>编程（184/384/484/584）</td>
<td>可使主机模拟编程器功能修改PC从机逻辑</td>
</tr>
<tr>
<td>0E</td>
<td>探询（184/384/484/584）</td>
<td>可使主机与正在执行任务的从机通信，定期控询该从机是否已完成其程序操作，仅在含有功能13的报文发送后，本功能码才得发送</td>
</tr>
<tr>
<td>0F</td>
<td>写多个线圈</td>
<td>可以写多个线圈—强置一串连续逻辑线圈的通断</td>
</tr>
<tr>
<td>10</td>
<td>写多个保持寄存器</td>
<td>写多个保持寄存器—把具体的二进制值装入一串连续的保持寄存器</td>
</tr>
<tr>
<td>11</td>
<td>报告从机标识</td>
<td>可使主机判断编址从机的类型及该从机运行指示灯的状态</td>
</tr>
<tr>
<td>12</td>
<td>（884和MICRO84）</td>
<td>可使主机模拟编程功能，修改PC状态逻辑</td>
</tr>
<tr>
<td>13</td>
<td>重置通信链路</td>
<td>发生非可修改错误后，是从机复位于已知状态，可重置顺序字节</td>
</tr>
<tr>
<td>14</td>
<td>读取通用参数（584L）</td>
<td>显示扩展存储文件中的数据信息</td>
</tr>
<tr>
<td>15</td>
<td>写入通用参数（584L）</td>
<td>把通用参数写入扩展存储文件</td>
</tr>
<tr>
<td>16~40</td>
<td>保留做扩展功能备用</td>
<td></td>
</tr>
<tr>
<td>41~48</td>
<td>保留以备用户功能所用</td>
<td>留作用户功能的扩展编码</td>
</tr>
<tr>
<td>49~77</td>
<td>非法功能</td>
<td></td>
</tr>
<tr>
<td>78~7F</td>
<td>保留</td>
<td>留作内部作用</td>
</tr>
<tr>
<td>80~FF</td>
<td>保留</td>
<td>用于异常应答</td>
</tr>
</tbody></table>
<p>常用功能码如下：</p>
<table>
<thead>
<tr>
<th>功能码</th>
<th>名称</th>
<th>功能</th>
<th>对应的地址类型</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>读线圈状态</td>
<td>读位（读N个bit）—读从机线圈寄存器，位操作</td>
<td>0x</td>
</tr>
<tr>
<td>02</td>
<td>读输入离散量</td>
<td>读位（读N个bit）—读离散输入寄存器，位操作</td>
<td>1x</td>
</tr>
<tr>
<td>03</td>
<td>读多个寄存器</td>
<td>读整型、字符型、状态字、浮点型（读N个words）—读保持寄存器，字节操作</td>
<td>4X</td>
</tr>
<tr>
<td>04</td>
<td>读输入寄存器</td>
<td>读整型、状态字、浮点型（读N个words）—读输入寄存器，字节操作</td>
<td>3x</td>
</tr>
<tr>
<td>05</td>
<td>写单个线圈</td>
<td>写位（写一个bit）—写线圈寄存器，位操作</td>
<td>0x</td>
</tr>
<tr>
<td>06</td>
<td>写单个保持寄存器</td>
<td>写整型、字符型、状态字、浮点型（写一个word）—写保持寄存器，字节操作</td>
<td>4x</td>
</tr>
<tr>
<td>0F</td>
<td>写多个线圈</td>
<td>写位（写n个bit）—强置一串连续逻辑线圈的通断</td>
<td>0x</td>
</tr>
<tr>
<td>10</td>
<td>写多个保持寄存器</td>
<td>写整形、字符型、状态字、浮点型（写n个word）—把具体的二进制值装入一串连续的保持寄存器</td>
<td>4x</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/spi_bus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/spi_bus/" class="post-title-link" itemprop="url">spi总线</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spi/" itemprop="url" rel="index"><span itemprop="name">spi</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SPI(Serial Peripheral Interface)串行外设接口是一种用于芯片通信的串行同步传输总线协议，最初由Motorola在2000年提出。</p>
<ul>
<li><p>SPI允许传输单个bit数据，甚至允许暂停，因为SCK时钟线由主控设备控制，当没有时钟跳变时，从设备不采集或传送数据。</p>
</li>
<li><p>支持全双工通信，每个从设备需要独立的使能信号。</p>
</li>
<li><p>推挽输出的驱动性能相比开漏输出信号完整性更好，支持高速应用（100MHz以上）。</p>
</li>
<li><p>协议支持字长不限于8bits，可根据应用特点灵活选择消息字长。</p>
</li>
<li><p>相比I2C和SMbus节省上拉电阻，不需要仲裁机制。</p>
</li>
<li><p>没有寻址机制，只能靠设备片选选择不同从设备，故没有数据流控制和应答机制。</p>
</li>
<li><p>SPI没有规定最大传输速率，通常能达到10Mbps。</p>
</li>
</ul>
<p><strong>Dual SPI</strong>是针对SPI Flash而言，不是针对所有SPI外设。对于SPI Flash，全双工并不常用，因此修改了mosi和miso的用法，使其工作在半双工，能够加倍传输数据。也就是说对于Dual SPI Flash，可以发送一个命令字节进入dual mode，这样mosi变成SIO0，mosi变成SIO1，这样一个时钟周期内就能传输2个bit数据。</p>
<p><strong>Qual SPI</strong>也是针对SPI Flash，Qual SPI 在Dual SPI基础上增加了两根线（SIO2、SIO3），目的是一个时钟内能传输4个bit数据。</p>
<h2 id="信号定义"><a href="#信号定义" class="headerlink" title="信号定义"></a>信号定义</h2><p><strong>MOSI</strong>：主设备数据输出，从设备数据输入。</p>
<p><strong>MISO</strong>：主设备数据输入，从设备数据输出。</p>
<p><strong>SCLK</strong>：时钟信号，由主设备产生。</p>
<p><strong>CS/SS</strong>：片选，从设备使能信号，由主设备控制。</p>
<p>SPI总线定义两个及以上设备间的数据传输，提供时钟的设备为主设备，接收时钟的设备为从设备。片选信号SS通常低电平有效。SPI数据传输原理是基于主从设备内部移位寄存器的数据交换。在主设备SCK的控制下，待传数据由各自设备的数据寄存器传输到移位寄存器，再通过MOSI和MISO信号线完成主从设备间的数据交换。</p>
<p><img src="/images/spi/spi_ms_mod_reg.png" alt="spi框图"></p>
<h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p>SPI有4种操作模式，每种模式由一对参数决定，主从设备必须使用相同的工作参数，才能正常工作。</p>
<p>CPOL时钟极性(clock polarity)，决定时钟空闲时的电平为高或低，对于SPI数据传输格式没有显著影响。</p>
<ul>
<li>0 : 时钟高电平时有效，空闲时为低。</li>
<li>1 : 时钟低电平时有效，空闲时为高。</li>
</ul>
<p>CPHA时钟相位(clock phase)，定义时钟脉冲在哪条边沿转换输出信号，哪条边沿采样输入信号。</p>
<ul>
<li>0 : 数据采样发生在时钟奇数边沿。</li>
<li>1 : 数据采样发生在时钟偶数边沿。</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>Mode 0</td>
<td>SCLK 空闲是为低电平，数据在上升沿有效</td>
</tr>
<tr>
<td>Mode 1</td>
<td>SCLK 空闲是为低电平，数据在下降沿有效</td>
</tr>
<tr>
<td>Mode 2</td>
<td>SCLK 空闲是为高电平，数据在下降沿有效</td>
</tr>
<tr>
<td>Mode 3</td>
<td>SCLK 空闲是为高电平，数据在上升沿有效</td>
</tr>
</tbody></table>
<p><img src="/images/spi/4mode.png" alt="4种模式"></p>
<p><img src="/images/spi/timing_diagram.png" alt="时序"></p>
<h2 id="多个从设备"><a href="#多个从设备" class="headerlink" title="多个从设备"></a>多个从设备</h2><ul>
<li><strong>片选方式</strong></li>
</ul>
<p>每个从设备都需要单独的片选信号，主设备每次只能选择其中一个从设备进行通信。因为所有从设备的SCK、MOSI、MISO都是连在一起的，未被选中从设备的MISO要表现为高阻状态以避免数据传输错误。由于每个设备都需要单独的片选信号，如果需要的片选信号过多，可以使用译码器产生所有的片选信号。</p>
<p><img src="/images/spi/multiple-slaves.png" alt="主设备以片选方式控制多个从设备"></p>
<ul>
<li><strong>菊花链方式</strong></li>
</ul>
<p>数据信号经过主从设备所有的移位寄存器构成闭环。数据通过主设备发送（绿色线）经过从设备返回（蓝色线）到主设备。在这种方式下，片选和时钟同时接到所有从设备。</p>
<p>菊花链式连接常用于仅需主设备发送数据而不需要接收返回数据的场合，如LED驱动器。在这种应用下，主设备MISO可以不连。如果需要接收从设备的返回数据，则需要连接主设备的MISO形成闭环。同样地，切记要发送足够多的接收指令以确保数据移位送达主设备。</p>
<p><img src="/images/spi/multiple-slaves2.png" alt="主设备以菊花链方式控制多个从设备"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/i2c_bus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/i2c_bus/" class="post-title-link" itemprop="url">i2c总线</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/i2c/" itemprop="url" rel="index"><span itemprop="name">i2c</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a target="_blank" rel="noopener" href="https://www.i2c-bus.org/">https://www.i2c-bus.org/</a></p>
<p>I2C总线(Inter Integrated-Circuit)是由PHILIPS公司在上世纪80年代发明的一种电路板级串行总线标准，通过时钟线SCL和数据线SDA即可完成主从机的单工通信，广泛应用于电路板级的内部通信。</p>
<ul>
<li><p>总线上的所有设备通过软件寻址且具有唯一的地址。</p>
</li>
<li><p>总线上所有器件都具有自动应答功能，保证数据传输的正确性；</p>
</li>
<li><p>主机和从机的区别在于对SCL的发送权，只有主机才能发送SCL；</p>
</li>
<li><p>I2C数据传输速率有标准模式(100 kbps)、快速模式(400 kbps)和高速模式(3.4 Mbps)。</p>
</li>
</ul>
<p><img src="/images/i2c/i2c-bus.png" alt=" I2C连接示意图"></p>
<p>I2C总线上所有器件的SDA、SCL引脚输出驱动都为漏极开路结构，因此SDA和SCL可以被拉低为低电平，但是不能被驱动为高电平，低电平输出电压最大为0.4V，上拉电阻一般为4.7KΩ。通过外接上拉电阻实现总线上所有节点SDA、SCL信号的线与逻辑关系。<strong>线与</strong>的意思是只要总线上有一个设备输出底电平，总线信号就会被拉底。线与的作用在于可以实现总线的仲裁控制，总线的控制权会交给最后一个输出低电平的设备，其它设备(输出为高)通过检测总线上的电平状态(表现为低)，对比与自己输出状态不一致，则自动退出对总线的控制请求。</p>
<p>漏极开路/集电极开路的缺点是对于一个距离长的数据线，信号传输速率得不到有效保证。更长的走线对于输出驱动器表现为更大的容性负载，等效容性负载C和信号线的上拉电阻R构成RC振荡器。RC越大，意味着反射和振荡越强，从而影响总线的信号完整性。所以I2C总线允许挂载最多的设备数量取决于总线上最大电容值，一般为400pf(Hs模式100pf)。</p>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><p><img src="/images/i2c/i2c-data.webp" alt="数据序列"></p>
<h3 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h3><p>协议没有规定I2C逻辑1和0的电平值。每传输一比特数据SDA，对应产生一个时钟脉冲SCL。<strong>SCL为高时，SDA不允许变化；只有在SCL为低时，SDA才可以变化</strong>。</p>
<p><img src="/images/i2c/bit.png" alt="位的传输"></p>
<h3 id="开始-结束条件"><a href="#开始-结束条件" class="headerlink" title="开始/结束条件"></a>开始/结束条件</h3><p>如果I2C总线空闲，那么SCL和SDA信号线将都为高电平。<strong>在SCL为高电平时，将SDA由高到低电平跳变，作为起始信号，SDA由低到高电平跳变，作为结束信号</strong>。</p>
<p><img src="/images/i2c/start-stop.png" alt="开始和结束条件"></p>
<p>开始/结束条件总是由主机发起的。主机发出开始条件后，总线处于忙的状态；主机发出结束条件后，总线处于空闲状态。如果两个主机在同一时刻都希望获得总线的所有权，那么谁先将SDA拉低，谁就赢得了总线的控制权。</p>
<p>当所有数据都发送完成时，主设备需要产生一个停止信号，告诉从设备自己已经操作完成。停止信号在SDA置于低电平时，将SCL拉高并保持高电平，然后将SDA拉高。在正常传输数据过程中，当SCL处于高电平时，SDA上的值不应该变化，防止意外产生一个停止信号。</p>
<p>在操作中，如果主机发出重复开始条件而非结束条件，则总线仍处于忙的状态。也就是说重复开始条件和开始条件在功能上是相同的。</p>
<h3 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h3><p>在地址帧发送之后，就可以开始传输数据了。主设备负责产生时钟，并且在时钟上升沿之前准备好数据。每个数据帧8bits，数据帧的数量可以是任意的，直到产生停止条件。每一帧数据传输之后，接收方就需要回复一个ACK或NACK。数据传输过程中，<strong>先发送高位，再发送低位</strong>。</p>
<p>如果在数据传输过程中，从机如果没有准备好接收或发送下一个字节（比如内部中断需要处理等），它可以通过拉低SCL强制主机进入等待状态。直到从机释放SCL，主机才开始下一个字节的发送或接收。</p>
<p><img src="/images/i2c/tu4.png" alt="I2C总线的数据传输"></p>
<h3 id="应答"><a href="#应答" class="headerlink" title="应答"></a>应答</h3><p><img src="/images/i2c/ack.png" alt="I2C总线的数据应答"></p>
<p>当主设备发送完地址帧之后，在应答时钟周期内，会放弃SDA总线控制权，让从设备获得SDA控制权，这样从设备才能通过将SDA拉低通知发送器数据已被成功接收。此时从设备应该在第9个时钟脉冲之前回复一个ACK以表示接收正常。SCL为高的时候，SDA数据才是有效的，因此接收器发送ACK时，要保证SCL为高的同时，SDA为低电平；建立和保持时间也要满足规范要求。</p>
<p>如果在第9个时钟周期，SDA为高，表明接收设备无应答（NACK）。主机可以据此发出结束条件命令结束此次传输，或发起重传请求重新传输数据。有5种情况可能导致无应答：</p>
<ul>
<li>总线上没有报文中所指定地址的设备不存在。</li>
<li>接收器件尚未准备好与主机的通信。</li>
<li>接收器件无法解析读取的数据。</li>
<li>接收器件无法收取更多的数据，比如程序或者芯片内置缓冲区已经满了。</li>
<li>主机作为接收器时，在读取从机发出的最后一个字节数据后，发出NACK通知从发送器释放数据线SDA，以便主机发起结束或重传指令。</li>
</ul>
<p>主机作为发送器和接收器在写和读情况下的数据格式：</p>
<h3 id="重复开始信号"><a href="#重复开始信号" class="headerlink" title="重复开始信号"></a>重复开始信号</h3><p>主设备可以发起多个开始信号来完成数据的传输，只要不发停止信号，总线上的其他主设备就不能占据这条总线，有时候发送完一组数据后，希望重新发数据，所以就有了重复开始信号。重复的开始信号为，SDA在SCL低电平时拉高，然后SCL拉高。重复开始条件的传输时序如下图所示：</p>
<p><img src="/images/i2c/restart.jpg" alt="重复开始条件的传输时序"></p>
<h2 id="时钟同步和仲裁"><a href="#时钟同步和仲裁" class="headerlink" title="时钟同步和仲裁"></a>时钟同步和仲裁</h2><p>I2C的一大特点是可以在同一条总线上接多个主机，当两个及以上的主机同时发起传输请求时，需要通过某种机制确定哪个主机获得总线的使用权；另外，每个主机都独立产生时钟，时钟速率可能千差万别，这也需要某种机制解决时钟速率不一致的问题。这种机制就是时钟同步（Clock Synchronization）和仲裁（Arbitration）。在单主机的I2C系统中，不需要时钟同步和仲裁。</p>
<h3 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h3><p>每个I2C的主机内部都有两个计数器，分别计数SCL上高电平和低电平的时间。如果总线上只有一个主机，则这两个计数器的值取决于系统时钟速率。当多个主机存在时，不同设备的计数器速度可能不一致，因此涉及时钟同步的概念。</p>
<p>时钟同步是通过I2C接口的“线与”逻辑实现的。SCL信号线由高变低时，所有连接在SCL上的主机都开始计数低电平的时间（低电平计数器复位），由线与的逻辑可知：只有当SCL总线上所有主机的时钟输出端都为高时，SCL总线才会由低变高。SCL的低电平时间由总线上低电平时间最长的主机决定。时钟端口先跳变为高的其它主机进入等待状态。这样所有主机的时钟输出和SCL线上的状态保持相同；当SCL由低变高后，所有主机（高电平计数器）开始计数SCL高电平的时间；最早由高跳变到低的主机再次将SCL拉低。通过这种方式产生的同步时钟：其低电平时间是所有主机时钟中最长的低电平时间，其高电平时间是所有主机时钟中最短的高电平时间。</p>
<p><img src="/images/i2c/clock_sync.png" alt="仲裁阶段的时钟同步"></p>
<h3 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h3><p>当总线上有一个以上的主机时，协议通过仲裁的方法确定哪个主机获得总线的使用权。从机不参与仲裁的过程。</p>
<p>当总线处于空闲状态时，在最小的保持时间内，多个主机都可能发起开始条件在总线上传输数据。仲裁用来判断哪个主机的传输可以正常进行。</p>
<p>仲裁是按位进行的。仲裁开始时，对于每一位数据，SCL为高时，每个主机都检测SDA上的数据是否和自己发送的数据相同。可能需要进行多个位的比较，主机才开始检测到SDA上数据和自己发送的不一致。实际上，只要SDA上的数据和主机发送的数据一致，这些主机就可以将数据一致发送下去。当主机发送为HIGH，检测SDA上电平却为LOW，那么该主机就在仲裁中失去主控权，并将其SDA输出关闭。余下的主机获得总线控制权并继续数据的传输。如图8，当主机1在检测到SDA数据和它自身的输出DATA1不一致时，将自动关闭DATA1的输出，停止向总线上发送数据。</p>
<p>由此可见，在仲裁过程中胜出的主机是没有丢失数据的。在仲裁中失去总线控制权的主机在本次字节传输结束后继续产生时钟，并在总线空闲时开始上次数据的重传。如果同一个器件可以工作在主从两种模式，它在仲裁过程中失去总线控制权，那么有可能是仲裁胜出的主机将要访问该器件，该器件应该立即切换到从机模式。</p>
<p><img src="/images/i2c/arbitration.png" alt="两个主机的仲裁过程"></p>
<p>从上面的原理分析可知，I2C不存在核心主机，是没有优先级的概念的。总线的控制权仅取决于主机在SDA上的竞争（SDA包含地址和数据）。</p>
<p>在仲裁过程中，存在以下未定条件会导致不可预期的结果：</p>
<ul>
<li>主机1在主机2发送数据的过程中发出重复开始条件</li>
<li>主机1在主机2发送数据的过程中发出结束条件</li>
<li>主机1在主机发出结束条件的过程中发出重复开始条件</li>
</ul>
<h3 id="时钟拉伸"><a href="#时钟拉伸" class="headerlink" title="时钟拉伸"></a>时钟拉伸</h3><p>如果主设备发送的速度比从设备接收的速度快，因为是同步传输，可能就会出现问题，这时候，从设备可以通过控制时钟线，要求主设备线暂停传输，这就叫时钟拉伸(clock stretching)。</p>
<p>时钟拉伸通过拉低SCL延迟数据的传输。从机在主机释放SCL后，将SCL主动拉低并保持，此时主机停止在SCL上产生脉冲以及在SDA上发送数据，直到slave释放SCL，让SCL变成高电平。之后，主机便可以继续正常的数据传输了。可见时钟拉伸实际上是利用了时钟同步的机制，只是时钟由从机产生。</p>
<p>时钟拉伸是可选功能，实际上许多从机不包括SCL驱动器，因此也无法拉伸时钟。</p>
<p>包含时钟拉伸的I2C数据传输时序图为：</p>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><h3 id="7位地址"><a href="#7位地址" class="headerlink" title="7位地址"></a>7位地址</h3><p>7位从机地址，其高4位为设备类型地址，由生产厂家制定，低3位为器件引脚定义地址，由使用者定义。</p>
<p>8位地址的第0位是数据方向控制位：为0表示主机写数据，1表示主机读数据。</p>
<p>主机发送结束条件（P）终止一次传输。主机也可以通过发起重复开始条件（Sr）进行一次新的传输，而不需要先产生结束条件（P）。在一次传输过程中，可能存在多种读写组合，包括：</p>
<ul>
<li>主机作为发送，向从机发送（写）数据，传输的方向不变；</li>
</ul>
<p><img src="/images/i2c/tu10.png" alt="7位地址主发从收模式"></p>
<ul>
<li>主机发送开始条件（S）以及其后的第一个字节，立即改为从总线上读取状态。收到从机的应答（ACK）后，主机由主发模式切换到主收模式，从机由从收模式切换到从发模式。第一个应答是从机发出的。主机先发送NACK，再发送结束条件（P）结束本次传输；</li>
</ul>
<p><img src="/images/i2c/tu11.png" alt="主机在第一个字节后立即读取从机内容"></p>
<p><img src="/images/i2c/tu12.png" alt="混合模式"></p>
<h3 id="10位地址"><a href="#10位地址" class="headerlink" title="10位地址"></a>10位地址</h3><p>任何I2C设备都有一个7位地址，理论上，现实中只能有127种不同的IIC设备。实际上，已有IIC的设备种类远远多于这个限制，在一条总线上出现相同的地址的IIC设备的概率相当高。为了突破这个限制，很多设备使用了双重地址，7位地址加引脚地址。IIC 标准也预知了这种限制，提出10位的地址方案。</p>
<p>在10-bit地址的I2C系统中，需要两帧来传输slave的地址。第一个帧的前<strong>5个bit固定为b11110</strong>，后接slave地址的高2位，第8位仍然是R/W位，接着是一个ACK位，然后再发送另外8bit的地址，发送完后从设备会给出应答。</p>
<p><img src="/images/i2c/10-addr.bmp" alt="10位地址"></p>
<p><img src="/images/i2c/tu13.png" alt="主发送器寻址从接收器"></p>
<p>主接收器读取10位地址的从发送器发送的数据。数据传送方向在第二个R/W后发生改变。如图15所示，A2之前的操作和主发送器向从接收器写数据没有区别。通过Sr，匹配地址的从机得知它就是被寻址的设备，接下来从机检测Sr后的七个比特是否和先前START后的七比特一致（1111 0XX），并检测第八位（R/W）是否为1。如果是，则从机据此判断它被寻址并将要作为发送器往总线上发送数据，此时从机产生响应A3。从机一直占用总线，直到接收到STOP或Sr指向另一个从机地址。收到Sr信号后，所有从机都会对比Sr后第一个字节的前七位（1111 0XX），并检测该字节的第八位（R/W）。对于10位地址设备R/W=1，对于7位地址设备，地址（1111 0XX）不匹配，因此这些设备都不会响应Sr，不会被寻址。</p>
<p><img src="/images/i2c/tu14.png" alt="主接收器寻址从发送器"></p>
<h3 id="保留地址"><a href="#保留地址" class="headerlink" title="保留地址"></a>保留地址</h3><table>
<thead>
<tr>
<th align="left">设备地址</th>
<th align="left">读写位</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0000 000</td>
<td align="left">0</td>
<td align="left">广播地址</td>
</tr>
<tr>
<td align="left">0000 000</td>
<td align="left">1</td>
<td align="left">启动字节</td>
</tr>
<tr>
<td align="left">0000 001</td>
<td align="left">X</td>
<td align="left">CBUS 地址</td>
</tr>
<tr>
<td align="left">0000 010</td>
<td align="left">X</td>
<td align="left">预留给不同的总线格式</td>
</tr>
<tr>
<td align="left">0000 011</td>
<td align="left">X</td>
<td align="left">预留未来扩展使用</td>
</tr>
<tr>
<td align="left">0000 1XX</td>
<td align="left">1</td>
<td align="left">Hs-mode 主代码</td>
</tr>
<tr>
<td align="left">1111 1XX</td>
<td align="left">1</td>
<td align="left">设备 ID</td>
</tr>
<tr>
<td align="left">1111 0XX</td>
<td align="left">X</td>
<td align="left">10 位从地址</td>
</tr>
</tbody></table>
<h3 id="通用广播地址"><a href="#通用广播地址" class="headerlink" title="通用广播地址"></a>通用广播地址</h3><p>通用广播地址是为了寻址总线上所有设备。如果一个设备不需要使用广播功能，可以不响应广播。如果设备需要使用广播功能，则它在检测到广播地址后发送响应，并作为从接收器读取总线上发送的数据。主机不知道总线上有多少从机发送响应。总线上所有可以响应广播的从机读取广播地址后的第二个及后面的字节。不能处理这些广播数据的从机通过不发送响应的方式忽略它。同样地，如果有一个或一个以上的从机发送响应，则主机就检测不到总线上其它没有响应的设备。广播消息的含义总是定义在第二个字节。</p>
<p><img src="/images/i2c/tu15.png" alt="广播消息格式"></p>
<p>有两种可能情况：</p>
<ul>
<li>最低位“B”为0</li>
<li>最低位“B”为1</li>
</ul>
<p><strong>“B”为0</strong>，第二个字节包括以下定义：</p>
<ul>
<li><strong>0000 0110（06h）</strong>：复位并通过硬件写内容到从机的可编程部分。所有可以响应此类广播的从机，收到此两字节后，进行复位并进入它们地址的可编程部分。注意确保设备在加电后不会将SDA或SCL拉低，因为这些低电平会阻塞总线；</li>
<li><strong>0000 0100（04h）</strong>：通过硬件写内容到从机的可编程部分，作用类似（06h），但设备不会复位；</li>
<li><strong>0000 0000（00h）</strong>：这个不应该作为第二个字节用。</li>
</ul>
<p>编程时序参考相应设备的DATASHEET。</p>
<p><strong>“B”为1</strong>，两字节广播定义为“硬件广播”。主机（如键盘扫描器）在编程后，可以发送既定的从机地址到总线上，构成两字节序列的“硬件广播”。既然主机可能并不知道总线上从机的地址，它只能通过硬件广播的方式，将自身地址通知给系统。</p>
<p><img src="/images/i2c/tu16.png" alt="主发送器的数据传输格式"></p>
<p>硬件广播的第二个字节的前七位包括主机的地址。总线上的智能设备如微控制器，读取此地址并接收主机发送的其它信息。如果主机也可以作为从机使用，则以上读取的主机地址实际上也就是（切换主从模式后的）从机地址。</p>
<p>在系统中，一种可能是系统复位后设备由主机发送模式切换到从机接收模式，这时由系统主机先告诉硬件主机数据应送往的从机地址，这样当硬件主机发送数据时就可以直接向指定从机地址发送数据了。</p>
<p><strong>软件复位</strong></p>
<p>通用广播地址0000 0000后发送0000 0110（06h）可以使总线上设备进入复位过程。该功能是可选的，所有预留该功能的设备在收到该两字节序列（00 06h）后，开始响应（复位），并进入它们地址的可编程部分。注意确保设备在加电后不会将SDA或SCL拉低，因为这些低电平会阻塞总线。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/uart_bus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/uart_bus/" class="post-title-link" itemprop="url">uart协议</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/uart/" itemprop="url" rel="index"><span itemprop="name">uart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>TTL电平</strong></p>
<p>TTL(Transistor-Transistor Logic)晶体管-晶体管逻辑，电路规格：</p>
<ul>
<li>输出高电平&gt;=2.4V，输出低电平&lt;=0.4V；</li>
<li>输入高电平&gt;=2.0V，输入低电平&lt;=0.8V。</li>
<li>噪声容限是0.4V。</li>
</ul>
<h2 id="RS232"><a href="#RS232" class="headerlink" title="RS232"></a>RS232</h2><p>RS232是串口的一个标准，RS232是负逻辑电平，它定义+5 ~ +12V为低电平，而-12 ~ -5V为高电平。</p>
<ul>
<li>最大传输距离 50 米。</li>
<li>传输速率较低，在异步传输时，波特率为 20Kbps。</li>
<li>只允许一对一通信。</li>
</ul>
<p><img src="/images/uart/com.webp" alt="img"><br><img src="/images/uart/max3232.png" alt="max3232"></p>
<h2 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a>RS485</h2><p>RS-232接口只能点对点的通信，不能实现联网功能，于是一个新的标准RS-485产生了。RS-485使用一对双绞线采用差分传输方式，由于是差分通信，因此数据的接收和发送数据不能同时进行，只能工作在半双工模式，常用于总线网。</p>
<ul>
<li>电气特性：逻辑1以两线间的电压差为+2 ~ 6V表示；逻辑0以两线间的电压差为-2 ~ 6V表示。</li>
<li>最大的通信距离约为1200米（9600bps 时），实际上可达 3000 米。</li>
<li>最大传输速率为10Mb/s。</li>
<li>RS-485总线一般最大支持32个节点。</li>
</ul>
<p><img src="/images/uart/max485.png" alt="MAX485"></p>
<p>为了提高RS485的抗干扰性能，需要在靠近MAX485的AB引脚之间并接一个100 ~ 1K的电阻。</p>
<h2 id="RS422"><a href="#RS422" class="headerlink" title="RS422"></a>RS422</h2><p>RS-422（EIA RS-422-A Standard）是Apple的Macintosh计算机的串口连接标准。有4根信号线：两根发送，两根接收。由于RS-422 的收与发是分开的，所以可以全双工，适用于两个站之间通信，星型网、环网，不可用于总线网。</p>
<ul>
<li>最大传输距离为1219米，最大传输速率为10Mb/s。</li>
<li>最多可接10个节点。</li>
<li>支持点对多的双向通信。</li>
</ul>
<p><img src="/images/uart/RS-xxx.webp" alt="RS-xxx"></p>
<h2 id="校验方式"><a href="#校验方式" class="headerlink" title="校验方式"></a>校验方式</h2><p>串口通信过程中有5种校验方式：</p>
<ul>
<li><p>奇校验(odd parity)：让传输的数据（包含校验位）中1的个数是否为奇数，即如果传输字节中1的个数是偶数，则校验位为1，奇数为0。</p>
</li>
<li><p>偶校验(even parity)：传输的数据（包含校验位）中1的个数是否为偶数，即如果传输字节中1的个数是偶数，则校验位为0，奇数为0。</p>
</li>
<li><p>1校验(mark parity): 校验位始终为1。</p>
</li>
<li><p>0校验(space parity): 校验位始终为0。</p>
</li>
</ul>
<h2 id="Modbus"><a href="#Modbus" class="headerlink" title="Modbus"></a>Modbus</h2><p>Modbus协议是一种广泛应用于工业控制领域的通用通讯协议，使用的是主从通讯技术，即由主设备主动查询和操作从设备。通讯物理接口可以选用串口（包括RS232、RS485和RS422），也可以选择以太网口。有三种通信方式：</p>
<ul>
<li>以太网：对应的通信模式是MODBUS TCP/IP。</li>
<li>异步串行传输（各种介质如有线RS-232-/422/485/；光纤、无线等），对应的通信模式是MODBUS RTU或MODBUS ASCII。</li>
<li>高速令牌传递网络：对应的通信模式是Modbus PLUS</li>
</ul>
<h3 id="ASCII模式"><a href="#ASCII模式" class="headerlink" title="ASCII模式"></a>ASCII模式</h3><p><img src="/images/uart/Modbus-frame-structure-ASCII-mode.jpg" alt="Modbus帧结构-ASCII模式"></p>
<p>在ASCII模式下，消息以冒号（:）字符（ASCII码 3AH）开始，以回车换行符结束（ASCII码 0DH,0AH）。其它域可以使用的传输字符是十六进制的0…9,A…F。网络上的设备不断侦测“:”字符，当有一个冒号接收到时，每个设备都解码地址域来判断是否发给自己的。消息中字符间发送的时间间隔最长不能超过1秒，否则接收的设备将认为传输错误。</p>
<p>错误检测域包含两个ASCII字符，使用LRC（纵向冗长检测）方法对消息内容计算得出的，不包括开始的冒号符及回车换行符。</p>
<h3 id="RTU模式"><a href="#RTU模式" class="headerlink" title="RTU模式"></a>RTU模式</h3><p><img src="/images/uart/RTU.bmp" alt="RTU报文帧"></p>
<p><img src="/images/uart/1.5T.jpg" alt="img"></p>
<p>RTU模式规定消息发送至少要以3.5个字符时间的停顿间隔开始。至少3.5个字符时间的停顿标定了消息的结束。消息帧内字节间隔为1.5个字符时间。</p>
<p>从设备的地址范围是1~247，地址0是用作广播地址。主设备通过将要联络的从设备的地址放入消息中的地址域来选通从设备。当从设备发送回应消息时，它把自己的地址放入回应的地址域中，以便主设备知道是哪一个设备作出回应。</p>
<h3 id="功能码"><a href="#功能码" class="headerlink" title="功能码"></a>功能码</h3><p>Modbus的操作对象有四种：线圈、离散输入、输入寄存器、保持寄存器。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>线圈</td>
<td>1bit，ON或OFF，可读可写，有效的地址范围是1-9999</td>
</tr>
<tr>
<td>离散量</td>
<td>1bit，ON或OFF，只读，有效地址范围是10001-19999</td>
</tr>
<tr>
<td>输入寄存器</td>
<td>16位的寄存器，只读，可以用作模拟量或16位打包输入点，有效地址范围是30001-39999</td>
</tr>
<tr>
<td>保持寄存器</td>
<td>16位的寄存器，可读可写，既可以是一个模拟量或16位打包输入点，也可以是模拟量或16位打包输出点，有效地址范围是40001-49999</td>
</tr>
</tbody></table>
<p>Modbus的功能码有：</p>
<table>
<thead>
<tr>
<th>功能码</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>读线圈状态</td>
<td>读位（读N个bit）—读从机线圈寄存器，位操作</td>
</tr>
<tr>
<td>02</td>
<td>读输入离散量</td>
<td>读位（读N个bit）—读离散输入寄存器，位操作</td>
</tr>
<tr>
<td>03</td>
<td>读多个寄存器</td>
<td>读整型、字符型、状态字、浮点型（读N个words）—读保持寄存器，字节操作</td>
</tr>
<tr>
<td>04</td>
<td>读输入寄存器</td>
<td>读整型、状态字、浮点型（读N个words）—读输入寄存器，字节操作</td>
</tr>
<tr>
<td>05</td>
<td>写单个线圈</td>
<td>写位（写一个bit）—写线圈寄存器，位操作</td>
</tr>
<tr>
<td>06</td>
<td>写单个保持寄存器</td>
<td>写整型、字符型、状态字、浮点型（写一个word）—写保持寄存器，字节操作</td>
</tr>
<tr>
<td>07</td>
<td>读取异常状态</td>
<td>取得8个内部线圈的通断状态，这8个线圈的地址由控制器决定，用户逻辑可以将这些线圈定义，以说明从机状态，短报文适宜于迅速读取状态</td>
</tr>
<tr>
<td>08</td>
<td>回送诊断校验</td>
<td>把诊断校验报文送从机，以对通信处理进行评鉴</td>
</tr>
<tr>
<td>09</td>
<td>编程（只用于484）</td>
<td>使主机模拟编程器作用，修改PC从机逻辑</td>
</tr>
<tr>
<td>0A</td>
<td>控询（只用于484）</td>
<td>可使主机与一台正在执行长程序任务从机通信，探询该从机是否已完成其操作任务，仅在含有功能码9的报文发送后，本功能码才发送</td>
</tr>
<tr>
<td>0B</td>
<td>读取事件计数</td>
<td>可使主机发出单询问，并随即判定操作是否成功，尤其是该命令或其他应答产生通信错误时</td>
</tr>
<tr>
<td>0C</td>
<td>读取通讯事件记录</td>
<td>可是主机检索每台从机的ModBus事务处理通信事件记录。如果某项事务处理完成，记录会给出有关错误</td>
</tr>
<tr>
<td>0D</td>
<td>编程（184/384/484/584）</td>
<td>可使主机模拟编程器功能修改PC从机逻辑</td>
</tr>
<tr>
<td>0E</td>
<td>探询（184/384/484/584）</td>
<td>可使主机与正在执行任务的从机通信，定期控询该从机是否已完成其程序操作，仅在含有功能13的报文发送后，本功能码才得发送</td>
</tr>
<tr>
<td>0F</td>
<td>写多个线圈</td>
<td>可以写多个线圈—强置一串连续逻辑线圈的通断</td>
</tr>
<tr>
<td>10</td>
<td>写多个保持寄存器</td>
<td>写多个保持寄存器—把具体的二进制值装入一串连续的保持寄存器</td>
</tr>
<tr>
<td>11</td>
<td>报告从机标识</td>
<td>可使主机判断编址从机的类型及该从机运行指示灯的状态</td>
</tr>
<tr>
<td>12</td>
<td>（884和MICRO84）</td>
<td>可使主机模拟编程功能，修改PC状态逻辑</td>
</tr>
<tr>
<td>13</td>
<td>重置通信链路</td>
<td>发生非可修改错误后，是从机复位于已知状态，可重置顺序字节</td>
</tr>
<tr>
<td>14</td>
<td>读取通用参数（584L）</td>
<td>显示扩展存储文件中的数据信息</td>
</tr>
<tr>
<td>15</td>
<td>写入通用参数（584L）</td>
<td>把通用参数写入扩展存储文件</td>
</tr>
<tr>
<td>16~40</td>
<td>保留做扩展功能备用</td>
<td></td>
</tr>
<tr>
<td>41~48</td>
<td>保留以备用户功能所用</td>
<td>留作用户功能的扩展编码</td>
</tr>
<tr>
<td>49~77</td>
<td>非法功能</td>
<td></td>
</tr>
<tr>
<td>78~7F</td>
<td>保留</td>
<td>留作内部作用</td>
</tr>
<tr>
<td>80~FF</td>
<td>保留</td>
<td>用于异常应答</td>
</tr>
</tbody></table>
<p>常用功能码如下：</p>
<table>
<thead>
<tr>
<th>功能码</th>
<th>名称</th>
<th>功能</th>
<th>对应的地址类型</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>读线圈状态</td>
<td>读位（读N个bit）—读从机线圈寄存器，位操作</td>
<td>0x</td>
</tr>
<tr>
<td>02</td>
<td>读输入离散量</td>
<td>读位（读N个bit）—读离散输入寄存器，位操作</td>
<td>1x</td>
</tr>
<tr>
<td>03</td>
<td>读多个寄存器</td>
<td>读整型、字符型、状态字、浮点型（读N个words）—读保持寄存器，字节操作</td>
<td>4X</td>
</tr>
<tr>
<td>04</td>
<td>读输入寄存器</td>
<td>读整型、状态字、浮点型（读N个words）—读输入寄存器，字节操作</td>
<td>3x</td>
</tr>
<tr>
<td>05</td>
<td>写单个线圈</td>
<td>写位（写一个bit）—写线圈寄存器，位操作</td>
<td>0x</td>
</tr>
<tr>
<td>06</td>
<td>写单个保持寄存器</td>
<td>写整型、字符型、状态字、浮点型（写一个word）—写保持寄存器，字节操作</td>
<td>4x</td>
</tr>
<tr>
<td>0F</td>
<td>写多个线圈</td>
<td>写位（写n个bit）—强置一串连续逻辑线圈的通断</td>
<td>0x</td>
</tr>
<tr>
<td>10</td>
<td>写多个保持寄存器</td>
<td>写整形、字符型、状态字、浮点型（写n个word）—把具体的二进制值装入一串连续的保持寄存器</td>
<td>4x</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/pci/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/pci/" class="post-title-link" itemprop="url">PCI总线</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pci/" itemprop="url" rel="index"><span itemprop="name">pci</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PCI即Peripheral Component Interconnect，中文意思是“外围器件互联”，是由PCISIG (PCI Special Interest Group)推出的一种局部并行总线标准。PCI总线是由ISA(Industy Standard Architecture)总线发展而来的，是一种同步的独立于处理器的32位或64位局部总线。从结构上看，PCI是在CPU的供应商和原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，并实现上下之间的接口以协调数据的传送。广泛用于当前高档微机、工作站，以及便携式微机。主要用于连接显卡、网卡、声卡。</p>
<p>PCI总线是一种树型结构，并且独立于CPU总线，可以和CPU总线并行操作。PCI总线上可以挂接PCI设备和PCI桥，PCI总线上只允许有一个PCI主设备（同一时刻），其他的均为PCI 从设备，而且读写操作只能在主从设备之间进行，从设备之间的数据交换需要通过主设备中转。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">176</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
