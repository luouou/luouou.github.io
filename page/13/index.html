<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/module_make/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/module_make/" class="post-title-link" itemprop="url">make module</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>编译一个模块需要内核源码（已经编译过的）和当前模块的Makefile文件。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(info KERNELRELEASE: <span class="variable">$(KERNELRELEASE)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">KERNEL_DIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	obj-m += hello.o</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@find ./ \</span><br><span class="line">		\( -name &#x27;*.[oas]&#x27; -o -name &#x27;.*.cmd&#x27; -o -name &#x27;*.symvers&#x27;\</span><br><span class="line">		-o -name &#x27;.*.d&#x27; -o -name &#x27;.*.tmp&#x27; -o -name &#x27;*.mod.c&#x27; \</span><br><span class="line">		-o -name &#x27;*.symtypes&#x27; -o -name &#x27;modules.order&#x27; \</span><br><span class="line">		-o -name modules.builtin -o -name &#x27;.tmp_*.o.*&#x27; \</span><br><span class="line">		-o -name &#x27;*.gcno&#x27; -o -name tags -o -name &#x27;.tags*&#x27; \</span><br><span class="line">		 \) -type f -print | xargs rm -f</span><br><span class="line"></span><br><span class="line">	@find ./ \</span><br><span class="line">		\( -name .tmp_versions \) -type d -print | xargs rm -rf</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean all</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>先判断<code>KERNELRELEASE</code>环境变量是否为空，该变量的値在进入内核源码目录后，会设置为内核版本号。</li>
<li>执行<code>-C $(KERNEL_DIR)</code>选项，进入内核源码目录。</li>
<li>根据选项<code>M=$(PWD)</code>，编译器会回到模块当前目录，再次执行Makefile文件，此时<code>KERNELRELEASE</code>环境变量已经有値了，生成hello.o中间文件。</li>
<li>运行MODPOST程序，生成hello.mod.c文件。</li>
<li>最后链接生成hello.ko。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">KERNELRELEASE: </span><br><span class="line">make -C /lib/modules/4.10.0-38-generic/build M=/home/luo_u/CodeHub/dev/test modules</span><br><span class="line">make[1]: Entering directory &#x27;/usr/src/linux-headers-4.10.0-38-generic&#x27;</span><br><span class="line">KERNELRELEASE: 4.10.0-38-generic</span><br><span class="line">  CC [M]  /home/luo_u/CodeHub/dev/test/hello.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">KERNELRELEASE: 4.10.0-38-generic</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /home/luo_u/CodeHub/dev/test/hello.mod.o</span><br><span class="line">  LD [M]  /home/luo_u/CodeHub/dev/test/hello.ko</span><br><span class="line">make[1]: Leaving directory &#x27;/usr/src/linux-headers-4.10.0-38-generic&#x27;</span><br></pre></td></tr></table></figure>

<p>加载模块，后在/sys/module/hello/目录和/proc/modules文件就可以看到模块信息了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsmod | grep hello</span></span><br><span class="line">hello                  16384  0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/modules | grep hello</span></span><br><span class="line">hello 16384 0 - Live 0x0000000000000000 (OE)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /sys/module/hello/</span></span><br><span class="line">coresize  holders  initsize  initstate  notes  refcnt  sections  srcversion  taint  uevent</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/kernel_make/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/kernel_make/" class="post-title-link" itemprop="url">kernel make and menuconfig</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>指定交叉工具和平台。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CROSS_COMPILE=arm-none-linux-gnueabi- ARCH=arm menuconfig</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul>
<li>屏蔽编译信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &gt; /dev/null</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>make -j&lt;n&gt;</code>参数加速编译</p>
</li>
<li><p>指定编译某些模块</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make M=drivers/i2c/ modules</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 verbose 模式，将每一步执行的命令都打印出来，并重定向到一个文件中去，这样以后可以方便地查找模块之间的依赖关系。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make V=1 &gt; ~/bak.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 ccache 提高编译速度，使用 ccache时，需要更改源码树根目录下面的 Makefile 文件，在 CC 和 HOSTCC 变量的定义前添加 ccache。<a target="_blank" rel="noopener" href="http://ccache.samba.org/">ccache主页</a>。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC = ccache <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">HOSTCC = ccache gcc</span><br></pre></td></tr></table></figure>

<h2 id="编译文档"><a href="#编译文档" class="headerlink" title="编译文档"></a>编译文档</h2><p>使用下面的一些命令可以在 Documentation/DocBook/目录下，生成一些文档。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make htmldocs //生成 HTML 文件</span><br><span class="line">make pdfdocs  //生成 PDF 文件</span><br><span class="line">make psdocs   //生成 Postscript 文件</span><br><span class="line">make mandocs  //生成 Kernel API 手册</span><br><span class="line">make installmandocs //将 Kernel API 手册页安装到 man 程序能够找到的目录中</span><br></pre></td></tr></table></figure>

<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>1.缺少libncurses5-dev</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig requires the ncurses libraries.</span><br></pre></td></tr></table></figure>

<p>2.没有安装u-boot-tools</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkimage command not found – U-Boot images will not be built</span><br></pre></td></tr></table></figure>

<p>3.源文件编译生成的.o文件和模块目标文件xxx.o重名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module license &#x27;unspecified&#x27; taints kernel.</span><br><span class="line">Disabling lock debugging due to kernel taint</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/kernel_arch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/kernel_arch/" class="post-title-link" itemprop="url">Linux Kernel Architecture</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="linux系统结构"><a href="#linux系统结构" class="headerlink" title="linux系统结构"></a>linux系统结构</h2><img src="/images/kernel/kernel/linux_arch.jpeg" alt="Unix/Linux系统分层结构" style="zoom: 33%;" />

<p><img src="/images/kernel/kernel/linux-arch.webp" alt="Linux系统层次结构"></p>
<p>最上面是用户空间，这是用户应用程序执行的地方。用户空间之下是内核空间，GNU C Library （glibc）也位于这里，它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。</p>
<p>Linux 内核可以进一步划分成三层。最上面是系统调用接口。之下是内核代码，是与处理器体系结构无关的通用代码。最下面是依赖于特定处理器体系结构的代码，称为 BSP（Board Support Package）。</p>
<h2 id="内核架构"><a href="#内核架构" class="headerlink" title="内核架构"></a>内核架构</h2><p><img src="/images/kernel/kernel/kernel_struct.webp" alt="linux内核架构"></p>
<p>Linux内核的主要组件有：系统调用接口、进程调度、内存管理、虚拟文件系统、网络协议栈、进程间通信、设备驱动程序和硬件架构的相关代码。</p>
<p>LXR (Linux Cross Reference)是一个内核的源代码浏览工具，<a target="_blank" rel="noopener" href="http://lxr.linux.no/%E3%80%82">http://lxr.linux.no/。</a></p>
<p><img src="/images/kernel/kernel/linux_kernel_map.svg" alt="Linux kernel map"></p>
<p><a target="_blank" rel="noopener" href="https://makelinux.github.io/kernel/map/">https://makelinux.github.io/kernel/map/</a></p>
<h3 id="目录详解"><a href="#目录详解" class="headerlink" title="目录详解"></a>目录详解</h3><table>
<thead>
<tr>
<th align="left">目录 / 文件名</th>
<th align="left">源码功能简介</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/Documentation</td>
<td align="left">说明文档，对每个目录的具体作用进行说明。</td>
</tr>
<tr>
<td align="left">/arch</td>
<td align="left">不同 CPU 架构下的核心代码。其中的每一个子目录都代表 Linux 支持的 CPU 架构。</td>
</tr>
<tr>
<td align="left">/block</td>
<td align="left">块设备通用函数。</td>
</tr>
<tr>
<td align="left">/certs</td>
<td align="left">与证书相关。</td>
</tr>
<tr>
<td align="left">/crypto</td>
<td align="left">常见的加密算法的C 语言实现代码，譬如 crc32、md5、sha1 等。</td>
</tr>
<tr>
<td align="left">/drivers</td>
<td align="left">内核中所有设备的驱动程序，其中的每一个子目录对应一种设备驱动。</td>
</tr>
<tr>
<td align="left">/include</td>
<td align="left">内核编译通用的头文件。</td>
</tr>
<tr>
<td align="left">/init</td>
<td align="left">内核初始化的核心代码。</td>
</tr>
<tr>
<td align="left">/ipc</td>
<td align="left">内核中进程间的通信代码。</td>
</tr>
<tr>
<td align="left">/kernel</td>
<td align="left">内核的核心代码，此目录下实现了大多数 Linux 系统的内核函数。与处理器架构相关的内核代码在 /kernel/$ARCH/kernel。</td>
</tr>
<tr>
<td align="left">/lib</td>
<td align="left">内核共用的函数库，与处理器架构相关的库在 /kernel/$ARCH/lib。</td>
</tr>
<tr>
<td align="left">/mm</td>
<td align="left">内存管理代码，譬如页式存储管理内存的分配和释放等。与具体处理器架构相关的内存管理代码位于 /arch/$ARCH/mm 目录下。</td>
</tr>
<tr>
<td align="left">/net</td>
<td align="left">网络通信相关代码。</td>
</tr>
<tr>
<td align="left">/samples</td>
<td align="left">示例代码。</td>
</tr>
<tr>
<td align="left">/scripts</td>
<td align="left">用于内核配置的脚本文件，用于实现内核配置的图形界面。</td>
</tr>
<tr>
<td align="left">/security</td>
<td align="left">安全性相关的代码。</td>
</tr>
<tr>
<td align="left">/sound</td>
<td align="left">与音频有关的代码，包括与音频有关的驱动程序 [2]。</td>
</tr>
<tr>
<td align="left">/tools</td>
<td align="left">Linux 中的常用工具。</td>
</tr>
<tr>
<td align="left">/usr</td>
<td align="left">该目录中的代码为内核尚未完全启动时执行用户空间代码提供了支持。</td>
</tr>
<tr>
<td align="left">/virt</td>
<td align="left">此文件夹包含了虚拟化代码，它允许用户一次运行多个操作系统。</td>
</tr>
<tr>
<td align="left">COPYING</td>
<td align="left">许可和授权信息。</td>
</tr>
<tr>
<td align="left">CREDITS</td>
<td align="left">贡献者列表。</td>
</tr>
<tr>
<td align="left">Kbuild</td>
<td align="left">内核设定脚本，可以对内核中的变量进行设定。</td>
</tr>
<tr>
<td align="left">Kconfig</td>
<td align="left">配置哪些文件编译，那些文件不用编译 [4]。</td>
</tr>
<tr>
<td align="left">Makefile</td>
<td align="left">该文件将编译参数、编译所需的文件和必要的信息传给编译器。</td>
</tr>
</tbody></table>
<h2 id="drivers目录"><a href="#drivers目录" class="headerlink" title="drivers目录"></a>drivers目录</h2><p><strong>accessibility</strong>  这些驱动提供支持一些辅助设备。在Linux 3.9.4中，这个文件夹中只有一个驱动就是盲文设备驱动。</p>
<p><strong>acpi</strong>  高级配置和电源接口（ACPI : Advanced Configuration and Power Interface）驱动用来管理电源使用。</p>
<p><strong>amba</strong>  高级微控制器总线架构（AMBA : Advanced Microcontroller Bus Architecture）是与片上系统（SoC）的管理和互连的协议。SoC是一块包含许多或所有必要的计算机组件的芯片。这里的AMBA驱动让内核能够运行在这上面。</p>
<p><strong>ata</strong>  该目录包含PATA和SATA设备的驱动程序。串行ATA（SATA）是一种连接主机总线适配器到像硬盘那样的存储器的计算机总线接口。并行ATA（PATA）用于连接存储设备，如硬盘驱动器，软盘驱动器，光盘驱动器的标准。PATA就是我们所说的IDE。</p>
<p><strong>atm</strong>  异步通信模式(ATM : Asynchronous Transfer Mode)是一种通信标准。这里有各种接到PCI桥的驱动(他们连接到PCI总线)和以太网控制器(控制以太网通信的集成电路芯片)。</p>
<p><strong>auxdisplay</strong>  这个文件夹提供了三个驱动。LCD 帧缓存（framebuffer）驱动、LCD控制器驱动和一个LCD驱动。这些驱动用于管理液晶显示器 —— 液晶显示器会在按压时显示波纹。注意:按压会损害屏幕,所以请不要用力戳LCD显示屏。</p>
<p><strong>base</strong>  这是个重要的目录包含了固件、系统总线、虚拟化能力等基本的驱动。</p>
<p><strong>bcma</strong>  这些驱动用于使用基于AMBA协议的总线。AMBA是由博通公司开发。</p>
<p><strong>block</strong>  这些驱动提供对块设备的支持，像软驱、SCSI磁带、TCP网络块设备等等。</p>
<p><strong>bluetooth</strong>  蓝牙是一种安全的无线个人区域网络标准(PANs)。蓝牙驱动就在这个文件夹，它允许系统使用各种蓝牙设备。例如，一个蓝牙鼠标不用电缆，并且计算机有一个电子狗(小型USB接收器)。Linux系统必须能够知道进入电子狗的信号，否则蓝牙设备无法工作。</p>
<p><strong>bus</strong>  这个目录包含了三个驱动。一个转换ocp接口协议到scp协议。一个是设备间的互联驱动，第三个是用于处理互联中的错误处理。</p>
<p><strong>cdrom</strong>  这个目录包含两个驱动。一个是cd-rom，包括DVD和CD的读写。第二个是gd-rom(只读GB光盘)，GD光盘是1.2GB容量的光盘，这像一个更大的CD或者更小的DVD。GD通常用于世嘉游戏机中。</p>
<p><strong>char</strong>  字符设备驱动就在这里。字符设备每次传输数据传输一个字符。这个文件夹里的驱动包括打印机、PS3闪存驱动、东芝SMM驱动和随机数发生器驱动等。</p>
<p><strong>clk</strong>  这些驱动用于系统时钟。</p>
<p><strong>clocksource</strong>  这些驱动用于作为定时器的时钟。</p>
<p><strong>connector</strong>  这些驱动使内核知道当进程fork并使用proc连接器更改UID(用户ID)、GID(组ID)和SID(会话ID)。内核需要知道什么时候进程fork(CPU中运行多个任务)并执行。否则,内核可能会低效管理资源。</p>
<p><strong>cpufreq</strong>  这些驱动改变CPU的电源能耗。</p>
<p><strong>cpuidle</strong>  这些驱动用来管理空闲的CPU。一些系统使用多个CPU，其中一个驱动可以让这些CPU负载相当。</p>
<p><strong>crypto</strong>  这些驱动提供加密功能。</p>
<p><strong>dca</strong>  直接缓存访问（DCA ： Direct Cache Access）驱动允许内核访问CPU缓存。CPU缓存就像CPU内置的RAM。CPU缓存的速度比RAM更快。然而,CPU缓存的容量比RAM小得多。CPU在这个缓存系统上存储了最重要的和执行的代码。</p>
<p><strong>devfreq</strong>  这个驱动程序提供了一个通用的动态电压和频率调整(DVFS ： Generic Dynamic Voltage and Frequency Scaling)框架，可以根据需要改变CPU频率来节约能源。这就是所谓的CPU节能。</p>
<p><strong>dio</strong>  数字输入/输出（DIO ：Digital Input/Output）总线驱动允许内核可以使用DIO总线。</p>
<p><strong>dma</strong>  直接内存访问(DMA)驱动允许设备无需CPU直接访问内存。这减少了CPU的负载。</p>
<p><strong>edac</strong>  错误检测和校正（ Error Detection And Correction）驱动帮助减少和纠正错误。</p>
<p><strong>eisa</strong>  扩展工业标准结构总线（Extended Industry Standard Architecture）驱动提供内核对EISA总线的支持。</p>
<p><strong>extcon</strong>  外部连接器（EXTernal CONnectors）驱动用于检测设备插入时的变化。例如，extcon会检测用户是否插入了USB驱动器。</p>
<p><strong>firewire</strong>  这些驱动用于控制苹果制造的类似于USB的火线设备。</p>
<p><strong>firmware</strong>  这些驱动用于和像BIOS(计算机的基本输入输出系统固件)这样的设备的固件通信。BIOS用于启动操作系统和控制硬件与设备的固件。一些BIOS允许用户超频CPU。超频是使CPU运行在一个更快的速度。CPU速度以MHz(百万赫兹)或GHz衡量。一个3.7 GHz的CPU的的速度明显快于一个700Mhz的处理器。</p>
<p><strong>gpio</strong>  通用输入/输出(GPIO ：General Purpose Input/Output)是可由用户控制行为的芯片的管脚。这里的驱动就是控制GPIO。</p>
<p><strong>gpu</strong>  这些驱动控制VGA、GPU和直接渲染管理(DRM ：Direct Rendering Manager )。VGA是640*480的模拟计算机显示器或是简化的分辨率标准。GPU是图形处理器。DRM是一个Unix渲染系统。</p>
<p><strong>hid</strong>  这驱动用于对USB人机界面设备的支持。</p>
<p><strong>hsi</strong>  这个驱动用于内核访问像Nokia N900这样的蜂窝式调制解调器。</p>
<p><strong>hv</strong>  这个驱动用于提供Linux中的键值对(KVP ：Key Value Pair)功能。</p>
<p><strong>hwmon</strong>  硬件监控驱动用于内核读取硬件传感器上的信息。比如，CPU上有个温度传感器。那么内核就可以追踪温度的变化并相应地调节风扇的速度。</p>
<p><strong>hwspinlock</strong>  硬件转锁驱动允许系统同时使用两个或者更多的处理器，或使用一个处理器上的两个或更多的核心。</p>
<p><strong>i2c</strong>  I2C驱动可以使计算机用I2C协议处理主板上的低速外设。系统管理总线(SMBus ：System Management Bus)驱动管理SMBus,这是一种用于轻量级通信的two-wire总线。</p>
<p><strong>ide</strong>  这些驱动用来处理像CDROM和硬盘这些PATA/IDE设备。</p>
<p><strong>idle</strong>  这个驱动用来管理Intel处理器的空闲功能。</p>
<p><strong>iio</strong>  工业I/O核心驱动程序用来处理数模转换器或模数转换器。</p>
<p><strong>infiniband</strong>  Infiniband是在企业数据中心和一些超级计算机中使用的一种高性能的端口。这个目录中的驱动用来支持Infiniband硬件。</p>
<p><strong>input</strong>  这里包含了很多驱动，这些驱动都用于输入处理，包括游戏杆、鼠标、键盘、游戏端口（旧式的游戏杆接口）、遥控器、触控、耳麦按钮和许多其他的驱动。如今的操纵杆使用USB端口，但是在上世纪80、90年代，操纵杆是插在游戏端口的。</p>
<p><strong>iommu</strong>  输入/输出内存管理单元(IOMMU ：Input/Output Memory Management Unit)驱动用来管理内存管理单元中的IOMMU。IOMMU连接DMA IO总线到内存上。IOMMU是设备在没有CPU帮助下直接访问内存的桥梁。这有助于减少处理器的负载。</p>
<p><strong>ipack</strong>  Ipack代表的是IndustryPack。 这个驱动是一个虚拟总线,允许在载体和夹板之间操作。</p>
<p><strong>irqchip</strong>  这些驱动程序允许硬件的中断请求(IRQ)发送到处理器，暂时挂起一个正在运行的程序而去运行一个特殊的程序（称为一个中断处理程序）。</p>
<p><strong>isdn</strong>  这些驱动用于支持综合业务数字网(ISDN)，这是用于同步数字传输语音、视频、数据和其他网络服务使用传统电话网络的电路的通信标准。</p>
<p><strong>leds</strong>  用于LED的驱动。</p>
<p><strong>lguest</strong>  lguest用于管理客户机系统的中断。中断是CPU被重要任务打断的硬件或软件信号。CPU接着给硬件或软件一些处理资源。</p>
<p><strong>macintosh</strong>  苹果设备的驱动在这个文件夹里。</p>
<p><strong>mailbox</strong>  这个文件夹(pl320-pci)中的驱动用于管理邮箱系统的连接。</p>
<p><strong>md</strong>  多设备驱动用于支持磁盘阵列，一种多块硬盘间共享或复制数据的系统。</p>
<p><strong>media</strong>  媒体驱动提供了对收音机、调谐器、视频捕捉卡、DVB标准的数字电视等等的支持。驱动还提供了对不同通过USB或火线端口插入的多媒体设备的支持。</p>
<p><strong>memory</strong>  支持内存的重要驱动。</p>
<p><strong>memstick</strong>  这个驱动用于支持Sony记忆棒。</p>
<p><strong>message</strong>  这些驱动用于运行LSI Fusion MPT(一种消息传递技术)固件的LSI PCI芯片/适配器。LSI大规模集成，这代表每片芯片上集成了几万晶体管、</p>
<p><strong>mfd</strong>  多用途设备(MFD)驱动提供了对可以提供诸如电子邮件、传真、复印机、扫描仪、打印机功能的多用途设备的支持。这里的驱动还给MFD设备提供了一个通用多媒体通信端口(MCP)层。</p>
<p><strong>misc</strong>  这个目录包含了不适合在其他目录的各种驱动。就像光线传感器驱动。</p>
<p><strong>mmc</strong>  MMC卡驱动用于处理用于MMC标准的闪存卡。</p>
<p><strong>mtd</strong>  内存技术设备(MTD ：Memory technology devices)驱动程序用于Linux和闪存的交互，这就就像一层闪存转换层。其他块设备和字符设备的驱动程序不会以闪存设备的操作方式来做映射。尽管USB记忆卡和SD卡是闪存设备，但它们不使用这个驱动，因为他们隐藏在系统的块设备接口后。这个驱动用于新型闪存设备的通用闪存驱动器驱动。</p>
<p><strong>net</strong>  网络驱动提供像AppleTalk、TCP和其他的网络协议。这些驱动也提供对调制解调器、USB 2.0的网络设备、和射频设备的支持。</p>
<p><strong>nfc</strong>  这个驱动是德州仪器的共享传输层之间的接口和NCI核心。</p>
<p><strong>ntb</strong>  不透明的桥接驱动提供了在PCIe系统的不透明桥接。PCIe是一种高速扩展总线标准。</p>
<p><strong>nubus</strong>  NuBus是一种32位并行计算总线。用于支持苹果设备。</p>
<p><strong>of</strong>  此驱动程序提供设备树中创建、访问和解释程序的OF助手。</p>
<p><strong>oprofile</strong>  这个驱动用于从驱动到用户空间进程(运行在用户态下的应用)评测整个系统。这帮助开发人员找到性能问题—-性能分析机制-是用于 Linux 的若干种评测和性能监控工具中的一种</p>
<p><strong>parisc</strong>  这些驱动用于HP生产的PA-RISC架构设备。PA-RISC是一种特殊指令集的处理器。</p>
<p><strong>parport</strong>  并口驱动提供了Linux下的并口支持。</p>
<p><strong>pci</strong>  这些驱动提供了PCI总线服务。</p>
<p><strong>pcmcia</strong>  这些是笔记本的pc卡驱动</p>
<p><strong>pinctrl</strong>  这些驱动用来处理引脚控制设备。引脚控制器可以禁用或启用I/O设备。</p>
<p><strong>platform</strong> 这个文件夹包含了不同的计算机平台的驱动像Acer、Dell、Toshiba、IBM、Intel、Chrombooks等等。</p>
<p><strong>pnp</strong>  即插即用驱动允许用户在插入一个像USB的设备后可以立即使用而不必手动配置设备。</p>
<p><strong>power</strong>  电源驱动使内核可以测量电池电量，检测充电器和进行电源管理。</p>
<p><strong>pps</strong>  Pulse-Per-Second驱动用来控制电流脉冲速率。这用于计时。</p>
<p><strong>ps3</strong>  这是Sony的游戏控制台驱动- PlayStation3。</p>
<p><strong>ptp</strong>  图片传输协议(PTP)驱动支持一种从数码相机中传输图片的协议。</p>
<p><strong>pwm</strong>  脉宽调制(PWM)驱动用于控制设备的电流脉冲。主要用于控制像CPU风扇。</p>
<p><strong>rapidio</strong>  RapidIO驱动用于管理RapidIO架构，它是一种高性能分组交换，用于电路板上交互芯片的交互技术，也用于互相使用底板的电路板。</p>
<p><strong>regulator</strong>  校准驱动用于校准电流、温度、或其他可能系统存在的校准硬件。—-用于控制系统中某些设备的电压电流供应</p>
<p><strong>remoteproc</strong>  这些驱动用来管理远程处理器。</p>
<p><strong>rpmsg</strong>  这个驱动用来控制支持大量驱动的远程处理器通讯总线(rpmsg)。这些总线提供消息传递设施,促进客户端驱动程序编写自己的连接协议消息。—-该基础架构允许主处理器上的 Linux 操作系统管理远程处理器上远程软件环境的生命周期和通信-用于在 AMP 环境中的操作系统之间实现 IPC 的 rpmsg 组件和 API</p>
<p><strong>rtc</strong>  实时时钟(RTC)驱动使内核可以读取时钟。</p>
<p><strong>s390</strong>  用于31/32位的大型机架构的驱动。</p>
<p><strong>sbus</strong>  用于管理基于SPARC的总线驱动。</p>
<p><strong>scsi</strong>  允许内核使用SCSI标准外围设备。例如,Linux将在与SCSI硬件传输数据时使用SCSI驱动。</p>
<p><strong>sfi</strong> 简单固件接口(SFI)驱动允许固件发送信息表给操作系统。这些表的数据称为SFI表。</p>
<p><strong>sh</strong>  该驱动用于支持SuperHway总线。</p>
<p><strong>sn</strong>  该驱动用于支持IOC3串口。</p>
<p><strong>spi</strong>  这些驱动处理串行设备接口总线(SPI)，它是一个在在全双工下运行的同步串行数据链路标准,。全双工是指两个设备可以同一时间同时发送和接收信息。双工指的是双向通信。设备在主/从模式下通信(取决于设备配置)。</p>
<p><strong>ssb</strong>  ssb(Sonics Silicon Backplane)驱动提供对在不同芯片和嵌入式设备上使用的迷你总线的支持。</p>
<p><strong>staging</strong>  该目录含有许多子目录。这里所有的驱动还需要在加入主内核前经过更多的开发工作。</p>
<p><strong>target</strong>  SCSI设备驱动</p>
<p><strong>tc</strong>  这些驱动用于TURBOchannel，TURBOchannel是数字设备公司开发的32位开放总线。这主要用于DEC工作站。</p>
<p><strong>thermal</strong>  thermal驱动使CPU保持较低温度。—Linux温控框架</p>
<p><strong>tty</strong>  tty驱动用于管理物理终端连接。</p>
<p><strong>uio</strong>  该驱动允许用户编译运行在用户空间而不是内核空间的驱动。这使用户驱动不会导致内核崩溃。—–运行在用户空间的IO技术</p>
<p><strong>usb</strong>  USB设备允许内核使用USB端口。闪存驱动和记忆卡已经包含了固件和控制器,所以这些驱动程序允许内核使用USB接口和与USB设备。</p>
<p><strong>uwb</strong>  Ultra-WideBand驱动用来管理短距离，高带宽通信的超低功耗的射频设备</p>
<p><strong>vfio</strong>  允许设备访问用户空间的VFIO驱动。用户态驱动框架。</p>
<p><strong>vhost</strong>  这是用于宿主内核中的virtio服务器驱动。用于虚拟化中。</p>
<p><strong>video</strong>  这是用来管理显卡和监视器的视频驱动。</p>
<p><strong>virt</strong>  这些驱动用来虚拟化。</p>
<p><strong>virtio</strong>  这个驱动用来在虚拟PCI设备上使用virtio设备。用于虚拟化中。</p>
<p><strong>vlynq</strong>  这个驱动控制着由德州仪器开发的专有接口。这些都是宽带产品，像WLAN和调制解调器，VOIP处理器，音频和数字媒体信号处理芯片。</p>
<p><strong>vme</strong>  WMEbus最初是为摩托罗拉68000系列处理器开发的总线标准</p>
<p><strong>w1</strong>  这些驱动用来控制one-wire总线。</p>
<p><strong>watchdog</strong>  该驱动管理看门狗定时器，这是一个可以用来检测和恢复异常的定时器。</p>
<p><strong>xen</strong>  该驱动是Xen管理程序系统。这是个允许用户运行多个操作系统在一台计算机的软件或硬件。这意味着xen的代码将允许用户在同一时间的一台计算机上运行两个或更多的Linux系统。用户也可以在Linux上运行Windows、Solaris、FreeBSD、或其他操作系统。</p>
<p><strong>zorro</strong>  该驱动提供Zorro Amiga总线支持。</p>
<p>Documentation/CodingStyle 文件描 述 了 Linux 内 核 对 编 码 风 格 的 要 求，内 核 下 的scripts/checkpatch.pl 脚本可以检查代码风格。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/lcd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/lcd/" class="post-title-link" itemprop="url">液晶显示器原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a>LCD</h3><p>液晶（Liquid Crystal）是一种介于液态与结晶态之间的一种物质状态的高分子材料。液晶具有双折射性，使得能对偏振光选择性透过。</p>
<p>LCD是英文Liquid Crystal Display 的简称，指的是液晶显示屏。主要有TFT、UFB、TFD、STN等几种类型。其构造包括塑料球、玻璃球、边框胶、玻璃基板、上偏光片、定向层、液晶、导电ITO图案、导通点、IPO电极和下偏光片。</p>
<p><img src="/images/lcd/LCD-struct.jpeg" alt="TN"></p>
<p>两块偏光板相互垂直时光线就完全无法通过，液晶显示器就是在上下两片栅栏之间互垂直的偏光板之间充满液晶，利用电场控制液晶分子产生扭曲，从而对穿越其中的光线进行有规则的折射，来改变光的行进方向，如此一来，不同的电场大小，就会形成不同颜色。</p>
<p>因为液晶材料本身并不发光，所以在显示屏两边都设有作为光源的灯管，而在液晶显示屏背面有一块背光板和反光膜，背光板是由荧光物质组成的可以发射光线，其作用主要是提供均匀的背景光源。</p>
<p>液晶显示的原理基于液晶的透光率随其所施电压大小而变化的特性。当光通过下偏振片后，变成线性偏振光，偏振方向与偏振片振动方向一致，与上下玻璃基板上面液晶分子排列顺序一致。当光通过液晶层时，由于受液晶折射，线性偏振光被分解为两束光。又由于这两束光传播速度不同（相位相同），因而当两束光合成后，必然使振光的振动方向发生变化。通过液晶层的光，则被逐渐扭曲。当光达到上偏振片时，其光轴振动方向被扭曲了90度，且与上偏振片的振动方向保持一致。这样，光线通过上偏振片形成亮场。加上电压以后，液晶在电场作用下取向，扭曲消失。这时，通过下偏振片的线性偏振光，在液晶层不再旋转，无法通过上偏振片而形成暗场。可见液晶本身不发光，在外光源的调制下，才能显示，在整个显示过程中，液晶起到一个电压控制的光阀作用。</p>
<p>LCD依据驱动方式可分为静态驱动、简单矩阵驱动以及主动<br>矩阵驱动 3 种。其中简单矩阵型又可再细分扭转向列型(TN)和超扭转式向列型(STN)两种，而主动矩阵型则以薄膜式晶体管型(TFT)为主流。</p>
<p>NW(Normally white)是指当液晶面板不施加电压时，面板是亮的画面。另外一种， 液晶面板不施加电压时，面板无法透光, 看起来是黑色的，就称之为NB(Normally black)。</p>
<p><strong>可视角度</strong>指的是使用者能从不一样的方位清晰地看见荧幕上所有显示内容的角度。液晶显示器的可视角度左右对称，而上下则不一定对称。当背光源的入射光通过偏光板、液晶及取向膜后，输出光便具备了特定的方向特性。假如从一个非常斜的角度观看一个全白的画面，我们可能会看到黑色或是色彩失真。一般来说，上下角度要小于或等于左右角度。现在有些厂商就开发出各种广视角技术，试图改善液晶显示器的视角特性，如：IPS(In Plane Switching)、MVA(Multidomain Vertical Alignment)、TN+FILM。</p>
<h3 id="TFT"><a href="#TFT" class="headerlink" title="TFT"></a>TFT</h3><h2 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h2><p>OLED是Organic Light-Emitting Diode 的简称，中文名是有机发光二极管。</p>
<p>不同于LCD需要通过背光板照射才能显示，OLED是自发光。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/mipi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/mipi/" class="post-title-link" itemprop="url">mipi接口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:56:37" itemprop="dateModified" datetime="2022-06-08T17:56:37+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MIPI (Mobile Industry Processor Interface) 是2003年由ARM, Nokia, ST ,TI等公司成立的一个联盟，目的是把手机内部的接口如摄像头、显示屏接口、射频/基带接口等标准化，从而减少手机设计的复杂程度和增加设计灵活性。</p>
<p>MIPI联盟下面有不同的WorkGroup，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI、显示接口DSI、射频接口DigRF、麦克风 /喇叭接口SLIMbus等。统一接口标准的好处是手机厂商根据需要可以从市面上灵活选择不同的芯片和模组，更改设计和功能时更加快捷方便。下图是按照 MIPI的规划下一代智能手机的内部架构。</p>
<p><img src="/images/mipi/MIPI-Protocol-865x1024.png" alt="img"></p>
<h2 id="MIPI规范"><a href="#MIPI规范" class="headerlink" title="MIPI规范"></a>MIPI规范</h2><p>已经完成和正在计划中的规范如下:<br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MIPI#cite_note-Working_Groups:_Overview-1">https://zh.wikipedia.org/wiki/MIPI#cite_note-Working_Groups:_Overview-1</a></p>
<table>
<thead>
<tr>
<th><strong>工作组</strong></th>
<th><strong>规范名称</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Camera工作组</td>
<td>MIPI Camera Serial Interface 2 (MIPI CSI-2) v2.0 (March 2017)MIPI Camera Serial Interface 3 (MIPI CSI-3) v1.1 (March 2014)MIPI Camera Command Set (MIPI CCS) v1.0 (October 2017)</td>
</tr>
<tr>
<td>Device Descriptor Block工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>DigRF工作组</td>
<td>DigRF Baseband/RF Digital Interface Specification v4 (Feb. 2014)</td>
</tr>
<tr>
<td>Display工作组</td>
<td>DBI-2DPI-2DSI-2 v1.0 (January 2016)DCS</td>
</tr>
<tr>
<td>高速同步接口工作组</td>
<td>HSI 1.0</td>
</tr>
<tr>
<td>接口管理框架工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>低速多点连接工作组</td>
<td>SLIMbus v2.0 (August 2015)SoundWire v1.1 (August 2016)</td>
</tr>
<tr>
<td>NAND软件工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>物理层工作组</td>
<td>C-PHY v1.2 (March 2017)D-PHY v2.1 (March 2017)M-PHY v4.1 (March 2017)</td>
</tr>
<tr>
<td>软件工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>系统电源管理工作组</td>
<td>SPMI v2.0 (August 2012)</td>
</tr>
<tr>
<td>检测与调试工作组</td>
<td>暂无</td>
</tr>
<tr>
<td>统一协议工作组</td>
<td>UniPro 1 point-to-point v1.61 (October 2015)PIE</td>
</tr>
</tbody></table>
<h3 id="DSI-CSI"><a href="#DSI-CSI" class="headerlink" title="DSI/CSI"></a>DSI/CSI</h3><p>MIPI是一个比较新的标准，其规范也在不断修改和改进，目前比较成熟的接口应用有DSI(显示接口)和CSI（摄像头接口）。CSI/DSI分别是指其承载的是针对Camera或Display应用，都有复杂的协议结构。以DSI为例，其协议层结构如下：</p>
<p><img src="/images/mipi/MIPI-DSI.png" alt="img"></p>
<p>CSI/DSI的物理层（Phy Layer）由专门的WorkGroup负责制定，其目前的标准是D-PHY。D-PHY采用1对源同步的差分时钟和1～4对差分数据线来进行数据传输。数据传输采用DDR方式，即在时钟的上下边沿都有数据传输。</p>
<p>D-PHY的物理层支持HS(High Speed)和LP(Low Power)两种工作模式。HS模式下采用低压差分信号，功耗较大，但是可以传输很高的数据速率（数据速率为80M～1Gbps）； LP模式下采用单端信号，数据速率很低（&lt;10Mbps），但是相应的功耗也很低。两种模式的结合保证了MIPI总线在需要传输大量数据（如图像） 时可以高速传输，而在不需要大数据量传输时又能够减少功耗。</p>
<p><img src="/images/mipi/MIPI-DPHY.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/100476927">https://zhuanlan.zhihu.com/p/100476927</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/sensor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/sensor/" class="post-title-link" itemprop="url">sensor</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:55:37" itemprop="dateModified" datetime="2022-06-08T17:55:37+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Sensor 将从 lens 上传导过来的光线转换为电信号，再经过内部AD转换为数字信号。每个pixel像素点只能感受R、G、B中的一种，因此每个像素点中存放的数据是单色光，像素表示的就是有多少个感光点，每个感光点只能感应一种光，这些最原始的感光数据我们称为RAW Data。Raw Data数据要经过ISP的处理才能还原出三原色，也就是说如果一个像素点感应为R值，那么ISP会根据该感光点周围的G、B的值，通过插值和特效处理等，计算出该R点的G、B值，这样该点的RGB就被还原了。目前常用的sensor有两种，一种是CCD（电荷耦合）；一种是CMOS（金属氧化物导体）。</p>
<ul>
<li>CCD（Charge Coupled Device），电荷耦合器件传感器：使用一种高感光度的半导体材料制成，能把光线转变成电荷，通过模数转换器芯片转换成电信号。CCD由许多独立的感光单位组成，通常以百万像素为单位。当CCD表面受到光照时，每个感光单位都会将电荷反映在组件上，所有的感光单位产生的信号加在一起，就构成了一幅完整的图像。CCD传感器以日本厂商为主导，全球市场上有90%被日本厂商垄断，索尼、松下、夏普是龙头。</li>
<li>CMOS（Complementary Metal-Oxide Semiconductor），互补性氧化金属半导体：主要是利用硅和锗做成的半导体，使其在CMOS上共存着带N(-)和P(+)级的半导体，这两个互补效应所产生的电流可以被处理芯片记录并解读成影像。CMOS传感器主要以美国、韩国和中国台湾为主导，主要生产厂家是美国的OmnVison、Agilent、Micron，中国台湾的锐像、原相、泰视等，韩国的三星、现代。</li>
</ul>
<h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>ISP 是图像信号处理器（Image Sensor Processor）。一般用来处理Image Sensor（图像传感器）的输出数据，如做AE（自动曝光）、AGC（自动增益控制）、AWB（自动白平衡）、色彩校正、Lens Shading、Gamma 校正、祛除坏点、Auto Black Level、Auto White Level 等等功能的处理。</p>
<h3 id="AE"><a href="#AE" class="headerlink" title="AE"></a>AE</h3><p>自动曝光（Auto Exposure），根据外界光线的强弱自动调整曝光量和增益，防止曝光过度或者不足。AE 算法的主要调控对象一般是光圈、sensor增益（包含模拟增益和数字增益）、ISP数字增益这三个参数。</p>
<p>影响曝光的因素有曝光时间；光圈大小；Sensor的ISO感光度。</p>
<p>帧曝光时间Ft和帧率f的关系为：f = 1 / Ft，曝光时间的计算方法由sensor厂商提供。</p>
<p>EV曝光值（exposure value），摄影技术中定义的曝光值参数，代表能够给出同样曝光的所有相机光圈组合。它的定义是：$EV = \log(N^2 \div t)$<br>其中N是光圈的f-stop值；t是曝光时间，单位为秒。</p>
<p>EV0 对应于ISO100，曝光时间为1秒，光圈为f/1.0，以及与之等效的所有曝光组合，这些组合可以使18%的中性灰卡在所处光照条件下获得合适的曝光。因此曝光值主要体现了拍摄场景的亮度，同时在一定程度上也能反映相机的灵敏度。</p>
<p>曝光值每增加1称为增加一挡曝光，也就是将曝光量减半，比如将曝光时间或光圈面积减半，因此可以从EV0出发，按照光圈、快门加倍或减半的方式推导出其余的曝光档位，一般常用的档位在-6~20之间。</p>
<p>如果已知使画面正确曝光的EV值，则可以在下表中选择一个合适的曝光时间+光圈组合。举例来说，假设已知某拍摄场景正确曝光需要EV2，在固定ISO100的前提下，光圈和快门组合只能在（1s,f/2），（1/2s,f/1.4），（1/4s,f/1）这三个方案中选择一个。</p>
<p><img src="/images/sensor/v2-c02e83e125e4c8ef22e1ed881274f0a0_b.jpg" alt="img"></p>
<p>下表给出了EV0~EV20的典型场景。<br><img src="/images/sensor/v2-6e533fff18f0d918e10799c77da24350_b.jpg" alt="img"></p>
<p>下表给出了更完整的EV数据，同时包含了ISO，光圈和快门值<br><img src="/images/sensor/v2-fdcf59270dee877d6e1b9d79bf9c625f_b.jpg" alt="img"></p>
<p>光圈、快门、增益都可以影响画面亮度，但是这三者在效能上并不是完全等价的。摄影领域常用一个曝光三角形来形象地阐释三者之间的关系。<br><img src="/images/sensor/v2-af09e43949d8c5d8dc36214597209286_b.jpg" alt="img"></p>
<p>光圈（aperture）的副作用主要是影响景深。快门的副作用主要是影响运动模糊。一般而言，当曝光时间大于15ms时，画面中速度大于40km/h的车辆就会开始变模糊。当曝光时间大于30ms时，画面中走动的人就会变模糊。因此拍摄对象的预期移动速度基本上决定了曝光时间的上限。增益的副作用主要表现为画面噪声，尤其是数字增益会引入较大的噪声，显著降低图像质量。<br><img src="/images/sensor/v2-ed7c2425f86f43612ef449e0bff2ce4a_b.jpg" alt="img"></p>
<h3 id="AWB"><a href="#AWB" class="headerlink" title="AWB"></a>AWB</h3><p>色温随可见光的光谱成分变化而变化，在低色温光源下，白色物体偏红，在高色温光源下，白色物体偏蓝。人眼可根据大脑的记忆判断，识别物体的真实颜色，AWB（自动白平衡调整Auto White Balance ） 算法的功能是降低外界光源对物体真实颜色的影响，使得我们采集的颜色信息转变为在理想日光光源下的无偏色信息。要求在不同色温环境下，照白色的物体，屏幕中的图像应也是白色的。</p>
<ul>
<li><p>色温的定义：将黑体从绝对零度开始加温，当温度升高到一定程度时候，黑体便辐射出可见光，其光谱成份以及给人的感觉也会着温度的不断升高发生相应的变化。于是，就把黑体辐射一定色光的温度定为发射相同色光光源的色温。</p>
</li>
<li><p>白平衡：在不同色温的光源下，白色在传感器中的响应会偏蓝或偏红。白平衡算法通过调整 R, G, B 三个颜色通道的强度，使白色真实呈现。</p>
</li>
</ul>
<h3 id="3DNR"><a href="#3DNR" class="headerlink" title="3DNR"></a>3DNR</h3><p>2D降噪：只在2维空间域上进行降噪处理。对一个像素将其与周围像素平均，平均后噪声降低，但缺点是会造成画面模糊，特别是物体边缘部分。因此对这种算法的改进主要是进行边缘检测，边缘部分的像素不用来进行模糊。</p>
<p>3D降噪即3D DNR（3D Digital Noise Reducer），通过对比相邻的几帧图像，将图像信号中不重叠的噪波自动滤出。目前比较普遍的是进行Y/C分离，即从视频信号中将亮度信号（Y）和颜色信号（C）分离，然后对Y信号，C信号进行3维数字降噪。3D降噪增添了时域处理，因此变为3维。和2D降噪的不同在于，2D降噪只考虑一帧图像，而3D降噪进一步考虑帧与帧之间的时域关系，对每个像素进行时域上的平均，故计算量大，耗时更长。</p>
<h3 id="BLC"><a href="#BLC" class="headerlink" title="BLC"></a>BLC</h3><p>BLC（Black Level Correction）/ Black Level Compensate (OBC) ：黑电平校正。黑电平是在没有外界光线输入时，理想情况下像素值应该是0，但是实际中因为sensor暗电流作用仍会输出的亮度值。ISP 需要减去这个亮度值（这一个值会受到AWBGain，CCM，Gamma的影响）。</p>
<h3 id="LSC"><a href="#LSC" class="headerlink" title="LSC"></a>LSC</h3><p>LSC（Lens Shading Correction）/Color Shading ：阴影校正。Lens Shading是由于镜片从边缘到中心对入射光线的反射程度不同，镜头中心接收的光强大，边缘接收的光强较少， 造成图像从中心到边缘亮度逐渐变暗。Color Shading是由于Lens从中心到边缘，其R、G、B变暗的速率不一样，总体表现就是Gb/Gr像素值差异较大，两个像素之间有细微纹理。</p>
<h3 id="CCM"><a href="#CCM" class="headerlink" title="CCM"></a>CCM</h3><p>CCM（Color Correction Matrix/ DSC color calibration）：颜色校正矩阵。sensor 对光谱的响应在 RGB 各分量上与人眼对光谱的响应通常是有偏差的，拍摄color checker24色板，将相机拍摄图片值与色板标准值之间进行对比，得出一组能将拍摄值校正到最接近标准值的3x3矩阵。通常通过一个色彩校正矩阵对所有相机拍摄的图片进行颜色校正，使图像与人眼视觉在色彩上保持一致。</p>
<p><img src="/images/sensor/image-20200221200943546.png" alt="image-20200221200943546"><br>m<del>RR</del> + m<del>RG</del> + m<del>RB</del> = 256<br>m<del>GR</del> + m<del>GG</del> + m<del>GB</del> = 256<br>m<del>BR</del> + m<del>BG</del> + m<del>BB</del> = 256</p>
<p>（2）DPC/BPD（Defect Pixel Correction/Bad Pixel Detect）：坏点校正/坏点检测。相机中成像坏点一般是白色或者黑色的点，和周围像素点的差异明显。</p>
<p>（3）FPN（Fix Pattern Noise）：固定模式噪声。由于CMOS每个感光二极体旁都搭配一个ADC 放大器，如果以百万像素计，那么就需要百万个以上的 ADC 放大器，但是每个像素结构中的光电二极管的尺寸、掺杂浓度、生产过程中的沾污以及MOS场效应管的参数的偏差等都会造成像素输出信号的变化。对于给定的单个像素它是固定的。通常消除固定模式噪声采用“双采样降噪”方法，这是CMOS 感光器件特有的一种降噪方式。在光线较暗的环境下使用时，画面会有明显的噪声，这时通过对景物进行两次不同曝光率和敏感度的采样，然后将两次采样的结果进行综合处理，就可以有效解决低照度下的图像噪声问题。</p>
<p>（5）Flare offset：光学上称Flare也叫stray light,耀斑补偿。镜片的表面反射或镜筒、反光镜组的内面所引起的反射光，到达底面后造成画面整体或一部份产生了雾蒙，降低了图像的鲜锐度。镜片的镀膜及内面防反射处理的加强，固然可以大幅度地减少光斑，但被摄体的状况并不相同，不可能完全消除。</p>
<p>因此，在相机里面设计都是黑色的，且其内侧表明设计都是粗糙的，目前就是为了减小flare。flare如何修正？做直方图，然后每阶的亮度都往下降，这样是否会影响颜色呢？因此，flare一定要是在linear domain去做，不能在RGB domain去做。</p>
<p>（9）DM（Demosaicing/Color Filter Array Interpolation/CFA插值）：CMOS Sensor出来的RawData是Bayer格式的图像，每个像素只有一个通道的信息。DM是将Bayer格式的图像恢复成每个像素用RGB三通道表示的方式。DM的主要依据是图像在平滑的局部区域，各分量的ratio是相等的。插值算法的好坏会影响图片的细节，如摩尔纹。</p>
<p>（12）EE（Edge Enhancement/Edge Sharpening）：锐化，边缘增强。通过滤波器获取图像的高频分量，按照一定的比例将高频部分和原图进行加权求和获取锐化后的图像。</p>
<p>（13）DRC/HDR（Dynamic Range Compression/ High-Dynamic Range）：宽动态。高动态图像的拍摄出来的结果通常会有，亮部太亮，暗部太暗的问题。DRC是调整图像暗部亮度使之变亮，调整亮部亮度使之变暗，而且保持图像的对比度。</p>
<p>（14）PCA/VDE：Hue，Saturation，Contrast，Brightness调试。单独针对Hue，Saturation，Contrast，Brightness各图像分量进行调节。</p>
<p>（15）Histogram：直方图均衡化。重新分布图片的亮度。使图片的亮度分布更加均匀。</p>
<p>（16）FlashLight Control：闪光灯控制</p>
<p>（17）Cross talk：Optical cross-talk是当主光线进光角度过大，导致光线不能有效地进入本像素的Microlens内，而是进入相邻像素单元或其他无效区域内的现象。</p>
<p>Electric cross-talk：相邻单元之间的光生少数载流子通过衬底扩散和漏电相互影响造成相邻单元的现象。</p>
<p>上述原因导致结果都是图像在对角线上相邻两个像素的Gr和Gb value差异较大而产生不平滑的纹理状。</p>
<p>（18）Gradation Control（GDC）：可能是对图像数据精度进行的操作</p>
<p>（19）Scaler：对图像进行缩放，缩放的过程中采样和插值直接影响图像的细节质量。</p>
<p>（20）Adaptive tone scale：(这个没有办法处理多种场景)进来的影像，根据histogram，可以调节，让其明暗亮度的曲线比较好看。因此，它最重要的就是histogram equalization，其关键是在哪个domain去做。目前我们的做法应该是在L*做histogram，但只做edge的histogram，这样就ok了。</p>
<p>（21）Dynamic Range Compression：就是把暗的地方变亮一些，亮的地方变暗一些。AE的主要目的是避免亮度饱和的pixels，其余exposure的pixel可以通过DRC校准回来。</p>
<h2 id="Iris"><a href="#Iris" class="headerlink" title="Iris"></a>Iris</h2><p>光圈是镜头上的一个组件，由机械或电压控制，可通过控制通光孔的开合程度，控制进光量的大小，光圈的进光量与其f值的平方成反比。DC-Iris不能精确定位，P-Iris能精确定位。</p>
<p>计量光学系统的通光量时使用f-stop作为计量单位，f-stop = f （镜头焦距）/ D（光圈孔径），f-stop值越大表示光圈孔径越小，常用的f-stop值一般在1.4~22之间,如下图所示。<br><img src="/images/sensor/v2-910b34243ef1be1dfba55f6f564290a0_720w.jpg" alt="img"></p>
<p>由于f-stop反比于光圈孔径，根据圆面积公式S=πD^2/4，镜头的实际通光量与f-stop的平方成反比，它们之间名义上的对应关系如下。<br><img src="/images/sensor/v2-907684804fe2f746a039be86ab42a9cf_720w.jpg" alt="img"></p>
<p>一般来说，光圈f值从f1.8<del>f22较常见， 其中 f1.8</del>f5.4，室内用得多一些；而f5.0以上室外用得多，暗场景一般使用最小的f值光圈以获得较大的通光量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/pc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/pc/" class="post-title-link" itemprop="url">计算机组成原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:39:27" itemprop="dateModified" datetime="2022-06-08T20:39:27+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h2><p><strong>计算机由控制器、存储器、运算器、输入设备和输出设备5个部件组成</strong>。</p>
<p>度量计算机性能的指标有响应时间和吞吐率，<strong>响应时间</strong>是指完成一个任务所需的总时间，<strong>吞吐量</strong>表示单位时间内完成的任务数量。</p>
<p>集成电路主要用的是CMOS，其主要能耗来源是晶体管开头过程中产生的动态能耗，其値取决于每个晶体管的负载电容和工作电压：能耗 = 负载电容 x 电压^2^ 。每个晶体管需要的功耗是一个翻转能耗和开头频率的乘积： 功耗 = 负载电容 x 电压^2^ x 开头频率。</p>
<h2 id="计算机设计思想"><a href="#计算机设计思想" class="headerlink" title="计算机设计思想"></a>计算机设计思想</h2><ol>
<li>面向摩尔定律的设计，摩尔定律是指单芯片上的集成度每18 -24月翻一番。设计者必须预测其设计完成时的工艺水平。</li>
<li>使用抽象简化设计，用抽象表示不同的设计层次，在高层次中看不到低层次的细节。</li>
<li>加速大概率事件远比优化小概率事件更能提高性能。</li>
<li>并行执行提高性能。</li>
<li>通过流水线提高性能。</li>
<li>通过预测提高性能。</li>
<li>通过使用冗余部件提高系统的可靠性。比如汽车的备用轮胎。</li>
<li>存储器层次结构，较快的存储器靠近处理器。</li>
</ol>
<h2 id="存储器结构"><a href="#存储器结构" class="headerlink" title="存储器结构"></a>存储器结构</h2><h3 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h3><p>冯·诺依曼结构，又称为普林斯顿体系结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。取指令和取操作数都在同一总线上，通过分时复用的方式进行；缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。由于程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同。</p>
<p><img src="/images/cpu/Princeton.jpg" alt="img"></p>
<h3 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h3><p>哈佛结构是一种将程序指令存储和数据存储分开的存储器结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问，目的是为了减轻程序运行时的访存瓶颈。</p>
<p><img src="/images/cpu/Harvard.jpg" alt="img"></p>
<p>哈佛结构的中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据。程序指令储存和数据储存分开，数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度。</p>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p><strong>原码</strong>：用第一位表示符号，其余位表示值，负数符号位为1。</p>
<p><strong>反码</strong>：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p>
<p><strong>补码</strong>：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p><strong>移码</strong>：将符号位取反的补码（不区分正负）。</p>
<p>原码使数字有了正负概念，但是计算不正确，正负相加不等于0，而且存在+0和-0。反码解决了正负相加不等于0的问题。为了追求连续性和唯一性，补码修复了存在两个0编码的问题，而且还能够多表示一个最低数，所以1个字节能表示的范围为[-128, 127]。</p>
<p>用[0000 0000]表示0, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p>
<blockquote>
<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>
</blockquote>
<h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><h4 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h4><p><img src="/images/pc/float_mem.jpg" alt="浮点表示"></p>
<ul>
<li>第一段 占 1bit，表示符号位。0代表正数，1代表负数。</li>
<li>第二段 占 8bits，表示指数。代称为 E(Exponent)。</li>
<li>第三段 占 23bits，表示尾数。代称为 M(Mantissa)。</li>
</ul>
<p>浮点数在计算机存储使用二进制科学计数法。如小数 78.375，符号位为0，指数为6，尾数是001110011。</p>
<blockquote>
<p>整数部分：(78)<del>10</del> = (100 1110)<del>2</del><br>小数部分：(0.375)<del>10</del>　=　3/8 = 1/4 + 1/8 = 2^-2^ + 2^-3^ = (0.01)<del>2</del> + (0.001)<del>2</del> = (0.011)<del>2</del><br>(78.375)<del>10</del> = (1001110.011)<del>2</del> = 1.001110011 * 2^6^</p>
</blockquote>
<p>对于 int 和 float 变量类型不能使用强制类型转换，要通过float指针来转换。</p>
<h4 id="浮点加法"><a href="#浮点加法" class="headerlink" title="浮点加法"></a>浮点加法</h4><h4 id="浮点乘法"><a href="#浮点乘法" class="headerlink" title="浮点乘法"></a>浮点乘法</h4><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>时钟周期也叫振荡周期或晶振周期，即晶振的单位时间发出的脉冲数。是计算机中最基本的、最小的时间单位。</p>
<p>机器周期：在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。8051单片机的机器周期由6个状态周期组成，也就是说一个机器周期=6个状态周期=12个时钟周期。机器周期也是单片机定时器和计数器的时间基准。例如一个单片机选择了12MHZ晶振，那么当定时器的数值加1时，实际经过的时间就是1us。</p>
<p>指令周期是执行一条指令所需要的时间，一般由若干个机器周期组成。指令不同，所需的机器周期数也不同。</p>
<p>系统时钟就是CPU指令运行的频率，系统时钟由晶振或内部RC产生。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/cpu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/cpu/" class="post-title-link" itemprop="url">各种处理器介绍</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:34:03" itemprop="dateModified" datetime="2022-06-08T20:34:03+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/cpu/cpu.jpg" alt="img"></p>
<p>cpu内部由控制器、运算器、寄存器、时钟4部分组成。</p>
<h2 id="处理器架构"><a href="#处理器架构" class="headerlink" title="处理器架构"></a>处理器架构</h2><h3 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a>CISC</h3><p>CISC（Complex Instruction Set Computer，复杂指令集计算机）是一种微处理器指令集架构（ISA），每个指令可执行若干低阶操作，诸如从内存读取、储存、和计算操作，全部集于单一指令之中。CISC特点：</p>
<ul>
<li>指令系统庞大，指令功能复杂，指令格式、寻址方式多；</li>
<li>绝大多数指令需多个机器周期完成；</li>
<li>各种指令都可访问存储器；</li>
<li>采用微程序控制；</li>
<li>有专用寄存器，少量；</li>
<li>难以用优化编译技术生成高效的目标代码程序；</li>
</ul>
<p>在CISC指令集的各种指令中，大约有20%的指令会被反复使用，占整个程序代码的80%。而余下的80%的指令却不经常使用，在程序设计中只占20%。</p>
<h3 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h3><p>RISC（Reduced Instruction Set Computer，精简指令集计算机）对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。它能够以更快的速度执行操作。现在的RISC指令集也达到数百条，运行周期也不再固定。RISC设计的根本原则—针对流水线化的处理器优化。RISC特点：</p>
<ul>
<li>统一指令编码（例如，所有指令中的op-code永远位于同样的位元位置、等长指令），可快速解译；</li>
<li>泛用的暂存器，所有暂存器可用于所有内容，以及编译器设计的单纯化（不过暂存器中区分了整数和浮点数）；</li>
<li>单纯的寻址模式（复杂寻址模式以简单计算指令序列取代）；</li>
<li>硬件中支援少数资料型别（例如，一些CISC电脑中存有处理字节字串的指令。这在RISC电脑中不太可能出现）。</li>
<li>　所有计算都要在寄存器中完成。而寄存器和内存的通信则由单独的指令完成。</li>
<li>有非常多的通用寄存器，并采用了重叠寄存器窗口和寄存器堆等技术使寄存器资源得到充分的利用。</li>
</ul>
<p>**[区别]**：</p>
<p>CISC和RISC是当前CPU的两种架构。它们的区别在于不同的CPU设计理念和方法。早期的CPU全部是CISC架构，它的设计目的是用最少的机器语言指令来完成所需的计算任务。它们的差异主要有：</p>
<ol>
<li><p>指令系统：RISC设计者把主要精力放在那些经常使用的指令上，尽量使它们具有简单高效的特色。对不常用的功能，常通过组合指令来完成。因此，在RISC机器上实现特殊功能时，效率可能较低。但可以利用流水技术和超标量技术加以改进和弥补。而CISC计算机的指令系统比较丰富，有专用指令来完成特定的功能。因此，处理特殊任务效率较高。</p>
</li>
<li><p>存储器操作：RISC对存储器操作有限制，使控制简单化；而CISC机器的存储器操作指令多，操作直接。</p>
</li>
<li><p>程序：RISC汇编语言程序一般需要较大的内存空间，实现特殊功能时程序复杂，不易设计；而CISC汇编语言程序编程相对简单，科学计算及复杂操作的程序社设计相对容易，效率较高。</p>
</li>
<li><p>中断：RISC机器在一条指令执行的适当地方可以响应中断；而CISC机器是在一条指令执行结束后响应中断。</p>
</li>
<li><p>CPU：RISCCPU包含有较少的单元电路，因而面积小、功耗低；而CISCCPU包含有丰富的电路单元，因而功能强、面积大、功耗大。</p>
</li>
<li><p>设计周期：RISC微处理器结构简单，布局紧凑，设计周期短，且易于采用最新技术；CISC微处理器结构复杂，设计周期长。</p>
</li>
<li><p>用户使用：RISC微处理器结构简单，指令规整，性能容易把握，易学易用；CISC微处理器结构复杂，功能强大，实现特殊功能容易。</p>
</li>
<li><p>应用范围：由于RISC指令系统的确定与特定的应用领域有关，故RISC机器更适合于专用机；而CISC机器则更适合于通用机。</p>
</li>
</ol>
<h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><p>x86或80x86是英特尔首先开发制造的一种微处理器体系结构的泛称。该系列较早期的处理器名称是以数字来表示，并以“86”作为结尾，包括Intel 8086、80186、80286、80386以及80486，因此其架构被称为“x86”。成为了个人电脑的标准平台</p>
<p>x86架构于1978年推出的Intel 8086中央处理器中首度出现，它是从Intel 8008处理器中发展而来的，而8008则是发展自Intel 4004的。8086在三年后为IBM PC所选用，之后x86便，成为了历来最成功的CPU架构。</p>
<p>8086是16位元处理器；直到1985年32位元的80386的开发，这个架构都维持是16位元。接着一系列的处理器表示了32位元架构的细微改进，推出了数种的扩充，直到2003年AMD对于这个架构发展了64位元的扩充，并命名为AMD64。后来Intel也推出了与之兼容的处理器，并命名为Intel 64。两者一般被统称为x86-64或x64，开创了x86的64位时代。</p>
<p>x86架构是重要地可变指令长度的CISC。字组（word, 4字节）长度的内存存取允许不对齐内存位址，字组是以低位字节在前的顺序储存在内存中。向后相容性一直都是在x86架构的发展背后一股驱动力量。但在较新的微架构中，x86处理器会把x86指令转换为更像RISC的微指令再予执行，从而获得可与RISC比拟的超标量性能，而仍然保持向前兼容。</p>
<p>X86指令集只有8个通用寄存器。所以，CISC的CPU执行是大多数时间是在访问存储器中的数据，而不是寄存器中的。这就拖慢了整个系统的速度。</p>
<h3 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h3><p>ARM架构（进阶精简指令集机器（AdvancedRISC Machine），是一个32位RISC处理器架构，广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。</p>
<p>ARM采用的RISC体系最大特点是指令长度固定，指令格式种类少，寻址方式种类少，大多数是简单指令且都能在一个时钟周期内完成，易于设计超标量与流水线，寄存器数量多，大量操作在寄存器之间进行，因此有较快运行速度。</p>
<p>ARM指令集的特点：</p>
<ul>
<li>体积小，低功耗，低成本，高性能；</li>
<li>支持 Thumb（16位）/ARM（32位）双指令集，能很好的兼容8位/16位器件；</li>
<li>大量使用寄存器，指令执行速度更快，大多数数据操作都在寄存器中完成；</li>
<li>寻址方式灵活简单，执行效率高；</li>
<li>指令长度固定，流水线处理方式</li>
</ul>
<h3 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h3><p>MIPS架构（无内部互锁流水级的微处理器，Microprocessorwithout Interlocked Pipeline Stages），是一种采取精简指令集的处理器架构，1981年出现，由MIPS科技公司开发并授权，广泛被使用在许多电子产品、网络设备、个人娱乐装置与商业装置上。其机制是尽量利用软件办法避免流水线中的数据相关问题。它最早是在80年代初期由斯坦福大学Hennessy教授领导的研究小组研制出来的。MIPS公司的R系列就是在此基础上开发的RISC工业产品的微处理器。这些系列产品为很多计算机公司采用构成各种工作站和计算机系统。</p>
<p>MIPS是出现最早的商业RISC架构芯片之一。MIPS的系统结构及设计理念比较先进，强调软硬件协同提高性能，同时简化硬件设计。</p>
<p>**[ARM与MIPS对比]**：</p>
<p>MIPS架构的优势：</p>
<ol>
<li><p>MIPS支持64bit指令和操作，ARM目前只到32bit。</p>
</li>
<li><p>MIPS有专门的除法器，可以执行除法指令。</p>
</li>
<li><p>MIPS的内核寄存器比ARM多一倍，所以同样的性能下MIPS的功耗会比ARM更低，同样功耗下性能比ARM更高。</p>
</li>
<li><p>MIPS指令比ARM稍微多一点，稍微灵活一点。</p>
</li>
<li><p>ARM很昂贵，而且不能随意自行更改内核。而MIPS就要开放的多了。</p>
</li>
</ol>
<p>MIPS架构的不足：</p>
<ol>
<li><p>MIPS的内存地址起始有问题，这导致了MIPS在内存和cache的支持方面都有限制，现在的MIPS处理器单内核面对高容量内存时有问题</p>
</li>
<li><p>MIPS今后的发展方向是并行线程，类似INTEL的超线程，而ARM未来的发展方向是物理多核，目前看来物理多核占优。由此来看，我国的龙芯向多核发展还是颇具远见的。</p>
</li>
<li><p>MIPS虽然结构更加简单，但是到现在还是顺序单发射，ARM已经进化到了乱序双发射，甚至NV的丹佛已经是乱序三发射了。</p>
</li>
</ol>
<h2 id="各种处理器"><a href="#各种处理器" class="headerlink" title="各种处理器"></a>各种处理器</h2><p>DSP – Digital Signal Processor，是一种专用于数字信号处理的微处理器。内部采用程序和数据分开的哈佛结构，具有专门的硬件乘法器，广泛采用流水线操作，提供特殊的DSP指令，可以用来快速的实现各种数字信号处理算法。功耗更低。</p>
<p>FPGA – Field－Programmable Gate Array，现场可编程门阵列。</p>
<p>APU – Accelerated Processing Unit, 加速处理器，AMD公司推出加速图像处理芯片产品。</p>
<p>BPU – Brain Processing Unit, 地平线公司主导的嵌入式处理器架构。</p>
<p>CPU – Central Processing Unit，中央处理器。CPU主要包括控制器、运算器，其中还包括高速缓冲存储器及实现它们之间联系的数据、控制的总线。主要功能为处理指令、执行操作、控制时间、处理数据。</p>
<p>DPU – Deep learning Processing Unit, 深度学习处理器，最早由国内深鉴科技提出；另说有Dataflow Processing Unit 数据流处理器， Wave Computing 公司提出的AI架构；Data storage Processing Unit，深圳大普微的智能固态硬盘处理器。</p>
<p>FPU – Floating Processing Unit 浮点计算单元，通用处理器中的浮点运算模块。</p>
<p>GPU – Graphics Processing Unit，图形处理单元，采用多线程SIMD架构，为图形处理而生。它是显卡的处理器，专为执行复杂的数学和几何计算而设计的，这些计算是图形渲染所必需的。</p>
<p>HPU – Holographics Processing Unit 全息图像处理器， 微软出品的全息计算芯片与设备。</p>
<p>IPU – Intelligence Processing Unit， Deep Mind投资的Graphcore公司出品的AI处理器产品。</p>
<p>MCU – Microcontroller Unit，微控制单元，又称单片机，是把CPU的频率与规格做适当缩减，并将内存、计数器、USB、A/D转换、UART、PLC、DMA等周边接口，甚至LCD驱动电路都整合在单一芯片上，形成芯片级的计算机。</p>
<p>NPU – Neural Network Processing Unit，神经网络处理单元，是基于神经网络算法与加速的新型处理器总称。</p>
<p>RPU – Radio Processing Unit, 无线电处理器， Imagination Technologies 公司推出的集合集Wifi/蓝牙/FM/处理器为单片的处理器。</p>
<p>TPU – Tensor Processing Unit 张量处理器， Google 公司推出的为机器学习而定制的芯片，经过了专门深度机器学习方面的训练，它有更高效能（每瓦计算能力）。目前一代TPU面向Inference，二代面向训练。</p>
<p>VPU – Vector Processing Unit 矢量处理器，Intel收购的Movidius公司推出的图像处理与人工智能的专用芯片的加速计算核心。</p>
<p>WPU – Wearable Processing Unit， 可穿戴处理器，Ineda Systems公司推出的可穿戴片上系统产品，包含GPU/MIPS CPU等IP。</p>
<p>XPU – 百度与Xilinx公司在2017年Hotchips大会上发布的FPGA智能云加速，含256核。</p>
<p>ZPU – Zylin Processing Unit, 由挪威Zylin 公司推出的一款32位开源处理器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/memory/" class="post-title-link" itemprop="url">memory and disk</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:34:18" itemprop="dateModified" datetime="2022-06-08T20:34:18+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p><strong>ROM</strong> (Read Only Memory)程序存储器，在掉电之后仍然可以保持数据，用于存储各种固化程序和数据。</p>
<p><strong>PROM</strong> (Programmable ROM，可编程ROM)，写入时，烧录器通过高电压在芯片内永久地烧断或者建立内部连接（熔丝或反熔丝），因此只能一次编程。</p>
<p><strong>EPROM</strong> (Erasable Programmable ROM，可擦去可编程ROM)，使用紫外线照射此类型的ROM可以抹去其中的数据。</p>
<p><strong>EEPROM</strong> (Electrically Erasable Programmable ROM，电可擦去可编程ROM)，使用电来对其进行擦写，常用于电脑系统的BIOS。</p>
<h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p><strong>RAM</strong> (Random Access Memory)随机访问存储器，存储单元的内容可按照需要随机取出或存入，且存取的速度与存储单元的位置无关。在掉电之后就丢失数据，主要用来存储程序中用到的变量。随机存储器主要分两种：静态随机存储器SRAM和动态随机存储器DRAM。</p>
<p><strong>DRAM</strong> (Dynamic RAM/DRAM)动态随机存储器，DRAM保留数据的时间很短，需要周期性地刷新。计算机内存就是DRAM的。</p>
<p>DRAM利用MOS管的栅电容上的电荷来存储信息，存储单元存储的是0还是1取决于电容是否有电荷，有电荷代表1，无电荷代表0。由于栅极会漏电，所以每隔一定的时间就需要一个刷新机构给这些栅电容补充电荷，这个就叫动态刷新。刷新操作定期对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电；若电量小于1/2，则认为其代表0，并把电容放电，以此来保持数据的连续性。</p>
<p><strong>SRAM</strong> (Static Random-Access Memory)静态随机存取存储器，只要保持通电，里面储存的数据就可以一直保持，对任何数据访问的时间都是固定的。SRAM的优点是只要器件不掉电，存储内容就不丢失，工作速度快。缺点是集成度低、功耗大、价格高。CPU Cache采用的就是这种技术。</p>
<h2 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h2><p>Flash 存储器（FLASH EEPROM）又称闪存，快闪。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备EEPROM的性能，还不会断电丢失数据同时可以快速读取数据。它于EEPROM的最大区别是，FLASH按扇区操作，而EEPROM按照字节操作。FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因此适合用于做程序存储器。</p>
<p>flash是非易失存储器，可以对称为块的存储器单元块进行擦写和再编程。任何flash器件的写入操作只能在空或已擦除的单元内进行，所以在进行写入操作之前必须先执行擦除。擦除的过程就是把所有位都写为1的过程，块内的所有字节变为0xFF。擦除是以块为单位进行的。</p>
<h3 id="Nor-Flash"><a href="#Nor-Flash" class="headerlink" title="Nor Flash"></a>Nor Flash</h3><p>Nor Flash支持随机访问，具有XIP（eXecute In Place）特性，可以像普通ROM一样执行程序。所存储的内容可以直接映射到 CPU 地址空间，不需要拷贝到 RAM 中即可被 CPU 访问。容量小，读操作快，但擦除和写操作慢，块大小范围：64~128KB。NOR flash带有SRAM接口，有足够的地址引脚来寻址，可以很容易地存取其内部的每一个字节。</p>
<p>Nor Flash根据数据传输的位数可以分为并行（Parallel，即地址线和数据线直接和处理器相连）和串行（SPI，即通过SPI接口和处理器相连）。早期Norflash的接口是parallel的形式，即把数据线和地址线并排与IC的管脚连接。但是后来发现不同容量的Norflash不能硬件上兼容（数据线和地址线的数量不一样），并且封装比较大，占用了较大的PCB板位置，后来逐渐被串行接口的SPI Norflash所取代，至于现在说起NOR flash都直接以SPI flash来代称。</p>
<p>spi flash 接口定义：</p>
<ul>
<li>Standard SPI: CLK, /CS, DI, DO, /WP, /Hold</li>
<li>Dual SPI: CLK, /CS, IO0, IO1, /WP, /Hold</li>
<li>Quad SPI: CLK, /CS, IO0, IO1, IO2, IO3</li>
</ul>
<h3 id="Nand-Flash"><a href="#Nand-Flash" class="headerlink" title="Nand Flash"></a>Nand Flash</h3><p>Nand Flash是串行接口，容量大，擦除和写都快。块大小范围：8~64KB。没有采取内存的随机读取技术，读和写操作都采用512字节的块。</p>
<p>Nor的读速度比Nand稍快一些，Nand的写入速度比Nor快很多。</p>
<p>Nand闪存中每个块的最大擦写次数是一百万次，而Nor的擦写次数是十万次。</p>
<p><img src="/images/memory/nor_nand.jpg" alt="nor_nand"></p>
<p>由于Flash固有的电器特性，在读写数据过程中会偶然产生1位或几位数据错误，即位反转。Nand Flash发生位反转的几率要远大于Nor Flash。位反转无法避免，因此使用 Nand Flash 的同时，应采用错误探测/错误更正(EDC/ECC)算法。</p>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘(Hard Disk Drive，HDD)靠磁性盘片记录二进制数据。</p>
<p><img src="/images/memory/disk/hdd.jpg" alt="img"></p>
<p>Track Sector：磁道扇面      Head：磁头      Actuator Arm：悬浮磁臂。</p>
<p>当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道(Track)。划分分区时，分区大小必须以磁道为参考，一个分区必须包含一个或多个整数磁道，不能只占半个磁道。也就是说如果磁盘有两个磁道，最多只能分成2个分区。</p>
<p>在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面(Cylinder)。</p>
<p>磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区(Sector)。硬盘的第一个扇区，叫做引导扇区。磁盘上数据读写的最小单位。</p>
<p>硬盘片的盘面上有一层涂得很薄的磁性材料。写入数据时，通电的磁头会形成磁场，在磁性材料层上留下一个一个小磁化区，每个被磁化的区域代表二进制的1。读取数据时，磁头扫过磁化区的时候能感受到微小的磁场变化。</p>
<p>操作系统内核中的文件管理系统会将硬盘的扇区组合成<strong>簇</strong>(Data Cluster)，操作系统会记录文件所在簇的编号(文件数据分布在哪几个扇区)，方便查找并读写。</p>
<p>机械硬盘通过磁头读取旋转的盘片来传输数据，而盘片的转速RPM(Round Per Minute，每分钟的转数)直接决定了硬盘读取和写入数据的速度。目前主流的机械硬盘，转速在6000~7500RPM左右。磁盘在写入数据时，会使用磁盘缓存暂时存储数据。</p>
<p><strong>磁盘缓存</strong>(Disk Cache)，就是将下载到的数据先保存于系统为软件分配的内存空间中，当保存到内存池中的数据达到一个程度时，便将数据保存到硬盘中。这样可以减少实际的磁盘操作，有效的保护磁盘免于重复的读写操作而导致的损坏。目前主流的500G机械硬盘大都装载64MB的缓存。</p>
<p>硬盘的主控芯片主要负责：</p>
<ul>
<li>控制磁头的读取</li>
<li>温度检测</li>
<li>为操作系统的文件管理系统提供逻辑接口</li>
<li>负责纠错，磁头读写时会使用磁信号，而磁信号的误码率非常高，大约每记录0.6KB的数据就会出现一个bit的错误。</li>
<li>负责将数据从RAM/硬盘缓存写入，或者将硬盘读出的数据写回RAM。</li>
</ul>
<h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>RAID(独立硬盘冗余阵列，Redundant Array of Independent Disks)，简称磁盘阵列。利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或数据冗余，或是两者同时提升。</p>
<ul>
<li><strong>RAID0</strong></li>
</ul>
<p>RAID0 是一种非常简单的的方式，它将多块磁盘组合在一起形成一个大容量的存储。当我们要写数据的时候，会将数据分为N份，以独立的方式实现N块磁盘的读写，那么这N份数据会同时并发的写到磁盘中，读写性能理论上是单块磁盘的N倍。</p>
<p>但RAID0的问题是，它并不提供数据校验或冗余备份，因此一旦某块磁盘损坏了，数据就直接丢失，无法恢复了。因此RAID0就不可能用于高要求的业务中，但可以用在对可靠性要求不高，对读写性能要求高的场景中。</p>
<ul>
<li><strong>RAID1</strong></li>
</ul>
<p>RAID1 是磁盘阵列中单位成本最高的一种方式。因为它的原理是在往磁盘写数据的时候，将同一份数据无差别的写两份到磁盘，分别写到工作磁盘和镜像磁盘，对数据做了冗余备份，但它的实际空间使用率只有50%了，是一种比较昂贵的方案。</p>
<ul>
<li><strong>RAID3</strong></li>
</ul>
<p>RAID3的方式是：将数据按照RAID0的形式，分成多份同时写入多块磁盘，但是还会另外留出一块磁盘用于写奇偶校验码，一旦某一块磁盘坏掉了，就可以利用那块校验码磁盘去恢复数据。但是由于任何数据的写入都会要去更新这块磁盘，导致这块磁盘的读写是最频繁的，也就非常的容易损坏。</p>
<ul>
<li><strong>RAID5</strong></li>
</ul>
<p>RAID5对RAID3进行了改进，是一种存储性能、数据安全、存储成本兼顾的方案。</p>
<p>在RAID5模式中，不再需要用单独的磁盘写校验码了。它把校验码信息分布到各个磁盘上。例如，总共有N块磁盘，那么会将要写入的数据分成N份，并发的写入到N块磁盘中，同时还将数据的校验码信息也写入到这N块磁盘中，数据与对应的校验码信息必须得分开存储在不同的磁盘上。一旦某一块磁盘损坏了，就可以用剩下的数据和对应的奇偶校验码信息去恢复损坏的数据。</p>
<p><img src="/images/memory/disk/RAID5.jpg" alt="img"></p>
<p>RAID5的方式，最少需要三块磁盘来组建磁盘阵列，允许最多同时坏一块磁盘。如果有两块磁盘同时损坏了，那数据就无法恢复了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/hardware/usb_if/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/hardware/usb_if/" class="post-title-link" itemprop="url">usb接口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 18:03:15" itemprop="dateModified" datetime="2022-06-08T18:03:15+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/usb/usb-if2.png" alt="usb接口"></p>
<p><img src="/images/usb/usb-if3.png" alt="usb接口"></p>
<p><img src="/images/usb/usb_if.bmp" alt="usb接口"></p>
<p><img src="/images/usb/usb-if.png" alt="usb接口"></p>
<p>标准USB接口使用标记为D+(绿线)和D-(白线) 的双绞线传输，它们各自使用半双工的差分信号并协同工作，以抵消长导线的电磁干扰。</p>
<p>Mini USB接口把第4针作为ID线，用来标识身份，mini-A插头的ID引脚接地，而mini-B插头悬空。<strong>USB OTG根据ID线状态判断是主机还是从机，接地为主机，悬空为从机</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">179</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
