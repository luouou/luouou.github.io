<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/tool/shell-if/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/tool/shell-if/" class="post-title-link" itemprop="url">shell if 条件判断</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-13 21:56:51" itemprop="dateCreated datePublished" datetime="2022-08-13T21:56:51+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell/" itemprop="url" rel="index"><span itemprop="name">shell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ command ]; then</span><br><span class="line"></span><br><span class="line">elif [ command ]; then</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><em>注意</em>：</p>
<p>1、[ ]表示条件测试，要注意在’[‘后面和’]’前面都必须要有空格。</p>
<p>2、在shell中，then和fi是分开的语句。如果要在同一行里面输入，则需要用分号将他们隔开。</p>
<p>3、if判断中对于变量的处理，需要加引号，以免一些不必要的错误。没有加双引号会在一些含空格等的字符串变量判断的时候产生错误。比如<code>[ -n &quot;$var&quot; ]</code>，如果var为空会出错。</p>
<p>4、不支持浮点值。</p>
<p>5、如果只单独使用&gt;或者&lt;号，系统会认为是输出或者输入重定向，虽然结果显示正确，但是其实是错误的，因此要对这些符号进行转义。</p>
<p>6、运行if语句中的命令所产生的错误信息默认仍然出现在脚本的输出结果中。</p>
<p>7、使用-z或者-n来检查长度的时候，没有定义的变量也为0。</p>
<p>8、空变量和没有初始化的变量可能会对shell脚本测试产生灾难性的影响，因此在不确定变量的内容的时候，在测试前使用-n或者-z测试一下。</p>
<p>9、? 变量包含了之前执行命令的退出状态（最近完成的前台进程），可以用于检测退出状态。</p>
<h2 id="文件-目录判断"><a href="#文件-目录判断" class="headerlink" title="文件/目录判断"></a>文件/目录判断</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。</span><br><span class="line">[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。</span><br><span class="line">[ -d DIR ]  如果 FILE 存在且是一个目录则为真。</span><br><span class="line">[ -e FILE ] 如果 FILE 存在则为真。</span><br><span class="line">[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。</span><br><span class="line">[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。</span><br><span class="line">[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。</span><br><span class="line">[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。</span><br><span class="line">[ -r FILE ] 如果 FILE 存在且是可读的则为真。</span><br><span class="line">[ -s FILE ] 如果 FILE 存在且大小不为0则为真。</span><br><span class="line">[ -t FD ]   如果文件描述符 FD 打开且指向一个终端则为真。</span><br><span class="line">[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。</span><br><span class="line">[ -w FILE ] 如果 FILE存在且是可写的则为真。</span><br><span class="line">[ -x FILE ] 如果 FILE 存在且是可执行的则为真。</span><br><span class="line">[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。</span><br><span class="line">[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。</span><br><span class="line">[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。</span><br><span class="line">[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。</span><br><span class="line">[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。</span><br><span class="line">[ FILE1 -nt FILE2 ] 如果 FILE1 比 FILE2 新，则为真。</span><br><span class="line">[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。</span><br><span class="line">[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。</span><br></pre></td></tr></table></figure>

<h2 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ -z STRING ] 判断是否为空</span><br><span class="line">[ -n STRING ] 判断是否为非空</span><br><span class="line">[ STRING1 ]　 如果字符串不为空则为真</span><br><span class="line">[ STRING1 = STRING2 ]  如果两个字符串相同则为真</span><br><span class="line">[ STRING1 == STRING2 ] 如果两个字符串相同则返回为真</span><br><span class="line">[ STRING1 != STRING2 ] 如果字符串不相同则为真</span><br><span class="line">[ STRING1 &lt; STRING2 ]  如果 “STRING1”字典排序在“STRING2”前面则返回为真。</span><br><span class="line">[ STRING1 &gt; STRING2 ]  如果 “STRING1”字典排序在“STRING2”后面则返回为真。</span><br></pre></td></tr></table></figure>

<p><strong>比较两个字符串是否相等的办法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$test&quot;x = &quot;test&quot;x ]; then</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ol>
<li>使用单个等号，等号两边各有一个空格。</li>
<li>注意到”$test”x最后的x，这是特意安排的，因为当$test为空的时候，上面的表达式就变成了x = testx，显然是不相等的。而如果没有这个x，表达式就会报错：”[: =: unary operator expected”。</li>
</ol>
<p><strong>==的功能在<code>[[]]</code>和<code>[]</code>中的行为是不同的</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ \$a == z* ]]      # 如果$a以&quot;z&quot;开头(模式匹配)那么将为true</span><br><span class="line">[[ \$a == &quot;z*&quot; ]]    # 如果$a等于z*(字符匹配),那么结果为true</span><br><span class="line">[ \$a == z* ]        # File globbing 和word splitting将会发生</span><br><span class="line">[ &quot;\$a&quot; == &quot;z&quot; ]     # 如果$a等于z(字符匹配),那么结果为true</span><br></pre></td></tr></table></figure>

<h2 id="数值判断"><a href="#数值判断" class="headerlink" title="数值判断"></a>数值判断</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INT1 -eq INT2           INT1和INT2两数相等为真</span><br><span class="line">INT1 -ne INT2           INT1和INT2两数不等为真</span><br><span class="line">INT1 -gt INT2           INT1大于INT1为真</span><br><span class="line">INT1 -ge INT2           INT1大于等于INT2为真</span><br><span class="line">INT1 -lt INT2           INT1小于INT2为真</span><br><span class="line">INT1 -le INT2           INT1小于等于INT2为真</span><br></pre></td></tr></table></figure>

<h2 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ ! EXPR ]         逻辑非，如果 EXPR 是false则返回为真。</span><br><span class="line">[ EXPR1 -a EXPR2 ] 逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。</span><br><span class="line">[ EXPR1 -o EXPR2 ] 逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。</span><br><span class="line">[ ] || [ ]         用OR来合并两个条件</span><br><span class="line">[ ] &amp;&amp; [ ]         用AND来合并两个条件</span><br></pre></td></tr></table></figure>

<h2 id="其他判断"><a href="#其他判断" class="headerlink" title="其他判断"></a>其他判断</h2><p>[ -t FD ] 如果文件描述符 FD （默认值为1）打开且指向一个终端则返回为真<br>[ -o optionname ] 如果shell选项optionname开启则返回为真</p>
<h2 id="IF高级特性"><a href="#IF高级特性" class="headerlink" title="IF高级特性"></a>IF高级特性</h2><p>双圆括号<code>(( ))</code>：表示数学表达式，比判断命令提供更多的数学符号，而且在双圆括号里面的’&gt;’,’&lt;’号不需要转义。</p>
<p>双方括号<code>[[ ]]</code>：表示高级字符串处理函数，使用标准的字符串比较，还可以使用匹配模式，从而定义与字符串相匹配的正则表达式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/c/daemon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/c/daemon/" class="post-title-link" itemprop="url">daemon process</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-13 21:56:50" itemprop="dateCreated datePublished" datetime="2022-08-13T21:56:50+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。</p>
<p>守护进程(daemon)是一种在系统引导装入时起动，在系统关闭时终止，不会受到用户、终端或者其他的变化而影响，在后台运行没有控制终端的进程。</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>进程组是一个或多个进程的集合。进程组由进程组 ID 来惟一标识。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;                 <span class="comment">/* POSIX.1 version */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">pid_t</span> pid)</span>;            <span class="comment">/* BSD version */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;                   <span class="comment">/* System V version */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;  <span class="comment">/* BSD version */</span></span><br></pre></td></tr></table></figure>

<p>setpgid()将pid进程的进程组ID设置为pgid。如果pid和pgid相等，则由pid指定的进程变成进程组组长，如果pid是0，则使用调用者的进程ID，如果pgid是0，则由pid指定的进程ID被用作为进程组ID。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话是一个或多个进程组的集合，一个会话开始于用户登录，终止于用户退出，在此期间该用户运行的所有进程都属于这个会话。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>setsid()函数能够使进程完全独立出来，从而脱离其他进程的控制：</p>
<ul>
<li>让进程摆脱原会话的控制。</li>
<li>让进程摆脱原进程组的控制。</li>
<li>让进程摆脱原控制终端的控制。</li>
</ul>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><ol>
<li><p>首先fork一个子进程，然后让父进程exit。这样做实现了下面几点：(a)如果精灵进程是由一条shell命令起动的，那么父进程终止使得shell认为这条命令已经执行完成。(b)进程继承了父进程的进程组ID，其进程ID则是新分配的，这就保证了子进程不是一个进程组的首进程，这是setsid()调用的前提条件。</p>
</li>
<li><p>调用setsid()以创建一个新对话期，使调用进程：(a)成为新对话期的首进程，(b)成为一个新进程组的首进程，(c)没有控制终端。</p>
</li>
<li><p>将当前工作目录更改为/目录，保证工作目录所在的文件系统不能被卸载。</p>
</li>
<li><p>将文件权限掩码设置为0，方便进程操作文件。</p>
</li>
<li><p>关闭不再需要的文件描述符，从父进程那里继承打开了的文件，可能永远不会被守护进程读或写，但一样消耗系统资源，而且可能导致所在的文件系统无法被卸载。</p>
</li>
</ol>
<p>守护进程没有控制终端，所以不能将错误信息输出到控制终端，可以使用syslog服务将程序中的出错信息输入到系统日志文件/var/log/syslog。</p>
<h2 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h2><p>syslog是linux中的系统日志管理服务，通过守护进程syslogd来维护，该守护进程在启动时会读配置文件/etc/syslog.conf，该文件决定了不同种类的消息会发送向何处。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> option, <span class="type">int</span> facility)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>openlog用于打开系统日志服务的一个连接。ident参数定义消息的标签字符串，option参数：</p>
<ul>
<li>LOG_CONS  如果消息无法送到系统日志服务，则直接输出到系统控制终端</li>
<li>LOG_NDELAY  立即打开系统日志服务的连接。在正常情况下，直接发送到第一条消息时才打开连接</li>
<li>LOG_PERROR  将日志消息发送给 s y s l o g和stderr。</li>
<li>LOG_PID  消息中包含进程的PID</li>
</ul>
<p>facility参数指定程序发送的消息类型：</p>
<ul>
<li>LOG_AUTHPRIV  安全/授权信息</li>
<li>LOG_CRON  时间守护进程(cron 及 at)函数传入值</li>
<li>LOG_DAEMON  其他系统守护进程</li>
<li>LOG_KERN  内核信息</li>
<li>LOG_LOCAL[0~7]  保留</li>
<li>LOG_LPR  行打印机子系统</li>
<li>LOG_MAIL  邮件子系统</li>
<li>LOG_NEWS  新闻子系统</li>
<li>LOG_SYSLOG  syslogd 内部所产生的信息</li>
<li>LOG_USER  一般使用者等级信息</li>
<li>LOG_UUCP  UUCP 子系统</li>
</ul>
<p>syslog是用于向日志文件中写入消息，format参数规定消息输出格式等。priority参数指定消息等级：</p>
<ul>
<li>LOG_EMERG  紧急(系统不可使用)</li>
<li>LOG_ALERT  需要立即采取措施</li>
<li>LOG_CRIT  重要情况</li>
<li>LOG_ERR  错误消息</li>
<li>LOG_WARNING  警告消息</li>
<li>LOG_NOTICE  正常情况,但也是重要情况</li>
<li>LOG_INFO  信息消息</li>
<li>LOG_DEBUG  调试信息</li>
</ul>
<p>closelog是用于关闭系统日志服务的连接。</p>
<h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开系统日志服务 */</span></span><br><span class="line">openlog(<span class="string">&quot;daemon_syslog&quot;</span>, LOG_PID, LOG_DAEMON);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建新的会话组*/</span></span><br><span class="line"><span class="type">int</span> ret = setsid();</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    syslog(LOG_ERR, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    syslog(LOG_ERR, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*关闭父进程的文件描述符*/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; getdtablesize(); ++i) &#123;</span><br><span class="line">    close(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syslog(LOG_INFO, <span class="string">&quot;daemon init\n&quot;</span>);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/c/fileio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/c/fileio/" class="post-title-link" itemprop="url">linux file io</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-13 21:56:50" itemprop="dateCreated datePublished" datetime="2022-08-13T21:56:50+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">c语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><table>
<thead>
<tr>
<th align="center">文件描述符</th>
<th align="center">用途</th>
<th>POSIX 名称</th>
<th>stdio 流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">标准输入</td>
<td>STDIN_FILENO</td>
<td>stdin</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">标准输出</td>
<td>STDOUT_FILENO</td>
<td>stdout</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">标准错误</td>
<td>STDERR_FILENO</td>
<td>stderr</td>
</tr>
</tbody></table>
<p>stdout和stderr两者默认向屏幕输出，stdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。而stderr是无缓冲的，会直接输出。如果重定向向标准输出到文件，stdout输出到文件，stderr在屏幕。</p>
<h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>flags参数：</p>
<ul>
<li><code>O_RDONLY</code>  只读打开；</li>
<li><code>O_WRONLY</code>  只写打开；</li>
<li><code>O_RDWR</code>  读写打开；</li>
<li><code>O_CLOEXEC</code>  设置close-on-exec标志</li>
<li><code>O_CREAT</code>  若文件不存在则创建之</li>
<li><code>O_DIRECT</code>  无缓冲的输入/输出</li>
<li><code>O_DIRECTORY</code>  如果pathname不是目录，则失败</li>
<li><code>O_EXCL</code>  结合O_CREAT参数使用，如果要创建的文件已存在，则返回-1，并且修改errno的值</li>
<li><code>O_LARGEFILE</code>  在32位系统中使用此标志打开大文件</li>
<li><code>O_NOATIME</code> 调用read，不修改文件最近访问时间</li>
<li><code>O_NOCTTY</code>  不要让pathname所指向的终端设备成为控制终端</li>
<li><code>O_NOFOLLOW</code>  对符号链接不予解引用  </li>
<li><code>O_TRUNC</code>  截断已有文件，使其长度为零</li>
<li><code>O_APPEND</code>  总在文件尾部追加数据  </li>
<li><code>O_ASYNC</code>  异步I/O，产生信号通知进程</li>
<li><code>O_DSYNC</code>  提供同步的 I/O 数据完整性</li>
<li><code>O_NONBLOCK</code>  以非阻塞方式打开</li>
<li><code>O_NDELAY</code>  同O_NONBLOCK</li>
<li><code>O_SYNC</code>  以同步方式写入文件</li>
<li><code>O_TEXT</code>  打开文本文件翻译CR-LF控制字符；</li>
<li><code>O_BINARY</code>  打开二进制字符，不作CR-LF翻译</li>
</ul>
<p>mode 参数:</p>
<ul>
<li><code>S_IRWXU</code>  00700 user (file owner) has read, write, and execute permission</li>
<li><code>S_IRUSR</code>  00400 user has read permission</li>
<li><code>S_IWUSR</code>  00200 user has write permission</li>
<li><code>S_IXUSR</code>  00100 user has execute permission</li>
<li><code>S_IRWXG</code>  00070 group has read, write, and execute permission</li>
<li><code>S_IRGRP</code>  00040 group has read permission</li>
<li><code>S_IWGRP</code>  00020 group has write permission</li>
<li><code>S_IXGRP</code>  00010 group has execute permission</li>
<li><code>S_IRWXO</code>  00007 others have read, write, and execute permission</li>
<li><code>S_IROTH</code>  00004 others have read permission</li>
<li><code>S_IWOTH</code>  00002 others have write permission</li>
<li><code>S_IXOTH</code>  00001 others have execute permission</li>
<li><code>S_ISUID</code>  0004000 set-user-ID bit</li>
<li><code>S_ISGID</code>  0002000 set-group-ID bit (see stat(2))</li>
<li><code>S_ISVTX</code>  0001000 sticky bit (see stat(2))</li>
</ul>
<p>openat() 函数使进程内的各线程拥有不同的当前目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek()"></a>lseek()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>lseek()函数会重新定位被打开文件的位移量，根据参数offset以及whence的组合来决定。</p>
<ul>
<li>SEEK_SET： 从文件头部开始偏移offset个字节。</li>
<li>SEEK_CUR：从文件当前读写的指针位置开始，增加offset个字节的偏移量。</li>
<li>SEEK_END：文件偏移量设置为文件的大小加上偏移量字节。</li>
</ul>
<p>因为管道、套接字等文件是不可定位的，所以无法在这些文件使用lseek()。</p>
<p><strong>空洞文件</strong></p>
<p>通过 lseek() 设置文件大小，可以形成一个空洞文件，有很多用途：</p>
<ul>
<li>迅雷未下载完，就占据文件全部大小的空间，可以实现多线程从多个地址写入。</li>
<li>提前占用空间，防止所需空间不足。</li>
<li>使磁盘尽可能的连续，减少磁盘寻道开销。</li>
<li>追加数据不会改变大小，故不涉及元数据的修改。</li>
</ul>
<h3 id="read-write"><a href="#read-write" class="headerlink" title="read() write()"></a>read() write()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>  filedes, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes)</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="type">void</span> * buff, <span class="type">size_t</span> nbytes)</span></span><br></pre></td></tr></table></figure>

<p>read()从打开文件中读数据，返回读到的字节数，若已到文件尾为 0，若出错为- 1。</p>
<p>write()向打开文件写数据，若成功返回已写的字节数，若出错为- 1。不带缓存。</p>
<p><strong>pwrite() pread()</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>pwrite函数在单线程的情况下，相当于 lseek 和 write 函数的组合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lseek</span>(fd, offset, SEEK_SET);</span><br><span class="line"><span class="built_in">write</span>(fd, buf, len);</span><br></pre></td></tr></table></figure>

<p>在 fd文件描述符没有O_APPEND属性的情况下，write函数会修改文件偏移指针，下次不seek写入位置直接调用write函数时，write函数会接着上次的位置继续写入（offset+len），而pwrite函数则不会改变文件偏移指针。另外，pwrite函数的seek和写入是原子操作，不会因为进程调度或者其他因素中断。</p>
<h2 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl()"></a>fcntl()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">   <span class="type">short</span> l_type;    <span class="comment">/* Type of lock: F_RDLCK,F_WRLCK, F_UNLCK */</span></span><br><span class="line">   <span class="type">short</span> l_whence;  <span class="comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">   <span class="type">off_t</span> l_start;   <span class="comment">/* Starting offset for lock */</span></span><br><span class="line">   <span class="type">off_t</span> l_len;     <span class="comment">/* Number of bytes to lock */</span></span><br><span class="line">   <span class="type">pid_t</span> l_pid;     <span class="comment">/* PID of process blocking our lock(set by F_GETLK and F_OFD_GETLK) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>F_DUPFD  复制文件描述符</li>
<li>F_GETFD  获得fd的close-on-exec标志，若标志未设置，则文件经过exec函数之后仍保持打开状态</li>
<li>F_SETFD  设置close-on-exec标志，该标志由参数arg的FD_CLOEXEC位决定</li>
<li>F_GETFL  得到文件描述符标志</li>
<li>F_SETFL  改变文件描述符标志，新标志值按第三个参数设置。</li>
<li>F_GETLK  根据lock参数值，决定是否上文件锁</li>
<li>F_SETLK  设置lock参数值的文件锁</li>
<li>F_SETLKW  这是F_SETLK的阻塞版本</li>
</ul>
<p>读取锁又称为共享锁，它能够使多个进程都能在文件的同一部分建立读取锁。而写入锁又称为排斥锁，在任何时刻只能有一个进程在文件的某个部分上建立写入锁。当然，在文件的同一部分不能同时建立读取锁和写入锁。</p>
<h2 id="dup"><a href="#dup" class="headerlink" title="dup()"></a>dup()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure>

<p>dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。dup2()则可以用newfd参数指定新描述符的数值，如果newfd已经打开，则先将其关闭，若oldfd等于newfd，则dup2返回newfd，不关闭它。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><ul>
<li><p>阻塞式IO：使用系统调用，并一直被阻塞，直到数据准备好且从内核复制到用户程序才返回。</p>
</li>
<li><p>非阻塞式IO：如果数据没有准备好，不会阻塞，而是返回一个错误码。</p>
</li>
<li><p>IO多路复用：类似与非阻塞，只不过轮询不是由用户线程去执行，而是由内核去轮询，直到监听到数据准备好。</p>
</li>
<li><p>信号驱动IO：内核在数据准备就绪时通过信号来进行通知，首先开启信号驱动io套接字，并使用sigaction系统调用来安装信号处理程序，内核直接返回，不会阻塞用户态，数据准备好时，内核会发送SIGIO信号，用户进程收到信号后才开始进行io操作。</p>
</li>
<li><p>异步IO：依赖信号处理程序来进行通知，等IO操作完成时通过回调函数对数据进行处理，unix中异步io函数以aio_或lio_打头。</p>
</li>
</ul>
<h3 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">            fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pselect</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">            fd_set *exceptfds, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout, <span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span>;</span><br></pre></td></tr></table></figure>

<p>nfds参数值为需要监视的文件描述符的最大值+1。</p>
<p>在使用 select()函数之前，首先使用 FD_ZERO()和 FD_SET()来初始化文件描述符集，在使用了select()函数时，可循环使用 FD_ISSET()来测试描述符集，在执行完对相关文件描述符的操作之后，使用FD_CLR()来清除描述符集。</p>
<p>select 机制的缺陷:</p>
<ul>
<li>内核必须检查多余的文件描述符</li>
<li>每次调用后必须重置被监听的文件描述符集</li>
<li>可监听的文件个数受限制，最大FD_SETSIZE</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>numfds:需要监听的文件个数，fds参数所指向的数组中的元素数目。<br>timeout:表示 poll 阻塞的超时时间(毫秒)。如果该值小于0，则表示无限等待。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll()"></a>epoll()</h3><p>用于代替poll和select，没有大小限制。使用一个文件描述符管理多个文件描述符，使用红黑树存储。同时用事件驱动代替了轮询。epoll_ctl中注册的文件描述符在事件触发的时候会通过回调机制激活该文件描述符。epoll_wait便会收到通知。epoll还采用了mmap虚拟内存映射技术减少用户态和内核态数据传输的开销。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/159457916">https://zhuanlan.zhihu.com/p/159457916</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/c/gnu_c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/c/gnu_c/" class="post-title-link" itemprop="url">GNU extend c syntax</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-13 21:56:50" itemprop="dateCreated datePublished" datetime="2022-08-13T21:56:50+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">c语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GCC 对c语言语法进行了扩展，这些扩展对优化、目标代码布局、更安全的检查等提供了很强的支持，其实这并不完全符合 ANSI C 标准。</p>
<p>gcc如果使用“-ansi –pedantic”编译选项，则不使用 GNU 扩展语法。</p>
<h2 id="语句表达式"><a href="#语句表达式" class="headerlink" title="语句表达式"></a>语句表达式</h2><p>GCC把包含在括号中的复合语句看作是一个表达式，称为语句表达式，它允许在一个表达式内使用循环、跳转、局部变量，并可以出现在任何允许表达式出现的地方。位于括号中的复合语句的最后一句必需是一个以分号结尾的表达式，它的值将成为这个语句表达式的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(x,y) (&#123; \</span></span><br><span class="line"><span class="meta">    const typeof(x) _x = (x); \</span></span><br><span class="line"><span class="meta">    const typeof(y) _y = (y); \</span></span><br><span class="line"><span class="meta">    (void) (&amp;_x == &amp;_y); \</span></span><br><span class="line"><span class="meta">    _x &lt; _y ? _x : _y; &#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="零长数组"><a href="#零长数组" class="headerlink" title="零长数组"></a>零长数组</h2><p>零长数组是长度为0的数组，也可以称之为可变长数组，它并不占用结构的空间，一般用作结构体最后一个成员，用于访问该结构体对象之后的一段内存，来看<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html">GNU C官网</a>的一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="type">char</span> contents[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> *<span class="title">thisline</span> =</span> (<span class="keyword">struct</span> line *)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> line) + this_length);</span><br><span class="line">thisline-&gt;length = this_length;</span><br></pre></td></tr></table></figure>

<p>contents只是结构体之后一段内存的标记，使用时往后申请this_length大的内存，即可使用thisline-&gt;contents进行访问。</p>
<h2 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> debug(format, ...) fprintf(stderr, format, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<p>其中的“…”表示可变参数，实际调用时，它们会替代宏体里的<code>__VA_ARGS__</code>。甚至还可以给可变参数取个名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pr_info(fmt,arg...) printk(KERN_INFO fmt,##arg)</span></span><br></pre></td></tr></table></figure>

<p>其中“##”主要针对参数为空的情况，既然称为可变参数，那传递空参数也是可以的。宏展开后，其中的字符串后面会多个多余的逗号，而“##”则会使预处理器去掉这个多余的逗号。</p>
<h2 id="标号元素"><a href="#标号元素" class="headerlink" title="标号元素"></a>标号元素</h2><p>在标准 C 里，数组或结构变量的初始化值必须以固定的顺序出现，而在 GCC 中，通过指定索引或结构域名，则允许初始化值以任意顺序出现。</p>
<p>指定数组索引的方法是在初始化值前写<code>[INDEX] =</code>，还可以使用<code>[FIRST ... LAST] =</code>的形式指定一个范围，比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num[SIZE] = &#123;</span><br><span class="line">    [<span class="number">0</span>] = <span class="number">0</span>,</span><br><span class="line">    [<span class="number">1</span> ... SIZE] = <span class="number">-1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于结构初始化，使用这种形式，当结构体的定义变化导致元素的偏移位置改变时，仍然可以确保已知元素的正确性。对于未出现在初始化中的元素，其初值为 0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">misc_ops</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = gpio_drv_open,</span><br><span class="line">    .release = gpio_drv_release,</span><br><span class="line">    .unlocked_ioctl = gpio_drv_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="attribute-属性"><a href="#attribute-属性" class="headerlink" title="__attribute__属性"></a>__attribute__属性</h2><ul>
<li><strong>format</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((format(<span class="built_in">printf</span>,m,n)))</span><br><span class="line">__attribute__((format(<span class="built_in">scanf</span>,m,n)))</span><br></pre></td></tr></table></figure>

<p>编译器会检查格式化字符串与“…”的匹配情况，其中参数m与n的含义为：<br>    m 格式化字符串（format string）的位置（顺序从1开始）；<br>    n 参数“…”的位置（顺序从1开始）；</p>
<ul>
<li><strong>availability</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((availability(macosx,introduced=m,deprecated=n)))</span><br></pre></td></tr></table></figure>

<p>指明API版本的变更。m 引入的版本；n 过时的版本</p>
<ul>
<li><strong>deprecated</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((deprecated))</span><br><span class="line">__attribute__((deprecated(s)))</span><br></pre></td></tr></table></figure>

<p>使编译会给出过时的警告。</p>
<ul>
<li><strong>unavailable</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((unavailable))</span><br></pre></td></tr></table></figure>

<p>告诉编译器该方法不可用，如果强行调用编译器会提示错误。比如某个类在构造的时候不想直接通过init来初始化，只能通过特定的初始化方法，就可以将init方法标记为unavailable。</p>
<ul>
<li><strong>const</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((<span class="type">const</span>))</span><br></pre></td></tr></table></figure>

<p>用于带有数值类型参数的函数上。当重复调用带有数值参数的函数时，由于返回值是相同的，所以此时编译器可以进行优化处理，除第一次需要运算外， 其它只需要返回第一次的结果就可以了，进而可以提高效率。该属性主要适用于没有静态状态和副作用的一些函数，并且返回值仅仅依赖输入的参数。（const参数不能用在带有指针类型参数的函数中，因为该属性不但影响函数的参数值，同样也影响到了参数指向的数据，它可能会对代码本身产生严重甚至是不可恢复的严重后果）。</p>
<ul>
<li><strong>cleanup</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((cleanup(...)))</span><br></pre></td></tr></table></figure>

<p>离开作用域之后执行指定的方法。实际应用中可以在作用域结束之后做一些特定的工作，比如清理。</p>
<ul>
<li><strong>constructor / destructor</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">__attribute__((destructor))</span><br><span class="line">__attribute__((constructor(PRIORITY)))</span><br><span class="line">__attribute__((destructor(PRIORITY)))</span><br></pre></td></tr></table></figure>

<p>constructor标志的函数和全局变量对象（或静态变量）的构造函数在main函数之前调用。destructor标志的函数和全局变量对象（或静态变量）的析构函数在main函数之后调用。PRIORITY 为优先级。main函数之前的，数值越小,越先调用；main函数之后的数值越大，越先调用。（可用于动态库注入的Hook）</p>
<ul>
<li><strong>noreturn</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((<span class="keyword">noreturn</span>))</span><br></pre></td></tr></table></figure>

<p>定义有返回值的函数时，而实际情况有可能没有返回值，避免编译器产生警告信息。</p>
<ul>
<li><strong>unused</strong></li>
</ul>
<p>表示该函数或变量可能并不使用,这个属性能够避免编译器产生警告信息。</p>
<ul>
<li><strong>nonnull</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((nonnull(...)))</span><br></pre></td></tr></table></figure>

<p>编译器对函数参数进行NULL的检查</p>
<ul>
<li><strong>aligned</strong></li>
<li><strong>packed</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((aligned (m)))</span><br><span class="line">__attribute__((aligned))</span><br><span class="line">__attribute__((packed))</span><br></pre></td></tr></table></figure>

<p>aligned(m) 将强制编译器尽其所能地确保变量在分配空间时采用m字节对齐方式。packed该属性对struct 或者union 类型进行定义，设定其类型的每个变量按1字节对齐,这个常用于与协议有关的网络传输中，当用在enum 类型定义时，暗示了应该使用最小完整的类型。aligned 属性使被设置的对象占用更多的空间，使用packed 可以减小对象占用的空间。</p>
<ul>
<li><strong>overloadable</strong></li>
</ul>
<p>用于c语言函数,可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型。</p>
<h2 id="builtin函数"><a href="#builtin函数" class="headerlink" title="__builtin函数"></a>__builtin函数</h2><p>GNU C 提供了大量的内建函数，其中大部分是标准 C 库函数的内建版本，不属于库函数的其他内建函数通常以__builtin 开始命名。</p>
<blockquote>
<p>__builtin_return_address(LEVEL)</p>
</blockquote>
<p>返回当前函数或其调用者的返回地址，参数LEVEL 指定调用栈的级数，如 0表 示当前函数的返回地址，1 表示当前函数的调用者的返回地址。</p>
<blockquote>
<p>__builtin_constant_p(EXP)</p>
</blockquote>
<p>用于判断一个值是否为编译时常数，如果参数 EXP的值是常数，函数返回 1，否则返回 0。</p>
<blockquote>
<p>__builtin_expect(long exp, long c)</p>
</blockquote>
<p>这个内建函数的意思就是exp的预期值为c，用于为编译器提供分支预测信息，其返回值是整数表达式exp的值，c的值必须是编译时常数。内核的likely函数就是利用这个实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x)    __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x)  __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>

<p>likely和unlikely主要用于if语句中，当条件被认为是非常有可能满足时，则使用likely()宏，而条件很难满足时，则使用unlikely()宏。好让编译器对这个条件判断进行优化，生成了高效的汇编码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __builtin_types_compatible_p(type_a, type_b);</span><br></pre></td></tr></table></figure>

<p>此函数为GNU扩展，用来判断两个类型是否相同，如果type_a与 type_b相同的话，就会返回1，否则的话，返回0。</p>
<ol>
<li>限定符会被忽略，例如const long和long的类型是相同的。</li>
<li>用typedef定义的类型，当且它们定义的类型是相同的时候，它们才是相同的。</li>
<li>两个enum类型是不相同的。</li>
</ol>
<h2 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h2><p>在include\linux\compiler-gcc.h中__weak是这样定义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __weak              __attribute__((weak))</span></span><br></pre></td></tr></table></figure>

<p>GCC通过<code>__attribute__((weak))</code>指令定义的函数或变量称为弱符号，实际上这个指令大部分时候都是用来定义函数，很少用于定义变量。编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。规则如下：</p>
<ol>
<li>当两者都为强符号时，报错：redefinition of ‘xxx’</li>
<li>当两者为一强一弱时，选取强符号的值</li>
<li>当两者同时为弱时，选择其中占用空间较大的符号，保证至少不会造成诸如溢出、越界等严重后果。</li>
</ol>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>GNU C支持 case x…y 这样的语法，区间[x,y]的数都会满足这个case的条件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> ... <span class="number">4</span> :</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 - 4\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> ... <span class="number">8</span> :</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;5 - 8\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch类型必须是一个整型或枚举类型，因为可以隐式转换，所以char short也是可以的。</p>
<h2 id="typeof-x"><a href="#typeof-x" class="headerlink" title="typeof(x)"></a>typeof(x)</h2><p>typeof(x)语句可以获得x的类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> min(x,y) (&#123; \</span></span><br><span class="line"><span class="meta">    const typeof(x) _x = (x); \</span></span><br><span class="line"><span class="meta">    const typeof(y) _y = (y); \</span></span><br><span class="line"><span class="meta">    (void) (&amp;_x == &amp;_y); \</span></span><br><span class="line"><span class="meta">    _x &lt; _y ? _x : _y; &#125;)</span></span><br></pre></td></tr></table></figure>

<p><code>(void) (&amp;_x == &amp;_y);</code>检查_x 和_y 的类型是否一致。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/c/ipc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/c/ipc/" class="post-title-link" itemprop="url">linux ipc</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-13 21:56:50" itemprop="dateCreated datePublished" datetime="2022-08-13T21:56:50+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">c语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h2><p>无名管道通常用于具有亲缘关系的父子进程或者兄弟进程间通信，是半双工的，数据只能往一个方向流动，先入先出，要想双向通信，需要建立两个管道。</p>
<p><img src="/images/linux/ipc/pipe.png" alt="pipe"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>pipe创建的管道两端处于一个进程中，用于父子进程间的通信。管道建立时会创建两个文件描述符，pipefd[0]固定用于读管道，而pipefd[1]固定用于写管道。</p>
<ol>
<li><p>如果读一个写端已被关闭的管道，在所有数据都被读取后，read返回0指示达到了文件结束处。</p>
</li>
<li><p>只有在管道的读端存在时，向管道写入数据才有意义。否则写一个读端已被关闭的管道，将产生信号SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回，则write出错返回，errno设置为EPIPE。</p>
</li>
<li><p>管道写入数据不保证原子性，管道存在缓冲区，如果读进程不读取管道缓冲区中的数据，那么写操作将会一直阻塞。</p>
</li>
</ol>
<h2 id="标准流管道"><a href="#标准流管道" class="headerlink" title="标准流管道"></a>标准流管道</h2><p><img src="/images/linux/ipc/popen.png" alt="popen"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>popen提供连接到另一个进程的标准输入或标准输出的一个单行管道，创建的管道必须使用标准I/O函数进行操作。popen先执行fork，然后调用exec以执行command，并且返回一个标准I/O文件指针。如果type是”r”，则文件指针连接到command的标准输出。如果type是”w”，则文件指针连接到command的标准输入。</p>
<p>pclose用来关闭创建的管道流，返回由popen所执行的进程的终止状态。</p>
<h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>命名管道在非父子、兄弟进程之间也可相互通信。FIFO遵循先进先出规则，对FIFO的读总是从开始处返回数据，写则把数据添加到末尾，不支持如 lseek()等文件定位操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>对于读进程：</p>
<ul>
<li>若该管道是阻塞打开，且当前 FIFO 内没有数据，则对读进程而言将一直阻塞到有数据写入。</li>
<li>若该管道是非阻塞打开，则不论 FIFO 内是否有数据，读进程都会立即执行读操作。即如果 FIFO<br>内没有数据，则读函数将立刻返回 0。</li>
</ul>
<p>对于写进程：</p>
<ul>
<li><p>若该管道是阻塞打开，则写操作将一直阻塞到数据可以被写入。</p>
</li>
<li><p>若该管道是非阻塞打开而不能写入全部数据，则读操作进行部分写入或者调用失败。</p>
</li>
<li><p>O_RDONLY  读管道</p>
</li>
<li><p>O_WRONLY  写管道</p>
</li>
<li><p>O_RDWR      读写管道</p>
</li>
<li><p>O_NONBLOCK  非阻塞</p>
</li>
<li><p>O_CREAT  如果该文件不存在，那么就创建一个新的文件，并用第三个参数为其设置权限。</p>
</li>
<li><p>O_EXCL   如果使用O_CREAT时文件存在，那么可返回错误消息。可测试文件是否存在。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>返回错误类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>EACCESS</td>
<td>所指定的目录路径无可执行的权限</td>
</tr>
<tr>
<td>EEXIST</td>
<td>所指定的文件已存在</td>
</tr>
<tr>
<td>ENAMETOOLONG</td>
<td>的路径名称太长</td>
</tr>
<tr>
<td>ENOENT</td>
<td>包含的目录不存在</td>
</tr>
<tr>
<td>ENOSPC</td>
<td>文件系统的剩余空间不足</td>
</tr>
<tr>
<td>ENOTDIR</td>
<td>路径中的目录存在但却非真正的目录</td>
</tr>
<tr>
<td>EROFS</td>
<td>指定的文件存在于只读文件系统内</td>
</tr>
</tbody></table>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是软件中断，用于在多个进程之间传递异步信号，可以直接进行用户空间进程和内核进程之间的交互。<code>kill -l</code>命令可以查看系统支持的信号列表。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<ul>
<li>SIGABRT 调用abort函数时产生此信号。进程异常终止。</li>
<li>SIGALRM 超过用alarm函数设置的时间时产生此信号。由setitimer函数设置的间隔时间已经过时。</li>
<li>SIGBUS 指示一个实现定义的硬件故障。</li>
<li>SIGCHLD 在一个进程终止或停止时被送给其父进程。</li>
<li>SIGCONT 此作业控制信号送给需要继续运行的处于停止状态的进程。如果接收到此信号的进程处于停止状态,则系统默认动作是使该进程继续运行，否则默认动作是忽略此信号。</li>
<li>SIGEMT 指示一个实现定义的硬件故障。</li>
<li>SIGFPE 此信号表示一个算术运算异常，例如除以0，浮点溢出等。</li>
<li>SIGHUP 如果终端界面检测到一个连接断开，则将此信号送给与该终端相关的控制进程。</li>
<li>SIGILL 此信号指示进程已执行一条非法硬件指令。</li>
<li>SIGINT 当用户按中断键(Ctrl+C)时，此信号送至前台进程组中的每一个进程。</li>
<li>SIGIO 此信号指示一个异步I/O事件。</li>
<li>SIGIOT 这指示一个实现定义的硬件故障。</li>
<li>SIGKILL  杀死任一进程。不能被捕捉或忽略。</li>
<li>SIGPIPE 如果在读进程已终止时写管道，则产生此信号。当套接口的一端已经终止时，若进程写该套接口也产生此信号。</li>
<li>SIGPOLL 在一个可轮询设备上发生一特定事件时产生此信号。</li>
<li>SIGPROF 当setitimer函数设置的梗概统计间隔时间已经超过时产生此信号。</li>
<li>SIGPWR 它主要用于具有不间断电源(UPS)的系统上。蓄电池电压过低时将信号发送给init进程，然后由init处理停机操作。</li>
<li>SIGQUIT 当用户在终端上按退出键(Ctrl+)时，产生此信号，并送至前台进程组中的所有进程。终止前台进程组并产生core文件。</li>
<li>SIGSEGV 指示进程进行了一次无效的存储访问。</li>
<li>SIGSTOP 这是一个作业控制信号，它停止一个进程。不能被捕捉或忽略。</li>
<li>SIGSYS 指示一个无效的系统调用。</li>
<li>SIGTERM kill命令发送的系统默认终止信号。</li>
<li>SIGTRAP 指示一个实现定义的硬件故障。</li>
<li>SIGTSTP 交互停止信号，当用户在终端上按挂起键(Ctrl+Z)时，终端驱动程序产生此信号。</li>
<li>SIGTTIN 当一个后台进程组进程试图读其控制终端时，终端驱动程序产生此信号。当读进程忽略或阻塞此信号，或读进程所属的进程组是孤儿进程组时不产生此信号，读操作出错并设置errno。</li>
<li>SIGTTOU 当一个后台进程组进程试图写其控制终端时产生此信号。当写进程忽略或阻塞此信号，或写进程所属的进程组是孤儿进程组时不产生此信号，写操作出错并设置errno。</li>
<li>SIGURG 此信号通知进程已经发生一个紧急情况。在网络连接上，接到非规定波特率的数据时，此信号可选择地产生。</li>
<li>SIGUSR1 这是一个用户定义的信号，可用于应用程序。</li>
<li>SIGUSR2 这是一个用户定义的信号，可用于应用程序。</li>
<li>SIGVTALRM 当一个由setitimer函数设置的虚拟间隔时间已经超过时产生此信号。</li>
<li>SIGWINCH 如果一个进程用ioctl设置窗口大小命令更改了窗口大小，则内核将信号送至前台进程组。</li>
<li>SIGXCPU 如果进程超过了其软CPU时间限制，则产生此信号。</li>
<li>SIGXFSZ 如果进程超过了其软文件长度限制产生此信号。</li>
</ul>
<p>一个完整的信号生命周期可以分为几个阶段：信号产生、信号在进程中注册、信号在进程中注销、执行信号处理函数。</p>
<p><strong>signal()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_ERR  ((__sighandler_t) -1) <span class="comment">/* Error return.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_DFL  ((__sighandler_t)  0) <span class="comment">/* Default action.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_IGN  ((__sighandler_t)  1) <span class="comment">/* Ignore signal.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>

<p>对于handler参数：</p>
<ul>
<li>SIG_IGN  表示忽略此信号(SIGKILL和SIGSTOP不能忽略)</li>
<li>SIG_DFL  表示执行系统默认动作。</li>
<li>自定义的信号处理函数指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="type">int</span>        sa_flags;</span><br><span class="line">    <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/ipc/sighandle_r.png" alt="sighandle_r"></p>
<p><strong>raise()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p>raise()给进程本身发送信号。</p>
<p><strong>kill()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p>kill()给一个进程发送信号，pid参数:</p>
<ul>
<li><code>pid &gt; 0</code>   将信号发送给pid相等的进程。</li>
<li><code>pid == 0</code>  将信号发送给与其进程组ID相等的进程。</li>
<li><code>pid &lt; 0</code>   将信号发送给进程组ID等于pid绝对值的进程。</li>
</ul>
<p>进程将信号发送给其他进程需要许可权，对于非root用户，其规则是发送者的实际或有效用户ID必须等于接收者的实际或有效用户ID。</p>
<p><strong>alarm()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<p>alarm()函数可以设置一个闹钟时间，超时后产生SIGALRM信号，如果不忽略或不捕捉此信号，则其默认动作是终止进程。</p>
<p>每个进程只能有一个闹钟时间。如果在调用alarm()时，以前已设置过闹钟时间，而且还没有超时，则该闹钟时间的余留值作为本次函数调用的值返回，以前登记的闹钟时间则被新值代换。</p>
<p><strong>pause()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>pause()函数是用于将调用进程挂起直至捕捉到信号为止。</p>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量用于进程同步，只有获得了信号量的进程才可以运行，没有获得信号量的进程则只能等待。</p>
<p>信号量包括一个称为信号量的变量和在该信号量下等待资源的进程等待队列，以及对信号量进行的两个原子操作(PV操作)。其中信号量对应于某一种资源，取一个非负的整型值，信号量值指的是当前可用的该资源的数量，若它等于 0 则意味着目前没有可用的资源。PV原子操作的具体定义如下:</p>
<ul>
<li><p>P操作：获得信号量，将值-1。如果值非负，表明有可用的资源，则占用一个资源直接返回，否则被阻塞，直到别的任务释放该信号量才能运行。它会导致调用的进程睡眠，因此不能在中断上下文使用。</p>
</li>
<li><p>V操作：释放信号量，把值+1，如果值为非正数，表明有任务等待该信号量，因此唤醒这些任务。</p>
</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>因为进程可以直接读写内存，不需要任何数据的复制。为了在多个进程间交换信息，内核专门留出了一块内存区。这段内存区可以由需要访问的进<br>程将其映射到自己的私有地址空间。因此，进程就可以直接读写这一内存区而不需要进行数据的复制，从而大大提高了效率。当然，由于多个进程共享一段内存，因此也需要有相应的同步机制。</p>
<p><code>ipcs -m</code>命令可以查看系统的共享内存，共享存储段紧靠在栈之下。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链表，存放在内核中并由消息队列标识符标识，用户可以从消息队列中添加消息和读取消息等，消息队列具有一定的FIFO特性，但是也可以按消息的类型字段随机查取消息。</p>
<p>消息队列的实现包括创建或打开消息队列、添加消息、读取消息和控制消息队列这 4 种操作：</p>
<ul>
<li>创建或打开消息队列使用的函数是 msgget()，这里创建的消息队列的数量会受到系统消息队列数量的限制。</li>
<li>添加消息使用的函数是 msgsnd()函数，它把消息添加到已打开的消息队列末尾。</li>
<li>读取消息使用的函数是msgrcv()，它把消息从消息队列中取走，与 FIFO 不同的是，这里可以指定取走某一条消息。</li>
<li>控制消息队列使用的函数是 msgctl()。</li>
</ul>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/c/stdio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/c/stdio/" class="post-title-link" itemprop="url">linux standard io</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-13 21:56:50" itemprop="dateCreated datePublished" datetime="2022-08-13T21:56:50+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">c语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>标准I/O提供了三种类型的缓存:</p>
<ul>
<li>全缓存，当填满缓存后才进行实际I/O操作，对于驻在磁盘上的文件通常是由标准I/O库实施全缓存的。</li>
<li>行缓存，当在输入和输出中遇到新行符时才执行I/O操作，标准输入和标准输出就是使用行缓冲。</li>
<li>不带缓存。标准出错流stderr通常是不带缓存的，使得出错信息可以尽快显示出来。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>setbuf函数打开或关闭缓存机制。为了带缓存进行I/O，参数buf必须指向一个长度为BUFSIZ的缓存，设置后通常该流是全缓存的，但如果该流与一个终端设备相关，某些系统可能将其设置为行缓存。将buf设置为NUL可可以关闭缓存。</p>
<p>setvbuf可以精确地设置缓存类型。这是依靠mode参数实现的:</p>
<ul>
<li>_IOFBF 全缓存</li>
<li>_IOLBF 行缓存</li>
<li>_IONBF 不带缓存</li>
</ul>
<p><img src="/images/linux/stdio/setbuf.png" alt="setbuf"></p>
<h2 id="fflush"><a href="#fflush" class="headerlink" title="fflush()"></a>fflush()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>刷新流的输出缓冲区，若fp是NULL，则此函数刷新所有输出流。</p>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>fopen打开一个标准I/O流，返回:若成功则为文件指针，若出错则为NULL，并设置errno。mode参数指定对该I/O流的读、写方式:</p>
<table>
<thead>
<tr>
<th>字符串</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读方式打开文件，该文件必须存在</td>
</tr>
<tr>
<td>r+</td>
<td>以读/写方式打开文件，该文件必须存在</td>
</tr>
<tr>
<td>rb+</td>
<td>以读/写方式打开一个二进制文件，只允许读/写数据</td>
</tr>
<tr>
<td>rt+</td>
<td>以读/写方式打开一个文本文件，允许读和写</td>
</tr>
<tr>
<td>w</td>
<td>打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件</td>
</tr>
<tr>
<td>w+</td>
<td>打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件</td>
</tr>
<tr>
<td>a</td>
<td>以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）</td>
</tr>
<tr>
<td>a+</td>
<td>以附加方式打开可读/写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）</td>
</tr>
<tr>
<td>wb</td>
<td>以只写方式打开或新建一个二进制文件，只允许写数据</td>
</tr>
<tr>
<td>wb+</td>
<td>以读/写方式打开或新建一个二进制文件，允许读和写</td>
</tr>
<tr>
<td>wt+</td>
<td>以读/写方式打开或新建一个文本文件，允许读和写</td>
</tr>
<tr>
<td>at+</td>
<td>以读/写方式打开一个文本文件，允许读或在文本末追加数据</td>
</tr>
<tr>
<td>ab+</td>
<td>以读/写方式打开一个二进制文件，允许读或在文件末追加数据</td>
</tr>
</tbody></table>
<p><img src="/images/linux/stdio/io_mode.png" alt="io_mode"></p>
<ol>
<li>以 x 结尾的模式为独占模式，文件已存在或者无法创建（一般是路径不正确）都会导致 fopen 失败。文件以操作系统支持的独占模式打开。</li>
<li>上述的形态字符串都可以加入 b 字符用来告诉函数库以二进制模式打开文件。如果不加 b，表示默认加了 t，表示以文本模式打开文件。</li>
<li>由 fopen() 所建立的新文件会具有_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666) 权限，此文件权限也会参考umask值。</li>
<li>有些 C编译系统可能不完全提供所有这些功能，有的C版本不”r+”、”w+”、”a+”，而用”rw”、”wr”、”ar”等。</li>
<li>在Windows系统中，文本模式下，文件以”\r\n”代表换行，若以文本模式打开文件，并用 fputs 等函数写入换行符”\n”时，函数会自动在”\n”前面加上”\r”，即实际写入文件的是”\r\n”。</li>
<li>在类 Unix/Linux 系统中文本模式下，文件以”\n”代表换行。所以 Linux 系统中在文本模式和二进制模式下并无区别。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">FILE *<span class="title function_">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>fdopen可以将文件描述符转为文件指针，写打开时并不截短该文件，因为描述符已被打开。</p>
<h2 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc()"></a>fgetc()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>一次读一个字符，fgetc不能实现为宏。返回:若成功则为下一个字符，若已处文件尾端或出错则为EOF(-1)，<code>Ctrl+d</code>可产生1个EOF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>FILE对象中有出错标志和文件结束标志，feof和ferror可以用来判断这些标志，若条件为真返回非0，否则为0。clearerr则清除这两个标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>从一个流读之后，ungetc将字符再送回流中，返回:若成功则为c,若出错则为EOF。回送的字符，不一定要是上一次读到的字符。EOF不能回送。已经到达文件尾端时，仍可以回送一字符。</p>
<h2 id="fputc"><a href="#fputc" class="headerlink" title="fputc()"></a>fputc()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="fgets-fputs"><a href="#fgets-fputs" class="headerlink" title="fgets() fputs()"></a>fgets() fputs()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p>fgets必须指定缓存的长度n，一直读到下一个新行符为止，但是不超过n-1个字符，读入的字符被送入缓存，缓存以’\0’字符结尾。如若该行包括最后一个新行符的字符数超过n-1，则只返回一个不完整的行，而且缓存总是以’\0’字符结尾，对fgets的下一次调用会继续读该行。</p>
<p>gets并不将新行符存入缓存中，已经被停用，因为不能指定缓存的长度，会造成缓存越界。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p>fputs将一个以’\0’终止的字符串写到指定的流，终止符’\0’不写出。</p>
<h2 id="fread-fwrite"><a href="#fread-fwrite" class="headerlink" title="fread() fwrite()"></a>fread() fwrite()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb,FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>fread和fwrite返回读或写的对象数。对于读，如果出错或到达文件尾端，则此返回値小于nmemb，应调用ferror或feof判断是那一种情况。对于写，如果返回值小于nmemb，则出错。</p>
<p>当用来读写结构体时，应当考虑不同系统之间的结构体对齐方式，整数和浮点数的存储格式的不同。</p>
<h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>fseek定位一个二进制文件，必须指定一个字节offset，whence是位移量的方式:</p>
<ul>
<li>SEEK_SET  表示从文件的起始位置开始</li>
<li>SEEK_CUR  表示从当前文件位置</li>
<li>SEEK_END  表示从文件的尾端</li>
</ul>
<p>对于文本文件，whence一定要是SEEK_SET，而且offset只能有两种值:0 表示文件起始位置；或ftell所返回的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>ftell返回当前文件的位置指示，若出错则为-1。<br>rewind函数也可将一个流设置到文件的起始位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE *stream, <span class="type">fpos_t</span> *pos)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span>;</span><br></pre></td></tr></table></figure>

<p>fgetpos将文件位置指示器的当前值存入由pos指向的对象中。以后调用fsetpos时，可以使用此值将流重新定位至该位置。</p>
<h2 id="fprintf-sprintf"><a href="#fprintf-sprintf" class="headerlink" title="fprintf() sprintf()"></a>fprintf() sprintf()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>格式化数据到流，成功返回输出字符数。</p>
<h2 id="fscanf-sscanf"><a href="#fscanf-sscanf" class="headerlink" title="fscanf() sscanf()"></a>fscanf() sscanf()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="fileno"><a href="#fileno" class="headerlink" title="fileno()"></a>fileno()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>获得流的描述符。</p>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">tmpnam</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">tempnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dir, <span class="type">const</span> <span class="type">char</span> *pfx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> P_tmpdir</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> P_tmpdir <span class="string">&quot;/tmp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TMP_MAX</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TMP_MAX 238328</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>tmpnam()在tmp目录下产生一个有效路径名字符串，最多调用次数是TMP_MAX。该使用不安全，建议用mkstemp代替。</p>
<ul>
<li>若ptr是NULL，则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。下一次再调用tmpnam时，会重写该静态区。</li>
<li>若ptr不是NULL，则它指向长度至少是L_tmpnam个字符的数组。产生的路径名存放在该数组中，ptr也作为函数值返回。</li>
</ul>
<p>tmpfile创建一个临时二进制文件(类型wb+)，在关闭该文件或程序结束时会自动删除。</p>
<p>tempnam可以指定临时文件的目录和前缀。对于目录有四种不同的优先选择：</p>
<ol>
<li>如果定义了环境变量TMPDIR，则用作为目录。</li>
<li>如果参数directory非NULL，则用作为目录。</li>
<li>将&lt;stdio.h&gt;中的字符串P_tmpdir作为目录。</li>
<li>将/tmp作为目录。如果prefix非NULL，则它至少5个字节。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkostemp</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemps</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> suffixlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkostemps</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> suffixlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>创建一个惟一的临时文件，并返回文件的描述符，各文件路径，所以template必须是数组，且后6个字符为”XXXXXX”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/c/pthread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/c/pthread/" class="post-title-link" itemprop="url">linux pthread</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-13 21:56:50" itemprop="dateCreated datePublished" datetime="2022-08-13T21:56:50+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>进程是系统中程序执行和资源分配的基本单位，每个进程都拥有自己的数据段、代码段和堆栈段，这就造成进程在进行切换时需要消耗更多的处理器空转时间，为了减少上下文切换开销，进程在演化中出现了线程。</p>
<p>线程处理器调度的最小单元。线程可以访问进程的内存空间和资源，并与同一进程中的其他线程共享，因此线程的上下文切换的开销比创建进程小很多。同进程一样，线程也将相关的执行状态和存储变量放在线程控制表内，一个进程可以有多个线程，也就是有多个线程控制表及堆栈寄存器，但却共享一个用户地址空间。由于线程共享了进程的资源和地址空间，因此任何线程对系统资源的操作都会给其他线程带来影响，必须考虑线程间资源访问的同步与互斥问题。</p>
<p>线程按照其调度者可以分为用户级线程和核心级线程两种：</p>
<ul>
<li><p>用户级线程主要解决的是上下文切换的问题，它的调度算法和调度过程全部由用户自行选择决定，在运行时不需要内核支持。系统往往会提供一个用户空间的线程库，该线程库提供了线程的创建、调度和撤销等功能，而内核仍然仅对进程进行管理。如果一个进程中的某一个线程调用了一个阻塞的系统调用函数，那么该进程包括该进程中的其他所有线程也同时被阻塞。这种用户级线程的主要缺点是在一个进程中的多个线程的调度中无法发挥多处理器的优势。</p>
</li>
<li><p>内核级线程允许不同进程中的线程按照同一相对优先调度方法进行调度，这样就可以发挥多处理器的并发优势。</p>
</li>
</ul>
<p>现在大多数系统都采用用户级线程与核心级线程并存的方法，一个用户级线程可以对应一个或几个核心级线程，这样既可满足多处理机系统的需要，也可以最大限度地减少调度开销。</p>
<p>gcc在编译时要链接libpthread库<code>gcc -lpthread</code>。</p>
<h2 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁是用一种简单的加锁方法来控制对共享资源按顺序进行原子操作。这个互斥锁只有两种状态，也就是上锁和解锁，在同一时刻只能有一个线程掌握某个互斥锁，拥有上锁状态的线程能够对共享资源进行操作，若其他线程希望上锁一个已经被上锁的互斥锁，则该线程就会挂起，直到上锁的线程释放掉互斥锁为止。</p>
<p>互斥锁可以分为快速互斥锁、递归互斥锁和检错互斥锁，区别在于其他未占有互斥锁的线程在希望得到互斥锁时是否需要阻塞等待，默认为快速互斥锁。</p>
<ul>
<li>快速锁是指调用线程会阻塞，直至拥有互斥锁的线程解锁为止。</li>
<li>递归互斥锁能够成功地返回，并且在调用线程互斥上多次加锁。</li>
<li>检错互斥锁则为快速互斥锁的非阻塞版本，它会立即返回并返回一个错误信息。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span> <span class="params">(<span class="keyword">struct</span> __pthread_mutex *__restrict __mutex,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *__restrict __attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span> <span class="params">(<span class="keyword">struct</span> __pthread_mutex *__mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread_mutex_init()创建互斥锁，attr参数：</p>
<ul>
<li>PTHREAD_MUTEX_INITIALIZER  创建快速互斥锁</li>
<li>PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP   创建递归互斥锁</li>
<li>PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP  创建检错互斥锁</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>pthread_create()函数的第二个参数attr表示线程的属性，默认为非绑定、非分离、缺省1M的堆栈以及与父进程同样级别的优先级。</p>
<ul>
<li><p>绑定属性：一个用户线程固定地分配给一个内核线程，可以保证在需要的时候总有一个内核线程与之对应。</p>
</li>
<li><p>非绑定属性：用户线程和内核线程的关系不是始终固定的，由系统来控制分配。</p>
</li>
<li><p>分离属性：线程结束时会立即释放它所占有的系统资源，如果这个线程运行非常快，可能在pthread_create()函数返回之前就终止了，系统就可能将线程号和系统资源移交给其他的线程使用，从而导致出错。</p>
</li>
<li><p>非分离属性：线程结束时要等 pthread_join()函数返回，才释放自己占用的系统资源。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scheduling algorithms.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_OTHER 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_FIFO  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_RR    2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> &#123;</span></span><br><span class="line">   <span class="type">int</span> sched_priority;     <span class="comment">/* Scheduling priority */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setscope</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> scope)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getscope</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *scope)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setschedpolicy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getschedpolicy</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *policy)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setschedparam</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getschedparam</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="keyword">struct</span> sched_param *param)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread_attr_init() 初始化线程属性。pthread_attr_destroy() 对分配的属性结构指针进行清理和回收。</p>
<p>pthread_attr_setscope() 设置绑定属性：</p>
<ul>
<li>PTHREAD_SCOPE_SYSTEM  绑定</li>
<li>PTHREAD_SCOPE_PROCESS  非绑定</li>
</ul>
<p>pthread_attr_setdetachstate() 设置线程分离属性：</p>
<ul>
<li>PTHREAD_CREATE_DETACHED  分离</li>
<li>PTHREAD _CREATE_JOINABLE  非分离</li>
</ul>
<p>pthread_attr_getschedparam() 获取线程优先级。pthread_attr_setschedparam() 设置线程优先级，设置之前可用sched_get_priority_max() 确定优先级的取値范围。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_max</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_min</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/14/linux/file_mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/linux/file_mode/" class="post-title-link" itemprop="url">linux file mode</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-14 20:13:02" itemprop="dateCreated datePublished" datetime="2022-07-14T20:13:02+08:00">2022-07-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实际用户ID：真实用户，就是登陆系统时的身份ID。<br>有效用户ID：是进程的属性，决定了进程对文件的访问权限。</p>
<p>r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。</p>
<p>w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。</p>
<p>x(execute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。</p>
<p>i不可修改权限。通过<code>chattr + i</code>  <code>chattr - i</code>来设置，用<code>lsattr</code>命令查看。</p>
<p>a只追加权限，对于日志系统很好用，让目标文件只能追加，不能删除，而且不能通过编辑器追加。通过<code>chattr +a</code>  <code>chattr -a</code>来设置。</p>
<h2 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h2><p>SUID全称Set User ID，当小写字母s出现在文件拥有者权限的执行位上，具有这种权限的二进制会在其执行时，使调用者暂时获得该文件拥有者的权限，原理是将进程的有效ID临时更改为文件的所有者ID。例如passwd命令便是个设置了SUID的程序，使得普通用户无读写/etc/shadow文件的权限，也可以修改自己的密码。</p>
<ol>
<li>只对二进制文件有效，不能作用于目录或Shell脚本；</li>
<li>调用者对该文件有执行权，必须先设置x权限</li>
<li>在执行过程中，调用者会暂时获得该文件的所有者权限；</li>
<li>该权限只在程序执行的过程中有效。</li>
</ol>
<p>当ls -l 看到rwS，大写S说明SUID权限未生效。</p>
<h2 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h2><p>SGID全称Set Group ID，当小写字母s出现在文件用户组的执行权限位上，它对普通二进制文件和目录都有效。当它作用于普通文件时，和SUID类似，在执行该文件时，用户将获得该文件所属组的权限。当SGID作用于目录时，当用户对某一目录有写和执行权限时，该用户就可以在该目录下建立文件，如果该目录用SGID修饰，则该用户在这个目录下建立的文件都是属于这个目录所属的组。</p>
<p>大写S表明该文件的SGID属性无效，比如给一个不可执行的文件设置SGID属性。</p>
<h2 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h2><p>SBIT全称Sticky Bit（粘滞位），它出现在其他用户权限的执行位上，只能用来修饰一个目录。当某一个目录拥有SBIT权限时，则任何的用户都能够在这个目录下创建文档，但只能删除自己创建的文档，用来阻止非文件的所有者删除文件。例如/tmp目录。可通过<code>chmod + t</code>  <code>chmod - t</code>  <code>chmod 1777</code>来设置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/14/cpp/c++98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/cpp/c++98/" class="post-title-link" itemprop="url">C++98</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-14 20:13:02" itemprop="dateCreated datePublished" datetime="2022-07-14T20:13:02+08:00">2022-07-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>名称空间是给代码限定使用空间，有助于降低命名冲突的风险。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">using <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">using <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><p>由于c语言和C++的符号修饰方式不同，函数用extern “C”声明，告诉编译器对此函数使用c语言的方式来处理，则此函数的符号就是按c语言方式生成的，可以避免 C++ 因符号修饰导致代码不能和c语言库中的符号进行链接的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>在定义函数时给参数一个缺省値，在使用函数时，如果函数调用时没有传递参数，就使用默认参数。</p>
<ol>
<li>如果某个参数是默认参数，那么它后面的参数必须都是默认参数。</li>
<li>默认参数只能放到函数声明或定义两者之一，如果放在函数定义中，那就只能在当前文件中调用该函数。</li>
<li>在多态中，重载的函数不要使用默认参数，因为默认参数是静态绑定，虚函数是动态绑定。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNum</span><span class="params">(<span class="type">int</span> n = <span class="number">4</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用只能绑定对象，不能是字面值。引用的类型要和初始化的类型一致。</p>
<p>引用与指针的区别：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<p>引用作为函数返回值时，不能返回局部数据的引用，因为当函数调用完成后局部数据就会被销毁，C++ 编译器检测到该行为时也会给出警告。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">//分配1个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">//释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">//分配10个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// placement new</span></span><br><span class="line">p2 = <span class="built_in">new</span>(p) <span class="built_in">int</span>();  <span class="comment">// 在p所指向的内存分配一个int对象</span></span><br></pre></td></tr></table></figure>

<p>new和delete不是库函数，而是 c++的运算符。new 是在堆区分配内存，必须手动释放。为了避免内存泄露，new 和 delete、new[] 和 delete[] 操作符应该配对使用。new和delete会自动调用构造函数和析构函数。</p>
<p>使用 new 在堆上生成对象，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 运算符重载为私有，那么第一阶段就无法完成，也就不能够在堆上构造对象了。</p>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p><strong>typeid</strong></p>
<p>typeid 运算符返回一个表达式的类型信息。对于基本数据类型，类型信息指数据的类型。对于类类型的数据，类型信息是指对象所属的类、所包含的成员、所在的继承关系等。经常被用来判断两个类型是否相等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">typeid</span>(ClassA) == <span class="built_in">typeid</span>(object)</span><br></pre></td></tr></table></figure>

<p>typeid 会把获取到的类型信息保存到一个 type_info 类型的对象里面，并返回该对象的常引用，当需要具体的类型信息时，可以通过成员函数来提取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">type_info</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">type_info</span>();</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>==(<span class="type">const</span> type_info&amp; rhs) <span class="type">const</span>;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>!=(<span class="type">const</span> type_info&amp; rhs) <span class="type">const</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">before</span><span class="params">(<span class="type">const</span> type_info&amp; rhs)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">raw_name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> *_m_data;</span><br><span class="line">    <span class="type">char</span> _m_d_name[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">type_info</span>(<span class="type">const</span> type_info&amp; rhs);</span><br><span class="line">    type_info&amp; <span class="keyword">operator</span>=(<span class="type">const</span> type_info&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了减小编译后文件的体积，编译器不会为所有的类型创建 type_info 对象，一个类型不管使用了多少次，编译器都只为它创建一个type_info 对象，所有 typeid 都返回这个对象的引用。不过有一种特殊情况，就是带虚函数的类（包括继承来的），不管有没有使用 typeid 运算符，编译器都会为带虚函数的类创建 type_info 对象。</p>
<p><strong>decltype</strong></p>
<p>decltype()返回操作数的数据类型。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li><code>const_cast</code>  去掉表达式的const或volatile属性</li>
<li><code>static_cast</code>  基本类型静态显式转换</li>
<li><code>dynamic_cast</code>  多态类之间转换，运行时检查类型安全，转换失败返回NULL，使用时需要检查返回値。</li>
<li><code>reinterpret_cast</code>  将任何指针转换为任何其他指针类型，对二进制重新解释类型，比如指针转整型，取地址値。</li>
</ul>
<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>RAII(Resource Acquisition Is Initialization)是 C++ 所特有的资源管理方式。RAII 依托栈和析构函数，来对所有的资源，包括堆内存在内进行管理。有了RAII使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。</p>
<p>内存管理器的操作：</p>
<ol>
<li>让内存管理器分配一个某个大小的内存块</li>
<li>让内存管理器释放一个之前分配的内存块让内存管理器进行垃圾收集操作，</li>
<li>寻找不再使用的内存块并予以释放</li>
</ol>
<p>C++ 通常会做上面的操作 1 和 2。Java 会做上面的操作 1 和 3。而 Python 会做上面的操作 1、2、3。这是语言的特性和实现方式决定的。</p>
<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p>bitset是用于处理位标志的类，它提供了一些位操作的函数和运算符。</p>
<table>
<thead>
<tr>
<th align="center">运算符/函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;&lt;</td>
<td>将位序列的文本表示插入到输出流中</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td>将一个字符串插入到 bitset 对象中</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td align="center">|</td>
<td>按位或</td>
</tr>
<tr>
<td align="center">^</td>
<td>按位异或</td>
</tr>
<tr>
<td align="center">~</td>
<td>按位取反</td>
</tr>
<tr>
<td align="center">&gt;&gt;=</td>
<td>按位右移</td>
</tr>
<tr>
<td align="center">&lt;&lt;=</td>
<td>按位左移</td>
</tr>
<tr>
<td align="center">[N]</td>
<td>返回指向位序列中第N位的引用</td>
</tr>
<tr>
<td align="center">set()</td>
<td>所有位都设置为 1</td>
</tr>
<tr>
<td align="center">set (N, val=1)</td>
<td>将第 N 位设置为 val 指定的值(默认为 1)</td>
</tr>
<tr>
<td align="center">reset()</td>
<td>所有位都重置为 0</td>
</tr>
<tr>
<td align="center">reset (N)</td>
<td>将N位清除</td>
</tr>
<tr>
<td align="center">filp()</td>
<td>将位序列中的所有位取反</td>
</tr>
<tr>
<td align="center">size()</td>
<td>返回序列中的位数</td>
</tr>
<tr>
<td align="center">count()</td>
<td>返回序列中值为 1 的位数</td>
</tr>
</tbody></table>
<h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><p>restrict是c99标准引入的，它用于限定和约束指针，表明指针是访问一个数据对象的唯一且初始的方式，而不能通过其它指针来修改，这样可以帮助编译器会优化代码。restrict修饰的指针主要用于函数形参，说明指针参数不指向同一数据，或指向由malloc()分配的内存空间。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>用register声明的变量是寄存器变量存放在CPU的寄存器里的。运算速度快，因为不是存放在内存，所以不能取地址。只能用于局部变量和函数形参。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改，告诉编译器不应对这样的对象进行优化。volatile 关键字声明的变量，每次访问时都必须从内存中取出值。没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值<br>const 可以是 volatile（只读的状态寄存器）；指针可以是 volatile（指向一段内存地址）。</p>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>在c++中结构体中的成员默认都是 public 属性，默认是 public 继承，且不能使用模块。</p>
<h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值，当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是static的</li>
</ul>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>内联函数在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</p>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p><code>explicit</code>关键字用于修饰类的单参数构造函数，限定此构造函数只能显示初始化当前类，防止其它类对象通过隐式转换作为参数传入。无参构造函数和多参构造函数本身就是显示调用，加了没意义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">//  People(int num) &#123;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">People</span><span class="params">(<span class="type">int</span> name)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    People a1 = <span class="built_in">People</span>(<span class="number">1</span>);</span><br><span class="line">    People a2 = <span class="number">2</span>; <span class="comment">// 没有报错，正常应该 error: conversion from ‘int’ to non-scalar type ‘People</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>pair将一对值(T1和T2)组合成一个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">3</span>, <span class="string">&quot;aaa&quot;</span>)</span></span>;</span><br><span class="line">    pair&lt;<span class="type">int</span>, string&gt; p2 = <span class="built_in">make_pair</span>(<span class="number">6</span>, <span class="string">&quot;nnn&quot;</span>);</span><br><span class="line">    pair&lt;<span class="type">int</span>, string&gt; p3;</span><br><span class="line"></span><br><span class="line">    p3.first = <span class="number">8</span>;</span><br><span class="line">    p3.second = <span class="string">&quot;rrr&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="built_in">tie</span>(num, name) = p1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h2><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>函数模板里调用另一个函数模板时，最外层的函数模板参数通常是万能引用，传递一个右值到外层，再转给内层时参数变成了左值，原参数属性丢失了。</p>
<p><strong>引用折叠</strong></p>
<ul>
<li>引用的引用折叠成左值引用(<code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 折叠成 <code>X&amp;</code>)</li>
<li>右值引用的右值引用，折叠成右值引用(<code>X&amp;&amp; &amp;&amp;</code> 折叠成 <code>X&amp;&amp;</code>)</li>
</ul>
<p><strong>万能引用</strong></p>
<p>即可以绑定到左值引用，也可以绑定到右值引用，并且不能保持左右值的const属性的函数模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(T&amp;&amp; v)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="std-ref"><a href="#std-ref" class="headerlink" title="std::ref"></a>std::ref</h2><p>可以在模板传参时传入引用，对于std::bind 或 std::thread，可以显式通过std::ref来绑定引用进行传参。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/26/net/tcpdump/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/26/net/tcpdump/" class="post-title-link" itemprop="url">tcpdump 使用指南</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-26 17:51:09 / 修改时间：18:44:41" itemprop="dateCreated datePublished" datetime="2022-06-26T17:51:09+08:00">2022-06-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcpdump [ -AdDeflLnNOpqRStuUvxX ] [ -c count ]</span><br><span class="line">           [ -C file_size ] [ -F file ]</span><br><span class="line">           [ -i interface ] [ -m module ] [ -M secret ]</span><br><span class="line">           [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]</span><br><span class="line">           [ -W filecount ]</span><br><span class="line">           [ -E spi@ipaddr algo:secret,...  ]</span><br><span class="line">           [ -y datalinktype ] [ -Z user ]</span><br><span class="line">           [ expression ]</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p><img src="/images/net/tcpdump.png"></p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>可以使用表达式过滤指定类型的流量，有三种主要的表达式类型：</p>
<ul>
<li>类型（type）选项包含：host, net, port, portrange</li>
<li>方向（dir）选项包含：src, dst, src or dst</li>
<li>协议（proto）选项包含：tcp, udp, icmp, ip, ip6, arp, rarp,ether,wlan, fddi, tr, decnet</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>捕获所有流量</strong></p>
<pre><code>tcpdump -i any
</code></pre>
<p><strong>指定网卡接口</strong></p>
<pre><code>tcpdump -i eth0
</code></pre>
<p><strong>基于IP地址过滤</strong></p>
<pre><code>tcpdump host 192.168.10.100
</code></pre>
<p><strong>查看包中的内容时，使用hex格式输出</strong></p>
<pre><code>tcpdump -nnvXSs 0 -c1 icmp
</code></pre>
<p><strong>使用源和目的地址过滤</strong></p>
<pre><code>tcpdump src 2.3.4.6
tcpdump dst 3.4.5.6
</code></pre>
<p><strong>基于网段进行过滤</strong></p>
<pre><code>tcpdump net 192.168.10.0/24
</code></pre>
<p><strong>基于端口进行过滤</strong></p>
<pre><code>tcpdump port 8088
</code></pre>
<p><strong>过滤指定协议</strong></p>
<pre><code>tcpdump icmp
</code></pre>
<p><strong>只显示IPV6流量</strong></p>
<pre><code>tcpdump ip6
</code></pre>
<p><strong>使用端口范围过滤</strong></p>
<pre><code>tcpdump portrange 21-23
</code></pre>
<p><strong>基于包的大小过滤流量</strong></p>
<pre><code>tcpdump less 32
tcpdump greater 64
tcpdump &lt;=128
</code></pre>
<p><strong>过滤广播/多播数据包</strong></p>
<pre><code>tcpdump ip broadcast
tcpdump ip multicast
</code></pre>
<p><strong>将捕获的内容写入文件</strong></p>
<pre><code>tcpdump port 8080 -w capturefile.pcap
</code></pre>
<p><strong>使用tcpdump加载之前保存的文件进行分析</strong></p>
<pre><code>tcpdump -r capturefile.pcap
</code></pre>
<p><strong>设置不解析域名提升速度</strong></p>
<ul>
<li><code>-n</code>：不把ip转化成域名，直接显示 ip，避免执行 DNS lookups 的过程，速度会快很多</li>
<li><code>-nn</code>：不把协议和端口号转化成名字，速度也会快很多。</li>
<li><code>-N</code>：不打印出host 的域名部分.。比如,，如果设置了此选现，tcpdump 将会打印’nic’ 而不是 ‘nic.ddn.mil’.</li>
</ul>
<p><strong>控制详细内容的输出</strong></p>
<ul>
<li><code>-v</code>：产生详细的输出. 比如包的TTL，id标识，数据包长度，以及IP包的一些选项。同时它还会打开一些附加的包完整性检测，比如对IP或ICMP包头部的校验和。</li>
<li><code>-vv</code>：产生比-v更详细的输出. 比如NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码。（摘自网络，目前我还未使用过）</li>
<li><code>-vvv</code>：产生比-vv更详细的输出。比如 telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面，其相应的图形选项将会以16进制的方式打印出来（摘自网络，目前我还未使用过）</li>
</ul>
<p><strong>控制时间的显示</strong></p>
<ul>
<li><code>-t</code>：在每行的输出中不输出时间</li>
<li><code>-tt</code>：在每行的输出中会输出时间戳</li>
<li><code>-ttt</code>：输出每两行打印的时间间隔(以毫秒为单位)</li>
<li><code>-tttt</code>：在每行打印的时间戳之前添加日期的打印（此种选项，输出的时间最直观）</li>
</ul>
<p><strong>显示数据包的头部</strong></p>
<ul>
<li><code>-x</code>：以16进制的形式打印每个包的头部数据（但不包括数据链路层的头部）</li>
<li><code>-xx</code>：以16进制的形式打印每个包的头部数据（包括数据链路层的头部）</li>
<li><code>-X</code>：以16进制和 ASCII码形式打印出每个包的数据(但不包括连接层的头部)，这在分析一些新协议的数据包很方便。</li>
<li><code>-XX</code>：以16进制和 ASCII码形式打印出每个包的数据(包括连接层的头部)，这在分析一些新协议的数据包很方便。</li>
</ul>
<p><strong>对输出内容进行控制的参数</strong></p>
<ul>
<li><code>-D</code> : 显示所有可用网络接口的列表</li>
<li><code>-e</code> : 每行的打印输出中将包括数据包的数据链路层头部信息</li>
<li><code>-E</code> : 揭秘IPSEC数据</li>
<li><code>-L</code> ：列出指定网络接口所支持的数据链路层的类型后退出</li>
<li><code>-Z</code>：后接用户名，在抓包时会受到权限的限制。如果以root用户启动tcpdump，tcpdump将会有超级用户权限。</li>
<li><code>-d</code>：打印出易读的包匹配码</li>
<li><code>-dd</code>：以C语言的形式打印出包匹配码.</li>
<li><code>-ddd</code>：以十进制数的形式打印出包匹配码</li>
</ul>
<h2 id="过滤规则组合"><a href="#过滤规则组合" class="headerlink" title="过滤规则组合"></a>过滤规则组合</h2><ul>
<li>and：所有的条件都需要满足，也可以表示为 <code>&amp;&amp;</code></li>
<li>or：只要有一个条件满足就可以，也可以表示为 <code>||</code></li>
<li>not：取反，也可以使用 <code>!</code></li>
</ul>
<p>当你在使用多个过滤器进行组合时，有可能需要用到括号，而括号在 shell 中是特殊符号，因为你需要使用引号将其包含。例子如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &#x27;src 10.0.2.4 and (dst port 8090 or 22)&#x27;</span><br></pre></td></tr></table></figure>

<p>而在单个过滤器里，常常会判断一条件是否成立，这时候，就要使用下面两个符号</p>
<ul>
<li><code>=</code>：判断二者相等</li>
<li><code>==</code>：判断二者相等</li>
<li><code>!=</code>：判断二者不相等</li>
</ul>
<p>当你使用这两个符号时，tcpdump 还提供了一些关键字的接口来方便我们进行判断，比如</p>
<ul>
<li>if：表示网卡接口名、</li>
<li>proc：表示进程名</li>
<li>pid：表示进程 id</li>
<li>svc：表示 service class</li>
<li>dir：表示方向，in 和 out</li>
<li>eproc：表示 effective process name</li>
<li>epid：表示 effective process ID</li>
</ul>
<p>比如我现在要过滤来自进程名为 ntp 发出的流经 eth0 网卡的数据包，或者不流经 eth0 的入方向数据包，可以这样子写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &quot;( if=eth0 and proc=ntp ) || (if != en0 and dir=in)&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wongbingming/p/13212306.html">https://www.cnblogs.com/wongbingming/p/13212306.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
