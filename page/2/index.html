<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/block/" class="post-title-link" itemprop="url">block device</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/" itemprop="url" rel="index"><span itemprop="name">dev</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>块设备是一种具有一定结构的随机存取设备，读写数据的基本单位为块，使用缓冲区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者从设备一次性读到缓冲区。</p>
<ul>
<li>**页(page)**：Linux内存页，一般是4096字节，用作磁盘缓存。通过<code>getconf PAGE_SIZE</code>查看。</li>
<li>**段(Segments)**：由若干个块组成。是Linux内存管理机制中一个内存页或者内存页的一部分。</li>
<li><strong>块  (Blocks)</strong> ：  Linux虚拟文件系统I/O操作的最小单位，通常为扇区的2的幂次方倍。通过<code>tune2fs -l /dev/vdb1|grep Block</code>查看块大小。</li>
<li>**扇区(Sectors)**：块设备的基本单位。通常在512字节到32768字节之间，默认512字节。可以通过<code>fdisk -l</code>命令查看每个磁盘sector的大小</li>
</ul>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>Linux使用虚拟文件系统屏蔽不同I/O设备的差别，Linux内核通过映射层、通用块层、I/O调度层屏蔽不同块设备的差别。</p>
<p><img src="/images/kernel/block/block-arch.jpg" alt="块设备框架"></p>
<p><img src="/images/kernel/block/block-arch2.jpg" alt="块设备框架"></p>
<p><img src="/images/kernel/block/block.png" alt="块设备框架"></p>
<h2 id="块设备层"><a href="#块设备层" class="headerlink" title="块设备层"></a>块设备层</h2><h3 id="gendisk"><a href="#gendisk" class="headerlink" title="gendisk"></a>gendisk</h3><p>linux内核用 gendisk 结构体表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> major;   <span class="comment">/* major number of driver */</span></span><br><span class="line">    <span class="type">int</span> first_minor;</span><br><span class="line">    <span class="type">int</span> minors;                     <span class="comment">/* maximum number of minors, =1 for</span></span><br><span class="line"><span class="comment">                                         * disks that can&#x27;t be partitioned. */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> disk_name[DISK_NAME_LEN]; <span class="comment">/* name of major driver */</span></span><br><span class="line">    <span class="type">char</span> *(*devnode)(<span class="keyword">struct</span> gendisk *gd, <span class="type">mode_t</span> *mode);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> events;  <span class="comment">/* supported events */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> async_events; <span class="comment">/* async events, subset of all */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">disk_part_tbl</span> __<span class="title">rcu</span> *<span class="title">part_tbl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> <span class="title">part0</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">    <span class="type">void</span> *private_data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">driverfs_dev</span>;</span>  <span class="comment">// <span class="doctag">FIXME:</span> remove</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">slave_dir</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_rand_state</span> *<span class="title">random</span>;</span></span><br><span class="line">    <span class="type">atomic_t</span> sync_io;  <span class="comment">/* RAID */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">disk_events</span> *<span class="title">ev</span>;</span></span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gendisk 是一个动态分配的结构体，需要内核来初始化，不能自己分配 */</span></span><br><span class="line"><span class="keyword">struct</span> gendisk *<span class="title function_">alloc_disk</span><span class="params">(<span class="type">int</span> minors)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册磁盘设备 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_disk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 gendisk */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_gendisk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/kernel/block/add_disk.png" alt="块设备注册过程"></p>
<h3 id="block-device-operations"><a href="#block-device-operations" class="headerlink" title="block_device_operations"></a>block_device_operations</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> gendisk *, <span class="type">fmode_t</span>);</span><br><span class="line">    <span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*compat_ioctl) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*direct_access) (<span class="keyword">struct</span> block_device *, <span class="type">sector_t</span>,</span><br><span class="line">                        <span class="type">void</span> **, <span class="type">unsigned</span> <span class="type">long</span> *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*check_events)</span> <span class="params">(<span class="keyword">struct</span> gendisk *disk,</span></span><br><span class="line"><span class="params">                      <span class="type">unsigned</span> <span class="type">int</span> clearing)</span>;</span><br><span class="line">    <span class="comment">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span></span><br><span class="line">    <span class="type">int</span> (*media_changed) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line">    <span class="type">void</span> (*unlock_native_capacity) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line">    <span class="type">int</span> (*revalidate_disk) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line">    <span class="type">int</span> (*getgeo)(<span class="keyword">struct</span> block_device *, <span class="keyword">struct</span> hd_geometry *);</span><br><span class="line">    <span class="comment">/* this callback is with swap_lock and sometimes page table lock held */</span></span><br><span class="line">    <span class="type">void</span> (*swap_slot_free_notify) (<span class="keyword">struct</span> block_device *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>media_changed()检查可移动介质的驱动器中的介质是否已经改变，如果是返回一个非 0 值，否则返回 0。</p>
</li>
<li><p>revalidate_disk()函数被调用来响应一个介质改变，使介质做好工作准备。</p>
</li>
<li><p>getgeo()函数获得驱动器信息，根据驱动器的几何信息填充一个 hd_geometry 结构体，hd_geometry 结构体包含磁头、<br>扇区、柱面等信息，其定义于 include/linux/hdreg.h 头文件。</p>
</li>
<li><p>owner是指向拥有这个结构体的模块的指针，通常被初始化为<code>THIS_MODULE</code>。</p>
</li>
</ul>
<h2 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h2><p>通用块层 (Generic Block Layer) 负责维持一个 I/O 请求在上层文件系统与底层物理磁盘之间的关系。</p>
<h3 id="bio"><a href="#bio" class="headerlink" title="bio"></a>bio</h3><p>bio 结构体用来对应一个 I/O 请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">    <span class="type">sector_t</span>  bi_sector; <span class="comment">/* device address in 512 byte</span></span><br><span class="line"><span class="comment">                           sectors */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span>  *<span class="title">bi_next</span>;</span> <span class="comment">/* request queue link */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bi_bdev</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bi_flags; <span class="comment">/* status, command, etc */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bi_rw;  <span class="comment">/* bottom bits READ/WRITE,</span></span><br><span class="line"><span class="comment">                         * top bits priority</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  bi_vcnt; <span class="comment">/* how many bio_vec&#x27;s */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  bi_idx;  <span class="comment">/* current index into bvl_vec */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of segments in this BIO after</span></span><br><span class="line"><span class="comment">     * physical address coalescing is performed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_phys_segments;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_size; <span class="comment">/* residual I/O count */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * To keep track of the max segment size, we account for the</span></span><br><span class="line"><span class="comment">     * sizes of the first and last mergeable segments in this bio.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_seg_front_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_seg_back_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_max_vecs; <span class="comment">/* max bvl_vecs we can hold */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  bi_comp_cpu; <span class="comment">/* completion CPU */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_t</span>  bi_cnt;  <span class="comment">/* pin count */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>  *<span class="title">bi_io_vec</span>;</span> <span class="comment">/* the actual vec list */</span></span><br><span class="line">    <span class="type">bio_end_io_t</span>  *bi_end_io;</span><br><span class="line">    <span class="type">void</span>   *bi_private;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_integrity_payload</span> *<span class="title">bi_integrity</span>;</span>  <span class="comment">/* data integrity */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">bio_destructor_t</span> *bi_destructor; <span class="comment">/* destructor */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We can inline a number of vecs at the end of the bio, to avoid</span></span><br><span class="line"><span class="comment">     * double allocations for a small number of bio_vecs. This member</span></span><br><span class="line"><span class="comment">     * MUST obviously be kept at the very end of the bio.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>  <span class="title">bi_inline_vecs</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bio 描述了内存中连续几页的数据，每一页的数据由一个段 bio_vec 表示。多个页会被封装成多个段，这些段被组成一个数组，用 bio_io_vec 表示，bi_vcnt 是数组中元素的个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">bv_page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bv_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bv_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 遍历一个bio中的bi_io_vec 数组 */</span></span><br><span class="line"><span class="type">int</span> iter</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>  *<span class="title">bvec</span>;</span></span><br><span class="line">bio_for_each_segment(bvec, bio, iter)   </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回I/O操作的数据方向 */</span></span><br><span class="line">bio_rw(bio)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结束I/O请求 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bio_endio</span><span class="params">(<span class="keyword">struct</span> bio *bio, <span class="type">int</span> error)</span></span><br></pre></td></tr></table></figure>

<h2 id="I-O-调度层"><a href="#I-O-调度层" class="headerlink" title="I/O 调度层"></a>I/O 调度层</h2><p>I/O 调度层负责管理块设备的请求队列，对块设备提交的请求进行合并和排序预操作，以提高访问的效率。I/O调度算法可将连续的bio合并成一个请求，因此，一个请求可以包含多个bio，请求是bio经由I/O调度进行调整后的结果。</p>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>在 Linux 中，驱动对块设备的输入或输出 (I/O) 操作，都会向块设备发出一个请求，在驱动中用 request 结构体描述。但对于一些磁盘设备而言请求的速度很慢，这时候内核就提供一种队列的机制把这些 I/O 请求添加到队列中（即请求队列），在驱动中用 request_queue 结构体描述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queuelist</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">call_single_data</span> <span class="title">csd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cmd_flags;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">rq_cmd_type_bits</span> <span class="title">cmd_type</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">atomic_flags</span>;</span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the following two fields are internal, NEVER access directly */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> __data_len; <span class="comment">/* total data len */</span></span><br><span class="line">    <span class="type">sector_t</span> __sector;  <span class="comment">/* sector cursor */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bio</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">biotail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hash</span>;</span> <span class="comment">/* merge hash */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The rb_node is only used inside the io scheduler, requests</span></span><br><span class="line"><span class="comment">     * are pruned when moved to the dispatch queue. So let the</span></span><br><span class="line"><span class="comment">     * completion_data share space with the rb_node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span> <span class="comment">/* sort/lookup */</span></span><br><span class="line">        <span class="type">void</span> *completion_data;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Three pointers are available for the IO schedulers, if they need</span></span><br><span class="line"><span class="comment">     * more they have to dynamically allocate it.  Flush requests are</span></span><br><span class="line"><span class="comment">     * never put on the IO scheduler. So let the flush fields share</span></span><br><span class="line"><span class="comment">     * space with the three elevator_private pointers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *elevator_private[<span class="number">3</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span>  seq;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">        &#125; flush;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">rq_disk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> *<span class="title">part</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_time;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start_time_ns;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> io_start_time_ns;    <span class="comment">/* when passed to hardware */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Number of scatter-gather DMA addr+len pairs after</span></span><br><span class="line"><span class="comment">     * physical address coalescing is performed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> nr_phys_segments;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> nr_integrity_segments;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ioprio;</span><br><span class="line">    <span class="type">int</span> ref_count;</span><br><span class="line">    <span class="type">void</span> *special;  <span class="comment">/* opaque pointer available for LLD use */</span></span><br><span class="line">    <span class="type">char</span> *buffer;  <span class="comment">/* kaddr of the current segment if available */</span></span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">    <span class="type">int</span> errors;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * when request is used as a packet command carrier</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> __cmd[BLK_MAX_CDB];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *cmd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cmd_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra_len; <span class="comment">/* length of alignment and padding */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sense_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> resid_len; <span class="comment">/* residual count */</span></span><br><span class="line">    <span class="type">void</span> *sense;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> deadline;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">timeout_list</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> timeout;</span><br><span class="line">    <span class="type">int</span> retries;</span><br><span class="line">    rq_end_io_fn *end_io;</span><br><span class="line">    <span class="type">void</span> *end_io_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">next_rq</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化请求队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(request_fn_proc)</span> <span class="params">(<span class="keyword">struct</span> request_queue *q)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> request_queue *<span class="title function_">blk_init_queue</span><span class="params">(request_fn_proc *rfn, <span class="type">spinlock_t</span> *lock)</span></span><br></pre></td></tr></table></figure>

<p>rfn是请求处理函数的指针，lock是控制访问队列权限的自旋锁</p>
<ul>
<li>清除请求队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_cleanup_queue</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分配请求队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> request_queue *<span class="title function_">blk_alloc_queue</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span></span><br></pre></td></tr></table></figure>

<p>对于 Flash、RAM 盘等完全随机访问的非机械设备，并不需要进行复杂的 I/O 调度，这个时候，应该使用上述函数分配一个请求队列，并使用如下函数来绑定请求队列和制造请求函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(make_request_fn)</span> <span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> bio *bio)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_queue_make_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q, make_request_fn *mfn)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>队列操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从请求队列里面获得一个请求 */</span></span><br><span class="line"><span class="keyword">struct</span> request *<span class="title function_">blk_fetch_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否是队列尾部 */</span></span><br><span class="line"><span class="type">bool</span> __<span class="title function_">blk_end_request_cur</span><span class="params">(<span class="keyword">struct</span> request *rq, <span class="type">int</span> error)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得请求数据传送方向，0 返回值表示从设备中读，非 0 表示向设备写 */</span></span><br><span class="line"><span class="title function_">rq_data_dir</span><span class="params">(<span class="keyword">struct</span> request *req)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="request-queue"><a href="#request-queue" class="headerlink" title="request_queue"></a>request_queue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Together with queue_head for cacheline sharing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span>  *<span class="title">last_merge</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elevator_queue</span> *<span class="title">elevator</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * the queue request freelist, one for reads and one for writes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_list</span> <span class="title">rq</span>;</span></span><br><span class="line">    </span><br><span class="line">    request_fn_proc  *request_fn;</span><br><span class="line">    make_request_fn  *make_request_fn;</span><br><span class="line">    prep_rq_fn  *prep_rq_fn;</span><br><span class="line">    unprep_rq_fn  *unprep_rq_fn;</span><br><span class="line">    merge_bvec_fn  *merge_bvec_fn;</span><br><span class="line">    softirq_done_fn  *softirq_done_fn;</span><br><span class="line">    rq_timed_out_fn  *rq_timed_out_fn;</span><br><span class="line">    dma_drain_needed_fn *dma_drain_needed;</span><br><span class="line">    lld_busy_fn  *lld_busy_fn;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Dispatch queue sorting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">sector_t</span>  end_sector;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span>  *<span class="title">boundary_rq</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Delayed queue handling</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">delay_work</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> <span class="title">backing_dev_info</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The queue owner gets to use this for whatever they like.</span></span><br><span class="line"><span class="comment">     * ll_rw_blk doesn&#x27;t touch it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span>   *queuedata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queue needs bounce pages for pages above this limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">gfp_t</span>   bounce_gfp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * various queue flags, see QUEUE_* below</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  queue_flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * protects queue structures from reentrancy. -&gt;__queue_lock should</span></span><br><span class="line"><span class="comment">     * _never_ be used directly, it is queue private. always use</span></span><br><span class="line"><span class="comment">     * -&gt;queue_lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">spinlock_t</span>  __queue_lock;</span><br><span class="line">    <span class="type">spinlock_t</span>  *queue_lock;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queue kobject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queue settings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  nr_requests; <span class="comment">/* Max # of requests */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  nr_congestion_on;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  nr_congestion_off;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  nr_batching;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span>   *dma_drain_buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  dma_drain_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  dma_pad_mask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  dma_alignment;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_queue_tag</span> *<span class="title">queue_tags</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tag_busy_list</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  nr_sorted;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  in_flight[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  rq_timeout;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">timeout_list</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue_limits</span> <span class="title">limits</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sg stuff</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  sg_timeout;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  sg_reserved_size;</span><br><span class="line">    <span class="type">int</span>   node;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_trace</span> *<span class="title">blk_trace</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * for flush operations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  flush_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  flush_not_queueable:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  flush_queue_delayed:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  flush_pending_idx:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  flush_running_idx:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  flush_pending_since;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flush_queue</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flush_data_in_flight</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span>  <span class="title">flush_rq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>  <span class="title">sysfs_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BLK_DEV_BSG)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bsg_class_device</span> <span class="title">bsg_dev</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_THROTTLING</span></span><br><span class="line">    <span class="comment">/* Throttle data */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">throtl_data</span> *<span class="title">td</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/mmu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/mmu/" class="post-title-link" itemprop="url">kernel mmu</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存管理单元(MMU)的作用是控制和管理多个进程，使之能够安全的共享主内存区域，为各进程实现虚拟地址和物理地址转换、内存访问权限保护等功能，这将使得操作系统能单独为系统的每个用户进程分配独立的内存空间并保证用户空间不能访问内核空间的地址。</p>
<p>在 32 位系统上，Linux 内核将 4G 空间分为 1G 内核空间(3<del>4G)和 3G(0</del>3G)用户空间，通过内存管理，每个进程都可以使用 3G 的用户空间。</p>
<p><img src="/images/kernel/kernel/mmu.png" alt="mmu"></p>
<h3 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h3><p><strong>逻辑地址</strong>是由程式产生的和段相关的偏移地址部分。机器语言指令中出现的内存地址，都是逻辑地址。编译器编译程序时，会为程序生成代码段和数据段，然后将所有代码放到代码段中，将所有数据放到数据段中。最后程序中的每句代码和每条数据都会有自己的逻辑地址。</p>
<p><strong>线性地址</strong>是逻辑地址到物理地址变换之间的中间物。段中的偏移地址，加上段基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址能再变换成物理地址。</p>
<p>CPU加载程序后，会为程序分配代码段内存和数据段内存，代码段内存的基址保存在CS中，数据段内存的基址保存在DS中。</p>
<p><strong>物理地址</strong>是CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果没有启用分页机制，物理地址等于线性地址。</p>
<p><strong>虚拟地址与物理地址转化</strong></p>
<p>要将一个逻辑地址转换为物理地址，需要两步：首先利用段式内存管理单元将逻辑地址转换成线性地址，再利用页式内存管理单元，把线性地址转换为物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">phys_addr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*内核虚拟地址转化为物理地址*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">phys_addr_t</span> <span class="title function_">virt_to_phys</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __virt_to_phys((<span class="type">unsigned</span> <span class="type">long</span>)(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*物理地址转化为内核虚拟地址*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">phys_to_virt</span><span class="params">(<span class="type">phys_addr_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)__phys_to_virt(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h3><p>因为intel的CPU有20位的地址总线，而寄存器16位，要寻址2^20^=1M的内存空间，只能采用分段管理。线性地址 = 段基址 * 16 + 逻辑地址</p>
<h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><p>CPU的页式内存管理单元负责把线性地址转换为物理地址。从管理和效率的角度出发，线性地址被分为固定长度单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，用4KB为一个页来划分，整个线性地址就被划分为共有2^20^个页的数组，我们称之为页目录。目录中的每一个目录项，就是对应的页的地址。这个数组有2^20^个成员，每个成员是一个地址（32位机，一个地址4字节），那么要表示这个数组，就要4MB的内存空间。为了节省空间，引入二级管理模式来组织分页单元。</p>
<p><img src="/images/kernel/kernel/mmu_page.jpg" alt="img"></p>
<p><strong>每个进程都有其独立的虚似内存，拥有惟一的页目录和页表</strong>，它的地址放在CPU的cr3寄存器中，是进行地址转换的开始点。每一个32位的线性地址被划分为三部分：页目录索引(10位)、页表索引(10位)、偏移(12位) 。依据以下步骤进行转换：</p>
<ol>
<li><p>从cr3中取出进程的页目录地址。</p>
</li>
<li><p>根据线性地址的页目录索引，找到页表地址。</p>
</li>
<li><p>根据线性地址的页表索引，在页表中找到页的起始地址。</p>
</li>
<li><p>将页的起始地址与线性地址中的偏移相加。</p>
</li>
</ol>
<p>在二级管理模式中，页目录共有2^10^项，每项有2^10^个页表，每个页中可寻址2^12^个字节，2^10^ * 2^10^ * 2^12^ = 2^32^ = 4GB。能够表示4G的地址。同时页目录项和页表项共占空间 (2^10 * 4 + 2 ^10 *4) = 8KB，节省了空间。</p>
<p><strong>Linux的页式内存管理</strong></p>
<p>有些CPU，还有三级，甚至四级架构，Linux为了在更高层次提供抽像，为每个CPU提供统一的界面。提供了一个四层页管理架构，来兼容这些二级、三级、四级管理架构的CPU。这四级分别为： 页全局目录PGD、页上级目录PUD、页中间目录PMD、页表PT。 整个转换依据硬件转换原理，多了二次数组的索引。</p>
<p><img src="/images/kernel/kernel/mmu_page2.jpg" alt="img"></p>
<p>逻辑地址、线性地址和物理地址之间的变换过程如下图所示：</p>
<p><img src="/images/kernel/kernel/mem_t.jpg" alt="虚拟地址、线性地址和物理地址的转换"></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>Linux采用虚拟内存管理技术，使得每个进程都有独立的进程地址空间，Linux将4GB的虚拟内存空间分成两个部分：0 ~ 3GB属于用户空间，3 ~ 4GB 属于内核空间。用户进程只能访问用户空间，只能通过系统调用访问内核空间。</p>
<p><img src="/images/kernel/kernel/user_space.png" alt="img"></p>
<p>用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。</p>
<p>内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。</p>
<p>进程 fork(),execve(),malloc()等操作分配的内存仅仅是虚拟内存。只有当进程真正去访问地址时，才会产生缺页异常，内核才会为进程分配物理页，并建立对应的页表。</p>
<h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>ARM处理器分为7种工作模式:</p>
<ul>
<li>用户模式(usr)：大多数的应用程序运行在用户模式下,当处理器运行在用户模式下时,某些被保护的系统资源是不能被访问的。</li>
<li>快速中断模式(fiq)：用于高速数据传输或通道处理。</li>
<li>外部中断模式(irq)：用于通用的中断处理。</li>
<li>管理模式(svc)：操作系统使用的保护模式。</li>
<li>数据访问终止模式(abt)：当数据或指令预取终止时进入该模式,可用于虚拟存储及存储保护。</li>
<li>系统模式(sys)：运行具有特权的操作系统任务。</li>
<li>未定义指令中止模式(und)：当未定义的指令执行时进入该模式,可用于支持硬件协处理器的软件仿真。</li>
</ul>
<p>Linux为了保护内核的安全，只使用处理器的2个模式，把系统分成了2部分。内核可进行任何操作，特权指令只能在内核态使用，从而起到保护作用。而应用程序则被禁止对硬件的直接访问和对内存的未授权访问。内核空间和用户空间使用不同的地址空间。用户空间只能通过系统调用和硬件中断转移到内核空间。</p>
<p>Linux 中 1GB 的内核地址空间又被划分为物理内存映射区、虚拟内存分配区、高端页面映射区、专用页面映射区和系统保留映射区这几个区域。</p>
<p>物理内存映射区是从3G开始最896MB的线性空间，物理内存顺序映射在这个区域中，虚拟地址 = 3G + 物理地址。</p>
<p>动态内存映射区由vmalloc()分配，其线性空间连续，但物理空间不一定连续，可能处于低端内存，也可能处于高端内存。</p>
<p>超过直接映射区896MB的那部分内存称为高端内存，内核在存取高端内存时必须将它们映射到高端页面映射区。内核空间最顶部 FIXADDR_TOP~4GB 的区域作为保留区。</p>
<p>内核空间与用户空间的内存不能直接互访，必需借助函数 <code>copy_from_user()</code>完成用户空间到内核空间的拷贝，以及<code>copy_to_user()</code>完成内核空间到用户空间的拷贝。如果要复制的内存是简单类型，如char、int、long等，则可以使用<code>put_user()</code>和<code>get_user()</code>。宏__user 是一个指向用户空间地址的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __user  __attribute__((noderef, address_space(1)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> __user *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line"></span><br><span class="line">put_user(val, <span class="type">void</span> __user *ptr); <span class="comment">/* 内核→用户 */</span></span><br><span class="line">get_user(val, <span class="type">void</span> __user *ptr); <span class="comment">/* 用户→内核 */</span></span><br></pre></td></tr></table></figure>

<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *objp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">kzalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">return</span> kmalloc(size, flags | __GFP_ZERO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kmalloc在物理内存映射区域申请一个连续存储空间，保留内存原有的数据，不清零。分配的内存最小32Byte，最大128KB。flags参数：</p>
<ul>
<li>GFP_ATOMIC  原子性分配内存，分配内存的过程不会被高优先级进程或中断打断。若不存在空闲页，则不等待，直接返回。</li>
<li>GFP_KERNEL  在内核空间的进程中申请内存，若不存在空闲页会引起阻塞，因此不能在中断上下文或持有自旋锁时使用。</li>
<li>GFP_DMA  给DMA控制器分配内存（DMA要求分配虚拟地址和物理地址连续）。</li>
</ul>
<p>kzalloc() 会对申请到的内存内容清零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>

<p>vmalloc() 能在高端内存区分配，用来分配虚拟地址空间连续，而物理地址不一定连续的内存。常用于申请大内存空间。因为要建立新的页表，将不连续的物理内存映射成连续的虚拟内存，所以开销比较大。分配内存时则可能产生阻塞，因此不能从中断上下文调用。</p>
<h2 id="I-O端口"><a href="#I-O端口" class="headerlink" title="I/O端口"></a>I/O端口</h2><p>设备通常会提供一组寄存器来用于控制设备、读写设备和获取设备状态，即控制寄存器、数据寄存器和状态寄存器。这些寄存器可能位于 I/O 空间，也可能位于内存空间。当位于 I/O 空间时，通常被称为 I/O 端口，端口号标识了外设的寄存器地址。位于内存空间时，对应的内存空间被称为 I/O 内存。内存空间是必须的，而 I/O 空间是可选的。</p>
<p>I/O 端口访问的一种途径是直接使用 I/O 端口操作函数，在设备打开或驱动模块被加载时申请<br>I/O 端口区域，之后使用 inb()、outb()等进行端口访问，最后在设备关闭或驱动被卸载时释放 I/O<br>端口范围。</p>
<img src=".img/mem/io_port.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">request_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">release_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>request_region()函数向内核申请n个端口，这些端口从start开始，name 参数为设备的名称。如果返回NULL，则意味着申请端口失败。可以用来检查申请的资源是否可用，如果申请成功，则将其标志为已经使用，其他驱动再申请该资源时就会失败。</p>
<p>release_region()函数用来释放申请的IO资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读写字节端口(8 位宽)*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">inb</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte, <span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写字端口(16 位宽)*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">inw</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outw</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> word, <span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写长字端口(32 位宽)*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">inl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> longword, <span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写一串字节*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insb</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsb</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写一串字*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insw</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsw</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写一串长字*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><code>/proc/ioports</code>显示使用request_region( )分配的IO端口的情况。</p>
<h2 id="I-O内存"><a href="#I-O内存" class="headerlink" title="I/O内存"></a>I/O内存</h2><p>I/O 内存的访问步骤：首先是调用 request_mem_region()申请资源，接着将寄存器地址通过 ioremap()映射到内核空间虚拟地址，之后就可以通过 Linux 设备访问编程接口访问这些设备的寄存器了。访问完成后，应对 ioremap()申请的虚拟地址进行释放，并释放 release_mem_<br>region()申请的 I/O 内存资源。</p>
<p><img src="/images/kernel/mem/io_mem.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">request_mem_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">release_mem_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __iomem *<span class="title function_">ioport_map</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioport_unmap</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __iomem *<span class="title function_">ioremap</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> physaddr, <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">void</span> __iomem * <span class="title function_">ioremap_nocache</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iounmap</span><span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span>;</span><br></pre></td></tr></table></figure>

<p>ioremap()函数将设备所处的物理地址映射到虚拟地址。</p>
<p>ioremap_nocache()返回一个线性地址，此时CPU可以访问设备的内存空间。<em>phys_addr</em>要映射的物理地址 ；<em>size</em>要映射资源的大小。返回的映射地址必须使用<code>iounmap</code>来释放。</p>
<p>ioport_map()函数可以把 port 开始的 count 个连续的 I/O 端口重映射为一段内存空间，然后就可以在其返回的地址上像访问 I/O 内存一样访问这些 I/O 端口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读I/O内存*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ioread8</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ioread16</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ioread32</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">readb</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> __force *)addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">readw</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> le16_to_cpu(*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> __force *)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">readl</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> le32_to_cpu(*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> __force *)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*写I/O内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8</span><span class="params">(u8 val, <span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8</span><span class="params">(u16 val, <span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8</span><span class="params">(u32 val, <span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*读一串 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ioread8_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioread16_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioread32_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写一串 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite16_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite32_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*复制 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy_fromio</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *from, <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy_toio</span><span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memset_io</span><span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr, <span class="type">unsigned</span> <span class="type">char</span> val, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><code>/proc/iomem</code>文件记录物理地址的分配情况，这些地址范围是通过 requset_mem_region 函数申请得到的。</p>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA 是一种无需 CPU 的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制。因为DMA的目的地址与Cache 所缓存的内存地址可能重叠，所以要禁止 DMA 目标地址范围内内存的Cache 功能。</p>
<p>DMA 操作在整个常规内存区域进行，DMA 的硬件使用总线地址而非物理地址。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/watchdog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/watchdog/" class="post-title-link" itemprop="url">watchdog device</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/" itemprop="url" rel="index"><span itemprop="name">dev</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>watchdog_dev.c</li>
<li>watchdog_core.c</li>
<li>wdt.c</li>
</ul>
<p>内核配置<code>CONFIG_WATCHDOG_NOWAYOUT</code>选项表示看门狗一旦开启就无法被停止，可设置nowayout模块参数。</p>
<p>如果驱动支持”Magic Close”，除非在关闭看门狗前，魔幻字符’V’发送到/dev/watchdog，否则不能停止看门狗。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/sched/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/sched/" class="post-title-link" itemprop="url">kernel process manage</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程管理负责控制进程对 CPU 的访问，如任务的创建、调度和终止等。</p>
<p>进程是操作系统进行资源管理的最小单位，进程需要管理打开的文件、挂起的信号、内核内部数据、处理器状态等。线程是操作系统进行调度的最小单位。进程的可能状态有:</p>
<ul>
<li><p>运行态，已经获得了资源，并且进程正在被 CPU 执行。进程既可运行在内核态，也可运行在用户态。</p>
</li>
<li><p>内核态，内核和驱动所运行时的状态，程序处于特权阶级，能够访问系统的任何资源。</p>
</li>
<li><p>用户态，用户程序运行的状态，处于非特权阶级，不能随意访问系统资源，必须通过驱动程序方可访问，用户态程序可通过系统调用进入内核态。</p>
</li>
<li><p>就绪态，当系统资源已经可用，但由于前一个进程还没有执行完释放 CPU，准备进入运行状态。</p>
</li>
<li><p>可中断睡眠状态，当进程处于可中断等待状态时，系统不会调度该程序执行。当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，都可以被唤醒进入就绪状态或者运行态。</p>
</li>
<li><p>不可中断睡眠状态，处于中断等待状态，但是该进程只能被使用 wake_up()函数明确唤醒的时候才可进入就绪状态。</p>
</li>
<li><p>暂停状态，当进程收到 SIGSTOP、SIGSTP、SIGTTIN 或者 SIGTTOU 就会进入暂停状态，收到 SIGCONT 信号即可进入运行态。</p>
</li>
<li><p>僵死态，进程已经停止运行，但是其父进程还没有询问其状态。</p>
</li>
</ul>
<p>每个进程都有两个栈，用户栈和内核栈，在用户态运行时CPU堆栈指针寄存器指向用户栈地址。进程在内核态运行时，CPU堆栈指针寄存器指向内核栈地址。内核栈使用的空间很小，通常为8KB。</p>
<p><img src="/images/kernel/kernel/task_struct.png" alt="内核栈"></p>
<h2 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h2><p>在linux中线程和进程都使用 struct task_struct 结构体表示，通过唯一的进程标识值pid来标识每个进程，用全局指针current指向当前正在运行的进程的 task_struct。task_struct的state域存储了进程当前的状态，总共有7种状态：</p>
<ul>
<li><p><strong>TASK_RUNNING</strong> 一般指就绪状态，进程正在运行。</p>
</li>
<li><p><strong>TASK_INTERRUPTIBLE</strong> 进程暂停，直到它获得满足它继续运行的条件，比如进程获得了需要的资源、接收到硬件终端、或者收到某些signal等。</p>
</li>
<li><p><strong>TASK_UNINTERRUPTIBLE</strong> 进程暂停，不会被signal唤醒，只能等待某些事件(资源、硬件终端等)。</p>
</li>
<li><p><strong>TASK_STOPPED</strong> 进程中止运行，进程在接收到SIGSTOP, SIGTSTP, SIGTTIN或者SIGTTOU 信号时会进入这个状态。 接收到SIGCONT信号后，重新回到进行状态。</p>
</li>
<li><p><strong>TASK_TRACED</strong> 进程处于被调试，例如通过ptrace()对程序进行调试。</p>
</li>
<li><p><strong>EXIT_ZOMBIE</strong> 进程将要结束，等待父进程调用wait4()或者waitpid()来回收该进程。</p>
</li>
<li><p><strong>EXIT_DEAD</strong> 进程退出，这个状态主要用于避免多个进程同时对该进程调用类似wait()的函数或者系统调用。</p>
</li>
</ul>
<p><img src="/images/kernel/kernel/proc-sched.png" alt="proc"></p>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>任务调度由 Linux 内核调度器来完成。Linux 内核调度器根据进程的优先级选择运行进程。linux内核支持抢占，更高优先级的进程可以抢占低优先级进程。但在中断处理函数中，中断上下文的底半部，进程持有自旋锁的情况下不允许内核抢占。</p>
<p>当请求的资源不能得到满足时，内核会调度其他进程执行，并使本进程进入睡眠状态，直到它请求的资源被释放，才会被唤醒而进入就绪态。睡眠分成可被打断的睡眠和不可被打断的睡眠，区别在于可被打断的睡眠在收到信号的时候唤醒。</p>
<p>内核可以使用schedule()函数主动调度进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;state=TASK_INTERRUPTIBLE;</span><br><span class="line">schedule(); </span><br></pre></td></tr></table></figure>

<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>设备驱动中，如果需要几个并发执行的任务，可以启动内核线程，函数为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/rtc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/rtc/" class="post-title-link" itemprop="url">RTC device</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/" itemprop="url" rel="index"><span itemprop="name">dev</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>RTC(实时时钟)借助电池供电，在系统掉电的情况下时间依然可以正常走动，通常还具有产生周期性中断以及产生闹钟(alarm)中断的能力。</p>
<p><img src="/images/kernel/rtc/rtc-arch.png" alt="rtc"></p>
<ul>
<li>rtc-dev.c   rtc设备用户接口;</li>
<li>class.c     管理rtc sys class;</li>
<li>interface.c 间接rtc驱动接口;</li>
<li>rtc-lib.c   rtc辅助函数,主要用于rtc时间转换、计算;</li>
<li>rtc-proc    rtc proc fs用户接口;</li>
<li>rtc-sysfs   rtc sys fs用户接口;</li>
<li>hctosys.c   用于在系统启动时从rtc读取时间，并设置为系统时间;</li>
<li>rtc-xxx.c   rtc硬件芯片驱动，如rtc-wm8350.c、rtc-s3c.c等。</li>
<li>include/linux/rtc.h  rtc接口声明，定义ioctl命令宏。</li>
</ul>
<p>RTC框架大致可以分为三部分：芯片底层驱动，核心层API以及应用层接口，它们依次向上抽象注册。同时又对下面底层的函数进行回调。</p>
<h2 id="rtc-xxx-c"><a href="#rtc-xxx-c" class="headerlink" title="rtc-xxx.c"></a>rtc-xxx.c</h2><p>不同的芯片对应不同的.c文件，每种芯片的实现方式都不一样，由芯片硬件自身决定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> device *);</span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> device *);</span><br><span class="line">    <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*read_time)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_time *);</span><br><span class="line">    <span class="type">int</span> (*set_time)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_time *);</span><br><span class="line">    <span class="type">int</span> (*read_alarm)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_wkalrm *);</span><br><span class="line">    <span class="type">int</span> (*set_alarm)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_wkalrm *);</span><br><span class="line">    <span class="type">int</span> (*proc)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> seq_file *);</span><br><span class="line">    <span class="type">int</span> (*set_mmss)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">long</span> secs);</span><br><span class="line">    <span class="type">int</span> (*read_callback)(<span class="keyword">struct</span> device *, <span class="type">int</span> data);</span><br><span class="line">    <span class="type">int</span> (*alarm_irq_enable)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">int</span> enabled);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> <span class="title">s3c_rtcops</span> =</span> &#123;</span><br><span class="line">    .read_time  = s3c_rtc_gettime,</span><br><span class="line">    .set_time   = s3c_rtc_settime,</span><br><span class="line">    .read_alarm = s3c_rtc_getalarm,</span><br><span class="line">    .set_alarm  = s3c_rtc_setalarm,</span><br><span class="line">    .alarm_irq_enable = s3c_rtc_setaie,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span>;</span></span><br><span class="line">rtc = rtc_device_register(<span class="string">&quot;s3c&quot;</span>, &amp;pdev-&gt;dev, &amp;s3c_rtcops, THIS_MODULE);</span><br></pre></td></tr></table></figure>

<p>rtc芯片要实例化一个 rtc_class_ops 结构体，里面是一些rtc设备的操作函数，然后使用 <a href="#rtc_device_register">rtc_device_register()</a> 函数注册到rtc设备中。</p>
<h2 id="rtc-class-c"><a href="#rtc-class-c" class="headerlink" title="rtc-class.c"></a>rtc-class.c</h2><p>rtc-class.c 提供了一些rtc核心的API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> id;                                              <span class="comment">//代表是那个rtc设备  </span></span><br><span class="line">    <span class="type">char</span> name[RTC_DEVICE_NAME_SIZE];                     <span class="comment">//代表rtc设备的名称  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> *<span class="title">ops</span>;</span>                     <span class="comment">//rtc操作函数集，需要驱动实现  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">ops_lock</span>;</span>                               <span class="comment">//操作函数集的互斥锁  </span></span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">char_dev</span>;</span>                                <span class="comment">//代表rtc字符设备，因为rtc就是个字符设备  </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;                                 <span class="comment">//rtc的状态标志，例如RTC_DEV_BUSY  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> irq_data;                              <span class="comment">//rtc中断数据  </span></span><br><span class="line">    <span class="type">spinlock_t</span> irq_lock;                                 <span class="comment">//访问数据是要互斥，需要spin_lock  </span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> irq_queue;                         <span class="comment">//数据查询中用到rtc队列  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span>                   <span class="comment">//异步队列  </span></span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_task</span> *<span class="title">irq_task</span>;</span>                           <span class="comment">//在中断中使用task传输数据  </span></span><br><span class="line">    <span class="type">spinlock_t</span> irq_task_lock;                            <span class="comment">//task传输互斥  </span></span><br><span class="line">    <span class="type">int</span> irq_freq;                                        <span class="comment">//rtc的中断频率  </span></span><br><span class="line">    <span class="type">int</span> max_user_freq;                                   <span class="comment">//rtc的最大中断频率  </span></span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerqueue_head</span> <span class="title">timerqueue</span>;</span>                   <span class="comment">//定时器队列                    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">aie_timer</span>;</span>                          <span class="comment">//aie(alaram interrupt enable)定时器  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">uie_rtctimer</span>;</span>                       <span class="comment">//uie(update interrupt enable)定时器  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">pie_timer</span>;</span> <span class="comment">/* sub second exp, so needs hrtimer */</span> <span class="comment">//pie(periodic interrupt enable)定时器  </span></span><br><span class="line">    <span class="type">int</span> pie_enabled;                                     <span class="comment">//pie使能标志  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">irqwork</span>;</span>                            </span><br><span class="line">    <span class="comment">/* Some hardware can&#x27;t support UIE mode */</span>  </span><br><span class="line">    <span class="type">int</span> uie_unsupported;                                 <span class="comment">//uie使能标志  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RTC_INTF_DEV_UIE_EMUL                      <span class="comment">//RTC UIE emulation on dev interface配置项，目前没有开启  </span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">uie_task</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">uie_timer</span>;</span>  </span><br><span class="line">    <span class="comment">/* Those fields are protected by rtc-&gt;irq_lock */</span>  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> oldsecs;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uie_irq_active:<span class="number">1</span>;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stop_uie_polling:<span class="number">1</span>;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uie_task_active:<span class="number">1</span>;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> uie_timer_active:<span class="number">1</span>;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>

<h3 id="rtc-device-register"><a href="#rtc-device-register" class="headerlink" title="rtc_device_register"></a>rtc_device_register</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rtc_device *<span class="title function_">rtc_device_register</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="keyword">struct</span> rtc_class_ops *ops,</span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> module *owner)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_wkalrm</span> <span class="title">alrm</span>;</span></span><br><span class="line">    <span class="type">int</span> id, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idr_pre_get(&amp;rtc_idr, GFP_KERNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        err = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;idr_lock);</span><br><span class="line">    err = idr_get_new(&amp;rtc_idr, <span class="literal">NULL</span>, &amp;id);</span><br><span class="line">    mutex_unlock(&amp;idr_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">    id = id &amp; MAX_ID_MASK;</span><br><span class="line"></span><br><span class="line">    rtc = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rtc_device), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (rtc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> exit_idr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rtc-&gt;id = id;</span><br><span class="line">    rtc-&gt;ops = ops;</span><br><span class="line">    rtc-&gt;owner = owner;</span><br><span class="line">    rtc-&gt;irq_freq = <span class="number">1</span>;</span><br><span class="line">    rtc-&gt;max_user_freq = <span class="number">64</span>;</span><br><span class="line">    rtc-&gt;dev.parent = dev;</span><br><span class="line">    rtc-&gt;dev.class = rtc_class;</span><br><span class="line">    rtc-&gt;dev.release = rtc_device_release;</span><br><span class="line"></span><br><span class="line">    mutex_init(&amp;rtc-&gt;ops_lock);</span><br><span class="line">    spin_lock_init(&amp;rtc-&gt;irq_lock);</span><br><span class="line">    spin_lock_init(&amp;rtc-&gt;irq_task_lock);</span><br><span class="line">    init_waitqueue_head(&amp;rtc-&gt;irq_queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init timerqueue */</span></span><br><span class="line">    timerqueue_init_head(&amp;rtc-&gt;timerqueue);</span><br><span class="line">    INIT_WORK(&amp;rtc-&gt;irqwork, rtc_timer_do_work);</span><br><span class="line">    <span class="comment">/* Init aie timer */</span></span><br><span class="line">    rtc_timer_init(&amp;rtc-&gt;aie_timer, rtc_aie_update_irq, (<span class="type">void</span> *)rtc);</span><br><span class="line">    <span class="comment">/* Init uie timer */</span></span><br><span class="line">    rtc_timer_init(&amp;rtc-&gt;uie_rtctimer, rtc_uie_update_irq, (<span class="type">void</span> *)rtc);</span><br><span class="line">    <span class="comment">/* Init pie timer */</span></span><br><span class="line">    hrtimer_init(&amp;rtc-&gt;pie_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span><br><span class="line">    rtc-&gt;pie_timer.function = rtc_pie_update_irq;</span><br><span class="line">    rtc-&gt;pie_enabled = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check to see if there is an ALARM already set in hw */</span></span><br><span class="line">    err = __rtc_read_alarm(rtc, &amp;alrm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err &amp;&amp; !rtc_valid_tm(&amp;alrm.time))</span><br><span class="line">        rtc_initialize_alarm(rtc, &amp;alrm);</span><br><span class="line"></span><br><span class="line">    strlcpy(rtc-&gt;name, name, RTC_DEVICE_NAME_SIZE);</span><br><span class="line">    dev_set_name(&amp;rtc-&gt;dev, <span class="string">&quot;rtc%d&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">    rtc_dev_prepare(rtc);</span><br><span class="line"></span><br><span class="line">    err = device_register(&amp;rtc-&gt;dev);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        put_device(&amp;rtc-&gt;dev);</span><br><span class="line">        <span class="keyword">goto</span> exit_kfree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rtc_dev_add_device(rtc);</span><br><span class="line">    rtc_sysfs_add_device(rtc);</span><br><span class="line">    rtc_proc_add_device(rtc);</span><br><span class="line"></span><br><span class="line">    dev_info(dev, <span class="string">&quot;rtc core: registered %s as %s\n&quot;</span>,</span><br><span class="line">            rtc-&gt;name, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rtc;</span><br><span class="line"></span><br><span class="line">exit_kfree:</span><br><span class="line">    kfree(rtc);</span><br><span class="line"></span><br><span class="line">exit_idr:</span><br><span class="line">    mutex_lock(&amp;idr_lock);</span><br><span class="line">    idr_remove(&amp;rtc_idr, id);</span><br><span class="line">    mutex_unlock(&amp;idr_lock);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    dev_err(dev, <span class="string">&quot;rtc core: unable to register %s, err = %d\n&quot;</span>,</span><br><span class="line">            name, err);</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(err);</span><br></pre></td></tr></table></figure>

<p>rtc_device_register()函数主要工作是创建一个rtc设备和实现proc、sysfs文件系统操作。</p>
<h2 id="rtc-dev-c"><a href="#rtc-dev-c" class="headerlink" title="rtc-dev.c"></a>rtc-dev.c</h2><p>rtc-dev.c 是硬件抽象层，为应用层提供了文件操作接口，如read, ioctl等。同时也为rtc-class.c 提供了API，rtc字符设备的创建的实现也在这里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_AIE_ON  _IO(<span class="string">&#x27;p&#x27;</span>, 0x01)  <span class="comment">/* Alarm int. enable on     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_AIE_OFF _IO(<span class="string">&#x27;p&#x27;</span>, 0x02)  <span class="comment">/* ... off          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_UIE_ON  _IO(<span class="string">&#x27;p&#x27;</span>, 0x03)  <span class="comment">/* Update int. enable on    */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_UIE_OFF _IO(<span class="string">&#x27;p&#x27;</span>, 0x04)  <span class="comment">/* ... off          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_PIE_ON  _IO(<span class="string">&#x27;p&#x27;</span>, 0x05)  <span class="comment">/* Periodic int. enable on  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_PIE_OFF _IO(<span class="string">&#x27;p&#x27;</span>, 0x06)  <span class="comment">/* ... off          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_WIE_ON  _IO(<span class="string">&#x27;p&#x27;</span>, 0x0f)  <span class="comment">/* Watchdog int. enable on  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_WIE_OFF _IO(<span class="string">&#x27;p&#x27;</span>, 0x10)  <span class="comment">/* ... off          */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_ALM_SET _IOW(<span class="string">&#x27;p&#x27;</span>, 0x07, struct rtc_time) <span class="comment">/* Set alarm time  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_ALM_READ    _IOR(<span class="string">&#x27;p&#x27;</span>, 0x08, struct rtc_time) <span class="comment">/* Read alarm time */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_RD_TIME _IOR(<span class="string">&#x27;p&#x27;</span>, 0x09, struct rtc_time) <span class="comment">/* Read RTC time   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_SET_TIME    _IOW(<span class="string">&#x27;p&#x27;</span>, 0x0a, struct rtc_time) <span class="comment">/* Set RTC time    */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_IRQP_READ   _IOR(<span class="string">&#x27;p&#x27;</span>, 0x0b, unsigned long)   <span class="comment">/* Read IRQ rate   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_IRQP_SET    _IOW(<span class="string">&#x27;p&#x27;</span>, 0x0c, unsigned long)   <span class="comment">/* Set IRQ rate    */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_EPOCH_READ  _IOR(<span class="string">&#x27;p&#x27;</span>, 0x0d, unsigned long)   <span class="comment">/* Read epoch      */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_EPOCH_SET   _IOW(<span class="string">&#x27;p&#x27;</span>, 0x0e, unsigned long)   <span class="comment">/* Set epoch       */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_WKALM_SET   _IOW(<span class="string">&#x27;p&#x27;</span>, 0x0f, struct rtc_wkalrm)<span class="comment">/* Set wakeup alarm*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_WKALM_RD    _IOR(<span class="string">&#x27;p&#x27;</span>, 0x10, struct rtc_wkalrm)<span class="comment">/* Get wakeup alarm*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_PLL_GET _IOR(<span class="string">&#x27;p&#x27;</span>, 0x11, struct rtc_pll_info)  <span class="comment">/* Get PLL correction */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_PLL_SET _IOW(<span class="string">&#x27;p&#x27;</span>, 0x12, struct rtc_pll_info)  <span class="comment">/* Set PLL correction */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">rtc_dev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> *<span class="title">ops</span> =</span> rtc-&gt;ops;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">tm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_wkalrm</span> <span class="title">alarm</span>;</span></span><br><span class="line">    <span class="type">void</span> __user *uarg = (<span class="type">void</span> __user *) arg;</span><br><span class="line"></span><br><span class="line">    err = mutex_lock_interruptible(&amp;rtc-&gt;ops_lock);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check that the calling task has appropriate permissions</span></span><br><span class="line"><span class="comment">     * for certain ioctls. doing this check here is useful</span></span><br><span class="line"><span class="comment">     * to avoid duplicate code in each driver.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> RTC_EPOCH_SET:</span><br><span class="line">    <span class="keyword">case</span> RTC_SET_TIME:</span><br><span class="line">        <span class="keyword">if</span> (!capable(CAP_SYS_TIME))</span><br><span class="line">            err = -EACCES;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_IRQP_SET:</span><br><span class="line">        <span class="keyword">if</span> (arg &gt; rtc-&gt;max_user_freq &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line">            err = -EACCES;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_PIE_ON:</span><br><span class="line">        <span class="keyword">if</span> (rtc-&gt;irq_freq &gt; rtc-&gt;max_user_freq &amp;&amp;</span><br><span class="line">                !capable(CAP_SYS_RESOURCE))</span><br><span class="line">            err = -EACCES;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Drivers *SHOULD NOT* provide ioctl implementations</span></span><br><span class="line"><span class="comment">     * for these requests.  Instead, provide methods to</span></span><br><span class="line"><span class="comment">     * support the following code, so that the RTC&#x27;s main</span></span><br><span class="line"><span class="comment">     * features are accessible without using ioctls.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * RTC and alarm times will be in UTC, by preference,</span></span><br><span class="line"><span class="comment">     * but dual-booting with MS-Windows implies RTCs must</span></span><br><span class="line"><span class="comment">     * use the local wall clock time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> RTC_ALM_READ:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"></span><br><span class="line">        err = rtc_read_alarm(rtc, &amp;alarm);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(uarg, &amp;alarm.time, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line">            err = -EFAULT;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_ALM_SET:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;alarm.time, uarg, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        alarm.enabled = <span class="number">0</span>;</span><br><span class="line">        alarm.pending = <span class="number">0</span>;</span><br><span class="line">        alarm.time.tm_wday = <span class="number">-1</span>;</span><br><span class="line">        alarm.time.tm_yday = <span class="number">-1</span>;</span><br><span class="line">        alarm.time.tm_isdst = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* RTC_ALM_SET alarms may be up to 24 hours in the future.</span></span><br><span class="line"><span class="comment">         * Rather than expecting every RTC to implement &quot;don&#x27;t care&quot;</span></span><br><span class="line"><span class="comment">         * for day/month/year fields, just force the alarm to have</span></span><br><span class="line"><span class="comment">         * the right values for those fields.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RTC_WKALM_SET should be used instead.  Not only does it</span></span><br><span class="line"><span class="comment">         * eliminate the need for a separate RTC_AIE_ON call, it</span></span><br><span class="line"><span class="comment">         * doesn&#x27;t have the &quot;alarm 23:59:59 in the future&quot; race.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span>  some legacy code may have used invalid fields as</span></span><br><span class="line"><span class="comment">         * wildcards, exposing hardware &quot;periodic alarm&quot; capabilities.</span></span><br><span class="line"><span class="comment">         * Not supported here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> now, then;</span><br><span class="line"></span><br><span class="line">            err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            rtc_tm_to_time(&amp;tm, &amp;now);</span><br><span class="line"></span><br><span class="line">            alarm.time.tm_mday = tm.tm_mday;</span><br><span class="line">            alarm.time.tm_mon = tm.tm_mon;</span><br><span class="line">            alarm.time.tm_year = tm.tm_year;</span><br><span class="line">            err  = rtc_valid_tm(&amp;alarm.time);</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            rtc_tm_to_time(&amp;alarm.time, &amp;then);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* alarm may need to wrap into tomorrow */</span></span><br><span class="line">            <span class="keyword">if</span> (then &lt; now) &#123;</span><br><span class="line">                rtc_time_to_tm(now + <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>, &amp;tm);</span><br><span class="line">                alarm.time.tm_mday = tm.tm_mday;</span><br><span class="line">                alarm.time.tm_mon = tm.tm_mon;</span><br><span class="line">                alarm.time.tm_year = tm.tm_year;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rtc_set_alarm(rtc, &amp;alarm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_RD_TIME:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"></span><br><span class="line">        err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(uarg, &amp;tm, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line">            err = -EFAULT;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_SET_TIME:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;tm, uarg, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rtc_set_time(rtc, &amp;tm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_PIE_ON:</span><br><span class="line">        err = rtc_irq_set_state(rtc, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_PIE_OFF:</span><br><span class="line">        err = rtc_irq_set_state(rtc, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_AIE_ON:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        <span class="keyword">return</span> rtc_alarm_irq_enable(rtc, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_AIE_OFF:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        <span class="keyword">return</span> rtc_alarm_irq_enable(rtc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_UIE_ON:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        <span class="keyword">return</span> rtc_update_irq_enable(rtc, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_UIE_OFF:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        <span class="keyword">return</span> rtc_update_irq_enable(rtc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_IRQP_SET:</span><br><span class="line">        err = rtc_irq_set_freq(rtc, <span class="literal">NULL</span>, arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_IRQP_READ:</span><br><span class="line">        err = put_user(rtc-&gt;irq_freq, (<span class="type">unsigned</span> <span class="type">long</span> __user *)uarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_WKALM_SET:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;alarm, uarg, <span class="keyword">sizeof</span>(alarm)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rtc_set_alarm(rtc, &amp;alarm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RTC_WKALM_RD:</span><br><span class="line">        mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">        err = rtc_read_alarm(rtc, &amp;alarm);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(uarg, &amp;alarm, <span class="keyword">sizeof</span>(alarm)))</span><br><span class="line">            err = -EFAULT;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* Finally try the driver&#x27;s ioctl interface */</span></span><br><span class="line">        <span class="keyword">if</span> (ops-&gt;ioctl) &#123;</span><br><span class="line">            err = ops-&gt;ioctl(rtc-&gt;dev.parent, cmd, arg);</span><br><span class="line">            <span class="keyword">if</span> (err == -ENOIOCTLCMD)</span><br><span class="line">                err = -ENOTTY;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            err = -ENOTTY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/tty/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/tty/" class="post-title-link" itemprop="url">tty device</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/" itemprop="url" rel="index"><span itemprop="name">dev</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/uart/" itemprop="url" rel="index"><span itemprop="name">uart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><p>终端是一种字符型设备，它有多种类型，通常使用 tty 来简称各种类型的终端设备。 tty 是 Teletype 的缩写， Teletype 是最早出现的一种终端设备，很像电传打字机，是由 Teletype公司生产的。Linux 中包含如下几类终端设备。</p>
<ul>
<li><strong>串行端口终端(/dev/ttySn)</strong></li>
</ul>
<p>串行端口终端(Serial Port Terminal)是使用计算机串行端口连接的终端设备。计算机把每个串行端口都看作是一个字符设备。这些串行端口所对应的设备名称是/dev/ttyS0(或/dev/tts/0)、/dev/ttyS1(或/dev/tts/1)等，设备号是4。在命令行上把标准输出重定向到端口对应的设备文件名上就可以通过该端口发送数据，例如，在命令行提示符下键入<code>echo test &gt; /dev/ttyS1</code>会把单词“test”发送到连接在 ttyS1 端口的设备上。</p>
<p>USB-串口转换器对应设备结点通常为/dev/ttyUSB0， /dev/ttyUSB1 等。</p>
<ul>
<li><strong>伪终端(/dev/pty/)</strong></li>
</ul>
<p>伪终端 pty(Pseudo Terminal)是成对的逻辑终端设备，并存在成对的设备文件。伪终端由pts(pseudo-terminal slave)和ptm(pseudo-terminal master)两部分组成。</p>
<p>pts伪造出一个标准的TTY设备，应用程序可以直接访问。应用程序向pts写入的数据，会直接反映到ptm上，同样，应用程序从pts读数据，则相当于直接从ptm读取。</p>
<p>而pym，根据具体情况具体实现。例如：要通过网络接口和终端设备交互，则pym需要打开对应的socket，将pts写来的数据，从socket送出，将从socket读取的数据，送回给pts。打开/dev/ptmx文件的时候，系统会自动在/dev/pts目录下创建一个新的设备文件。只要不关闭/dev/ptmx文件描述符，那么这个设备文件就会存在，一旦关闭，这个设备文件会自动消失。</p>
<p>在telnet，ssh等远程终端工具中会使用到伪终端，telnet通过网络协议与linux主机上的telnetd进程通讯，telnetd进程收到网络中的数据后，将数据写入/dev/ptmx，/dev/ptmx像管道一样将数据传递给/dev/pts/x，getty进程从pts/x读取数据传递给shell去执行。</p>
<ul>
<li><strong>控制终端(/dev/tty)</strong></li>
</ul>
<p>如果当前进程有控制终端(Controlling Terminal)的话，那么/dev/tty 就是当前进程的控制终端的设备特殊文件。可以使用命令<code>ps –ax</code>来查看进程与哪个控制终端相连，使用命令<code>tty</code>可以查看它具体对应哪个实际终端设备。</p>
<ul>
<li><strong>控制台终端(/dev/ttyn，/dev/console)</strong></li>
</ul>
<p>在 UNIX 系统中，计算机显示器通常被称为控制台终端(console)。当用户在控制台上登录时，使用的是 tty1。可以使用 Alt+[F1<del>F6]组合键切换到 tty2</del>tty6。tty1~tty6 等称为虚拟终端，tty0 则是当前所使用虚拟终端的一个别名，系统所产生的信息会发送到该终端上。用户登录不同的虚拟终端，就有多个不同的会话期存在。只有超级用户可以向/dev/tty0 进行写操作。</p>
<p>可以在系统启动命令行里指定kernel使用那个控制台终端，格式如下:</p>
<blockquote>
<p>console=device， options</p>
</blockquote>
<ul>
<li>device 指代的是终端设备，可以是 tty0(前台的虚拟终端)、ttyx(第x个虚拟终端)、ttySx(第x个串口)、lp0(第一个并口)等。</li>
<li>options 指代对 device 进行的设置，它取决于具体的设备驱动。对于串口设备，参数定义为:波特率、校验位(n/o/e)、位数，默认 options 是 9600n8。</li>
</ul>
<p>用户可以在内核命令行中同时设定多个console，这样输出将会在所有的console上显示，而当用户调用open()打开/dev/console时，打开的是最后一个console。</p>
<p>通过查看 /proc/tty/drivers 文件可以获知tty设备驱动的信息。</p>
<h2 id="tty框架"><a href="#tty框架" class="headerlink" title="tty框架"></a>tty框架</h2><p>tty可以分为如下几层：</p>
<ul>
<li><strong>核心层（tty core）</strong>: 是tty设备的抽象</li>
<li><strong>线路规程（tty line discipline）</strong>: 是对上层和底层之间数据传输的协议转换, 不同类型的终端设备数据转换协议不同</li>
<li><strong>驱动层（tty driver）</strong>: 面向底层硬件的设备驱动</li>
</ul>
<p><img src="/images/kernel/tty/tty-arch.jpg" alt="img"></p>
<p><img src="/images/kernel/tty/tty-dev.bmp" alt="img"></p>
<p><img src="/images/kernel/tty/tty-ops.bmp" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">├── hvc</span><br><span class="line">├── ipwireless</span><br><span class="line">├── serdev</span><br><span class="line">├── vt</span><br><span class="line">├── serial</span><br><span class="line">│   ├── altera_uart.c</span><br><span class="line">│   ├── amba-pl010.c</span><br><span class="line">│   ├── amba-pl011.c</span><br><span class="line">│   ├── amba-pl011.h</span><br><span class="line">│   ├── atmel_serial.c</span><br><span class="line">│   ├── atmel_serial.h</span><br><span class="line">│   ├── rda-uart.c</span><br><span class="line">│   ├── samsung.c</span><br><span class="line">│   ├── samsung.h</span><br><span class="line">│   ├── serial_core.c</span><br><span class="line">│   ├── stm32-usart.c</span><br><span class="line">│   ├── stm32-usart.h</span><br><span class="line">├── tty_audit.c</span><br><span class="line">├── tty_baudrate.c</span><br><span class="line">├── tty_buffer.c</span><br><span class="line">├── tty_io.c        #ttty设备创建和相关文件操作API</span><br><span class="line">├── tty_ioctl.c</span><br><span class="line">├── tty_jobctrl.c</span><br><span class="line">├── tty_ldisc.c    #线路规程</span><br><span class="line">├── tty_ldsem.c</span><br><span class="line">├── tty_mutex.c</span><br><span class="line">├── tty_port.c</span><br><span class="line">├── n_tty.c</span><br><span class="line">├── n_gsm.c</span><br><span class="line">└── pty.c</span><br></pre></td></tr></table></figure>

<h2 id="tty核心层"><a href="#tty核心层" class="headerlink" title="tty核心层"></a>tty核心层</h2><h3 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> magic;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">  <span class="type">spinlock_t</span> ctrl_lock;</span><br><span class="line">  <span class="type">spinlock_t</span> flow_lock;</span><br><span class="line">  <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>  <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>   <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>   <span class="comment">/* winsize_mutex */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> stopped:<span class="number">1</span>,  <span class="comment">/* flow_lock */</span></span><br><span class="line">          flow_stopped:<span class="number">1</span>,</span><br><span class="line">          unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> hw_stopped;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ctrl_status:<span class="number">8</span>,  <span class="comment">/* ctrl_lock */</span></span><br><span class="line">          packet:<span class="number">1</span>,</span><br><span class="line">          unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">  <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">  <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">  <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">  <span class="type">void</span> *disc_data;</span><br><span class="line">  <span class="type">void</span> *driver_data;</span><br><span class="line">  <span class="type">spinlock_t</span> files_lock;    <span class="comment">/* protects tty_files list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> closing;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">  <span class="type">int</span> write_cnt;</span><br><span class="line">  <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tty-driver"><a href="#tty-driver" class="headerlink" title="tty_driver"></a>tty_driver</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span></span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line">  <span class="type">int</span> magic;    <span class="comment">/* magic number for this structure */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span> <span class="comment">/* Reference management */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> **<span class="title">cdevs</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>  *driver_name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>  *name;</span><br><span class="line">  <span class="type">int</span> name_base;  <span class="comment">/* offset of printed name */</span></span><br><span class="line">  <span class="type">int</span> major;    <span class="comment">/* major device number */</span></span><br><span class="line">  <span class="type">int</span> minor_start;  <span class="comment">/* start of minor device number */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>  num;  <span class="comment">/* number of devices allocated */</span></span><br><span class="line">  <span class="type">short</span> type;   <span class="comment">/* type of tty driver */</span></span><br><span class="line">  <span class="type">short</span> subtype;  <span class="comment">/* subtype of tty driver */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">init_termios</span>;</span> <span class="comment">/* Initial termios */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags;    <span class="comment">/* tty driver flags */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_entry</span>;</span> <span class="comment">/* /proc fs entry */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">other</span>;</span> <span class="comment">/* only used for the PTY driver */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> **<span class="title">ttys</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> **<span class="title">ports</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> **<span class="title">termios</span>;</span></span><br><span class="line">  <span class="type">void</span> *driver_state;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_drivers</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tty-port"><a href="#tty-port" class="headerlink" title="tty_port"></a>tty_port</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_bufhead</span>  <span class="title">buf</span>;</span>        <span class="comment">/* Locked internally */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span>   *<span class="title">tty</span>;</span>       <span class="comment">/* Back pointer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span>   *<span class="title">itty</span>;</span>      <span class="comment">/* internal back ptr */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_port_operations</span> *<span class="title">ops</span>;</span>  <span class="comment">/* Port operations */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_port_client_operations</span> *<span class="title">client_ops</span>;</span> <span class="comment">/* Port client operations */</span></span><br><span class="line">    <span class="type">spinlock_t</span>      lock;       <span class="comment">/* Lock protecting tty field */</span></span><br><span class="line">    <span class="type">int</span>         blocked_open;   <span class="comment">/* Waiting to open */</span></span><br><span class="line">    <span class="type">int</span>         count;      <span class="comment">/* Usage count */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span>   open_wait;  <span class="comment">/* Open waiters */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span>   delta_msr_wait; <span class="comment">/* Modem status change */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;      <span class="comment">/* User TTY flags ASYNC_ */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       iflags;     <span class="comment">/* Internal flags TTY_PORT_ */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>       console:<span class="number">1</span>,  <span class="comment">/* port is a console */</span></span><br><span class="line">                low_latency:<span class="number">1</span>;  <span class="comment">/* optional: tune for latency */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">mutex</span>;</span>      <span class="comment">/* Locking */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">buf_mutex</span>;</span>  <span class="comment">/* Buffer alloc lock */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>       *xmit_buf;  <span class="comment">/* Optional buffer */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        close_delay;    <span class="comment">/* Close port delay */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        closing_wait;   <span class="comment">/* Delay for output */</span></span><br><span class="line">    <span class="type">int</span>         drain_delay;    <span class="comment">/* Set to zero if no pure time</span></span><br><span class="line"><span class="comment">                           based drain is needed else</span></span><br><span class="line"><span class="comment">                           set to size of fifo */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>     <span class="title">kref</span>;</span>       <span class="comment">/* Ref counter */</span></span><br><span class="line">    <span class="type">void</span>            *client_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tty-port-operations"><a href="#tty-port-operations" class="headerlink" title="tty_port_operations"></a>tty_port_operations</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_port_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*carrier_raised)(<span class="keyword">struct</span> tty_port *port);</span><br><span class="line">    <span class="type">void</span> (*dtr_rts)(<span class="keyword">struct</span> tty_port *port, <span class="type">int</span> raise);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_port *port);</span><br><span class="line">    <span class="type">int</span> (*activate)(<span class="keyword">struct</span> tty_port *port, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*destruct)(<span class="keyword">struct</span> tty_port *port);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tty-operations"><a href="#tty-operations" class="headerlink" title="tty_operations"></a>tty_operations</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">      <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">  <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">  <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">  <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">          <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">  <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">  <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">  <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">           <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">  <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">  <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">  <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">  <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">  <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">  <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">  <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">  <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">  <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line">  <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">        <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">  <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">  <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">  <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">  <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">  <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">  <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tty-register-driver"><a href="#tty-register-driver" class="headerlink" title="tty_register_driver()"></a>tty_register_driver()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_register_driver</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> error;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">dev_t</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">d</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册字符设备 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!driver-&gt;major) &#123;</span><br><span class="line">    error = alloc_chrdev_region(&amp;dev, driver-&gt;minor_start,</span><br><span class="line">            driver-&gt;num, driver-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">      driver-&gt;major = MAJOR(dev);</span><br><span class="line">      driver-&gt;minor_start = MINOR(dev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dev = MKDEV(driver-&gt;major, driver-&gt;minor_start);</span><br><span class="line">    error = register_chrdev_region(dev, driver-&gt;num, driver-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_ALLOC) &#123;</span><br><span class="line">    error = tty_cdev_add(driver, dev, <span class="number">0</span>, driver-&gt;num);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutex_lock(&amp;tty_mutex);</span><br><span class="line">  list_add(&amp;driver-&gt;tty_drivers, &amp;tty_drivers);  <span class="comment">//添加到全局链表 tty_drivers</span></span><br><span class="line">  mutex_unlock(&amp;tty_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_DEV)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; driver-&gt;num; i++) &#123;</span><br><span class="line">      d = tty_register_device(driver, i, <span class="literal">NULL</span>); <span class="comment">//注册tty设备</span></span><br><span class="line">      <span class="keyword">if</span> (IS_ERR(d)) &#123;</span><br><span class="line">        error = PTR_ERR(d);</span><br><span class="line">        <span class="keyword">goto</span> err_unreg_devs;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  proc_tty_register_driver(driver);  <span class="comment">//添加 proc 文件系统</span></span><br><span class="line">  driver-&gt;flags |= TTY_DRIVER_INSTALLED;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tty_cdev_add</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver, <span class="type">dev_t</span> dev,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  driver-&gt;cdevs[index] = cdev_alloc();</span><br><span class="line">  <span class="keyword">if</span> (!driver-&gt;cdevs[index])</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  driver-&gt;cdevs[index]-&gt;ops = &amp;tty_fops;  <span class="comment">//设置文件操作函数集 tty_fops</span></span><br><span class="line">  driver-&gt;cdevs[index]-&gt;owner = driver-&gt;owner;</span><br><span class="line">  err = cdev_add(driver-&gt;cdevs[index], dev, count);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    kobject_put(&amp;driver-&gt;cdevs[index]-&gt;kobj);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册字符设备，将该 tty_driver-&gt;tty_drivers 添加到全局链表 tty_drivers。添加 proc 文件系统。设置文件操作函数集 tty_fops。</p>
<h3 id="tty-open"><a href="#tty-open" class="headerlink" title="tty_open()"></a>tty_open()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tty_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">  <span class="type">int</span> noctty, retval;</span><br><span class="line">  <span class="type">dev_t</span> device = inode-&gt;i_rdev;</span><br><span class="line">  <span class="type">unsigned</span> saved_flags = filp-&gt;f_flags;</span><br><span class="line"></span><br><span class="line">  tty = tty_open_current_tty(device, filp); <span class="comment">/* 获取当前线程锁定的tty */</span></span><br><span class="line">  <span class="keyword">if</span> (!tty)</span><br><span class="line">    tty = tty_open_by_driver(device, inode, filp); <span class="comment">/* 通过查找tty驱动打开tty设备 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tty-&gt;ops-&gt;open)</span><br><span class="line">    retval = tty-&gt;ops-&gt;open(tty, filp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tty_struct *<span class="title function_">tty_open_current_tty</span><span class="params">(<span class="type">dev_t</span> device, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前设备是/dev/tty则尝试重新打开 */</span></span><br><span class="line">    <span class="keyword">if</span> (device != MKDEV(TTYAUX_MAJOR, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tty = get_current_tty();</span><br><span class="line">    retval = tty_reopen(tty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tty_reopen</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span> =</span> tty-&gt;driver;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ld</span>;</span></span><br><span class="line"></span><br><span class="line">    ld = tty_ldisc_ref_wait(tty);</span><br><span class="line">    <span class="keyword">if</span> (ld) &#123;</span><br><span class="line">        tty_ldisc_deref(ld);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        retval = tty_ldisc_lock(tty, <span class="number">5</span> * HZ);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!tty-&gt;ldisc)</span><br><span class="line">            retval = tty_ldisc_reinit(tty, tty-&gt;termios.c_line);  </span><br><span class="line">        tty_ldisc_unlock(tty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用线路规程的<a href="#tty_ldisc_reinit()">tty_ldisc_reinit()</a>函数重新初始化tty设备的线路规程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tty_struct *<span class="title function_">tty_open_by_driver</span><span class="params">(<span class="type">dev_t</span> device, <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从 tty_drivers 全局链表中获取注册的 tty_driver */</span></span><br><span class="line">    driver = tty_lookup_driver(device, filp, &amp;index);</span><br><span class="line"></span><br><span class="line">    通过 tty_drivers 查找 tty_struct</span><br><span class="line">    tty = tty_driver_lookup_tty(driver, filp, index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tty) &#123;</span><br><span class="line">        tty_reopen(tty);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        tty = tty_init_dev(driver, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tty_struct *<span class="title function_">tty_init_dev</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    tty = alloc_tty_struct(driver, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tty-&gt;port)</span><br><span class="line">        tty-&gt;port = driver-&gt;ports[idx];</span><br><span class="line"></span><br><span class="line">    tty_ldisc_lock(tty, <span class="number">5</span> * HZ);</span><br><span class="line">    tty-&gt;port-&gt;itty = tty;</span><br><span class="line"></span><br><span class="line">    tty_ldisc_setup(tty, tty-&gt;link);</span><br><span class="line">    <span class="keyword">return</span> tty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tty_struct *<span class="title function_">alloc_tty_struct</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line"></span><br><span class="line">    tty = kzalloc(<span class="keyword">sizeof</span>(*tty), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    kref_init(&amp;tty-&gt;kref);</span><br><span class="line">    tty-&gt;magic = TTY_MAGIC;</span><br><span class="line"></span><br><span class="line">    tty_ldisc_init(tty);</span><br><span class="line"></span><br><span class="line">    tty-&gt;session = <span class="literal">NULL</span>;</span><br><span class="line">    tty-&gt;pgrp = <span class="literal">NULL</span>;</span><br><span class="line">    mutex_init(&amp;tty-&gt;legacy_mutex);</span><br><span class="line">    mutex_init(&amp;tty-&gt;throttle_mutex);</span><br><span class="line">    init_rwsem(&amp;tty-&gt;termios_rwsem);</span><br><span class="line">    mutex_init(&amp;tty-&gt;winsize_mutex);</span><br><span class="line">    init_ldsem(&amp;tty-&gt;ldisc_sem);</span><br><span class="line">    init_waitqueue_head(&amp;tty-&gt;write_wait);</span><br><span class="line">    init_waitqueue_head(&amp;tty-&gt;read_wait);</span><br><span class="line">    INIT_WORK(&amp;tty-&gt;hangup_work, do_tty_hangup);</span><br><span class="line">    mutex_init(&amp;tty-&gt;atomic_write_lock);</span><br><span class="line">    spin_lock_init(&amp;tty-&gt;ctrl_lock);</span><br><span class="line">    spin_lock_init(&amp;tty-&gt;flow_lock);</span><br><span class="line">    spin_lock_init(&amp;tty-&gt;files_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;tty-&gt;tty_files);</span><br><span class="line">    INIT_WORK(&amp;tty-&gt;SAK_work, do_SAK_work);</span><br><span class="line"></span><br><span class="line">    tty-&gt;driver = driver;</span><br><span class="line">    tty-&gt;ops = driver-&gt;ops;  <span class="comment">/* 设置tty设备文件操作接口 */</span></span><br><span class="line">    tty-&gt;index = idx;</span><br><span class="line">    tty_line_name(driver, idx, tty-&gt;name);</span><br><span class="line">    tty-&gt;dev = tty_get_device(tty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_ldisc_setup</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> tty_struct *o_tty)</span></span><br><span class="line">&#123;</span><br><span class="line">    tty_ldisc_open(tty, tty-&gt;ldisc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化一个 tty_struct，调用<a href="#tty_ldisc_open()">tty_ldisc_open()</a>打开一个线路规程。最后调用 tty_struct-&gt;ops-&gt;open 函数，其实是tty_driver-&gt;ops-&gt;open，也就是uart_ops中的open函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_open</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> *<span class="title">drv</span> =</span> tty-&gt;driver-&gt;driver_state;</span><br><span class="line">    <span class="type">int</span> retval, line = tty-&gt;index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span> =</span> drv-&gt;state + line;</span><br><span class="line"></span><br><span class="line">    tty-&gt;driver_data = state;</span><br><span class="line"></span><br><span class="line">    retval = tty_port_open(&amp;state-&gt;port, tty, filp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_port_open</span><span class="params">(<span class="keyword">struct</span> tty_port *port, <span class="keyword">struct</span> tty_struct *tty,</span></span><br><span class="line"><span class="params">                            <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock_irq(&amp;port-&gt;lock);</span><br><span class="line">    ++port-&gt;count;</span><br><span class="line">    spin_unlock_irq(&amp;port-&gt;lock);</span><br><span class="line">    tty_port_tty_set(port, tty);</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;port-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tty_port_initialized(port)) &#123;</span><br><span class="line">        clear_bit(TTY_IO_ERROR, &amp;tty-&gt;flags);</span><br><span class="line">        <span class="keyword">if</span> (port-&gt;ops-&gt;activate) &#123;</span><br><span class="line">            <span class="type">int</span> retval = port-&gt;ops-&gt;activate(port, tty);</span><br><span class="line">        &#125;</span><br><span class="line">        tty_port_set_initialized(port, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;port-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> tty_port_block_til_ready(port, tty, filp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_port_activate</span><span class="params">(<span class="keyword">struct</span> tty_port *port, <span class="keyword">struct</span> tty_struct *tty)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span> =</span> container_of(port, <span class="keyword">struct</span> uart_state, port);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">uport</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uart_startup(tty, state, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_startup</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> uart_state *state,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> init_hw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span> =</span> &amp;state-&gt;port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uart_port_startup(tty, state, init_hw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_port_startup</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> uart_state *state,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> init_hw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">uport</span> =</span> uart_port_check(state);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> page;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uport-&gt;type == PORT_UNKNOWN)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    uart_change_pm(state, UART_PM_STATE_ON);</span><br><span class="line"></span><br><span class="line">    page = get_zeroed_page(GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    uart_port_lock(state, flags);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;xmit.buf) &#123;</span><br><span class="line">        state-&gt;xmit.buf = (<span class="type">unsigned</span> <span class="type">char</span> *) page;</span><br><span class="line">        uart_circ_clear(&amp;state-&gt;xmit);</span><br><span class="line">        uart_port_unlock(uport, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        uart_port_unlock(uport, flags);</span><br><span class="line">        free_page(page);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    retval = uport-&gt;ops-&gt;startup(uport);</span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uart_console(uport) &amp;&amp; uport-&gt;cons-&gt;cflag) &#123;</span><br><span class="line">            tty-&gt;termios.c_cflag = uport-&gt;cons-&gt;cflag;</span><br><span class="line">            uport-&gt;cons-&gt;cflag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uart_change_speed(tty, state, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (init_hw &amp;&amp; C_BAUD(tty))</span><br><span class="line">            uart_port_dtr_rts(uport, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用的是state-&gt;uart_port-&gt;ops-&gt;startup()函数。</p>
<h3 id="tty-write"><a href="#tty-write" class="headerlink" title="tty_write()"></a>tty_write()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">tty_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">                        <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ld</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span> =</span> file_tty(file);</span><br><span class="line">        </span><br><span class="line">    ld = tty-&gt;ldisc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ld)</span><br><span class="line">        <span class="keyword">return</span> hung_up_tty_write(file, buf, count, ppos);</span><br><span class="line">    <span class="keyword">if</span> (!ld-&gt;ops-&gt;write)</span><br><span class="line">        ret = -EIO;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count);</span><br><span class="line">    tty_ldisc_deref(ld);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">ssize_t</span> <span class="title function_">do_tty_write</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>),</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> tty_struct *tty,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> ret, written = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> chunk;</span><br><span class="line"></span><br><span class="line">    ret = tty_write_lock(tty, file-&gt;f_flags &amp; O_NDELAY);</span><br><span class="line"></span><br><span class="line">    chunk = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">if</span> (test_bit(TTY_NO_WRITE_SPLIT, &amp;tty-&gt;flags))</span><br><span class="line">        chunk = <span class="number">65536</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; chunk)</span><br><span class="line">        chunk = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tty-&gt;write_cnt &lt; chunk) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *buf_chunk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (chunk &lt; <span class="number">1024</span>)</span><br><span class="line">            chunk = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        buf_chunk = kmalloc(chunk, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!buf_chunk) &#123;</span><br><span class="line">            ret = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        kfree(tty-&gt;write_buf);</span><br><span class="line">        tty-&gt;write_cnt = chunk;</span><br><span class="line">        tty-&gt;write_buf = buf_chunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">size_t</span> size = count;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; chunk)</span><br><span class="line">            size = chunk;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(tty-&gt;write_buf, buf, size))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ret = write(tty, file, tty-&gt;write_buf, size);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        written += ret;</span><br><span class="line">        buf += ret;</span><br><span class="line">        count -= ret;</span><br><span class="line">        <span class="keyword">if</span> (!count)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ret = -ERESTARTSYS;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cond_resched();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (written) &#123;</span><br><span class="line">        tty_update_time(&amp;file_inode(file)-&gt;i_mtime);</span><br><span class="line">        ret = written;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    tty_write_unlock(tty);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="串口驱动层"><a href="#串口驱动层" class="headerlink" title="串口驱动层"></a>串口驱动层</h2><h3 id="uart-driver"><a href="#uart-driver" class="headerlink" title="uart_driver"></a>uart_driver</h3><p>uart_driver描述串口驱动，包含了串口设备名、串口驱动名、主次设备号、串口控制台等信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>   *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>    *driver_name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>    *dev_name;</span><br><span class="line">    <span class="type">int</span>      major;</span><br><span class="line">    <span class="type">int</span>      minor;</span><br><span class="line">    <span class="type">int</span>      nr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">console</span>    *<span class="title">cons</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">tty_driver</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span>     <span class="title">port</span>;</span></span><br><span class="line">    <span class="type">int</span>         pm_state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">circ_buf</span>     <span class="title">xmit</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span>    *<span class="title">uart_port</span>;</span> <span class="comment">// 对应于一个串口设备</span></span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<h3 id="uart-port"><a href="#uart-port" class="headerlink" title="uart_port"></a>uart_port</h3><p>uart_port 用于描述一个UART端口的I/O端口或I/O内存地址、FIFO大小、端口类型等信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span>    lock;     <span class="comment">/* port lock */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   iobase;     <span class="comment">/* in/out[bwl] */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> __iomem *membase;   <span class="comment">/* read/write[bwl] */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span>    <span class="params">(*serial_in)</span><span class="params">(<span class="keyword">struct</span> uart_port *, <span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">void</span>      (*serial_out)(<span class="keyword">struct</span> uart_port *, <span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span>      (*set_termios)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">                        <span class="keyword">struct</span> ktermios *new,</span><br><span class="line">                        <span class="keyword">struct</span> ktermios *old);</span><br><span class="line">    <span class="type">void</span>      (*set_ldisc)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">                <span class="keyword">struct</span> ktermios *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span>    <span class="params">(*get_mctrl)</span><span class="params">(<span class="keyword">struct</span> uart_port *)</span>;</span><br><span class="line">    <span class="type">void</span>      (*set_mctrl)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span>    <span class="params">(*get_divisor)</span><span class="params">(<span class="keyword">struct</span> uart_port *,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">int</span> baud,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">int</span> *frac)</span>;</span><br><span class="line">    <span class="type">void</span>      (*set_divisor)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">int</span> baud,</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">int</span> quot,</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">int</span> quot_frac);</span><br><span class="line">    <span class="type">int</span>     (*startup)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">    <span class="type">void</span>      (*shutdown)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">    <span class="type">void</span>      (*throttle)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">    <span class="type">void</span>      (*unthrottle)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">    <span class="type">int</span>     (*handle_irq)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">    <span class="type">void</span>      (*pm)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span> state,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> old);</span><br><span class="line">    <span class="type">void</span>      (*handle_break)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">    <span class="type">int</span>     (*rs485_config)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">            <span class="keyword">struct</span> serial_rs485 *rs485);</span><br><span class="line">    <span class="type">int</span>     (*iso7816_config)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">                <span class="keyword">struct</span> serial_iso7816 *iso7816);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    irq;      <span class="comment">/* irq number */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   irqflags;   <span class="comment">/* irq flags  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    uartclk;    <span class="comment">/* base uart clock */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    fifosize;   <span class="comment">/* tx fifo size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   x_char;     <span class="comment">/* xon/xoff char */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   regshift;   <span class="comment">/* reg offset shift */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   iotype;     <span class="comment">/* io access style */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   quirks;     <span class="comment">/* internal quirks */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    read_status_mask; <span class="comment">/* driver specific */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    ignore_status_mask; <span class="comment">/* driver specific */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span>;</span>     <span class="comment">/* pointer to parent state */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_icount</span>  <span class="title">icount</span>;</span>     <span class="comment">/* statistics */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">console</span>    *<span class="title">cons</span>;</span>      <span class="comment">/* struct console, if any */</span></span><br><span class="line">    <span class="type">upf_t</span>     flags;</span><br><span class="line">    <span class="type">upstat_t</span>    status; </span><br><span class="line">    <span class="type">int</span>     hw_stopped;   <span class="comment">/* sw-assisted CTS flow state */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    mctrl;      <span class="comment">/* current modem ctrl settings */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    timeout;    <span class="comment">/* character-based timeout */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    type;     <span class="comment">/* port type */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    custom_divisor;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    line;     <span class="comment">/* port index */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    minor;</span><br><span class="line">    <span class="type">resource_size_t</span>   mapbase;    <span class="comment">/* for ioremap */</span></span><br><span class="line">    <span class="type">resource_size_t</span>   mapsize;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>   *<span class="title">dev</span>;</span>     <span class="comment">/* parent device */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   hub6;     <span class="comment">/* this should be in the 8250 driver */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   suspended;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   unused[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>    *name;      <span class="comment">/* port name */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>  *<span class="title">attr_group</span>;</span>    <span class="comment">/* port specific attributes */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">tty_groups</span>;</span>  <span class="comment">/* all attributes (serial core use only) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">serial_rs485</span>     <span class="title">rs485</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">serial_iso7816</span> <span class="title">iso7816</span>;</span>                                                         <span class="type">void</span>      *private_data;    <span class="comment">/* generic platform data pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>uart_port对应一个串口设备，用于描述串口端口的I/O端口或I/O内存地址、FIFO大小、端口类型、串口时钟等信息，需要实现串口相关操作方法的 uart_ops 结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> &#123;</span></span><br><span class="line">    unsignedint(*tx_empty)(<span class="keyword">struct</span> uart_port *); <span class="comment">/* 串口的Tx FIFO缓存是否为空 */</span></span><br><span class="line">    <span class="type">void</span>(*set_mctrl)(<span class="keyword">struct</span> uart_port *,unsignedint mctrl); <span class="comment">/* 设置串口modem控制 */</span></span><br><span class="line">    unsignedint(*get_mctrl)(<span class="keyword">struct</span> uart_port *);    <span class="comment">/* 获取串口modem控制 */</span></span><br><span class="line">    <span class="type">void</span>(*stop_tx)(<span class="keyword">struct</span> uart_port *); <span class="comment">/* 禁止串口发送数据 */</span></span><br><span class="line">    <span class="type">void</span>(*start_tx)(<span class="keyword">struct</span> uart_port *);    <span class="comment">/* 使能串口发送数据 */</span></span><br><span class="line">    <span class="type">void</span>(*send_xchar)(<span class="keyword">struct</span> uart_port *,<span class="type">char</span> ch);  <span class="comment">/* 发送xChar */</span></span><br><span class="line">    <span class="type">void</span>(*stop_rx)(<span class="keyword">struct</span> uart_port *); <span class="comment">/* 禁止串口接收数据 */</span></span><br><span class="line">    <span class="type">void</span>(*enable_ms)(<span class="keyword">struct</span> uart_port *);   <span class="comment">/* 使能modem的状态信号 */</span></span><br><span class="line">    <span class="type">void</span>(*break_ctl)(<span class="keyword">struct</span> uart_port *,<span class="type">int</span> ctl);   <span class="comment">/* 设置break信号 */</span></span><br><span class="line">    <span class="type">int</span>(*startup)(<span class="keyword">struct</span> uart_port *);  <span class="comment">/* 启动串口,应用程序打开串口设备文件时,该函数会被调用 */</span></span><br><span class="line">    <span class="type">void</span>(*shutdown)(<span class="keyword">struct</span> uart_port *);    <span class="comment">/* 关闭串口,应用程序关闭串口设备文件时,该函数会被调用 */</span></span><br><span class="line">    <span class="type">void</span>(*set_termios)(<span class="keyword">struct</span> uart_port *,<span class="keyword">struct</span> ktermios *new,<span class="keyword">struct</span> ktermios *old);   <span class="comment">/* 设置串口参数 */</span></span><br><span class="line">    <span class="type">void</span>(*pm)(<span class="keyword">struct</span> uart_port *,unsignedint state,</span><br><span class="line">    unsignedint oldstate);  <span class="comment">/* 串口电源管理 */</span></span><br><span class="line">    <span class="type">int</span>(*set_wake)(<span class="keyword">struct</span> uart_port *,unsignedint state);   <span class="comment">/* */</span></span><br><span class="line">    constchar*(*type)(<span class="keyword">struct</span> uart_port *);  <span class="comment">/* 返回一描述串口类型的字符串 */</span></span><br><span class="line">    <span class="type">void</span>(*release_port)(<span class="keyword">struct</span> uart_port *);    <span class="comment">/* 释放串口已申请的IO端口/IO内存资源,必要时还需iounmap */</span></span><br><span class="line">    <span class="type">int</span>(*request_port)(<span class="keyword">struct</span> uart_port *); <span class="comment">/* 申请必要的IO端口/IO内存资源,必要时还可以重新映射串口端口 */</span></span><br><span class="line">    <span class="type">void</span>(*config_port)(<span class="keyword">struct</span> uart_port *,<span class="type">int</span>); <span class="comment">/* 执行串口所需的自动配置 */</span></span><br><span class="line">    <span class="type">int</span>(*verify_port)(<span class="keyword">struct</span> uart_port *,<span class="keyword">struct</span> serial_struct *);   <span class="comment">/* 核实新串口的信息 */</span></span><br><span class="line">    <span class="type">int</span>(*ioctl)(<span class="keyword">struct</span> uart_port *,unsignedint,unsignedlong);   <span class="comment">/* IO控制 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="uart-driver注册"><a href="#uart-driver注册" class="headerlink" title="uart_driver注册"></a>uart_driver注册</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> <span class="title">s3c24xx_uart_drv</span> =</span> &#123;</span><br><span class="line">    .owner      = THIS_MODULE,</span><br><span class="line">    .driver_name    = <span class="string">&quot;s3c2410_serial&quot;</span>,</span><br><span class="line">    .nr     = CONFIG_SERIAL_SAMSUNG_UARTS,</span><br><span class="line">    .cons       = S3C24XX_SERIAL_CONSOLE,</span><br><span class="line">    .dev_name   = S3C24XX_SERIAL_NAME,</span><br><span class="line">    .major      = S3C24XX_SERIAL_MAJOR,</span><br><span class="line">    .minor      = S3C24XX_SERIAL_MINOR,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c24xx_uart_port</span></span></span><br><span class="line"><span class="class"><span class="title">s3c24xx_serial_ports</span>[<span class="title">CONFIG_SERIAL_SAMSUNG_UARTS</span>] =</span> &#123;</span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .port = &#123;</span><br><span class="line">            .lock       = __PORT_LOCK_UNLOCKED(<span class="number">0</span>),</span><br><span class="line">            .iotype     = UPIO_MEM,</span><br><span class="line">            .uartclk    = <span class="number">0</span>,</span><br><span class="line">            .fifosize   = <span class="number">16</span>,</span><br><span class="line">            .ops        = &amp;s3c24xx_serial_ops,</span><br><span class="line">            .flags      = UPF_BOOT_AUTOCONF,</span><br><span class="line">            .line       = <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .port = &#123;</span><br><span class="line">            .lock       = __PORT_LOCK_UNLOCKED(<span class="number">1</span>),</span><br><span class="line">            .iotype     = UPIO_MEM,</span><br><span class="line">            .uartclk    = <span class="number">0</span>,</span><br><span class="line">            .fifosize   = <span class="number">16</span>,</span><br><span class="line">            .ops        = &amp;s3c24xx_serial_ops,</span><br><span class="line">            .flags      = UPF_BOOT_AUTOCONF,</span><br><span class="line">            .line       = <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_serial_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c24xx_uart_port</span> *<span class="title">ourport</span>;</span></span><br><span class="line">    <span class="type">int</span> index = probe_index;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ourport = &amp;s3c24xx_serial_ports[index];</span><br><span class="line"></span><br><span class="line">    ourport-&gt;drv_data = s3c24xx_get_driver_data(pdev);</span><br><span class="line"></span><br><span class="line">    ourport-&gt;baudclk = ERR_PTR(-EINVAL);</span><br><span class="line">    ourport-&gt;info = ourport-&gt;drv_data-&gt;info;</span><br><span class="line">    ourport-&gt;cfg = (dev_get_platdata(&amp;pdev-&gt;dev)) ?</span><br><span class="line">            dev_get_platdata(&amp;pdev-&gt;dev) :</span><br><span class="line">            ourport-&gt;drv_data-&gt;def_cfg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ourport-&gt;drv_data-&gt;fifosize[index])</span><br><span class="line">        ourport-&gt;port.fifosize = ourport-&gt;drv_data-&gt;fifosize[index];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ourport-&gt;info-&gt;fifosize)</span><br><span class="line">        ourport-&gt;port.fifosize = ourport-&gt;info-&gt;fifosize;</span><br><span class="line"></span><br><span class="line">    ourport-&gt;min_dma_size = <span class="type">max_t</span>(<span class="type">int</span>, ourport-&gt;port.fifosize,</span><br><span class="line">                    dma_get_cache_alignment());</span><br><span class="line"></span><br><span class="line">    ret = s3c24xx_serial_init_port(ourport, pdev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s3c24xx_uart_drv.state) &#123;</span><br><span class="line">        ret = uart_register_driver(&amp;s3c24xx_uart_drv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将 uart_port 注册到 uart_driver */</span></span><br><span class="line">    uart_add_one_port(&amp;s3c24xx_uart_drv, &amp;ourport-&gt;port);</span><br><span class="line">    platform_set_drvdata(pdev, &amp;ourport-&gt;port);</span><br><span class="line"></span><br><span class="line">    clk_disable_unprepare(ourport-&gt;clk);</span><br><span class="line"></span><br><span class="line">    ret = s3c24xx_serial_cpufreq_register(ourport);</span><br><span class="line"></span><br><span class="line">    probe_index++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">samsung_serial_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = s3c24xx_serial_probe,</span><br><span class="line">    .remove     = s3c24xx_serial_remove,</span><br><span class="line">    .id_table   = s3c24xx_serial_driver_ids,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;samsung-uart&quot;</span>,</span><br><span class="line">        .pm = SERIAL_SAMSUNG_PM_OPS,</span><br><span class="line">        .of_match_table = of_match_ptr(s3c24xx_uart_dt_match),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_platform_driver(samsung_serial_driver);</span><br></pre></td></tr></table></figure>

<p>先实例化一个 uart_driver 结构体，再调用 <a href="#uart_register_driver()">uart_register_driver()</a>函数注册到内核。通过 <a href="#uart_add_one_port()">uart_add_one_port()</a>函数向该驱动添加uart_port。</p>
<h3 id="uart-register-driver"><a href="#uart-register-driver" class="headerlink" title="uart_register_driver()"></a>uart_register_driver()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_port_operations</span> <span class="title">uart_port_ops</span> =</span> &#123;</span><br><span class="line">    .carrier_raised = uart_carrier_raised,</span><br><span class="line">    .dtr_rts    = uart_dtr_rts,</span><br><span class="line">    .activate   = uart_port_activate,</span><br><span class="line">    .shutdown   = uart_tty_port_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_register_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">normal</span>;</span> </span><br><span class="line">    <span class="type">int</span> i, retval; </span><br><span class="line"></span><br><span class="line">    BUG_ON(drv-&gt;state); </span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Maybe we should be using a slab cache for this, especially if</span></span><br><span class="line"><span class="comment">    * we have a large number of ports to handle.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    drv-&gt;state = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> uart_state) * drv-&gt;nr, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!drv-&gt;state)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">        </span><br><span class="line">    normal = alloc_tty_driver(drv-&gt;nr);</span><br><span class="line">    <span class="keyword">if</span> (!normal)</span><br><span class="line">        <span class="keyword">goto</span> out_kfree;</span><br><span class="line">        </span><br><span class="line">    drv-&gt;tty_driver = normal;</span><br><span class="line">        </span><br><span class="line">    normal-&gt;driver_name = drv-&gt;driver_name;</span><br><span class="line">    normal-&gt;name    = drv-&gt;dev_name;</span><br><span class="line">    normal-&gt;major   = drv-&gt;major;</span><br><span class="line">    normal-&gt;minor_start = drv-&gt;minor;</span><br><span class="line">    normal-&gt;type    = TTY_DRIVER_TYPE_SERIAL;</span><br><span class="line">    normal-&gt;subtype   = SERIAL_TYPE_NORMAL;</span><br><span class="line">    normal-&gt;init_termios  = tty_std_termios;</span><br><span class="line">    normal-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;</span><br><span class="line">    normal-&gt;init_termios.c_ispeed = normal-&gt;init_termios.c_ospeed = <span class="number">9600</span>;</span><br><span class="line">    normal-&gt;flags   = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;</span><br><span class="line">    normal-&gt;driver_state    = drv;</span><br><span class="line">    tty_set_operations(normal, &amp;uart_ops);  <span class="comment">//将tty_driver的操作集设为uart_ops</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; drv-&gt;nr; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span> =</span> drv-&gt;state + i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span> =</span> &amp;state-&gt;port;</span><br><span class="line">        </span><br><span class="line">        tty_port_init(port);</span><br><span class="line">        port-&gt;ops = &amp;uart_port_ops;</span><br><span class="line">        port-&gt;close_delay     = HZ / <span class="number">2</span>; <span class="comment">/* .5 seconds */</span></span><br><span class="line">        port-&gt;closing_wait    = <span class="number">30</span> * HZ;<span class="comment">/* 30 seconds */</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    retval = tty_register_driver(normal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配一个 tty_driver，对 tty_driver 进行设置，其中包括默认波特率、校验方式等，然后调用<a href="#tty_register_driver()">tty_register_driver()</a>函数注册 tty_driver。根据 uart_driver-&gt;nr 来申请 nr 个 uart_state 空间，用来存放驱动所支持的串口端口的物理信息，每一个 uart_state 都有一个 uart_port。</p>
<h3 id="uart-add-one-port"><a href="#uart-add-one-port" class="headerlink" title="uart_add_one_port()"></a>uart_add_one_port()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uart_add_one_port</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv, <span class="keyword">struct</span> uart_port *uport)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">tty_dev</span>;</span></span><br><span class="line">    <span class="type">int</span> num_groups;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uport-&gt;line &gt;= drv-&gt;nr)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    state = drv-&gt;state + uport-&gt;line;</span><br><span class="line">    port = &amp;state-&gt;port;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;port_mutex);</span><br><span class="line">    mutex_lock(&amp;port-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_set</span>(&amp;state-&gt;refcount, <span class="number">1</span>);</span><br><span class="line">    init_waitqueue_head(&amp;state-&gt;remove_wait);</span><br><span class="line">    state-&gt;uart_port = uport;</span><br><span class="line">    uport-&gt;state = state;</span><br><span class="line"></span><br><span class="line">    state-&gt;pm_state = UART_PM_STATE_UNDEFINED;</span><br><span class="line">    uport-&gt;cons = drv-&gt;cons;</span><br><span class="line">    uport-&gt;minor = drv-&gt;tty_driver-&gt;minor_start + uport-&gt;line;</span><br><span class="line">    uport-&gt;name = kasprintf(GFP_KERNEL, <span class="string">&quot;%s%d&quot;</span>, drv-&gt;dev_name,</span><br><span class="line">                drv-&gt;tty_driver-&gt;name_base + uport-&gt;line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(uart_console(uport) &amp;&amp; (uport-&gt;cons-&gt;flags &amp; CON_ENABLED))) &#123;</span><br><span class="line">        spin_lock_init(&amp;uport-&gt;lock);</span><br><span class="line">        lockdep_set_class(&amp;uport-&gt;lock, &amp;port_lock_key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (uport-&gt;cons &amp;&amp; uport-&gt;dev)</span><br><span class="line">        of_console_check(uport-&gt;dev-&gt;of_node, uport-&gt;cons-&gt;name, uport-&gt;line);</span><br><span class="line"></span><br><span class="line">    uart_configure_port(drv, state, uport);</span><br><span class="line"></span><br><span class="line">    port-&gt;console = uart_console(uport);</span><br><span class="line"></span><br><span class="line">    num_groups = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (uport-&gt;attr_group)</span><br><span class="line">        num_groups++;</span><br><span class="line"></span><br><span class="line">    uport-&gt;tty_groups = kcalloc(num_groups, <span class="keyword">sizeof</span>(*uport-&gt;tty_groups),</span><br><span class="line">                    GFP_KERNEL);</span><br><span class="line">    uport-&gt;tty_groups[<span class="number">0</span>] = &amp;tty_dev_attr_group;</span><br><span class="line">    <span class="keyword">if</span> (uport-&gt;attr_group)</span><br><span class="line">        uport-&gt;tty_groups[<span class="number">1</span>] = uport-&gt;attr_group;</span><br><span class="line"></span><br><span class="line">    tty_dev = tty_port_register_device_attr_serdev(port, drv-&gt;tty_driver,</span><br><span class="line">            uport-&gt;line, uport-&gt;dev, port, uport-&gt;tty_groups);</span><br><span class="line"></span><br><span class="line">    uport-&gt;flags &amp;= ~UPF_DEAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>將 uart_prot 关联到 uart_driver 对应的 state。</p>
<h2 id="线路规程"><a href="#线路规程" class="headerlink" title="线路规程"></a>线路规程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc_ops</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> magic;</span><br><span class="line">    <span class="type">char</span>    *name;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> tty_struct *);</span><br><span class="line">    <span class="type">void</span>    (*close)(<span class="keyword">struct</span> tty_struct *);</span><br><span class="line">    <span class="type">void</span>    (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">ssize_t</span> (*read)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *file,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> nr);</span><br><span class="line">    <span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *file,</span><br><span class="line">             <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">size_t</span> nr);</span><br><span class="line">    <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *file,</span><br><span class="line">             <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">int</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *file,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span>    (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios *old);</span><br><span class="line">    <span class="type">__poll_t</span> (*poll)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> file *,</span><br><span class="line">                 <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">    <span class="type">int</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span>    (*receive_buf)(<span class="keyword">struct</span> tty_struct *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *cp,</span><br><span class="line">                   <span class="type">char</span> *fp, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">void</span>    (*write_wakeup)(<span class="keyword">struct</span> tty_struct *);</span><br><span class="line">    <span class="type">void</span>    (*dcd_change)(<span class="keyword">struct</span> tty_struct *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*receive_buf2)(<span class="keyword">struct</span> tty_struct *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *cp,</span><br><span class="line">                <span class="type">char</span> *fp, <span class="type">int</span> count);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ldisc注册"><a href="#ldisc注册" class="headerlink" title="ldisc注册"></a>ldisc注册</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc_ops</span> <span class="title">n_tty_ops</span> =</span> &#123;</span><br><span class="line">    .magic           = TTY_LDISC_MAGIC,</span><br><span class="line">    .name            = <span class="string">&quot;n_tty&quot;</span>,</span><br><span class="line">    .open            = n_tty_open,</span><br><span class="line">    .close           = n_tty_close,</span><br><span class="line">    .flush_buffer    = n_tty_flush_buffer,</span><br><span class="line">    .read            = n_tty_read,</span><br><span class="line">    .write           = n_tty_write,</span><br><span class="line">    .ioctl           = n_tty_ioctl,</span><br><span class="line">    .set_termios     = n_tty_set_termios,</span><br><span class="line">    .poll            = n_tty_poll,</span><br><span class="line">    .receive_buf     = n_tty_receive_buf,</span><br><span class="line">    .write_wakeup    = n_tty_write_wakeup,</span><br><span class="line">    .receive_buf2    = n_tty_receive_buf2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">n_tty_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    tty_register_ldisc(N_TTY, &amp;n_tty_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现代码在n_tty.c中，调用<a href="#tty_register_ldisc()">tty_register_ldisc()</a>函数，注册线路规程的操作函数集。</p>
<h3 id="tty-register-ldis"><a href="#tty-register-ldis" class="headerlink" title="tty_register_ldis()"></a>tty_register_ldis()</h3><h3 id="tty-ldisc-reinit"><a href="#tty-ldisc-reinit" class="headerlink" title="tty_ldisc_reinit()"></a>tty_ldisc_reinit()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tty_ldisc_reinit</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> disc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ld</span>;</span></span><br><span class="line"></span><br><span class="line">    ld = tty_ldisc_get(tty, disc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tty-&gt;ldisc) &#123;</span><br><span class="line">        tty_ldisc_close(tty, tty-&gt;ldisc);</span><br><span class="line">        tty_ldisc_put(tty-&gt;ldisc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tty-&gt;ldisc = ld;</span><br><span class="line">    tty_set_termios_ldisc(tty, disc);</span><br><span class="line">    retval = tty_ldisc_open(tty, tty-&gt;ldisc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置tty的线路规程，调用 <a href="#tty_ldisc_open()">tty_ldisc_open()</a> 函数打开一个线路规程。</p>
<h3 id="tty-ldisc-get"><a href="#tty-ldisc-get" class="headerlink" title="tty_ldisc_get()"></a>tty_ldisc_get()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> tty_ldisc *<span class="title function_">tty_ldisc_get</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> disc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ld</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc_ops</span> *<span class="title">ldops</span>;</span></span><br><span class="line"></span><br><span class="line">    ldops = get_ldops(disc);</span><br><span class="line"></span><br><span class="line">    ld = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tty_ldisc), GFP_KERNEL | __GFP_NOFAIL);</span><br><span class="line">    ld-&gt;ops = ldops;</span><br><span class="line">    ld-&gt;tty = tty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ld;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tty-ldisc-open"><a href="#tty-ldisc-open" class="headerlink" title="tty_ldisc_open()"></a>tty_ldisc_open()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tty_ldisc_open</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> tty_ldisc *ld)</span></span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &amp;tty-&gt;flags));</span><br><span class="line">    <span class="keyword">if</span> (ld-&gt;ops-&gt;open) &#123;</span><br><span class="line">        ret = ld-&gt;ops-&gt;open(tty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="microcom"><a href="#microcom" class="headerlink" title="microcom"></a>microcom</h2><p>microcom工具可以用来调度串口，它会将stdin的字节复制到TTY，并从TTY复制到stdout。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">microcom [-d DELAY] [-t TIMEOUT] [-s SPEED] [-X] TTY</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -d      Wait up to DELAY ms for TTY output before sending every</span><br><span class="line">            next byte to it</span><br><span class="line">    -t      Exit if both stdin and TTY are silent for TIMEOUT ms</span><br><span class="line">    -s      Set serial line to SPEED</span><br><span class="line">    -X      Disable special meaning of NUL and Ctrl-X from stdin</span><br></pre></td></tr></table></figure>

<p>如果想回显输入的字符，可以使用以下命令：</p>
<blockquote>
<p>tee /dev/stderr | microcom /dev/ttyS1</p>
</blockquote>
<hr>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lizuobin2/article/details/51773305">https://blog.csdn.net/lizuobin2/article/details/51773305</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/R/obzbBZNBzE/">https://www.bbsmax.com/R/obzbBZNBzE/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.shuzhiduo.com/A/ZOJP4pxOJv/">https://www.shuzhiduo.com/A/ZOJP4pxOJv/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/pm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/pm/" class="post-title-link" itemprop="url">power manage</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h2><p>电源管理就是当系统的某些设备不需要工作时，暂时以最低电耗的方式挂起设备，以节省系统的电能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/gpiolib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/gpiolib/" class="post-title-link" itemprop="url">gpio driver</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/" itemprop="url" rel="index"><span itemprop="name">dev</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="gpiolib"><a href="#gpiolib" class="headerlink" title="gpiolib"></a>gpiolib</h2><p>gpiolib的作用是对所有的gpio实行统一管理，因为驱动在工作的时候，会出现好几个驱动共同使用同一个gpio的情况，这会造成混乱，所以内核提供了一些方法来管理gpio资源。代码实现在gpio/gpiolib.c中。</p>
<h3 id="gpio-desc"><a href="#gpio-desc" class="headerlink" title="gpio_desc"></a>gpio_desc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line"><span class="comment">/* flag symbols are bit numbers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_REQUESTED  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_IS_OUT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_RESERVED   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_EXPORT 3   <span class="comment">/* protected by sysfs_lock */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_SYSFS  4   <span class="comment">/* exported via /sys/class/gpio/control */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_TRIG_FALL  5   <span class="comment">/* trigger on falling edge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_TRIG_RISE  6   <span class="comment">/* trigger on rising edge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_ACTIVE_LOW 7   <span class="comment">/* sysfs value has active low */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_SHIFT    16  <span class="comment">/* add new flags before this one */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_FLAGS_MASK     ((1 &lt;&lt; ID_SHIFT) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_TRIGGER_MASK   (BIT(FLAG_TRIG_FALL) | BIT(FLAG_TRIG_RISE))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *label;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> <span class="title">gpio_desc</span>[<span class="title">ARCH_NR_GPIOS</span>];</span></span><br></pre></td></tr></table></figure>

<p>定义了一个gpio_desc结构体数组。</p>
<h3 id="gpio-chip"><a href="#gpio-chip" class="headerlink" title="gpio_chip"></a>gpio_chip</h3><p>gpio_chip 结构体包含了对gpio的各种操作方法，比如设置gpio的输入输出，设置gpio的输出值或者获取值等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *label;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>       *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>       *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         (*request)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="type">void</span>            (*<span class="built_in">free</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         (*direction_input)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="type">int</span>         (*get)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="type">int</span>         (*direction_output)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset, <span class="type">int</span> value);</span><br><span class="line">    <span class="type">int</span>         (*set_debounce)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset, <span class="type">unsigned</span> debounce);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>            (*<span class="built_in">set</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset, <span class="type">int</span> value);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         (*to_irq)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>            (*dbg_show)(<span class="keyword">struct</span> seq_file *s,</span><br><span class="line">                        <span class="keyword">struct</span> gpio_chip *chip);</span><br><span class="line">    <span class="type">int</span>         base;</span><br><span class="line">    u16         ngpio;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *<span class="type">const</span> *names;</span><br><span class="line">    <span class="type">unsigned</span>        can_sleep:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>        exported:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_GPIO)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If CONFIG_OF is enabled, then all GPIO controllers described in the</span></span><br><span class="line"><span class="comment">     * device tree automatically may have an OF translation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line">    <span class="type">int</span> of_gpio_n_cells;</span><br><span class="line">    <span class="type">int</span> (*of_xlate)(<span class="keyword">struct</span> gpio_chip *gc, <span class="keyword">struct</span> device_node *np,</span><br><span class="line">                <span class="type">const</span> <span class="type">void</span> *gpio_spec, u32 *flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="gpiochip-add"><a href="#gpiochip-add" class="headerlink" title="gpiochip_add()"></a>gpiochip_add()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiochip_add</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   flags;</span><br><span class="line">    <span class="type">int</span>     status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span>    id;</span><br><span class="line">    <span class="type">int</span>     base = chip-&gt;base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((!gpio_is_valid(base) || !gpio_is_valid(base + chip-&gt;ngpio - <span class="number">1</span>))</span><br><span class="line">            &amp;&amp; base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        status = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        base = gpiochip_find_base(chip-&gt;ngpio);</span><br><span class="line">        <span class="keyword">if</span> (base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            status = base;</span><br><span class="line">            <span class="keyword">goto</span> unlock;</span><br><span class="line">        &#125;</span><br><span class="line">        chip-&gt;base = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* these GPIO numbers must not be managed by another gpio_chip */</span></span><br><span class="line">    <span class="keyword">for</span> (id = base; id &lt; base + chip-&gt;ngpio; id++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gpio_desc[id].chip != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            status = -EBUSY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (id = base; id &lt; base + chip-&gt;ngpio; id++) &#123;</span><br><span class="line">            gpio_desc[id].chip = chip;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* REVISIT:  most hardware initializes GPIOs as</span></span><br><span class="line"><span class="comment">             * inputs (often with pullups enabled) so power</span></span><br><span class="line"><span class="comment">             * usage is minimized.  Linux code should set the</span></span><br><span class="line"><span class="comment">             * gpio direction first thing; but until it does,</span></span><br><span class="line"><span class="comment">             * we may expose the wrong direction in sysfs.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            gpio_desc[id].flags = !chip-&gt;direction_input</span><br><span class="line">                ? (<span class="number">1</span> &lt;&lt; FLAG_IS_OUT)</span><br><span class="line">                : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    of_gpiochip_add(chip);</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    status = gpiochip_export(chip);</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-request"><a href="#gpio-request" class="headerlink" title="gpio_request()"></a>gpio_request()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span> *label)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">int</span>         status = -EINVAL;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    desc = &amp;gpio_desc[gpio];</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (chip == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!try_module_get(chip-&gt;owner))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span>  gpio_request() can be called in early boot,</span></span><br><span class="line"><span class="comment">     * before IRQs are enabled, for non-sleeping (SOC) GPIOs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (test_and_set_bit(FLAG_REQUESTED, &amp;desc-&gt;flags) == <span class="number">0</span>) &#123;</span><br><span class="line">        desc_set_label(desc, label ? : <span class="string">&quot;?&quot;</span>);</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = -EBUSY;</span><br><span class="line">        module_put(chip-&gt;owner);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chip-&gt;request) &#123;</span><br><span class="line">        <span class="comment">/* chip-&gt;request may sleep */</span></span><br><span class="line">        spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">        status = chip-&gt;request(chip, gpio - chip-&gt;base);</span><br><span class="line">        spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            desc_set_label(desc, <span class="literal">NULL</span>);</span><br><span class="line">            module_put(chip-&gt;owner);</span><br><span class="line">            clear_bit(FLAG_REQUESTED, &amp;desc-&gt;flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        pr_debug(<span class="string">&quot;gpio_request: gpio-%d (%s) status %d\n&quot;</span>,</span><br><span class="line">            gpio, label ? : <span class="string">&quot;?&quot;</span>, status);</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-free"><a href="#gpio-free" class="headerlink" title="gpio_free()"></a>gpio_free()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_free</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio)) &#123;</span><br><span class="line">        WARN_ON(extra_checks);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gpio_unexport(gpio);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    desc = &amp;gpio_desc[gpio];</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (chip &amp;&amp; test_bit(FLAG_REQUESTED, &amp;desc-&gt;flags)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chip-&gt;<span class="built_in">free</span>) &#123;</span><br><span class="line">            spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">            might_sleep_if(chip-&gt;can_sleep);</span><br><span class="line">            chip-&gt;<span class="built_in">free</span>(chip, gpio - chip-&gt;base);</span><br><span class="line">            spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        desc_set_label(desc, <span class="literal">NULL</span>);</span><br><span class="line">        module_put(desc-&gt;chip-&gt;owner);</span><br><span class="line">        clear_bit(FLAG_ACTIVE_LOW, &amp;desc-&gt;flags);</span><br><span class="line">        clear_bit(FLAG_REQUESTED, &amp;desc-&gt;flags);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        WARN_ON(extra_checks);</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-direction-input"><a href="#gpio-direction-input" class="headerlink" title="gpio_direction_input()"></a>gpio_direction_input()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_direction_input</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span> =</span> &amp;gpio_desc[gpio];</span><br><span class="line">    <span class="type">int</span>         status = -EINVAL;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio))</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (!chip || !chip-&gt;get || !chip-&gt;direction_input)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    gpio -= chip-&gt;base;</span><br><span class="line">    <span class="keyword">if</span> (gpio &gt;= chip-&gt;ngpio)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    status = gpio_ensure_requested(desc, gpio);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now we know the gpio is valid and chip won&#x27;t vanish */</span></span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    might_sleep_if(chip-&gt;can_sleep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        status = chip-&gt;request(chip, gpio);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;GPIO-%d: chip request fail, %d\n&quot;</span>,</span><br><span class="line">                chip-&gt;base + gpio, status);</span><br><span class="line">            <span class="comment">/* and it&#x27;s not available to anyone else ...</span></span><br><span class="line"><span class="comment">             * gpio_request() is the fully clean solution.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">goto</span> lose;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = chip-&gt;direction_input(chip, gpio);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">        clear_bit(FLAG_IS_OUT, &amp;desc-&gt;flags);</span><br><span class="line"></span><br><span class="line">    trace_gpio_direction(chip-&gt;base + gpio, <span class="number">1</span>, status);</span><br><span class="line">lose:</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">fail:</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: gpio-%d status %d\n&quot;</span>,</span><br><span class="line">            __func__, gpio, status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-direction-output"><a href="#gpio-direction-output" class="headerlink" title="gpio_direction_output()"></a>gpio_direction_output()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span> =</span> &amp;gpio_desc[gpio];</span><br><span class="line">    <span class="type">int</span>         status = -EINVAL;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio))</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (!chip || !chip-&gt;<span class="built_in">set</span> || !chip-&gt;direction_output)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    gpio -= chip-&gt;base;</span><br><span class="line">    <span class="keyword">if</span> (gpio &gt;= chip-&gt;ngpio)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    status = gpio_ensure_requested(desc, gpio);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now we know the gpio is valid and chip won&#x27;t vanish */</span></span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    might_sleep_if(chip-&gt;can_sleep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        status = chip-&gt;request(chip, gpio);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;GPIO-%d: chip request fail, %d\n&quot;</span>,</span><br><span class="line">                chip-&gt;base + gpio, status);</span><br><span class="line">            <span class="comment">/* and it&#x27;s not available to anyone else ...</span></span><br><span class="line"><span class="comment">             * gpio_request() is the fully clean solution.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">goto</span> lose;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = chip-&gt;direction_output(chip, gpio, value);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">        set_bit(FLAG_IS_OUT, &amp;desc-&gt;flags);</span><br><span class="line">    trace_gpio_value(chip-&gt;base + gpio, <span class="number">0</span>, value);</span><br><span class="line">    trace_gpio_direction(chip-&gt;base + gpio, <span class="number">0</span>, status);</span><br><span class="line">lose:</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">fail:</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: gpio-%d status %d\n&quot;</span>,</span><br><span class="line">            __func__, gpio, status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-get-value"><a href="#gpio-get-value" class="headerlink" title="gpio_get_value()"></a>gpio_get_value()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_get_value</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    chip = gpio_to_chip(gpio);</span><br><span class="line">    WARN_ON(chip-&gt;can_sleep);</span><br><span class="line">    value = chip-&gt;get ? chip-&gt;get(chip, gpio - chip-&gt;base) : <span class="number">0</span>;</span><br><span class="line">    trace_gpio_value(gpio, <span class="number">1</span>, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-set-value"><a href="#gpio-set-value" class="headerlink" title="gpio_set_value()"></a>gpio_set_value()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_set_value</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line"></span><br><span class="line">    chip = gpio_to_chip(gpio);</span><br><span class="line">    WARN_ON(chip-&gt;can_sleep);</span><br><span class="line">    trace_gpio_value(gpio, <span class="number">0</span>, value);</span><br><span class="line">    chip-&gt;<span class="built_in">set</span>(chip, gpio - chip-&gt;base, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpio注册"><a href="#gpio注册" class="headerlink" title="gpio注册"></a>gpio注册</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c_gpio_chip</span> <span class="title">exynos4_gpio_common_4bit</span>[] =</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        .base   = S5P_VA_GPIO1,</span><br><span class="line">        .eint_offset = <span class="number">0x0</span>,</span><br><span class="line">        .group  = <span class="number">0</span>,</span><br><span class="line">        .chip   = &#123;</span><br><span class="line">            .base   = EXYNOS4_GPA0(<span class="number">0</span>),</span><br><span class="line">            .ngpio  = EXYNOS4_GPIO_A0_NR,</span><br><span class="line">            .label  = <span class="string">&quot;GPA0&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        .base   = (S5P_VA_GPIO1 + <span class="number">0x20</span>),</span><br><span class="line">        .eint_offset = <span class="number">0x4</span>,</span><br><span class="line">        .group  = <span class="number">1</span>,</span><br><span class="line">        .chip   = &#123;</span><br><span class="line">            .base   = EXYNOS4_GPA1(<span class="number">0</span>),</span><br><span class="line">            .ngpio  = EXYNOS4_GPIO_A1_NR,</span><br><span class="line">            .label  = <span class="string">&quot;GPA1&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">exynos4_gpiolib_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c_gpio_chip</span> *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> nr_chips;</span><br><span class="line"></span><br><span class="line">    chip = exynos4_gpio_common_4bit;</span><br><span class="line">    nr_chips = ARRAY_SIZE(exynos4_gpio_common_4bit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_chips; i++, chip++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chip-&gt;config == <span class="literal">NULL</span>)</span><br><span class="line">            chip-&gt;config = &amp;gpio_cfg;</span><br><span class="line">        <span class="keyword">if</span> (chip-&gt;base == <span class="literal">NULL</span>)</span><br><span class="line">            pr_err(<span class="string">&quot;No allocation of base address for [common gpio]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    samsung_gpiolib_add_4bit_chips(exynos4_gpio_common_4bit, nr_chips);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">core_initcall(exynos4_gpiolib_init);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">samsung_gpiolib_add_4bit2_chips</span><span class="params">(<span class="keyword">struct</span> s3c_gpio_chip *chip,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> nr_chips)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (; nr_chips &gt; <span class="number">0</span>; nr_chips--, chip++) &#123;</span><br><span class="line">        samsung_gpiolib_add_4bit2(chip);</span><br><span class="line">        s3c_gpiolib_add(chip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__init <span class="type">void</span> <span class="title function_">s3c_gpiolib_add</span><span class="params">(<span class="keyword">struct</span> s3c_gpio_chip *chip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> &amp;chip-&gt;chip;</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;chip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;direction_input)</span><br><span class="line">        gc-&gt;direction_input = s3c_gpiolib_input;</span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;direction_output)</span><br><span class="line">        gc-&gt;direction_output = s3c_gpiolib_output;</span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;<span class="built_in">set</span>)</span><br><span class="line">        gc-&gt;<span class="built_in">set</span> = s3c_gpiolib_set;</span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;get)</span><br><span class="line">        gc-&gt;get = s3c_gpiolib_get;</span><br><span class="line"></span><br><span class="line">    gpiochip_add(gc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充gpio_chip结构体，再用<a href="#gpiochip_add">gpiochip_add()</a>函数注册到内核。需要确定每组gpio的虚拟地址，其中物理地址和虚拟地址的映射平台已经做好了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S5P_VA_GPIO1        S3C_ADDR(0x02200000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S5P_VA_GPIO2        S3C_ADDR(0x02240000)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">map_desc</span> <span class="title">exynos4_iodesc</span>[] __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .virtual    = (<span class="type">unsigned</span> <span class="type">long</span>)S5P_VA_GPIO1,</span><br><span class="line">        .pfn        = __phys_to_pfn(EXYNOS4_PA_GPIO1),</span><br><span class="line">        .length     = SZ_4K,</span><br><span class="line">        .type       = MT_DEVICE,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        .virtual    = (<span class="type">unsigned</span> <span class="type">long</span>)S5P_VA_GPIO2,</span><br><span class="line">        .pfn        = __phys_to_pfn(EXYNOS4_PA_GPIO2),</span><br><span class="line">        .length     = SZ_4K,</span><br><span class="line">        .type       = MT_DEVICE,</span><br><span class="line">    &#125;, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">exynos4_map_io</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    iotable_init(exynos4_iodesc, ARRAY_SIZE(exynos4_iodesc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pinctrl"><a href="#pinctrl" class="headerlink" title="pinctrl"></a>pinctrl</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/timer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/timer/" class="post-title-link" itemprop="url">linux kernel timer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/" itemprop="url" rel="index"><span itemprop="name">dev</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>HZ 变量表示系统时钟频率，范围50-1200，默认1000。当时钟中断发生时，内核内部计数器的値就会加1，内部计数器由全局变量 jiffies 来表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span> <span class="comment">/*定时器列表*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires; <span class="comment">/*定时器到期时间*/</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">/* 定时器处理函数*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data; <span class="comment">/*作为参数被传入定时器处理函数*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_base_s</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="type">int</span> slack;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化定时器*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="keyword">struct</span> timer_list * timer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_INITIALIZER(_function, _expires, _data) &#123;     \</span></span><br><span class="line"><span class="meta">        .entry = &#123; .prev = TIMER_ENTRY_STATIC &#125;,    \</span></span><br><span class="line"><span class="meta">        .function = (_function),            \</span></span><br><span class="line"><span class="meta">        .expires = (_expires),              \</span></span><br><span class="line"><span class="meta">        .data = (_data),                \</span></span><br><span class="line"><span class="meta">        .base = &amp;boot_tvec_bases,           \</span></span><br><span class="line"><span class="meta">        .slack = -1,                    \</span></span><br><span class="line"><span class="meta">        __TIMER_LOCKDEP_MAP_INITIALIZER(        \</span></span><br><span class="line"><span class="meta">            __FILE__ <span class="string">&quot;:&quot;</span> __stringify(__LINE__)) \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TIMER(_name, _function, _expires, _data)     \</span></span><br><span class="line"><span class="meta">    struct timer_list _name =               \</span></span><br><span class="line"><span class="meta">        TIMER_INITIALIZER(_function, _expires, _data)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册内核定时器，将定时器加入到内核动态定时器链表中*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list * timer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除定时器*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(<span class="keyword">struct</span> timer_list * timer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重装载定时器*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mod_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer, <span class="type">unsigned</span> <span class="type">long</span> expires)</span>;</span><br></pre></td></tr></table></figure>

<p>内核定时器注册的处理函数只会执行一次，所以执行完后要重装载定时器，使其循环执行。</p>
<p>定时器的到期时间是在目前 jiffies 的基础是加一个时延，若为Hz，则表示延迟 1s。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">msecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">usecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> us)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">timespec_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timespec *value)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="内核延时"><a href="#内核延时" class="headerlink" title="内核延时"></a>内核延时</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ndelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nsecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">udelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>;</span><br></pre></td></tr></table></figure>

<p>这三种延时是根据CPU频率进行一定次数循环的忙等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">msleep_interruptible</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ssleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<p>进程睡眠指定的时间，其中msleep()、ssleep()不能被打断。msleep_interruptible()可被打断。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/poll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/poll/" class="post-title-link" itemprop="url">poll</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-07 16:05:44 / 修改时间：16:21:49" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/" itemprop="url" rel="index"><span itemprop="name">dev</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>使用非阻塞 I/O的应用程序通常会使用 select()和 poll()查询是否可对设备进行无阻塞的访问。应用层调用select()最终会引发设备驱动中的 poll()函数被执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN      0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLPRI     0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT     0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR     0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLHUP     0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL    0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDNORM  0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDBAND  0x0080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRNORM  0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRBAND  0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLMSG     0x0400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLREMOVE  0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDHUP       0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">poll_wait</span><span class="params">(<span class="keyword">struct</span> file * filp, <span class="type">wait_queue_head_t</span> * wait_address, poll_table *p)</span>;</span><br></pre></td></tr></table></figure>

<p>驱动要实现poll函数，主要工作为：对可能引起设备文件状态变化的等待队列调用 poll_wait()函数，将对应的等待队列头添加到 poll_table中，poll_wait()并不会引起阻塞。返回表示是否能对设备进行无阻塞读、写访问的掩码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">xxx_poll</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> poll_table_struct *wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxx_object</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    poll_wait(filp, &amp;dev-&gt;read_wait, wait);</span><br><span class="line">    poll_wait(filp, &amp;dev-&gt;write_wait, wait);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (...) <span class="comment">//可读 </span></span><br><span class="line">    &#123;</span><br><span class="line">        mask |= POLLIN | POLLRDNORM; <span class="comment">/*数据可获得*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (...) <span class="comment">//可写 </span></span><br><span class="line">    &#123;</span><br><span class="line">        mask |= POLLOUT | POLLWRNORM; <span class="comment">/*数据可写入*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除一个文件描述符集*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将一个文件描述符从文件描述符集中清除*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将一个文件描述符加入文件描述符集*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断文件描述符是否被置位*/</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">                  fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>readfds、writefds、exceptfds 分别是被 select()监视的读、写和异常处理的文件描述符集合，numfds 参数是要检查的最高的文件描述符加1，timeout 参数是超时时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">176</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
