<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/11/algo/backtrack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/11/algo/backtrack/" class="post-title-link" itemprop="url">回溯算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-11 18:28:30 / 修改时间：19:03:45" itemprop="dateCreated datePublished" datetime="2022-12-11T18:28:30+08:00">2022-12-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>回溯算法是从一条路往前走，能进则进，走不通就退回，换一条路再试，实际 上就是一个决策树的遍历过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtrack</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表 &#123;</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表); <span class="comment">// 路径就是已经做出的选择</span></span><br><span class="line">        回溯撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p>给定2个整数n和k，返回范围[1,n]中所有可能的k的个数从小到大顺序的组合<br>输入：n = 4, k = 2<br>输出：[[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]</p>
<p><img src="/images/code/algo/backtrack.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;<span class="type">int</span>&gt; &amp;tmp, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : tmp) &#123;</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == target) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, tmp, i+<span class="number">1</span>);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    target = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// target = 3;</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">backtrack</span>(nums, tmp, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vec : res) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">            cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/05/algo/Greedy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/05/algo/Greedy/" class="post-title-link" itemprop="url">贪心算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-05 22:14:25" itemprop="dateCreated datePublished" datetime="2022-12-05T22:14:25+08:00">2022-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-11 18:25:29" itemprop="dateModified" datetime="2022-12-11T18:25:29+08:00">2022-12-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>贪心算法是指在对问题求解时，总是做出局部最优的选择，通过每一步贪心选择，最终可得到问题的一个整体最优解。</p>
<p>贪心算法和动态规划对比：</p>
<ul>
<li>贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。</li>
<li>贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。</li>
<li>动态规划主要运用于二维或三维问题，而贪心一般是一维问题。</li>
</ul>
<h2 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h2><p>给定多个形如[start, end]的闭区间，请计算出最多有多少个互不相交的区间。</p>
<ol>
<li>从排序后的区间中选出end最小的区间x</li>
<li>把所有与x区间相交的区间删除</li>
<li>重复步骤1和2，直到最后一个区间。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">interval</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector&lt;struct interval&gt; vec = &#123;&#123;1, 3&#125;, &#123;4, 6&#125;, &#123;2, 4&#125;&#125;;</span></span><br><span class="line">    vector&lt;<span class="keyword">struct</span> interval&gt; vec = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">        cout &lt;&lt; it.start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; it.end &lt;&lt; it.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [] (<span class="keyword">struct</span> interval a, <span class="keyword">struct</span> interval b) &#123; <span class="keyword">return</span> a.end &lt; b.end; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">        cout &lt;&lt; it.start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; it.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end = vec[<span class="number">0</span>].end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vec[i].start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec[i].end &lt;&lt; <span class="string">&quot; ==&gt; &quot;</span> &lt;&lt; end &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (vec[i].start &gt; end) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            end = vec[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
<ol>
<li><p>从后往前选择，先找到一个可以一步跳到结尾的位置n，如果有多个，就选择距离结尾最远的那个n-1。然后找到可以跳到n-1处的最远的地方n-2。依次类推，最终找到开头位置。</p>
</li>
<li><p>从前往后选择，在当前位置可以跳的步数范围内，选择下一跳可以跳到的最远的那个步数，来决定当前跳多少步。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; nums = &#123;2, 3, 1, 1, 4&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums[cur]; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[cur+i] &gt;= max) &#123;</span><br><span class="line">                max = nums[cur+i];</span><br><span class="line">                distance = i;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; cur &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; --&gt; &quot;</span> &lt;&lt; nums[cur+i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        cur += distance;</span><br><span class="line">        step++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;index = &quot;</span> &lt;&lt; cur &lt;&lt; <span class="string">&quot;, step = &quot;</span> &lt;&lt; step &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; step &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/04/algo/SlideWindow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/04/algo/SlideWindow/" class="post-title-link" itemprop="url">滑动窗口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-04 22:30:17" itemprop="dateCreated datePublished" datetime="2022-12-04T22:30:17+08:00">2022-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-07 22:57:06" itemprop="dateModified" datetime="2022-12-07T22:57:06+08:00">2022-12-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>滑动窗口就是维护一个窗口(队列/数组)，通过双指针同向移动不断滑动，然后更新答案，主要用来处理连续问题。</p>
<p><strong>固定窗口大小</strong></p>
<ol>
<li>left 初始化为 0，初始化 right，使得 right - left + 1 等于窗口大小。</li>
<li>同时移动 left 和 right，判断窗口内的连续元素是否满足限定条件。</li>
<li>如果满足，再判断是否需要更新最优解，如果不满足，则继续。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定窗口大小为 k</span></span><br><span class="line"><span class="comment">// 在 s 中寻找窗口大小为 k 时的所包含最大元音字母个数</span></span><br><span class="line">string s;</span><br><span class="line">window window;</span><br><span class="line"><span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    window.<span class="built_in">add</span>(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    <span class="comment">// 如果符合要求，说明窗口构造完成，</span></span><br><span class="line">    <span class="keyword">if</span> (right&gt;=k) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 把 right -k 位置元素从窗口里面移除</span></span><br><span class="line">        window.<span class="built_in">remove</span>(s[right -k]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p><strong>可变窗口大小</strong></p>
<ol>
<li>left 和 right 都初始化为 0。</li>
<li>right 指针剃每向右移动一步，就判断窗口内的连续元素是否满足限定条件。</li>
<li>如果满足，再判断是否需要更新最优解，通过移动 left 指针收缩窗口。 如果不满足，则继续。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建窗口window容器保存窗口内元素，可以采用数组、hashset、hashmap等</span></span><br><span class="line">window window;</span><br><span class="line"><span class="comment">//保存最优结果、最大或最小等</span></span><br><span class="line"><span class="type">int</span> result = defaltValue;</span><br><span class="line"><span class="comment">//构造窗口的左右边界指针</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.<span class="built_in">add</span>(s[right]);</span><br><span class="line">    <span class="comment">// 如果符合要求，说明窗口构造完成，移动 left 缩小窗口</span></span><br><span class="line">    <span class="keyword">while</span> (window 符合要求) &#123;</span><br><span class="line">        <span class="comment">// 如果这个窗口的条件更优，则更新result</span></span><br><span class="line">        result = <span class="built_in">maxOrMin</span>(result, window);</span><br><span class="line">        <span class="comment">//移出左指针元素</span></span><br><span class="line">        window.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和≥ s的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<p>输入: s = 7, nums = [2,3,1,2,4,3]<br>输出: 2<br>解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line">cin &gt;&gt; target;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = INT16_MAX;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    sum += nums[right];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">        res = <span class="built_in">MIN</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">        sum -= nums[left];</span><br><span class="line">        left++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;---- &quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot; res = &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot;   sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    right++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (res == INT16_MAX ? <span class="number">0</span> : res) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>给定一个字符串 s 、一个字符串 t ，返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”</p>
<p><img src="/images/code/algo/slide-window.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &amp;window, <span class="type">const</span> unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &amp;target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : target) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;        &quot; &lt;&lt; it.first &lt;&lt; &quot; : &quot; &lt;&lt; window[it.first] &lt;&lt; &quot;, &quot; &lt;&lt; it.second &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (window[it.first] &lt; it.second) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;ADOBECODEBANC&quot;</span>;</span><br><span class="line">    string t = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">        target[c]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> len = UINT16_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        window[s[right]]++;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;    &quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot; &quot; &lt;&lt; s[right] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">Check</span>(window, target)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            window[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">substr</span>(start, len) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/19/net/mac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/net/mac/" class="post-title-link" itemprop="url">MAC</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-19 15:08:35 / 修改时间：15:15:55" itemprop="dateCreated datePublished" datetime="2022-11-19T15:08:35+08:00">2022-11-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net/" itemprop="url" rel="index"><span itemprop="name">net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC(Medium Access Control)媒体访问控制，控制在往媒体上发送数据的先后，防止发生混乱。</p>
<p>MAC 地址共有 48 bit，用来唯一标识设备，在网卡生产时写入 ROM 里的，网卡驱动程序读取并分配给 MAC模块。通过 ARP 可以查询目标路由器的 MAC 地址。</p>
<table>
<thead>
<tr>
<th align="center">bit</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>0 单播地址<br/>1 多播地址</td>
</tr>
<tr>
<td align="center">2</td>
<td>0 全局地址<br/>1 本地地址</td>
</tr>
<tr>
<td align="center">3-24</td>
<td>厂商识别码</td>
</tr>
<tr>
<td align="center">25-48</td>
<td>网卡唯一标识</td>
</tr>
</tbody></table>
<p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，其作用就是将包送达路由器。</p>
<p><img src="/images/net/tcpip/mac_head.png" alt="img"></p>
<h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>网卡驱动从 IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC 模块发送发送包的命令。MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。再将数字信息按每个比特转换成电信号，然后由 PHY信号收发模块发送出去。</p>
<p><img src="/images/net/tcpip/pack.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改MAC地址</span></span><br><span class="line">ifconfig eth0 hw ether 12:34:56:78:90:12</span><br></pre></td></tr></table></figure>

<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机将网络包原样转发到目的地，交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。交换机的 MAC 地址表主要包含两个信息:设备的 MAC 地址，和该设备连接在交换机的端口。</p>
<p>交换机工作在全双工模式。</p>
<p><img src="/images/net/switch.png" alt="img"></p>
<p>交换机会自行更新或删除地址表中的记录，当收到包时会将发送方 MAC 地址以及其输入端口的号码写入MAC 地址表中，当端口上的设备长时间不工作，就会删除记录。</p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃。相对地，交换机的端口不具有 MAC 地址的端口，故不会核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。</p>
<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><p>集线器工作在物理层，会将收到的数据广播给其它端口。集线器里有一张以太网协议的表，根据以太网头部中记录的目的地信息查出相应的传输方向，在子网中将网络包传输到下一个转发设备。</p>
<p>集线器的接口中有一个 MDI/MDI-X 切换开关，MDI 就是对 RJ-45 接口和信号收发模块进行直连接线，而 MDI-X 则是交叉接线。</p>
<p>集线器工作在半双工模式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/algo/heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/algo/heap/" class="post-title-link" itemprop="url">堆</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-25 21:32:48" itemprop="dateCreated datePublished" datetime="2022-09-25T21:32:48+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-17 10:35:18" itemprop="dateModified" datetime="2022-12-17T10:35:18+08:00">2022-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>堆是一种完全二叉树，每个节点的值都大于等于（或小于等于）其子树节点的值。</p>
<ul>
<li>对于每个节点的值都大于等于子树中每个节点值的堆叫<strong>大顶堆</strong>，</li>
<li>对于每个节点的值都小于等于子树中每个节点值的堆叫<strong>小顶堆</strong>。</li>
</ul>
<p>堆比较适合用数组来存储。</p>
<p><img src="/images/code/algo/heap/heap.png" alt="heap"></p>
<p>堆典型应用场景：实现优先队列、求 Top N 、求中位数。</p>
<h2 id="堆化"><a href="#堆化" class="headerlink" title="堆化"></a>堆化</h2><p>堆的元素变动后，不符合堆定义的话，就需要进行调整，让其重新满足堆的特性，这个过程叫作堆化。堆化就是顺着节点所在的路径，向上或者向下进行对比，然后交换。</p>
<p><strong>插入元素</strong></p>
<p>插入的元素直接放到堆的最后，从下往上堆化，让新插入的节点与父节点对比大小，如果不满足子节点小于等于父节点的大小关系，就互换两个节点。一直重复这个过程，直到比对到根节点。</p>
<p><img src="/images/code/algo/heap/add.png" alt="堆化"></p>
<p><strong>删除堆顶元素</strong></p>
<p>删除堆顶元素后，就需要把第二大的元素放到堆顶，然后再迭代地删除第二大节点，以此类推，直到叶子节点被删除，但这样操作完成后的堆不再满足完全二叉树的特性。</p>
<p><img src="/images/code/algo/heap/del1.png" alt="堆化"></p>
<p>正确做法是先把最后一个节点放到堆顶，然后从上往下的堆化。</p>
<p><img src="/images/code/algo/heap/del2.png" alt="堆化"></p>
<p>一个包含 $n$ 个节点的完全二叉树高度小于 $log_{2}n$，堆化的时间复杂度跟树的高度成正比等于 $O(log\ n)$。</p>
<h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p>建堆就是将数组原地建成一个堆，从后往前处理数组，找到第一个非叶子节点，然后依次从上往下堆化，堆化过程只要比较和交换数组元素。</p>
<p><img src="/images/code/algo/heap/create.png" alt="建堆"></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>建堆后，如果是个大顶堆，那么排序步骤如下：</p>
<ol>
<li><p>取堆顶元素，与数组下标最后的元素交换位置，因为就是堆顶就是最大的元素，这样就排好了最大元素。</p>
</li>
<li><p>堆顶元素移除后发生堆化，将剩下的n−1个元素重新构建成堆。</p>
</li>
<li><p>再取堆顶的元素，交换至下标为 $n−1$ 的位置，一直重复这个过程，直到最后堆中只剩下标为 $1$ 的一个元素。</p>
</li>
</ol>
<p><img src="/images/code/algo/heap/sort.png" alt="排序"></p>
<p>堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 $O(n)$，排序过程的时间复杂度是 $O(nlog \  n)$，所以，堆排序整体的时间复杂度是 $O(nlog \  n)$。</p>
<p>堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/cpu/armv8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/cpu/armv8/" class="post-title-link" itemprop="url">ARMv8 架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-25 15:35:42 / 修改时间：16:52:22" itemprop="dateCreated datePublished" datetime="2022-09-25T15:35:42+08:00">2022-09-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="特权等级"><a href="#特权等级" class="headerlink" title="特权等级"></a>特权等级</h2><p>ARMv8中，引入了Secure World和Non-Secure World（Normal World）两种安全状态，四种异常级别。</p>
<ul>
<li><p>EL0是无特权模式，就是用户空间，运行应用程序，在Secure world就是Trust Application。</p>
</li>
<li><p>EL1是一个特权模式，能够执行一些特权指令，用于运行操作系统，在Secure World则就是Trusted OS，比如OP-TEE，豌豆荚的TEE等。</p>
</li>
<li><p>EL2提供了对虚拟化的支持，只在Noraml world使用。</p>
</li>
<li><p>EL3具有最高管理权限，负责安全监测和Secure World和Normal World之间的切换。当noraml world想要访问Secure world需要通过安全监视器调用SMC指令进入监视模式然后切换。</p>
</li>
</ul>
<p>安全状态主要是影响资源的访问，比如memory，系统寄存器等。</p>
<p>对于memory，有时候需要做数据隔离，用于保护数据的安全性。因此就可以将memory分成两个区域，secure区域和non-secure区域。对于secure的memory区域，只允许secure状态去访问，而对于non-secure的memory区域，允许secure状态和non-secure状态都可访问。这样可以保护数据的安全。</p>
<p>对于系统寄存器，有些系统寄存器限制了最低EL的访问，这样可以有效的保护系统。不让低EL运行的程序，误操作这些系统寄存器而使整个系统崩溃掉。</p>
<p>对于EL1和EL0，可以是non-secure状态，也可以是secure状态。对于EL2，只能是non-secure状态。对于EL3，只能是secure状态。</p>
<p>secure和non-secure状态的切换，只能通过EL3进行切换，也就是如果想从non-secure的EL0切换到secure的EL0，首先要先从non-secure的EL0，通过异常切换到EL3，然后再通过异常，返回到secure的EL0。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/cpu/armv8_reg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/cpu/armv8_reg/" class="post-title-link" itemprop="url">ARMv8 寄存器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-25 15:11:47" itemprop="dateCreated datePublished" datetime="2022-09-25T15:11:47+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-31 20:33:15" itemprop="dateModified" datetime="2022-12-31T20:33:15+08:00">2022-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="执行状态"><a href="#执行状态" class="headerlink" title="执行状态"></a>执行状态</h2><p>在 ARMv8 架构定义了两种执行状态：AArch64 以及 AArch32。这两种执行状态分别用于描述执行使用 64 位宽的通用寄存器或者使用 32 位宽的通用寄存器。系统运行在 64 位状态下的时候名字叫 Xn，运行在 32 位的时候就叫 Wn。</p>
<p>32位W寄存器使用对应64位X寄存器的低32位，即W0对应X0的低32位，W1对应X1的低32位，以此类推。读取W寄存器时，将会舍弃高32位的数据。写入W寄存器时，会将高32位清0，例如将0xFFFFFFFF写入W0后，X0中的值位0x00000000FFFFFFFF。</p>
<p><img src="/images/cpu/arm/reg.png" alt="img"></p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p><img src="/images/cpu/arm/reg2.png" alt="img"><br><img src="/images/cpu/arm/armv8_register.png" alt="img"></p>
<p>AArch64执行状态拥有 31 个通用寄存器，可以在任何时间和所有异常级别访问。</p>
<ul>
<li><p>X0-X7：参数寄存器，用于传递函数前面8个参数。</p>
</li>
<li><p>X0,X8：返回值寄存器，如果是基本数据类型，返回值保存在X0，如果是结构体，保存在X8。</p>
</li>
<li><p>X9-X15：临时寄存器，使用需要保存现场，返回时需要恢复现场。</p>
</li>
<li><p>X16 X17：程序内调用临时寄存器，使用需要保存现场，返回时需要恢复现场。</p>
</li>
<li><p>X18：平台寄存器，保留用于平台 ABI，尽量不使用</p>
</li>
<li><p>X19-X28：被保存的寄存器，这些寄存器保存在被调用者帧中。使用需要保存现场，返回时需要恢复现场。</p>
</li>
<li><p>X29：帧指针寄存器（Frame Pointer）。</p>
</li>
<li><p>X30：链接寄存器（Link Register）</p>
</li>
<li><p>X31：堆栈指针寄存器（Stack Pointer），存储栈顶地址。</p>
</li>
</ul>
<h2 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h2><p><strong>Zero register(WZR, XZR)</strong></p>
<p>当访问zero寄存器，所有的写入都被丢弃，所有的读取都返回0，AArch32执行状态使用WZR指令访问zero寄存器，AArch64执行状态使用XZR访问zero寄存器。</p>
<p><img src="/images/cpu/arm/armv8%E7%89%B9%E6%AE%8A%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="img"></p>
<p><strong>Program Counter(PC)</strong></p>
<p>程序计数寄存器，是一个各个异常级别通用的一个寄存器。PC寄存器不能作为命名寄存器访问，而是通过确定的指令隐含的访问，如相对PC的加载和产生地址。PC寄存器不能明确的作为数据处理指令或加载指令的目的寄存器。</p>
<p><strong>Stack Pointer(SP)</strong></p>
<p>栈顶指针寄存器，用来描述各个栈顶的指针寄存器。每个异常级别都拥有一个SP寄存器：SP_EL0, SP_EL1, SP_EL2, SP_EL3. 通过此寄存器就可以确定当前在那个EL。AArch32执行状态使用WSP访问当前栈指针寄存器，AArch64执行状态使用SP访问当前栈指针寄存器。</p>
<p><strong>Saved Program Status Register(SPSR)</strong></p>
<p>当异常发生时，处理器的状态将会被保存到相应异常级别的SPSR寄存器中。异常发生后，在处理异常之前，处理器会自动的将PSTATE寄存器的内容保存到SPSR中，异常返回时，会将SPSR保存的处理器状态恢复到PSTATE中。ARMv8定义的SPSR寄存器兼容ARMv7中的SPSR寄存器，只使用低32位。</p>
<p><img src="/images/cpu/arm/SPSR.png" alt="img"></p>
<p>各个位域定义如下：</p>
<ul>
<li>N (Negative)符号位标志位，记录相关指令执行后其结果是否为负数，如果为负数，则 N = 1；如果是非负数，则 N = 0。</li>
<li>Z (Zero)0标志位，记录相关指令执行后，其结果是否为0，如果结果为0，则 Z = 1；如果结果不为0，则 Z = 0。</li>
<li>C (Carry)进位标志位，当加法运算产生了进位时，C = 1，否则 C = 0 ；当减法运算（包括 CMP）产生了借位时，C = 0，否则 C = 1 。</li>
<li>V (Overflow)溢出标志位</li>
<li>SS 用于软件调试。异常发生的时候，通过设置MDSCR_EL1.SS为1启动单步调试机制</li>
<li>IL 不合法的执行状态（非法异常），保存自PSTATE.IL</li>
<li>D 处理器状态调试掩码。指示是否屏蔽来自观察点、断点和软件步骤调试事件的调试异常</li>
<li>A 软件错误掩码位</li>
<li>I IRQ掩码位</li>
<li>F FIQ掩码位</li>
<li>M[4] 发生异常时处理器的执行状态，0表示AArch64</li>
<li>M[3:0] M[3:2]发生异常的级别；M[1]保留；M[0]根据此选择栈指针寄存器，0表示t，1表示h。可以通过异常级别的栈指针后缀表明所选的栈指针。</li>
</ul>
<p><strong>Exception Link Register (ELR)</strong></p>
<p>异常链接寄存器，保存着异常返回地址。</p>
<p>比如当一个异常发生时，处理器必须去处理异常。处理异常时候就需要使用SPSR寄存器保存异常处理前的处理器状态，就是所谓的硬件上保存现场。当处理器处理完异常后，就需要从异常返回，则就需要从ELR寄存器中返回，然后再使用SPSR寄存器恢复现场即可。</p>
<h2 id="Processor-state-PSTATE"><a href="#Processor-state-PSTATE" class="headerlink" title="Processor state(PSTATE)"></a>Processor state(PSTATE)</h2><p>在AArch64执行状态中，处理器的状态使用PSTATE描述，但PSTATE不是寄存器，而是处理器状态各个位域的总称。</p>
<p>在AArch64执行状态中，使用ERET命令从异常中返回，即将SPSR_ELn寄存器中保存的发生异常时的处理器状态恢复到PSTATE中。SPSR_ELn中保存了发生异常时ALU的标志、执行状态、异常级别及处理器branches。处理器从异常返回后的执行地址保存在ELR_ELn中。</p>
<h2 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h2><table>
<thead>
<tr>
<th>名称</th>
<th>寄存器</th>
<th>描述</th>
<th>允许的异常级别</th>
</tr>
</thead>
<tbody><tr>
<td>ACTLR_ELn</td>
<td>辅助控制寄存器</td>
<td>控制处理器详细的特性</td>
<td>1，2，3</td>
</tr>
<tr>
<td>CCSIDR_ELn</td>
<td>当前Cache Size ID寄存器</td>
<td>当前架构所选择cache的信息</td>
<td>1</td>
</tr>
<tr>
<td>CLIDR_ELn</td>
<td>Cache Level ID寄存器</td>
<td>每个级别的cache类型及实现</td>
<td>1，2，3</td>
</tr>
<tr>
<td>CNTFRQ_ELn</td>
<td>计时器频率寄存器</td>
<td>反应了系统定时器的频率</td>
<td>0</td>
</tr>
<tr>
<td>CNTPCT_ELn</td>
<td>计时器物理计数寄存器</td>
<td>保存了当前64位计数值</td>
<td>0</td>
</tr>
<tr>
<td>CNTKCTL_ELn</td>
<td>内核计时器控制寄存器</td>
<td>控制从虚拟计数器生成事件流</td>
<td>1</td>
</tr>
<tr>
<td>CPACR_ELn</td>
<td>协处理器访问控制寄存器</td>
<td>控制访问Trace、 floating-point及NEON</td>
<td>1</td>
</tr>
<tr>
<td>CSSELR_ELn</td>
<td>Cache Size选择寄存器</td>
<td>定义了要求的cache级别、cache类型及指令cache或数据cache</td>
<td>1</td>
</tr>
<tr>
<td>CNTP_CTL_ELn</td>
<td>物理计时器控制寄存器</td>
<td>EL1物理计时器的控制寄存器</td>
<td>0</td>
</tr>
<tr>
<td>ELR_ELn</td>
<td>Exception Link Register</td>
<td>保存异常返回地址</td>
<td>1，2，3</td>
</tr>
<tr>
<td>ESR_ELn</td>
<td>Exception Syndrome Register</td>
<td>保存了发生异常的原因</td>
<td>1，2，3</td>
</tr>
<tr>
<td>FAR_ELn</td>
<td>Fault Address Register</td>
<td>保存了virtual faulting address</td>
<td>1，2，3</td>
</tr>
<tr>
<td>SCTLR_ELn</td>
<td>系统控制寄存器</td>
<td>控制架构特性，如MMU、caches及对齐检查</td>
<td>0，1，2，3</td>
</tr>
<tr>
<td>SPSR_ELn</td>
<td>Saved Program Status Registe</td>
<td>发生异常时，保存处理器的状态</td>
<td>abt，fiq，irq， und，1，2，3</td>
</tr>
</tbody></table>
<h2 id="NEON和浮点寄存器"><a href="#NEON和浮点寄存器" class="headerlink" title="NEON和浮点寄存器"></a>NEON和浮点寄存器</h2><p>armV8有32个128bit的浮点寄存器 V0-V31， 这些寄存器用来处理标量浮点运算时保存浮点操作数，或NEON 操作时保存标量和向量操作数。</p>
<p><img src="/images/cpu/arm/armv8_simd_reg.png" alt="img"></p>
<h2 id="兼容ARMv7"><a href="#兼容ARMv7" class="headerlink" title="兼容ARMv7"></a>兼容ARMv7</h2><p><img src="/images/cpu/arm/armv8_reg_map.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/cpu/arm-arch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/cpu/arm-arch/" class="post-title-link" itemprop="url">arm体系架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-25 11:23:54 / 修改时间：15:11:00" itemprop="dateCreated datePublished" datetime="2022-09-25T11:23:54+08:00">2022-09-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ARM指令集架构命名"><a href="#ARM指令集架构命名" class="headerlink" title="ARM指令集架构命名"></a>ARM指令集架构命名</h2><blockquote>
<p>| ARMv | n | variants | x（variants） |</p>
</blockquote>
<ul>
<li>ARMv – 固定字符，即ARM Version</li>
<li>n – 指令集版本号。迄今为之，ARM架构版本发布了8个系列，所以n=[1:8]。</li>
<li>variants – 变种</li>
<li>x（variants） – 排除x后指定的变种</li>
</ul>
<p>常见的variants有以下字母可选：</p>
<ul>
<li>T – Thumb指令集</li>
<li>M – 长乘法指令</li>
<li>E – 增强型DSP指令</li>
<li>J – Java加速器Jazelle</li>
<li>SIMD – ARM媒体功能扩展</li>
<li>D – Debug，提供调试支持</li>
<li>I – 芯片上带有内置的ICE，从而支持程序内的断点和数据空间的观察点设置。</li>
</ul>
<p>比如：ARMv5TxM表示ARM指令集版本为5，支持T变种，不支持M变种。</p>
<h2 id="ARM体系变种"><a href="#ARM体系变种" class="headerlink" title="ARM体系变种"></a>ARM体系变种</h2><p><strong>T变种</strong></p>
<p>thumb指令集是ARM指令集的一个子集重新编码而成的。它使ARM更加高效地进行运作。</p>
<p>ARM的指令长度为32位，而Thumb指令长度只有16位，对于一些冗余空余位的操作来讲的话，在使用16位的基础上，明显比使用32位更加高效。但是thumb自身也有一定的局限性：</p>
<ul>
<li><p>完成相同的操作时，Thumb指令通常情况下需要比ARM更多的指令。</p>
</li>
<li><p>Thumb指令集是不包含异常处理时的一些指令的</p>
</li>
</ul>
<p>因此ARM是不能舍弃ARM的32位指令的，它与16位的Thumb指令配合才能更加有效率地执行。</p>
<p><strong>M变种</strong></p>
<p>增加了两条长乘法的ARM指令：</p>
<ul>
<li><p>长乘法操作：32位整数乘以32位整数，生成64位整数</p>
</li>
<li><p>长乘加操作：32位整数乘以32位整数，然后加上加上32位整数，生成64位整数</p>
</li>
</ul>
<p>它其实做版本3中正式引入，版本2的时候仅是有了这个思想的，然后在版本4以后，M变种就变成了系统中的标准部分。我们也不再说M变种了，因为我们在开发ARM过程中直接是使用相应的指令的。</p>
<p><strong>E变种</strong></p>
<p>增强型DSP指令，针对于ARM的应用范围越来越广阔，为了满足DSP算法，就需要增强这个算法的处理性能。</p>
<ul>
<li><p>增加了新的16位数据乘法与乘加操作指令</p>
</li>
<li><p>实现饱和的带符号数的加减法操作指令</p>
</li>
<li><p>进行双字数据操作的指令，包含LDRD、STDR、MCRR\MRRC</p>
</li>
<li><p>cache预取指令PLD</p>
</li>
</ul>
<p>E变种是在版本5T中开始使用的。值得注意的是：早期的E变种未有包含LDRD、STRD、MCRR\MRRC、PLD。</p>
<p><strong>J变种</strong></p>
<p>ARM能跑android和java不得不归功于这个变种——java加数器jazelle，与一般的java虚拟机相比，它将java代码运行速度提高了整整8倍，而功耗竟降低了80%。</p>
<p><strong>SIMD变种</strong></p>
<p>媒体功能扩展，它将音频\视频处理性能提高了4倍。</p>
<ul>
<li>音频\视频处理性能提高了4倍</li>
<li>提供小数算术运算</li>
<li>可同时进行两个16位操作数或者4个8位操作数的运算</li>
<li>用户可以定义饱和运算模式</li>
<li>两套16位操作数的乘加/乘减运算</li>
<li>32位乘以32位的小数MAC</li>
</ul>
<h2 id="ARM处理器系列命名"><a href="#ARM处理器系列命名" class="headerlink" title="ARM处理器系列命名"></a>ARM处理器系列命名</h2><p>在 ARMv3 ~ ARMv6 时期规则：</p>
<blockquote>
<p>ARM{x}{y}{z}{T}{D}{M}{I}{E}{J}{F}{-S}</p>
</blockquote>
<ul>
<li>x – 处理器系列</li>
<li>y – 存储管理/保护单元</li>
<li>z – cache</li>
<li>T – 支持Thumb指令集</li>
<li>D – 支持片上调试</li>
<li>M – 支持快速乘法器</li>
<li>I – 支持Embedded ICE，支持嵌入式跟踪调试</li>
<li>E – 支持增强型DSP指令</li>
<li>J – 支持Jazelle</li>
<li>F – 具备向量浮点单元VFP</li>
<li>-S – 可综合版本</li>
</ul>
<p>比如：ARM926 是 ARM9系列的，2个存储管理/保护单元，6个Cache</p>
<p>在 ARMv7 后期，统一用 <strong>Cortex</strong> 作为主名，分为了3个款式：A、R、M &amp; SC：</p>
<ul>
<li>A 系列，应用级处理器，手机。</li>
<li>R 系列，实时处理器，执行一个指令段的耗时是固定时钟周期数。</li>
<li>M 系列，微处理器单片机。</li>
<li>SC（SecurCore）系列，主打安全，面向支付、政府、SIM 卡。</li>
</ul>
<h2 id="ARM处理器工作模式"><a href="#ARM处理器工作模式" class="headerlink" title="ARM处理器工作模式"></a>ARM处理器工作模式</h2><ul>
<li><p>用户模式（usr，User Mode）：ARM处理器正常的程序执行状态。</p>
</li>
<li><p>快速中断模式（fiq，Fast Interrupt Request Mode）：用于高速数据传输或通道处理。当触发快速中断时进入此模式。</p>
</li>
<li><p>外部中断模式（irq，Interrupt Request Mode）：用于通用的中断处理。当触发外部中断时进入此模式。</p>
</li>
<li><p>管理模式（svc，Supervisor Mode）：操作系统使用的保护模式。在系统复位或执行软件中断指令SWI时进入。</p>
</li>
<li><p>数据访问中止模式（abt，Abort Mode）：当数据或指令预取中止时进入该模式，可用于虚拟存储及存储保护。</p>
</li>
<li><p>系统模式（sys，System Mode）：运行具有特权的操作系统任务。</p>
</li>
<li><p>未定义指令中止模式（und，Undefined Mode）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。</p>
</li>
</ul>
<p>除了用户模式之外，其余六种模式都是特权模式。除了用户模式和系统模式之外，其余五种模式都是异常模式。</p>
<p>在特权模式下程序可以访问所有的系统资源。非特权模式和特权模式之间的区别在于有些操作只能在特权模式下才被允许，例如直接改变模式和中断使能等。而且为了保证数据安全，一般MMU会对地址空间进行划分，只有特权模式才能访问所有的地址空间。而用户模式如果需要访问硬件，必须切换到特权模式下，才允许访问硬件。</p>
<p><strong>工作模式的切换</strong></p>
<ul>
<li><p>执行软中断（SWI）或复位命令（Reset）指令。如果在用户模式下执行SWI指令，CPU就进入管理（Supervisor）模式。当然，在其他模式下执行SWI，也会进入该模式，不过一般操作系统不会这么做，因为除了用户模式属于非特权模式，其他模式都属于特权模式。执行SWI指令一般是为了访问系统资源，而在特权模式下可以访问所有的系统资源。SWI指令一般用来为操作系统提供API接口。</p>
</li>
<li><p>外部中断。如果发生了外部中断，CPU就会进入IRQ或FIQ模式。</p>
</li>
<li><p>CPU执行过程中产生异常。最典型的异常是由于MMU保护所引起的内存访问异常，此时CPU会切换到Abort模式。如果是无效指令，则会进入Undefined模式。</p>
</li>
<li><p>有一种模式是CPU无法自动进入的，这种模式就是System模式，要进入System模式必须由程序员编写指令来实现。要进入System模式只需改变CPSR的模式位为System模式对应的模式位即可。进入System模式一般是为了利用System模式和用户模式下的寄存器相同的特点，因此一般情况下，操作系统在通过SWI进入Supervisor模式后，做一些操作后，就进入System模式。</p>
</li>
<li><p>在任何特权模式下，都可以通过修改CPSR的MODE域来进入其他模式。不过需要注意的是由于修改的CPSR是该模式下的影子CPSR，即SPSR，因此并不是实际的CPSR，所以一般的做法是修改影子CPSR，然后执行一个MOVS指令来恢复执行某个断点并切换到新模式。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/cpu/cpu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/cpu/cpu/" class="post-title-link" itemprop="url">处理器设计</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-25 11:13:36" itemprop="dateCreated datePublished" datetime="2022-09-25T11:13:36+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-26 10:21:23" itemprop="dateModified" datetime="2022-11-26T10:21:23+08:00">2022-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h2><p>ISA（Instruction Set Architecture）指令集架构定义了一个处理器支持的指令和指令的字节级编码，包括很多个部分：</p>
<ul>
<li>指令集</li>
<li>指令集编码</li>
<li>基本数据类型</li>
<li>一组编程规范</li>
<li>寄存器</li>
<li>寻址模式</li>
<li>存储体系</li>
<li>异常事件处理</li>
<li>中断</li>
<li>外部I/O</li>
</ul>
<p><strong>CISC</strong>（Complex Instruction Set Computer，复杂指令集计算机）的每个指令可执行若干低阶操作，诸如从内存读取、储存、和计算操作，全部集于单一指令之中。CISC特点：</p>
<ul>
<li><p>指令系统庞大，指令功能复杂，指令格式、寻址方式多；</p>
</li>
<li><p>绝大多数指令需多个机器周期完成；- 各种指令都可访问存储器；</p>
</li>
<li><p>采用微程序控制；</p>
</li>
<li><p>有专用寄存器，少量；</p>
</li>
<li><p>难以用优化编译技术生成高效的目标代码程序；</p>
</li>
</ul>
<p>在CISC指令集的各种指令中，大约有20%的指令会被反复使用，占整个程序代码的80%。而余下的80%的指令却不经常使用，在程序设计中只占20%。</p>
<p><strong>RISC</strong>（Reduced Instruction Set Computer，精简指令集计算机）对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。它能够以更快的速度执行操作。RISC设计的根本原则量对流水线的优化。RISC特点：</p>
<ul>
<li>统一指令编码（例如，所有指令中的op-code永远位于同样的位元位置、等长指令），可快速解译；</li>
<li>泛用的暂存器，所有暂存器可用于所有内容，以及编译器设计的单纯化（不过暂存器中区分了整数和浮点数）；</li>
<li>单纯的寻址模式（复杂寻址模式以简单计算指令序列取代）。</li>
<li>硬件中支援少数资料型别（例如，一些CISC电脑中存有处理字节字串的指令。这在RISC电脑中不太可能出现）。</li>
<li>所有计算都要在寄存器中完成。而寄存器和内存的通信则由单独的指令完成。</li>
<li>有非常多的通用寄存器，并采用了重叠寄存器窗口和寄存器堆等技术使寄存器资源得到充分的利用。</li>
</ul>
<p><strong>CISC和RISC的区别</strong></p>
<ul>
<li>指令系统：RISC设计者把主要精力放在那些经常使用的指令上，尽量使它们具有简单高效的特色。对不常用的功能，常通过组合指令来完成。因此，在RISC机器上实现特殊功能时，效率可能较低。但可以利用流水技术和超标量技术加以改进和弥补。而CISC计算机的指令系统比较丰富，有专用指令来完成特定的功能。因此，处理特殊任务效率较高。</li>
<li>存储器操作：RISC对存储器操作有限制，使控制简单化；而CISC机器的存储器操作指令多，操作直接。</li>
<li>程序：RISC汇编语言程序一般需要较大的内存空间，实现特殊功能时程序复杂，不易设计；而CISC汇编语言程序编程相对简单，科学计算及复杂操作的程序社设计相对容易，效率较高。</li>
<li>中断：RISC机器在一条指令执行的适当地方可以响应中断；而CISC机器是在一条指令执行结束后响应中断。</li>
<li>CPU：RISC CPU包含有较少的单元电路，因而面积小、功耗低；而CISCCPU包含有丰富的电路单元，因而功能强、面积大、功耗大。</li>
<li>设计周期：RISC微处理器结构简单，布局紧凑，设计周期短，且易于采用最新技术；CISC微处理器结构复杂，设计周期长。</li>
<li>用户使用：RISC微处理器结构简单，指令规整，性能容易把握，易学易用；CISC微处理器结构复杂，功能强大，实现特殊功能容易。</li>
<li>应用范围：由于RISC指令系统的确定与特定的应用领域有关，故RISC机器更适合于专用机；而CISC机器则更适合于通用机。</li>
</ul>
<h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>MIPS处理器在设计时，将处理器的执行过程划分为5个阶段：IF取指、ID译码、EX执行、MEM内存数据读或写、WB数据写回到通用寄存器中。</p>
<p><img src="/images/cpu/%E6%B5%81%E6%B0%B4%E7%BA%BF.jpg" alt="img"></p>
<p>流水线在实际执行过程中会遇到一些因素导致流水线停顿，这些就被称为流水线冒险。</p>
<p><strong>结构冒险</strong></p>
<p>流水线中取指阶段和读写存储器阶段都需要访问存储器，处理器中，程序和数据存储器没有分开，IF和MEM操作同时访问存储器导致其中一个操作要等待。哈弗架构不存在这个问题。</p>
<p><strong>数据冒险</strong></p>
<p>由于从指令取指到数据更新至存储器/寄存器之间具有时钟延迟，当出现某些指令的组合时，可能会导致后面的指令使用了错误的数据。</p>
<p>解决方法一是加入几个cycle的等待，但这影响了执行效率。另一种更好的解决办法是使用直通（Forwarding）技术。当硬件检测到当前指令的源操作数正好在EX/MEM流水线寄存器中时，就直接将EX/MEM寄存器的值传递给ALU的输入，而不是从寄存器堆中读数据。</p>
<p><strong>控制冒险</strong></p>
<p>由于使用流水线操作，在当前指令正在执行时，后面的很多条指令已经完成了取指和译码等步骤。然而，程序中有很多跳转语句，如果程序的实际执行路径是要跳转到其它的地址去执行，那么流水线中已经做的这些取指和译码工作就白做了，这就是流水线的控制冒险。</p>
<p>此时处理器需要排空流水线，跳转到新的地址处重新进入流水线。x86处理器使用硬件冲刷流水线来保证发生跳转时，流水线能正确执行。在TI的DSP中，硬件不处理这些冒险，而是通过软件的方式，在跳转语句后增加5个NOP操作来保证流水线正确，编译器也可以将指令乱序，用有效指令代替NOP指令。</p>
<h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>流水线的控制冒险将可能引起流水线排空，这对程序性能的损害是巨大的，流水线越深，损害越大。现代的很多处理器采用了分支预测技术来避免跳转带来的损失。</p>
<p>采用分支预测，处理器猜测进入哪个分支，并且基于预测的结果来取指、译码。如果猜测正确，就能节省时间，若果猜测错误，则刷新流水线，在新的地址上取指、译码。因此，分支预测需要有足够的准确性。</p>
<p>介绍两种简单的分支预测算法：</p>
<ul>
<li><p>1位预测：如果该跳转指令上一次发生跳转，就预测这一次也会跳转，如果上一次没有跳转，就预测这一次也没有跳转。</p>
</li>
<li><p>2位预测：用2bit计数器保存跳转信息，如果跳转执行就加1，跳转未执行就减1,。当计数器值为0和1时，就预测该分支不执行；当计数器值为2和3时，就预测这个分支执行。</p>
</li>
</ul>
<p>分支预测会消耗大量的资源，很多低功耗处理器没有分支预测，取而代之的是使用条件执行来减少跳转指令，如TI的DSP和ARM的cortex系列内核等。</p>
<h2 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h2><p>指令在执行时常常因为一些限制而等待，后面的指令都要等待。如果处理器足够智能，就可以先执行后面不依赖该数据的指令，这就是处理器的乱序执行（out -of-order execution）。</p>
<p>乱序执行最大的障碍就是指令间的相关性。指令间相关大致有三种情况：</p>
<ul>
<li>寄存器相关，即前后指令使用了相同的寄存器。</li>
<li>控制相关，跳转指令之后执行哪些指令需要依赖于跳转的结果。</li>
<li>数据相关，即后面指令需要的数据依赖于前面指令的计算结果。</li>
</ul>
<p>对于寄存器相关，处理器通过<strong>寄存器重命名</strong>技术解决这一问题。相同的ISA寄存器可以映射到不同的物理寄存器，经过映射后，新的指令就可以使用不同的物理寄存器，指令间的相关性依赖也就消除了。</p>
<p>对于控制相关，处理器通过分支预测来决定哪些指令将会得到执行。</p>
<p>对于数据相关，这往往是由程序算法特性以及程序的设计共同决定的，它和处理器无关，和程序员以及编译器有关。在很多时候，编程人员可以通过调整代码设计将数据间的相关性降至最小。如下面这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = a + b;</span><br><span class="line">y = x + c;</span><br><span class="line">z = y + d;</span><br></pre></td></tr></table></figure>

<p>可以改写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = a + b;</span><br><span class="line">y = c + d;</span><br><span class="line">z = x + y;</span><br></pre></td></tr></table></figure>

<p>乱序执行比顺序执行要耗费更多的处理器资源，通常只有高端处理器才会使用。</p>
<h2 id="并行设计"><a href="#并行设计" class="headerlink" title="并行设计"></a>并行设计</h2><p><strong>指令并行</strong></p>
<p>多发射是指将多条指令同时发射到不同的译码器或者后续处理流水线中。</p>
<p>超标量是指一个时钟周期内能发射多条指令的流水线架构，内部有多个执行单元，</p>
<p><strong>数据并行</strong></p>
<p>SIMD（Single Instruction Multiple Data，单指令多数据）指令通过一条语句处理多个数据。在多媒体应用中，同一操作会重复处理多个数据，SIMD指令就特别适合处理这一类数据。</p>
<p><strong>线程并行</strong></p>
<p>线程并行的方式有：单核内多线程、多核、多处理器。</p>
<p>流水线是一种在垂直方向上对指令处理进行重叠来提升性能的技术，相对地，在水平方向上将指令进行重叠的技术称为<strong>超标量</strong>（superscalar），每个核内放置冗余单元如ALU，同一时钟内可以执行多条指令。</p>
<p>超线程是Intel公司提出的一种提高CPU性能的技术，利用特殊的硬件指令，把两个逻辑内核模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和应用软件，减少CPU的闲置时间，提高CPU的运行效率。</p>
<h2 id="核间通信"><a href="#核间通信" class="headerlink" title="核间通信"></a>核间通信</h2><p>多核处理器的多个核之间会共用处理器的外设与接口，如内存控制器、PCI-E接口等，通常也会共享一段Cache。核与核之间有时需要交换信息，因此核间连接/通信方式的选取也很关键。常见的几种多核组织结构：</p>
<ul>
<li><p>Bus结构比较简单，缺点是每两个内核通信都要占用总线，导致其它核不能通信，通信效率低。</p>
</li>
<li><p>Switch结构通信效率最高。但如果核太多，这种连接方式需耗费大量的互联资源，通常4个核左右的处理器采用这种方式。</p>
</li>
<li><p>Ring结构介于Bus和Switch结构之间。1和3通信需要经过2，越近的两个核通信效率越高，通信连线并不复杂，实现成本也低。通常8个核左右采用这种方式，Intel的很多处理器采用这种结构。</p>
</li>
<li><p>Mesh结构适用于核数非常多的情况，类似于二维的Ring结构。</p>
</li>
</ul>
<p><img src="/images/cpu/%E5%A4%9A%E6%A0%B8%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.jpg" alt="img"></p>
<p>因为核间通信会影响内核的运算效率，1个核可以做5件事情，并不代表4个核可以做20件事情，核越多时，数据交换延时越长。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/tool/GitFlow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/tool/GitFlow/" class="post-title-link" itemprop="url">GitFlow分支策略</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-25 10:55:13 / 修改时间：11:00:02" itemprop="dateCreated datePublished" datetime="2022-09-25T10:55:13+08:00">2022-09-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GitFlow通常包含五种类型的分支：</p>
<ul>
<li><p>Master分支：主干分支，是可以部署到生产环境中的代码，只允许从其他分支合并，不允许向Master分支直接提交代码。</p>
</li>
<li><p>Develop分支：开发分支，用来集成测试最新合入的开发成果，包含要发布到下一个Release的代码。这个主要用于与合并Feature分支合并。</p>
</li>
<li><p>Feature分支：特性分支，从Develop分支拉出，每个新特性的开发对应一个特性分支，用于开发人员提交代码并进行自测。自测完成后，会将Feature分支的代码合并至Develop分支，进入下一个Release。</p>
</li>
<li><p>Release分支：发布分支，发布新版本时，基于Develop分支创建，发布完成后，合并到Master和Develop分支。</p>
</li>
<li><p>Hotfix分支：热修复分支，生产环境发现新Bug时创建的临时分支，问题验证通过后，合并到Master和Develop分支，这样这个改动就会进入下一个Release。</p>
</li>
</ul>
<p>通常开发过程中新特性的开发过程如下：</p>
<ol>
<li><p>从Develop分支拉取一条Feature分支，在此分支上进行新功能开发。</p>
</li>
<li><p>完成开发后，将Feature分支合入到Develop分支，并进行开发环境的验证。</p>
</li>
<li><p>开发环境验证完成后，从Develop分支拉取一条Release分支，到测试环境进行ST/UT测试。</p>
</li>
<li><p>测试发现问题，提问题单修改，代码提交到Release分支上。</p>
</li>
<li><p>问题单都解决完后，可将Release分支合入Master分支。</p>
</li>
<li><p>待发布版本时，直接将Master分支代码部署到生产环境。</p>
</li>
</ol>
<p><img src="/images/git/GitFlow.png" alt="img"></p>
<p>GitFlow的优点是每个分支都有明确的定义，严格按照GitFlow管理项目代码的话，很难出现代码混乱。其缺点是：如果特性分支过多的话很容易造成代码冲突，从而提高了合入的成本。由于每次提交都涉及多个分支，所以不适合提交频率较高的项目。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">226</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
