<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/sched/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/sched/" class="post-title-link" itemprop="url">kernel process manage</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程管理负责控制进程对 CPU 的访问，如任务的创建、调度和终止等。</p>
<p>进程是操作系统进行资源管理的最小单位，进程需要管理打开的文件、挂起的信号、内核内部数据、处理器状态等。线程是操作系统进行调度的最小单位。进程的可能状态有:</p>
<ul>
<li><p>运行态，已经获得了资源，并且进程正在被 CPU 执行。进程既可运行在内核态，也可运行在用户态。</p>
</li>
<li><p>内核态，内核和驱动所运行时的状态，程序处于特权阶级，能够访问系统的任何资源。</p>
</li>
<li><p>用户态，用户程序运行的状态，处于非特权阶级，不能随意访问系统资源，必须通过驱动程序方可访问，用户态程序可通过系统调用进入内核态。</p>
</li>
<li><p>就绪态，当系统资源已经可用，但由于前一个进程还没有执行完释放 CPU，准备进入运行状态。</p>
</li>
<li><p>可中断睡眠状态，当进程处于可中断等待状态时，系统不会调度该程序执行。当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，都可以被唤醒进入就绪状态或者运行态。</p>
</li>
<li><p>不可中断睡眠状态，处于中断等待状态，但是该进程只能被使用 wake_up()函数明确唤醒的时候才可进入就绪状态。</p>
</li>
<li><p>暂停状态，当进程收到 SIGSTOP、SIGSTP、SIGTTIN 或者 SIGTTOU 就会进入暂停状态，收到 SIGCONT 信号即可进入运行态。</p>
</li>
<li><p>僵死态，进程已经停止运行，但是其父进程还没有询问其状态。</p>
</li>
</ul>
<p>每个进程都有两个栈，用户栈和内核栈，在用户态运行时CPU堆栈指针寄存器指向用户栈地址。进程在内核态运行时，CPU堆栈指针寄存器指向内核栈地址。内核栈使用的空间很小，通常为8KB。</p>
<p><img src="/images/kernel/kernel/task_struct.png" alt="内核栈"></p>
<h2 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h2><p>在linux中线程和进程都使用 struct task_struct 结构体表示，通过唯一的进程标识值pid来标识每个进程，用全局指针current指向当前正在运行的进程的 task_struct。task_struct的state域存储了进程当前的状态，总共有7种状态：</p>
<ul>
<li><p><strong>TASK_RUNNING</strong> 一般指就绪状态，进程正在运行。</p>
</li>
<li><p><strong>TASK_INTERRUPTIBLE</strong> 进程暂停，直到它获得满足它继续运行的条件，比如进程获得了需要的资源、接收到硬件终端、或者收到某些signal等。</p>
</li>
<li><p><strong>TASK_UNINTERRUPTIBLE</strong> 进程暂停，不会被signal唤醒，只能等待某些事件(资源、硬件终端等)。</p>
</li>
<li><p><strong>TASK_STOPPED</strong> 进程中止运行，进程在接收到SIGSTOP, SIGTSTP, SIGTTIN或者SIGTTOU 信号时会进入这个状态。 接收到SIGCONT信号后，重新回到进行状态。</p>
</li>
<li><p><strong>TASK_TRACED</strong> 进程处于被调试，例如通过ptrace()对程序进行调试。</p>
</li>
<li><p><strong>EXIT_ZOMBIE</strong> 进程将要结束，等待父进程调用wait4()或者waitpid()来回收该进程。</p>
</li>
<li><p><strong>EXIT_DEAD</strong> 进程退出，这个状态主要用于避免多个进程同时对该进程调用类似wait()的函数或者系统调用。</p>
</li>
</ul>
<p><img src="/images/kernel/kernel/proc-sched.png" alt="proc"></p>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>任务调度由 Linux 内核调度器来完成。Linux 内核调度器根据进程的优先级选择运行进程。linux内核支持抢占，更高优先级的进程可以抢占低优先级进程。但在中断处理函数中，中断上下文的底半部，进程持有自旋锁的情况下不允许内核抢占。</p>
<p>当请求的资源不能得到满足时，内核会调度其他进程执行，并使本进程进入睡眠状态，直到它请求的资源被释放，才会被唤醒而进入就绪态。睡眠分成可被打断的睡眠和不可被打断的睡眠，区别在于可被打断的睡眠在收到信号的时候唤醒。</p>
<p>内核可以使用schedule()函数主动调度进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;state=TASK_INTERRUPTIBLE;</span><br><span class="line">schedule(); </span><br></pre></td></tr></table></figure>

<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>设备驱动中，如果需要几个并发执行的任务，可以启动内核线程，函数为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/pm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/pm/" class="post-title-link" itemprop="url">power manage</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h2><p>电源管理就是当系统的某些设备不需要工作时，暂时以最低电耗的方式挂起设备，以节省系统的电能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/gpiolib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/gpiolib/" class="post-title-link" itemprop="url">gpio driver</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:18:38" itemprop="dateModified" datetime="2022-06-08T20:18:38+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/device/" itemprop="url" rel="index"><span itemprop="name">device</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="gpiolib"><a href="#gpiolib" class="headerlink" title="gpiolib"></a>gpiolib</h2><p>gpiolib的作用是对所有的gpio实行统一管理，因为驱动在工作的时候，会出现好几个驱动共同使用同一个gpio的情况，这会造成混乱，所以内核提供了一些方法来管理gpio资源。代码实现在gpio/gpiolib.c中。</p>
<h3 id="gpio-desc"><a href="#gpio-desc" class="headerlink" title="gpio_desc"></a>gpio_desc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line"><span class="comment">/* flag symbols are bit numbers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_REQUESTED  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_IS_OUT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_RESERVED   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_EXPORT 3   <span class="comment">/* protected by sysfs_lock */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_SYSFS  4   <span class="comment">/* exported via /sys/class/gpio/control */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_TRIG_FALL  5   <span class="comment">/* trigger on falling edge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_TRIG_RISE  6   <span class="comment">/* trigger on rising edge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_ACTIVE_LOW 7   <span class="comment">/* sysfs value has active low */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_SHIFT    16  <span class="comment">/* add new flags before this one */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_FLAGS_MASK     ((1 &lt;&lt; ID_SHIFT) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_TRIGGER_MASK   (BIT(FLAG_TRIG_FALL) | BIT(FLAG_TRIG_RISE))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *label;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> <span class="title">gpio_desc</span>[<span class="title">ARCH_NR_GPIOS</span>];</span></span><br></pre></td></tr></table></figure>

<p>定义了一个gpio_desc结构体数组。</p>
<h3 id="gpio-chip"><a href="#gpio-chip" class="headerlink" title="gpio_chip"></a>gpio_chip</h3><p>gpio_chip 结构体包含了对gpio的各种操作方法，比如设置gpio的输入输出，设置gpio的输出值或者获取值等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *label;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>       *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>       *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         (*request)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="type">void</span>            (*<span class="built_in">free</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         (*direction_input)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="type">int</span>         (*get)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="type">int</span>         (*direction_output)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset, <span class="type">int</span> value);</span><br><span class="line">    <span class="type">int</span>         (*set_debounce)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset, <span class="type">unsigned</span> debounce);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>            (*<span class="built_in">set</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset, <span class="type">int</span> value);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         (*to_irq)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">                        <span class="type">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>            (*dbg_show)(<span class="keyword">struct</span> seq_file *s,</span><br><span class="line">                        <span class="keyword">struct</span> gpio_chip *chip);</span><br><span class="line">    <span class="type">int</span>         base;</span><br><span class="line">    u16         ngpio;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *<span class="type">const</span> *names;</span><br><span class="line">    <span class="type">unsigned</span>        can_sleep:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>        exported:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_GPIO)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If CONFIG_OF is enabled, then all GPIO controllers described in the</span></span><br><span class="line"><span class="comment">     * device tree automatically may have an OF translation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line">    <span class="type">int</span> of_gpio_n_cells;</span><br><span class="line">    <span class="type">int</span> (*of_xlate)(<span class="keyword">struct</span> gpio_chip *gc, <span class="keyword">struct</span> device_node *np,</span><br><span class="line">                <span class="type">const</span> <span class="type">void</span> *gpio_spec, u32 *flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="gpiochip-add"><a href="#gpiochip-add" class="headerlink" title="gpiochip_add()"></a>gpiochip_add()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiochip_add</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   flags;</span><br><span class="line">    <span class="type">int</span>     status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span>    id;</span><br><span class="line">    <span class="type">int</span>     base = chip-&gt;base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((!gpio_is_valid(base) || !gpio_is_valid(base + chip-&gt;ngpio - <span class="number">1</span>))</span><br><span class="line">            &amp;&amp; base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        status = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        base = gpiochip_find_base(chip-&gt;ngpio);</span><br><span class="line">        <span class="keyword">if</span> (base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            status = base;</span><br><span class="line">            <span class="keyword">goto</span> unlock;</span><br><span class="line">        &#125;</span><br><span class="line">        chip-&gt;base = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* these GPIO numbers must not be managed by another gpio_chip */</span></span><br><span class="line">    <span class="keyword">for</span> (id = base; id &lt; base + chip-&gt;ngpio; id++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gpio_desc[id].chip != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            status = -EBUSY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (id = base; id &lt; base + chip-&gt;ngpio; id++) &#123;</span><br><span class="line">            gpio_desc[id].chip = chip;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* REVISIT:  most hardware initializes GPIOs as</span></span><br><span class="line"><span class="comment">             * inputs (often with pullups enabled) so power</span></span><br><span class="line"><span class="comment">             * usage is minimized.  Linux code should set the</span></span><br><span class="line"><span class="comment">             * gpio direction first thing; but until it does,</span></span><br><span class="line"><span class="comment">             * we may expose the wrong direction in sysfs.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            gpio_desc[id].flags = !chip-&gt;direction_input</span><br><span class="line">                ? (<span class="number">1</span> &lt;&lt; FLAG_IS_OUT)</span><br><span class="line">                : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    of_gpiochip_add(chip);</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    status = gpiochip_export(chip);</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-request"><a href="#gpio-request" class="headerlink" title="gpio_request()"></a>gpio_request()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span> *label)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">int</span>         status = -EINVAL;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    desc = &amp;gpio_desc[gpio];</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (chip == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!try_module_get(chip-&gt;owner))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span>  gpio_request() can be called in early boot,</span></span><br><span class="line"><span class="comment">     * before IRQs are enabled, for non-sleeping (SOC) GPIOs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (test_and_set_bit(FLAG_REQUESTED, &amp;desc-&gt;flags) == <span class="number">0</span>) &#123;</span><br><span class="line">        desc_set_label(desc, label ? : <span class="string">&quot;?&quot;</span>);</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = -EBUSY;</span><br><span class="line">        module_put(chip-&gt;owner);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chip-&gt;request) &#123;</span><br><span class="line">        <span class="comment">/* chip-&gt;request may sleep */</span></span><br><span class="line">        spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">        status = chip-&gt;request(chip, gpio - chip-&gt;base);</span><br><span class="line">        spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            desc_set_label(desc, <span class="literal">NULL</span>);</span><br><span class="line">            module_put(chip-&gt;owner);</span><br><span class="line">            clear_bit(FLAG_REQUESTED, &amp;desc-&gt;flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        pr_debug(<span class="string">&quot;gpio_request: gpio-%d (%s) status %d\n&quot;</span>,</span><br><span class="line">            gpio, label ? : <span class="string">&quot;?&quot;</span>, status);</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-free"><a href="#gpio-free" class="headerlink" title="gpio_free()"></a>gpio_free()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_free</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio)) &#123;</span><br><span class="line">        WARN_ON(extra_checks);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gpio_unexport(gpio);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    desc = &amp;gpio_desc[gpio];</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (chip &amp;&amp; test_bit(FLAG_REQUESTED, &amp;desc-&gt;flags)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chip-&gt;<span class="built_in">free</span>) &#123;</span><br><span class="line">            spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">            might_sleep_if(chip-&gt;can_sleep);</span><br><span class="line">            chip-&gt;<span class="built_in">free</span>(chip, gpio - chip-&gt;base);</span><br><span class="line">            spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        desc_set_label(desc, <span class="literal">NULL</span>);</span><br><span class="line">        module_put(desc-&gt;chip-&gt;owner);</span><br><span class="line">        clear_bit(FLAG_ACTIVE_LOW, &amp;desc-&gt;flags);</span><br><span class="line">        clear_bit(FLAG_REQUESTED, &amp;desc-&gt;flags);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        WARN_ON(extra_checks);</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-direction-input"><a href="#gpio-direction-input" class="headerlink" title="gpio_direction_input()"></a>gpio_direction_input()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_direction_input</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span> =</span> &amp;gpio_desc[gpio];</span><br><span class="line">    <span class="type">int</span>         status = -EINVAL;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio))</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (!chip || !chip-&gt;get || !chip-&gt;direction_input)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    gpio -= chip-&gt;base;</span><br><span class="line">    <span class="keyword">if</span> (gpio &gt;= chip-&gt;ngpio)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    status = gpio_ensure_requested(desc, gpio);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now we know the gpio is valid and chip won&#x27;t vanish */</span></span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    might_sleep_if(chip-&gt;can_sleep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        status = chip-&gt;request(chip, gpio);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;GPIO-%d: chip request fail, %d\n&quot;</span>,</span><br><span class="line">                chip-&gt;base + gpio, status);</span><br><span class="line">            <span class="comment">/* and it&#x27;s not available to anyone else ...</span></span><br><span class="line"><span class="comment">             * gpio_request() is the fully clean solution.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">goto</span> lose;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = chip-&gt;direction_input(chip, gpio);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">        clear_bit(FLAG_IS_OUT, &amp;desc-&gt;flags);</span><br><span class="line"></span><br><span class="line">    trace_gpio_direction(chip-&gt;base + gpio, <span class="number">1</span>, status);</span><br><span class="line">lose:</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">fail:</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: gpio-%d status %d\n&quot;</span>,</span><br><span class="line">            __func__, gpio, status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-direction-output"><a href="#gpio-direction-output" class="headerlink" title="gpio_direction_output()"></a>gpio_direction_output()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>    *<span class="title">desc</span> =</span> &amp;gpio_desc[gpio];</span><br><span class="line">    <span class="type">int</span>         status = -EINVAL;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gpio_is_valid(gpio))</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    chip = desc-&gt;chip;</span><br><span class="line">    <span class="keyword">if</span> (!chip || !chip-&gt;<span class="built_in">set</span> || !chip-&gt;direction_output)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    gpio -= chip-&gt;base;</span><br><span class="line">    <span class="keyword">if</span> (gpio &gt;= chip-&gt;ngpio)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    status = gpio_ensure_requested(desc, gpio);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now we know the gpio is valid and chip won&#x27;t vanish */</span></span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    might_sleep_if(chip-&gt;can_sleep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        status = chip-&gt;request(chip, gpio);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pr_debug(<span class="string">&quot;GPIO-%d: chip request fail, %d\n&quot;</span>,</span><br><span class="line">                chip-&gt;base + gpio, status);</span><br><span class="line">            <span class="comment">/* and it&#x27;s not available to anyone else ...</span></span><br><span class="line"><span class="comment">             * gpio_request() is the fully clean solution.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">goto</span> lose;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = chip-&gt;direction_output(chip, gpio, value);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">        set_bit(FLAG_IS_OUT, &amp;desc-&gt;flags);</span><br><span class="line">    trace_gpio_value(chip-&gt;base + gpio, <span class="number">0</span>, value);</span><br><span class="line">    trace_gpio_direction(chip-&gt;base + gpio, <span class="number">0</span>, status);</span><br><span class="line">lose:</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">fail:</span><br><span class="line">    spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: gpio-%d status %d\n&quot;</span>,</span><br><span class="line">            __func__, gpio, status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-get-value"><a href="#gpio-get-value" class="headerlink" title="gpio_get_value()"></a>gpio_get_value()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_get_value</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    chip = gpio_to_chip(gpio);</span><br><span class="line">    WARN_ON(chip-&gt;can_sleep);</span><br><span class="line">    value = chip-&gt;get ? chip-&gt;get(chip, gpio - chip-&gt;base) : <span class="number">0</span>;</span><br><span class="line">    trace_gpio_value(gpio, <span class="number">1</span>, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-set-value"><a href="#gpio-set-value" class="headerlink" title="gpio_set_value()"></a>gpio_set_value()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_set_value</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>    *<span class="title">chip</span>;</span></span><br><span class="line"></span><br><span class="line">    chip = gpio_to_chip(gpio);</span><br><span class="line">    WARN_ON(chip-&gt;can_sleep);</span><br><span class="line">    trace_gpio_value(gpio, <span class="number">0</span>, value);</span><br><span class="line">    chip-&gt;<span class="built_in">set</span>(chip, gpio - chip-&gt;base, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gpio注册"><a href="#gpio注册" class="headerlink" title="gpio注册"></a>gpio注册</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c_gpio_chip</span> <span class="title">exynos4_gpio_common_4bit</span>[] =</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        .base   = S5P_VA_GPIO1,</span><br><span class="line">        .eint_offset = <span class="number">0x0</span>,</span><br><span class="line">        .group  = <span class="number">0</span>,</span><br><span class="line">        .chip   = &#123;</span><br><span class="line">            .base   = EXYNOS4_GPA0(<span class="number">0</span>),</span><br><span class="line">            .ngpio  = EXYNOS4_GPIO_A0_NR,</span><br><span class="line">            .label  = <span class="string">&quot;GPA0&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        .base   = (S5P_VA_GPIO1 + <span class="number">0x20</span>),</span><br><span class="line">        .eint_offset = <span class="number">0x4</span>,</span><br><span class="line">        .group  = <span class="number">1</span>,</span><br><span class="line">        .chip   = &#123;</span><br><span class="line">            .base   = EXYNOS4_GPA1(<span class="number">0</span>),</span><br><span class="line">            .ngpio  = EXYNOS4_GPIO_A1_NR,</span><br><span class="line">            .label  = <span class="string">&quot;GPA1&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">exynos4_gpiolib_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c_gpio_chip</span> *<span class="title">chip</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> nr_chips;</span><br><span class="line"></span><br><span class="line">    chip = exynos4_gpio_common_4bit;</span><br><span class="line">    nr_chips = ARRAY_SIZE(exynos4_gpio_common_4bit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_chips; i++, chip++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chip-&gt;config == <span class="literal">NULL</span>)</span><br><span class="line">            chip-&gt;config = &amp;gpio_cfg;</span><br><span class="line">        <span class="keyword">if</span> (chip-&gt;base == <span class="literal">NULL</span>)</span><br><span class="line">            pr_err(<span class="string">&quot;No allocation of base address for [common gpio]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    samsung_gpiolib_add_4bit_chips(exynos4_gpio_common_4bit, nr_chips);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">core_initcall(exynos4_gpiolib_init);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">samsung_gpiolib_add_4bit2_chips</span><span class="params">(<span class="keyword">struct</span> s3c_gpio_chip *chip,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> nr_chips)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (; nr_chips &gt; <span class="number">0</span>; nr_chips--, chip++) &#123;</span><br><span class="line">        samsung_gpiolib_add_4bit2(chip);</span><br><span class="line">        s3c_gpiolib_add(chip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__init <span class="type">void</span> <span class="title function_">s3c_gpiolib_add</span><span class="params">(<span class="keyword">struct</span> s3c_gpio_chip *chip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gc</span> =</span> &amp;chip-&gt;chip;</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;chip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;direction_input)</span><br><span class="line">        gc-&gt;direction_input = s3c_gpiolib_input;</span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;direction_output)</span><br><span class="line">        gc-&gt;direction_output = s3c_gpiolib_output;</span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;<span class="built_in">set</span>)</span><br><span class="line">        gc-&gt;<span class="built_in">set</span> = s3c_gpiolib_set;</span><br><span class="line">    <span class="keyword">if</span> (!gc-&gt;get)</span><br><span class="line">        gc-&gt;get = s3c_gpiolib_get;</span><br><span class="line"></span><br><span class="line">    gpiochip_add(gc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充gpio_chip结构体，再用<a href="#gpiochip_add">gpiochip_add()</a>函数注册到内核。需要确定每组gpio的虚拟地址，其中物理地址和虚拟地址的映射平台已经做好了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S5P_VA_GPIO1        S3C_ADDR(0x02200000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S5P_VA_GPIO2        S3C_ADDR(0x02240000)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">map_desc</span> <span class="title">exynos4_iodesc</span>[] __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .virtual    = (<span class="type">unsigned</span> <span class="type">long</span>)S5P_VA_GPIO1,</span><br><span class="line">        .pfn        = __phys_to_pfn(EXYNOS4_PA_GPIO1),</span><br><span class="line">        .length     = SZ_4K,</span><br><span class="line">        .type       = MT_DEVICE,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        .virtual    = (<span class="type">unsigned</span> <span class="type">long</span>)S5P_VA_GPIO2,</span><br><span class="line">        .pfn        = __phys_to_pfn(EXYNOS4_PA_GPIO2),</span><br><span class="line">        .length     = SZ_4K,</span><br><span class="line">        .type       = MT_DEVICE,</span><br><span class="line">    &#125;, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">exynos4_map_io</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    iotable_init(exynos4_iodesc, ARRAY_SIZE(exynos4_iodesc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pinctrl"><a href="#pinctrl" class="headerlink" title="pinctrl"></a>pinctrl</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/timer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/timer/" class="post-title-link" itemprop="url">linux kernel timer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:18:38" itemprop="dateModified" datetime="2022-06-08T20:18:38+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/device/" itemprop="url" rel="index"><span itemprop="name">device</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>HZ 变量表示系统时钟频率，范围50-1200，默认1000。当时钟中断发生时，内核内部计数器的値就会加1，内部计数器由全局变量 jiffies 来表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span> <span class="comment">/*定时器列表*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires; <span class="comment">/*定时器到期时间*/</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">/* 定时器处理函数*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data; <span class="comment">/*作为参数被传入定时器处理函数*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_base_s</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="type">int</span> slack;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化定时器*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="keyword">struct</span> timer_list * timer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_INITIALIZER(_function, _expires, _data) &#123;     \</span></span><br><span class="line"><span class="meta">        .entry = &#123; .prev = TIMER_ENTRY_STATIC &#125;,    \</span></span><br><span class="line"><span class="meta">        .function = (_function),            \</span></span><br><span class="line"><span class="meta">        .expires = (_expires),              \</span></span><br><span class="line"><span class="meta">        .data = (_data),                \</span></span><br><span class="line"><span class="meta">        .base = &amp;boot_tvec_bases,           \</span></span><br><span class="line"><span class="meta">        .slack = -1,                    \</span></span><br><span class="line"><span class="meta">        __TIMER_LOCKDEP_MAP_INITIALIZER(        \</span></span><br><span class="line"><span class="meta">            __FILE__ <span class="string">&quot;:&quot;</span> __stringify(__LINE__)) \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TIMER(_name, _function, _expires, _data)     \</span></span><br><span class="line"><span class="meta">    struct timer_list _name =               \</span></span><br><span class="line"><span class="meta">        TIMER_INITIALIZER(_function, _expires, _data)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册内核定时器，将定时器加入到内核动态定时器链表中*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list * timer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除定时器*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(<span class="keyword">struct</span> timer_list * timer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重装载定时器*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mod_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer, <span class="type">unsigned</span> <span class="type">long</span> expires)</span>;</span><br></pre></td></tr></table></figure>

<p>内核定时器注册的处理函数只会执行一次，所以执行完后要重装载定时器，使其循环执行。</p>
<p>定时器的到期时间是在目前 jiffies 的基础是加一个时延，若为Hz，则表示延迟 1s。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">msecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">usecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> us)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">timespec_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timespec *value)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="内核延时"><a href="#内核延时" class="headerlink" title="内核延时"></a>内核延时</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ndelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nsecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">udelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>;</span><br></pre></td></tr></table></figure>

<p>这三种延时是根据CPU频率进行一定次数循环的忙等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">msleep_interruptible</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ssleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<p>进程睡眠指定的时间，其中msleep()、ssleep()不能被打断。msleep_interruptible()可被打断。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/poll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/poll/" class="post-title-link" itemprop="url">poll</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:18:38" itemprop="dateModified" datetime="2022-06-08T20:18:38+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/device/" itemprop="url" rel="index"><span itemprop="name">device</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>使用非阻塞 I/O的应用程序通常会使用 select()和 poll()查询是否可对设备进行无阻塞的访问。应用层调用select()最终会引发设备驱动中的 poll()函数被执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN      0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLPRI     0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT     0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR     0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLHUP     0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL    0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDNORM  0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDBAND  0x0080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRNORM  0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRBAND  0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLMSG     0x0400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLREMOVE  0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDHUP       0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">poll_wait</span><span class="params">(<span class="keyword">struct</span> file * filp, <span class="type">wait_queue_head_t</span> * wait_address, poll_table *p)</span>;</span><br></pre></td></tr></table></figure>

<p>驱动要实现poll函数，主要工作为：对可能引起设备文件状态变化的等待队列调用 poll_wait()函数，将对应的等待队列头添加到 poll_table中，poll_wait()并不会引起阻塞。返回表示是否能对设备进行无阻塞读、写访问的掩码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">xxx_poll</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> poll_table_struct *wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxx_object</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    poll_wait(filp, &amp;dev-&gt;read_wait, wait);</span><br><span class="line">    poll_wait(filp, &amp;dev-&gt;write_wait, wait);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (...) <span class="comment">//可读 </span></span><br><span class="line">    &#123;</span><br><span class="line">        mask |= POLLIN | POLLRDNORM; <span class="comment">/*数据可获得*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (...) <span class="comment">//可写 </span></span><br><span class="line">    &#123;</span><br><span class="line">        mask |= POLLOUT | POLLWRNORM; <span class="comment">/*数据可写入*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除一个文件描述符集*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将一个文件描述符从文件描述符集中清除*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将一个文件描述符加入文件描述符集*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断文件描述符是否被置位*/</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">                  fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>readfds、writefds、exceptfds 分别是被 select()监视的读、写和异常处理的文件描述符集合，numfds 参数是要检查的最高的文件描述符加1，timeout 参数是超时时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/platform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/platform/" class="post-title-link" itemprop="url">platform bus</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:18:38" itemprop="dateModified" datetime="2022-06-08T20:18:38+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/device/" itemprop="url" rel="index"><span itemprop="name">device</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>platform 是一种虚拟的总线，负责绑定设备和驱动，在系统每注册一个设备的时候，会寻找与之匹配的驱动；相反的，在系统每注册一个驱动的时候，会寻找与之匹配的设备，而匹配由总线完成。</p>
<p>platform 使设备被挂接在一个总线上，在 BSP 中定义 platform 设备和设备使用的资源、设备的具体配置信息，而在驱动中只需要通过 API 去获取资源和数据，做到了板级代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。</p>
<h2 id="platform-device"><a href="#platform-device" class="headerlink" title="platform_device"></a>platform_device</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;  </span><br><span class="line">    <span class="type">int</span>  id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">    u32  num_resources;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般在bsp板文件中定义了平台资源的对应的全部platform_device， 并包含在一个数组中，然后通过 platform_add_devices()函数统一注册。当然也可以自己单独实现:</p>
<ol>
<li>实例一个 platform_device 结构体。</li>
<li>初始化设备名、id等成员。</li>
<li>创建一个资源数组，并赋值给 platform_device 对象。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">hello_device</span>=</span></span><br><span class="line">&#123;</span><br><span class="line">    .name = <span class="string">&quot;hello_platform&quot;</span>,</span><br><span class="line">    .id = <span class="number">-1</span>,</span><br><span class="line">    .resource = hello_resource,</span><br><span class="line">    .num_resources = ARRAY_SIZE(hello_resource),</span><br><span class="line">    .dev = </span><br><span class="line">    &#123;</span><br><span class="line">        .platform_data = &amp;plat_data,</span><br><span class="line">        .release = hello_release,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_device_register(&amp;hello_device);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_device_unregister(&amp;hello_device);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>platform_device 结构体的 platform_data 成员用来存放设备自定义的私有数据，驱动中可通过设备指针来获取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxx_plat_data</span> *<span class="title">pdata</span> =</span> pdev-&gt;dev.platform_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册platform-device"><a href="#注册platform-device" class="headerlink" title="注册platform_device"></a>注册platform_device</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">platform_device_register</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    device_initialize(&amp;pdev-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> platform_device_add(pdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">platform_device_add</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pdev-&gt;dev.parent)</span><br><span class="line">        pdev-&gt;dev.parent = &amp;platform_bus;</span><br><span class="line"></span><br><span class="line">    pdev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pdev-&gt;num_resources; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">p</span>, *<span class="title">r</span> =</span> &amp;pdev-&gt;resource[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;name == <span class="literal">NULL</span>)</span><br><span class="line">            r-&gt;name = dev_name(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">        p = r-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resource_type(r) == IORESOURCE_MEM)</span><br><span class="line">                p = &amp;iomem_resource;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (resource_type(r) == IORESOURCE_IO)</span><br><span class="line">                p = &amp;ioport_resource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device_add(&amp;pdev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">device_add</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    dev = get_device(dev);</span><br><span class="line">    bus_add_device(dev);</span><br><span class="line">    bus_probe_device(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bus_probe_device</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bus &amp;&amp; bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">        ret = device_attach(dev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">device_attach</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;driver) &#123;</span><br><span class="line">        klist_node_attached(&amp;dev-&gt;p-&gt;knode_driver);</span><br><span class="line"></span><br><span class="line">        ret = device_bind_driver(dev);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = bus_for_each_drv(dev-&gt;bus, <span class="literal">NULL</span>, dev, __device_attach);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __device_attach(<span class="keyword">struct</span> device_driver *drv, <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!driver_match_device(drv, dev))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver_probe_device(drv, dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">driver_match_device</span><span class="params">(<span class="keyword">struct</span> device_driver *drv,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册 platform_device 后，会遍历 platform_bus 中的 platform_driver，根据 platform_bus 的 match() 函数规则来匹配相应的平台驱动。</p>
<h2 id="platform-driver"><a href="#platform-driver" class="headerlink" title="platform_driver"></a>platform_driver</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);</span><br><span class="line">    <span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>probe() 在总线匹配成功后调用</li>
<li>remove() 在移除驱动或设备时调用</li>
</ul>
<h2 id="注册platform-driver"><a href="#注册platform-driver" class="headerlink" title="注册platform_driver"></a>注册platform_driver</h2><p>先实例一个 platform_driver 结构体，然后实现其成员函数，最后通过 platform_driver_register() 函数注册到platform总线。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">platform_driver_register</span><span class="params">(<span class="keyword">struct</span> platform_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;driver.bus = &amp;platform_bus_type;</span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;probe)</span><br><span class="line">        drv-&gt;driver.probe = platform_drv_probe;</span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;remove)</span><br><span class="line">        drv-&gt;driver.remove = platform_drv_remove;</span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;shutdown)</span><br><span class="line">        drv-&gt;driver.shutdown = platform_drv_shutdown;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">driver_register</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">other</span>;</span></span><br><span class="line"></span><br><span class="line">    other = driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line">    <span class="keyword">if</span> (other) &#123;</span><br><span class="line">        put_driver(other);</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span></span><br><span class="line">            <span class="string">&quot;aborting...\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bus_add_driver(drv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bus_add_driver</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">        error = driver_attach(drv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">driver_attach</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> bus_for_each_dev(drv-&gt;bus, <span class="literal">NULL</span>, drv, __driver_attach);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __driver_attach(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">drv</span> =</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!driver_match_device(drv, dev))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">driver_match_device</span><span class="params">(<span class="keyword">struct</span> device_driver *drv,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册 platform_driver 后，会遍历 platform_bus 中的 platform_device ，根据 platform_bus 的 match() 函数规则来匹配相应的平台设备。</p>
<h2 id="platform-总线"><a href="#platform-总线" class="headerlink" title="platform 总线"></a>platform 总线</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">platform_bus_type</span> =</span> &#123;</span><br><span class="line">    .name  = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">    .dev_attrs = platform_dev_attrs,</span><br><span class="line">    .match  = platform_match,</span><br><span class="line">    .uevent  = platform_uevent,</span><br><span class="line">    .pm  = &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">kernel_ulong_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[PLATFORM_NAME_SIZE];</span><br><span class="line">    <span class="type">kernel_ulong_t</span> driver_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>match()成员函数确定了 platform_device 和 platform_driver 之间的匹配规则，有4种匹配规则：</p>
<ul>
<li>设备树匹配</li>
<li>ACPI风格的匹配</li>
<li>匹配ID表，即platform_device设备名是否出现在platform_driver的ID表内</li>
<li>比较设备名和驱动名</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">platform_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line">    <span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then try ACPI style match */</span></span><br><span class="line">    <span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then try to match against the id table */</span></span><br><span class="line">    <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">        <span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="platform-设备资源"><a href="#platform-设备资源" class="headerlink" title="platform 设备资源"></a>platform 设备资源</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="type">resource_size_t</span> start;  <span class="comment">/* 资源的起始物理地址 */</span></span><br><span class="line">    <span class="type">resource_size_t</span> end;    <span class="comment">/* 资源的结束物理地址 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;    <span class="comment">/* 资源的类型 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> num)</span></span><br></pre></td></tr></table></figure>

<p>资源类型flags取値：</p>
<ul>
<li>IORESOURCE_IO</li>
<li>IORESOURCE_MEM  platform_device 占据的内存</li>
<li>IORESOURCE_IRQ  platform_device 使用的中断号</li>
<li>IORESOURCE_DMA</li>
</ul>
<p>当 flags 为 IORESOURCE_MEM 时，start、end 分别表示该 platform_device 占据的内存的开始地址和结束地址;<br>当 flags 为 IORESOURCE_IRQ 时，start、end 分别表示该 platform_device 使用的中断号的开始值和结束值，如果只使用了 1 个中断号，开始和结束值相同。</p>
<p>在驱动中通过 platform_get_resource()函数获取设备资源，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">dm9000_resource</span>[] =</span> &#123;</span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .start = <span class="number">0x18000000</span>,</span><br><span class="line">        .end = <span class="number">0x18000000</span> + <span class="number">3</span>,</span><br><span class="line">        .flags = IORESOURCE_MEM</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .start = <span class="number">0x18000000</span> + <span class="number">0x4</span>,</span><br><span class="line">        .end = <span class="number">0x18000000</span> + <span class="number">0x7</span>,</span><br><span class="line">        .flags = IORESOURCE_MEM</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    [<span class="number">2</span>] = &#123;</span><br><span class="line">        .start = IRQ_EINT(<span class="number">7</span>),</span><br><span class="line">        .end = IRQ_EINT(<span class="number">7</span>),</span><br><span class="line">        .flags = IORESOURCE_IRQ,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db-&gt;addr_res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">db-&gt;data_res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">1</span>);</span><br><span class="line">db-&gt;irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/irq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/irq/" class="post-title-link" itemprop="url">kernel irq</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>根据中断入口跳转方法的不同，分为向量中断和非向量中断。采用向量中断的 CPU 通常为不同的中断分配不同的中断号，当检测到某中断号的中断到来后，就自动跳转到与该中断号对应的地址执行。不同中断号的中断有不同的入口地址。非向量中断的多个中断共享一个入口地址，进入该入口地址后再通过软件判断中断标志来识别具体是哪个中断。</p>
<p>中断处理程序是在中断上下文中运行的，它受到某些限制:</p>
<ol>
<li>不能向用户空间发送或接受数据</li>
<li>不能使用可能引起阻塞的函数</li>
<li>不能使用可能引起调度的函数</li>
</ol>
<p><img src="/images/kernel/irq/irq.png" alt="irq"></p>
<p>Linux 将中断处理程序分为顶半部(top half)和底半部(bottom half)。顶半部完成尽可能少的比较紧急的功能，往只是简单地读取寄存器中的中断状态并清除中断标志，这样才能服务更多的中断请求。底半部处理比较耗时的事情，而且可以被新的中断打断。Linux 实现底半部的机制主要有 tasklet、工作队列和软中断。</p>
<p>tasklet和内核定时器都是依靠软中断实现。软中断和tasklet 运行于软中断上下文，仍然属于原子上下文的一种，而工作队列则运行于进<br>程上下文。因此，软中断和 tasklet 处理函数中不能睡眠，而工作队列处理函数中允许睡眠。</p>
<p><code>/proc/interrupts</code>文件可以获得系统中中断的统计信息，第1列是中断号，第2列是向对应CPU产后的中断的次数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">irqreturn_t</span> <span class="params">(*<span class="type">irq_handler_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure>

<p>irq 是要申请的硬件中断号。handler 是向系统登记的中断处理函数，是一个回调函数，中断发生时，系统调用这个函数，dev_id 可在共享中断中作为参数传入中断处理函数，也可以为 NULL。</p>
<p>flags 是中断处理的属性，可以指定中断的触发方式以及处理方式。</p>
<ul>
<li>IRQF_TRIGGER_RISING</li>
<li>IRQF_TRIGGER_FALLING</li>
<li>IRQF_TRIGGER_HIGH</li>
<li>IRQF_TRIGGER_LOW</li>
<li>IRQF_ISABLED  表明中断处理程序是快速处理程序，快速处理程序被调用时屏蔽所有中断，慢速处理程序则不会屏蔽其他设备的驱动。</li>
<li>IRQF_SHARED  表示多个设备共享中断，主要是为PCI设备服务。</li>
</ul>
<p>request_irq()返回 0 表示成功；返回-EINVAL 表示中断号无效或处理函数指针为 NULL；返回-EBUSY 表示中断已经被占用且不能共享。</p>
<p>request_irq()相对应的释放中断的函数为 free_irq()。</p>
<p>共享中断到来时，会遍历执行共享此中断的所有中断处理程序，直到某一个函数返回 IRQ_HANDLED。在中断处理程序顶半部中，应对照传入的 dev_id 参数判断是否是本设备的中断，若不是返回 IRQ_NONE。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br></pre></td></tr></table></figure>

<p>这些函数用于使能和屏蔽一个中断源，disable_irq_nosync()立即返回，而disable_rq()会等待指定的中断被处理完，因此如果在顶半部调用，会引起系统的死锁。</p>
<h2 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h2><p>tasklet不能休眠，同一个tasklet不能在两个CPU上同时运行。定义 tasklet 及其中断底半部处理函数并将两者关联，在中断顶半部中调度task执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化tasklet，指定其处理函数及其传递的参数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t,</span></span><br><span class="line"><span class="params">          <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调度task执行*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁tasklet*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_kill</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>定义一个工作队列和一个底半部执行函数，并将其绑定，在中断顶半部调度工作队列执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="type">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        flags;      <span class="comment">/* I: WQ_* flags */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> __<span class="title">percpu</span>    *<span class="title">pcpu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span>     *<span class="title">single</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>               v;</span><br><span class="line">    &#125; cpu_wq;               <span class="comment">/* I: cwq&#x27;s */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">list</span>;</span>       <span class="comment">/* W: list of all workqueues */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">flush_mutex</span>;</span>    <span class="comment">/* protects wq flushing */</span></span><br><span class="line">    <span class="type">int</span>         work_color; <span class="comment">/* F: current work color */</span></span><br><span class="line">    <span class="type">int</span>         flush_color;    <span class="comment">/* F: current flush color */</span></span><br><span class="line">    <span class="type">atomic_t</span>        nr_cwqs_to_flush; <span class="comment">/* flush in progress */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span>   *<span class="title">first_flusher</span>;</span> <span class="comment">/* F: first flusher */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">flusher_queue</span>;</span>  <span class="comment">/* F: flush waiters */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">flusher_overflow</span>;</span> <span class="comment">/* F: flush overflow list */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">mayday_mask_t</span>       mayday_mask;    <span class="comment">/* cpus requesting rescue */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker</span>       *<span class="title">rescuer</span>;</span>   <span class="comment">/* I: rescue worker */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         saved_max_active; <span class="comment">/* W: saved cwq max_active */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *name;      <span class="comment">/* I: workqueue name */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>  <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">work_func_t</span>)</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化工作并将其与处理函数绑定*/</span></span><br><span class="line">INIT_WORK(<span class="keyword">struct</span> work_struct *work, <span class="type">work_func_t</span> func)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调度工作执行*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">flush_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">flush_work_sync</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cancel_work_sync</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> create_workqueue(name)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> create_freezable_workqueue(name)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> create_singlethread_workqueue(name)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flush_workqueue</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁工作队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_workqueue</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="delayed-work"><a href="#delayed-work" class="headerlink" title="delayed_work"></a>delayed_work</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="type">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">work_func_t</span>)</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"></span><br><span class="line">INIT_DELAYED_WORK(<span class="keyword">struct</span> delayed_work *dwork, <span class="type">work_func_t</span> func)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调度delayed_work 在指定延时后执行*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">schedule_delayed_work</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork, <span class="type">unsigned</span> <span class="type">long</span> delay)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">flush_delayed_work</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">flush_delayed_work_sync</span><span class="params">(<span class="keyword">struct</span> delayed_work *work)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cancel_delayed_work</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cancel_delayed_work_sync</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork)</span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/async/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/async/" class="post-title-link" itemprop="url">linux async</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:18:38" itemprop="dateModified" datetime="2022-06-08T20:18:38+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/device/" itemprop="url" rel="index"><span itemprop="name">device</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h2><p>异步通知是应用程序不需要一直查询设备状态，一旦设备就绪，则主动通知应用程序。为了使设备支持异步通知机制，驱动程序中涉及 3 项工作：</p>
<ul>
<li><p>支持 F_SETOWN 命令，能在这个控制命令处理中设置 filp-&gt;f_owner 为对应进程 ID。不<br>过此项工作已由内核完成，设备驱动无需处理。</p>
</li>
<li><p>支持 F_SETFL 命令的处理，当应用改变 FASYNC 标志时，驱动程序中的fasync()函数将得以执行。</p>
</li>
<li><p>在设备资源可获得时，激发相应的信号。</p>
</li>
</ul>
<p><img src="/images/kernel/async/async.png" alt="async"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理 FASYNC 标志变更 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fasync_helper</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> mode, <span class="keyword">struct</span> fasync_struct **fa)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kill_fasync</span><span class="params">(<span class="keyword">struct</span> fasync_struct **fp, <span class="type">int</span> sig, <span class="type">int</span> band)</span></span><br></pre></td></tr></table></figure>

<p>驱动中要实现fasync()函数，当应用改变 FASYNC 标志时，驱动程序中的fasync()函数将得以执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxx_object</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">return</span> fasync_helper(fd, filp, mode, &amp;dev-&gt;async_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设备资源可以获得时，应该调用 kill_fasync()释放 SIGIO 信号，可读时band参数设置为 <code>POLL_IN</code>，可写时设置为 <code>POLL_OUT</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 产生异步读信号 */</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;async_queue)</span><br><span class="line">&#123;</span><br><span class="line">    kill_fasync(&amp;dev-&gt;async_queue, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在设备驱动的 release()函数中，应调用设备驱动的 fasync()函数将文件从异步通知的列表中删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    xxx_fasync(<span class="number">-1</span>, file, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/udev/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/udev/" class="post-title-link" itemprop="url">udev</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-05 21:11:19" itemprop="dateModified" datetime="2022-10-05T21:11:19+08:00">2022-10-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h2><p>udev负责在用户空间，根据用户设置的规则，在监测到设备热插拔事件后，在/dev/下自动创建并命名设备文件节点，也可以自动设置设备属性。热插拔时，设备的详细信息会由内核输出到sysfs 文件系统。udev 的设备命名策略、权限控制和事件处理都是在用户态下完成的，它利用 sysfs 中的信息来进行创建设备文件节点等工作。</p>
<p>udev 根据系统中硬件设备的状态动态更新、创建和删除设备文件，进行设备文件的等，因此/dev 目录下只包含系统中真正存在的设备。linux在设备被发现的时候加载驱动模块。</p>
<p>udev主页 <a target="_blank" rel="noopener" href="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html">http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html</a></p>
<p>udev包下载 <a target="_blank" rel="noopener" href="http://www.us.kernel.org/pub/linux/utils/kernel/hotplug/">http://www.us.kernel.org/pub/linux/utils/kernel/hotplug/</a></p>
<p>udev 的设计目标如下：</p>
<ul>
<li>在用户空间中执行。</li>
<li>动态建立/删除设备文件。</li>
<li>允许每个人都不用关心主/次设备号。</li>
<li>提供 LSB 标准名称，如果需要，可提供固定的名称。</li>
</ul>
<p>udev 以 3 个分割的子计划发展：namedev、libsysfs 和 udev。namedev 为设备命名子系统；libsysfs 提供访问 sysfs 文件系统从中获取信息的标准接口；udev 提供/dev 设备节点文件的动态创建和删除策略，负责与 namedev 和 libsysfs 库交互的任务，当/sbin/hotplug程序被内核调用时，udev 将被运行。udev 的工作过程如下：</p>
<ol>
<li><p>当内核检测到在系统中出现了新设备后，内核会在 sysfs 文件系统中为该新设备生成新的记录并导出一些设备特定的信息及所发生的事件。</p>
</li>
<li><p>udev 获取内核导出的信息，它调用 namedev 决定应该给该设备指定的名称，如果是新插入设备，udev 将调用 libsysfs 决定应该为该设备的设备文件指定的主/次设备号，并用分析获得的设备名称和主/次设备号创建/dev 中的设备文件;如果是设备移除，则之前已经被创建的/dev 文件将被删除。</p>
</li>
</ol>
<p>namedev 中使用 5 步序列来决定指定设备的命名：</p>
<ol>
<li><p>标签(label)/序号(serial):这一步检查设备是否有惟一的识别记号，例如 USB 设备有惟一的 USB 序号，SCSI 有惟一的 UUID。如果 namedev 找到与这种惟一编号相对应的规则，它将使用该规则提供的名称。</p>
</li>
<li><p>设备总线号:这一步会检查总线设备编号，对于不可热插拔的环境，这一步足以辨别设备。例如，PCI 总线编号在系统的使用期间内很少变更。如果 namedev 找到相对应的规则，规则中的名称就会被使用。</p>
</li>
<li><p>总线上的拓扑:当设备在总线上的位置匹配用户指定的规则时，就会使用该规则指定的名称。</p>
</li>
<li><p>替换名称:当内核提供的名称匹配指定的替代字符串时，就会使用替代字符串指定的名称。</p>
</li>
<li><p>内核提供的名称:如果以前的几个步骤都没有被提供，默认的内核将被指定给该设备。</p>
</li>
</ol>
<h2 id="udev规则文件"><a href="#udev规则文件" class="headerlink" title="udev规则文件"></a>udev规则文件</h2><p><strong>配置文件</strong></p>
<p>udev的配置文件位于 /etc/udev/ 和 /lib/udev/。<br>udev 的主配置文件是 /etc/udev/udev.conf。 它包含一套变量，允许用户修改 udev 默认值。可以设置的变量如下：</p>
<ul>
<li>udev_root  设备目录，默认是/dev</li>
<li>udev_log   日志等级（表示严重程度），跟 syslog 一致，例如：err, info, debug。</li>
</ul>
<p><strong>规则文件</strong></p>
<p>udev的规则文件一般位于 /lib/udev/rules.d/，也可以位于 /etc/udev/rules.d/(优先)。规则文件以 .rules 作为扩展名。规则文件的每一行都是 key=value 格式，代表一个规则，key 分为匹配型和赋值型 key。</p>
<p>当所有匹配型 key 都匹配时，该规则即被采用，赋值型 key就会获得相应的值。也可以重命名网络接口，创建到设备节点的符号链或运行一个指定程序来处理该事件。</p>
<p>一条规则由多个 key=value 组成，以英文逗号隔开。 每个key 有一个操作，取决于操作符，有效的操作符如下：</p>
<ul>
<li>==    比较是否相等</li>
<li>!=    比较是否不相等</li>
<li>=     给一个key 赋值。表示一个列表的key会被重置，并且把这个唯一的值传给它</li>
<li>+=    将一个值增加到key中</li>
<li>:=    将一个值传给一个key，并且不允许再修改这个key。</li>
</ul>
<p><strong>匹配型KEY</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ACTION     匹配事件的动作名</span><br><span class="line">DEVPATH    匹配事件的设备devpath</span><br><span class="line">KERNEL     匹配事件的设备名</span><br><span class="line">NAME       匹配网络接口或者设备节点的名字。NAME 只有在前面的规则赋值之后才可以使用。</span><br><span class="line">SYMLINK    匹配设备节点符号链的名字。SYMLINK 只有在前面的规则赋值之后才可以使用。可以有多个 symlinks，只需要匹配一个。</span><br><span class="line">SUBSYSTEM  匹配设备子系统名</span><br><span class="line">BUS        匹配总线类型</span><br><span class="line">SYSFS      匹配从 sysfs 得到的信息，比如 label、vendor、USB 序列号</span><br><span class="line">DRIVER               匹配设备的驱动名。只对绑定到一个驱动的设备有用。</span><br><span class="line">ATTR &#123; filename &#125;    匹配事件设备的sysfs 属性。</span><br><span class="line">KERNELS         向上搜索devpath，直到找到一个匹配的设备名</span><br><span class="line">SUBSYSTEMS      向上搜索devpath，直到找到一个匹配的子系统名</span><br><span class="line">DRIVERS         向上搜索devpath，直到找到一个匹配的驱动名</span><br><span class="line">ATTRS&#123; filename &#125;    向上搜索devpath，直到找到一个含匹配 sysfs 属性的设备</span><br><span class="line">ENV&#123; key &#125;</span><br><span class="line">TAG             设备的 tag</span><br><span class="line">TEST&#123;octal mode mask&#125;   测试一个文件是否存在，可以指定一个8进制的模式掩码。</span><br><span class="line">PROGRAM     执行一个程序。如果程序成功返回， key 为 true。设备的属性被放在被执行进程的环境变量中，该程序的输出为 stdout， 可以从 RESULT 这个 key 读取。</span><br><span class="line">RESULT      匹配最近一次PROGRAM 调用的返回字符串。它应该在 PROGRAM 之后使用</span><br></pre></td></tr></table></figure>

<p>支持一些通配符：</p>
<ul>
<li><ul>
<li>代表任意个字符</li>
</ul>
</li>
<li>? 代表一定有一个任意字符</li>
<li><input disabled="" type="checkbox"> 代表一定有一个在括号内的字符</li>
</ul>
<p><strong>匹配型KEY</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NAME     创建的设备文件名</span><br><span class="line">SYMLINK  符号创建链接名</span><br><span class="line">OWNER    设置设备的所有者</span><br><span class="line">GROUP    设置设备的组</span><br><span class="line">MODE</span><br><span class="line">ATTR &#123; key &#125;</span><br><span class="line">ENV &#123; key &#125;</span><br><span class="line">TAG</span><br><span class="line">RUN</span><br><span class="line">LABEL              GOTO 可以跳到的地方</span><br><span class="line">GOTO               跳到下一个带有匹配名字的 LABEL 处。</span><br><span class="line">IMPORT &#123; type &#125;    调用外部程序</span><br><span class="line">WAIT_FOR</span><br><span class="line">OPTIONS</span><br></pre></td></tr></table></figure>

<p>NAME,  SYMLINK,   PROGRAM,   OWNER,  GROUP、MODE 和 RUN 这些 field 支持一个简单的、类似于 printf 函数的格式字符串替换。可用的字符替换如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$kernel,  %k: 该设备的内核名字(%k 替换$kernel)</span><br><span class="line">$number,  %n：该设备的内核号码。例如 sda3 的内核号码是 <span class="number">3</span>。</span><br><span class="line">$devpath, %p：该设备的 devpath</span><br><span class="line">$id,   %b：当向上搜索devpath，寻找 SUBSYSTEMS， KERNELS， DRIVERS 和 ATTRS 时，被匹配的设备名字</span><br><span class="line">$driver：当向上搜索devpath，寻找 SUBSYSTEMS， KERNELS， DRIVERS 和 ATTRS 时，被匹配的驱动名字</span><br><span class="line">$attr &#123; file &#125;, %s &#123; file &#125;：一个被发现的设备的sysfs 属性的值。如果该设备没有该属性，且前面的 KERNELS,  SUBSYSTEMS,  DRIVERS或 ATTRS 测试选择的是一个父设备，那么就用父设备的属性。如果属性是一个符号链，符号链的最后一个元素作为返回值。</span><br><span class="line">$env &#123; key &#125;, %E &#123; key &#125;：一个设备属性值</span><br><span class="line">$major, %M：该设备的内核主号码</span><br><span class="line">$minor, %m：该设备的内核次号码</span><br><span class="line">$result, %c：由 PROGRAM 调用的外部程序返回的字符串。如果这个字符串包含空格，可以用 %c&#123;N&#125; 选中第N个字段。如果这个数字N，后面有一个 + 字符， 则表示选中从这个字段开始的所有后面的字符串 %c &#123; N + &#125;</span><br><span class="line">$parent, %p：父设备的节点名字</span><br><span class="line">$name：设备节点的名字，用一个空格作为分隔符。该值只有在前面的规则赋值之后才存在，或者是remove事件。</span><br><span class="line">$links：当前符号链的列表，用空格隔开。该值只有在前面的规则赋值之后才存在，或者是remove事件。</span><br><span class="line">$root, %r：udev_root 的值</span><br><span class="line">$sys, %S：sysfs 挂载点</span><br><span class="line">$tempnode, %N：在真正的设备节点创建之前，创建的一个临时的设备节点的名字，这个临时设备节点供外部程序使用。</span><br><span class="line">$$：<span class="string">&#x27;$&#x27;</span>字符自己</span><br><span class="line">%%：<span class="string">&#x27;%&#x27;</span> 字符自己</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, SYSFS&#123;address&#125;==&quot;00:0d:87:f6:59:f3&quot;, IMPORT=&quot;/sbin/rename_netiface %k eth0&quot;</span><br></pre></td></tr></table></figure>

<h2 id="udevadm"><a href="#udevadm" class="headerlink" title="udevadm"></a>udevadm</h2><p>udevadm可用于控制服务、 请求内核事件、管理事件队列、进行简单的调试。</p>
<ul>
<li><p><code>-d</code>, <code>--debug</code></p>
<p>在标准错误(STDERR)上显示调试信息。 <strong>udevadm test</strong> 与 <strong>udevadm test-builtin</strong> 命令隐含了此选项。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-info-options-devpath-file-unit…"><a href="#udevadm-info-options-devpath-file-unit…" class="headerlink" title="udevadm info [options] [devpath|file|unit…]"></a>udevadm info [<em>options</em>] [<em>devpath</em>|<em>file</em>|<em>unit</em>…]</h3><p>从udev数据库中提取设备信息。</p>
<p>位置参数用于指定一个或多个设备，它可以是 一个设备名(必须以 <code>/dev/</code> 开头)、 一个 sys 路径(必须以 <code>/sys/</code> 开头)、 一个设备单元(必须以 “<code>.device</code>“ 结尾)。详见 <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd.device.html#">systemd.device(5)</a> 手册。</p>
<ul>
<li><p><code>-q</code>, <code>--query=*TYPE*</code></p>
<p>提取特定类型的设备信息。 <em>TYPE</em> 可以是下列值之一：<code>name</code>, <code>symlink</code>, <code>path</code>, <code>property</code>, <code>all</code>(默认值)</p>
</li>
<li><p><code>-p</code>, <code>--path=*DEVPATH*</code></p>
<p>该设备在 <code>/sys</code> 目录下的路径(例如 <code>[/sys]/class/block/sda</code>)。 因为此选项是位置参数以 <code>/sys/</code> 开头时的替代， 所以通常将 <strong>udevadm info –path=/class/block/sda</strong> 直接简写为 <strong>udevadm info /sys/class/block/sda</strong></p>
</li>
<li><p><code>-n</code>, <code>--name=*FILE*</code></p>
<p>设备节点或软连接的名称(例如 <code>[/dev]/sda</code>)。 因为此选项是位置参数以 <code>/dev/</code> 开头时的替代， 所以通常将 <strong>udevadm info –name=sda</strong> 直接简写为 <strong>udevadm info /dev/sda</strong></p>
</li>
<li><p><code>-r</code>, <code>--root</code></p>
<p>以绝对路径显示 <code>--query=name</code> 与 <code>--query=symlink</code> 的查询结果</p>
</li>
<li><p><code>-a</code>, <code>--attribute-walk</code></p>
<p>按照udev规则的格式，显示所有可用于匹配该设备的sysfs属性：从该设备自身开始，沿着设备树向上回溯(一直到树根)， 显示沿途每个设备的sysfs属性。</p>
</li>
<li><p><code>-x</code>, <code>--export</code></p>
<p>以 键=’值’ 的格式输出此设备的属性(注意，值两边有单引号界定)。 仅在指定了 <code>--query=property</code> 或 <code>--device-id-of-file=*FILE*</code> 的情况下才有效。</p>
</li>
<li><p><code>-P</code>, <code>--export-prefix=*NAME*</code></p>
<p>在输出的键名前添加一个前缀。 此选项隐含了 <code>--export</code></p>
</li>
<li><p><code>-d</code>, <code>--device-id-of-file=*FILE*</code></p>
<p>显示 <em>FILE</em> 文件所在底层设备的主/次设备号。 如果使用了此选项，那么将忽略所有位置参数。</p>
</li>
<li><p><code>-e</code>, <code>--export-db</code></p>
<p>导出udev数据库的全部内容</p>
</li>
<li><p><code>-c</code>, <code>--cleanup-db</code></p>
<p>清除udev数据库</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-trigger-options-devpath-file-unit"><a href="#udevadm-trigger-options-devpath-file-unit" class="headerlink" title="udevadm trigger [options] [devpath|file|unit]"></a>udevadm trigger [<em>options</em>] [<em>devpath</em>|<em>file</em>|<em>unit</em>]</h3><p>强制内核触发设备事件，主要用于重放内核初始化过程中的冷插(coldplug)设备事件。</p>
<p>接受一个用于指定设备的位置参数。参见前面对 <strong>info</strong> 的描述。</p>
<ul>
<li><p><code>-v</code>, <code>--verbose</code></p>
<p>显示被触发的设备列表</p>
</li>
<li><p><code>-n</code>, <code>--dry-run</code></p>
<p>并不真正触发设备事件</p>
</li>
<li><p><code>-t</code>, <code>--type=*TYPE*</code></p>
<p>仅触发特定类型的设备， TYPE 可以是下列值之一：<strong>devices</strong>(默认值), <strong>subsystems</strong></p>
</li>
<li><p><code>-c</code>, <code>--action=*ACTION*</code></p>
<p>指定触发哪种类型的设备事件，ACTION 可以是下列值之一：<strong>add</strong>, <strong>remove</strong>, <strong>change</strong>(默认值)</p>
</li>
<li><p><code>-s</code>, <code>--subsystem-match=*SUBSYSTEM*</code></p>
<p>仅触发属于 <em>SUBSYSTEM</em> 子系统的设备事件。 可以在 <em>SUBSYSTEM</em> 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，所有匹配的子系统中的设备都会被触发。</p>
</li>
<li><p><code>-S</code>, <code>--subsystem-nomatch=*SUBSYSTEM*</code></p>
<p>不触发属于 <em>SUBSYSTEM</em> 子系统的设备事件。 可以在 <em>SUBSYSTEM</em> 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则， 也就是说，只有不匹配所有指定子系统的设备才会被触发。</p>
</li>
<li><p><code>-a</code>, <code>--attr-match=*ATTRIBUTE*=*VALUE*</code></p>
<p>仅触发那些在设备的sysfs目录中存在 ATTRIBUTE 文件的设备事件。 如果同时还指定了”=VALUE”，那么表示仅触发那些 ATTRIBUTE 文件的内容匹配 VALUE 的设备事件。 注意，可以在 VALUE 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则， 也就是说，只有匹配所有指定属性的设备才会被触发。</p>
</li>
<li><p><code>-A</code>, <code>--attr-nomatch=*ATTRIBUTE*=*VALUE*</code></p>
<p>不触发那些在设备的sysfs目录中存在 ATTRIBUTE 文件的设备事件。 如果同时还指定了”=VALUE”，那么表示不触发那些 ATTRIBUTE 文件的内容匹配 VALUE 的设备事件。 注意，可以在 VALUE 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则， 也就是说，只有不匹配所有指定属性的设备才会被触发。</p>
</li>
<li><p><code>-p</code>, <code>--property-match=*PROPERTY*=*VALUE*</code></p>
<p>仅触发那些设备的 PROPERTY 属性值匹配 VALUE 的设备事件。注意，可以在 VALUE 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，匹配任意一个属性值的设备都会被触发。</p>
</li>
<li><p><code>-g</code>, <code>--tag-match=*PROPERTY*</code></p>
<p>仅触发匹配 PROPERTY 标签的设备事件。如果多次使用此选项， 那么表示以 AND 逻辑连接每个匹配规则，也就是说，只有匹配所有指定标签的设备才会被触发。</p>
</li>
<li><p><code>-y</code>, <code>--sysname-match=*SYSNAME*</code></p>
<p>仅触发设备sys名称(也就是该设备在 <code>/sys</code> 路径下最末端的文件名)匹配 <em>SYSNAME</em> 的设备事件。 注意，可以在 <em>SYSNAME</em> 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，匹配任意一个sys名称的设备都会被触发。</p>
</li>
<li><p><code>--name-match=*DEVPATH*</code></p>
<p>触发给定设备及其所有子设备的事件。<em>DEVPATH</em> 是该设备在 <code>/dev</code> 目录下的路径。 如果多次使用此选项，那么仅以最后一个为准。</p>
</li>
<li><p><code>-b</code>, <code>--parent-match=*SYSPATH*</code></p>
<p>触发给定设备及其所有子设备的事件。<em>SYSPATH</em> 是该设备在 <code>/sys</code> 目录下的路径。 如果多次使用此选项，那么仅以最后一个为准。</p>
</li>
<li><p><code>-w</code>, <code>--settle</code></p>
<p>除了触发设备事件之外，还要等待这些事件完成。 注意，此选项仅等待该命令自身触发的事件完成， 而 <strong>udevadm settle</strong> 则要一直等到 所有设备事件全部完成。</p>
</li>
<li><p><code>--wait-daemon[=*SECONDS*]</code></p>
<p>在触发设备事件之前，等待 systemd-udevd 守护进程完成初始化。 默认等待 5 秒之后超时(可以使用 <em>SECONDS</em> 参数修改)。 此选项等价于在 <strong>udevadm trigger</strong> 命令之前先使用 <strong>udevadm control –ping</strong> 命令。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<p>可以直接使用 以 <code>/sys</code> 或 <code>/dev</code> 开头的绝对路径来指定目标设备。</p>
<h3 id="udevadm-settle-options"><a href="#udevadm-settle-options" class="headerlink" title="udevadm settle [options]"></a>udevadm settle [<em>options</em>]</h3><p>监视udev事件队列，并且在所有事件全部处理完成之后退出。</p>
<ul>
<li><p><code>-t</code>, <code>--timeout=*SECONDS*</code></p>
<p>最多允许花多少秒等候事件队列清空。 默认值是120秒。 设为 0 表示仅检查事件队列是否为空， 并且立即返回。</p>
</li>
<li><p><code>-E</code>, <code>--exit-if-exists=*FILE*</code></p>
<p>如果 FILE 文件存在，则停止等待。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-control-option"><a href="#udevadm-control-option" class="headerlink" title="udevadm control option"></a>udevadm control <em>option</em></h3><p>控制udev守护进程(systemd-udevd)的内部状态。</p>
<ul>
<li><p><code>-e</code>, <code>--exit</code></p>
<p>向 systemd-udevd 发送”退出”信号并等待其退出。因为 <code>systemd-udevd.service</code> 中含有 <code>Restart=always</code> ，所以此选项实际是重启了 systemd-udevd 。 如果你想停止 <code>systemd-udevd.service</code> ，那么应该使用：<code>systemctl stop systemd-udevd-control.socket systemd-udevd-kernel.socket systemd-udevd.service</code></p>
</li>
<li><p><code>-l</code>, <code>--log-priority=*value*</code></p>
<p>设置 <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd-udevd.service.html#">systemd-udevd.service(8)</a> 的内部日志等级。 可以用数字或文本表示：r<code>emerg</code>(0), <code>alert</code>(1), <code>crit</code>(2), <code>err</code>(3), <code>warning</code>(4), <code>notice</code>(5), <code>info</code>(6), <code>debug</code>(7)</p>
</li>
<li><p><code>-s</code>, <code>--stop-exec-queue</code></p>
<p>向 systemd-udevd 发送”禁止处理事件”信号， 这样所有新发生的事件都将进入等候队列。</p>
</li>
<li><p><code>-S</code>, <code>--start-exec-queue</code></p>
<p>向 systemd-udevd 发送”开始处理事件”信号，也就是开始处理事件队列中尚未处理的事件。</p>
</li>
<li><p><code>-R</code>, <code>--reload</code></p>
<p>向 systemd-udevd 发送”重新加载”信号，也就是重新加载udev规则与各种数据库(包括内核模块索引)。 注意，重新加载之后并不影响已经存在的设备， 但是新的配置将会应用于所有将来发生的新设备事件。</p>
</li>
<li><p><code>-p</code>, <code>--property=*KEY*=*value*</code></p>
<p>为所有将来发生的新设备事件统一设置一个全局的 KEY 属性，并将其值设为 value</p>
</li>
<li><p><code>-m</code>, <code>--children-max=</code><em>value</em></p>
<p>设置最多允许 systemd-udevd 同时处理多少个设备事件。</p>
</li>
<li><p><code>--ping</code></p>
<p>向 systemd-udevd 发送一个”ping”消息并等待应答。用于检查 systemd-udevd 守护进程是否仍在正常运行。</p>
</li>
<li><p><code>-t</code>, <code>--timeout=</code><em>seconds</em></p>
<p>等候 systemd-udevd 应答的最大秒数。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-monitor-options"><a href="#udevadm-monitor-options" class="headerlink" title="udevadm monitor [options]"></a>udevadm monitor [<em>options</em>]</h3><p>监视内核发出的设备事件(以”KERNEL”标记)， 以及udev在处理完udev规则之后发出的事件(以”UDEV”标记)，并在控制台上输出事件的设备路径(devpath)。 可用于分析udev处理设备事件所花的时间(比较”KERNEL”与”UDEV”的时间戳)。</p>
<ul>
<li><p><code>-k</code>, <code>--kernel</code></p>
<p>仅显示”KERNEL”事件</p>
</li>
<li><p><code>-u</code>, <code>--udev</code></p>
<p>仅显示”UDEV”事件</p>
</li>
<li><p><code>-p</code>, <code>--property</code></p>
<p>同时还显示事件的各属性</p>
</li>
<li><p><code>-s</code>, <code>--subsystem-match=*subsystem[/devtype]*</code></p>
<p>根据 subsystem[/devtype] 对事件(包括 kernel uevent 与 udev event)进行过滤，仅显示与”子系统[/设备类型]”匹配的”UDEV”事件。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，所有指定子系统中的设备都会被监视。</p>
</li>
<li><p><code>-t</code>, <code>--tag-match=*string*</code></p>
<p>根据设备标签对事件(仅 udev event)进行过滤，仅显示与”标签”匹配的”UDEV”事件。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，拥有任一指定标签的设备都会被监视。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-test-options-devpath"><a href="#udevadm-test-options-devpath" class="headerlink" title="udevadm test [options] [devpath]"></a>udevadm test [<em>options</em>] [<em>devpath</em>]</h3><p>模拟一个设备事件，并输出调试信息。</p>
<ul>
<li><p><code>-a</code>, <code>--action=*ACTION*</code></p>
<p>指定模拟哪种类型的设备事件，ACTION 可以是下列值之一：<strong>add</strong>(默认值), <strong>remove</strong>, <strong>change</strong></p>
</li>
<li><p><code>-N</code>, <code>--resolve-names=early|late|never</code></p>
<p>指定 udevadm 何时解析用户与组的名称：<code>early</code>(默认值) 表示在规则的解析阶段； <code>late</code> 表示在每个事件发生的时候； <code>never</code> 表示从不解析， 所有设备的属主与属组都是 root 。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-test-builtin-options-command-devpath"><a href="#udevadm-test-builtin-options-command-devpath" class="headerlink" title="udevadm test-builtin [options] [command] [devpath]"></a>udevadm test-builtin [<em>options</em>] [<em>command</em>] [<em>devpath</em>]</h3><p>针对 <em>DEVPATH</em>设备 运行一个内置的 <em>COMMAND</em> 命令， 并输出调试信息。</p>
<ul>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h2 id="mdev"><a href="#mdev" class="headerlink" title="mdev"></a>mdev</h2><p>mdev 是udev的轻量级版本，集成于 busybox中。为了使用mdev 功能，/etc/init.d/rcS 包含的如下内容:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/bin/mount -t sysfs sysfs /sys</span><br><span class="line">/bin/mount -t tmpfs mdev /dev</span><br><span class="line">echo /bin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure>

<p><code>echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</code>的含义是当有热插拔事件产生时，内核会调用mdev。这时mdev扫描/sys 中所有的类设备目录，通过环境变量中的ACTION 和 DEVPATH，来确定此次热插拔事件的动作以及影响了/sys 中的那个目录。而<code>mdev -s</code>是自动扫描/sys 中所有的类设备目录。如果在目录中含有名为“dev”的文件，且文件中包含的是设备号，则mdev 就利用这些信息为该设备在/dev 下创建设备节点文件。</p>
<p>修改/etc/mdev.conf 文件可以修改mdev 的规则。</p>
<hr>
<p><a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/udevadm.html">http://www.jinbuguo.com/systemd/udevadm.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/kernel/sysfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/kernel/sysfs/" class="post-title-link" itemprop="url">sysfs</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h2><p>sysfs 是一个基于内存的虚拟文件系统，作用是将内核信息以文件的方式提供给用户程序使用。它把连接在系统上的设备和总线组织成为一个分级的文件，供用户空间存取；向用户空间导出内核数据结构以及它们的属性，以展示设备驱动模型中各组件的层次关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/sys/</span><br><span class="line">├── block     包含系统中发现的块设备;</span><br><span class="line">├── bus       包含内核注册的总线;</span><br><span class="line">├── class     包含注册到内核的设备类;</span><br><span class="line">├── bus       按总线类型分类</span><br><span class="line">│   ├── i2c</span><br><span class="line">│   │   ├── drivers</span><br><span class="line">│   │   └── devices   包含总线下的所有设备</span><br><span class="line">│   │       ├──i2c-0 -&gt; ../../../devices/pci0000:00/0000:00:02.0/i2c-0/</span><br><span class="line">│   │       └──i2c-1 -&gt; ../../../devices/pci0000:00/0000:00:02.0/i2c-1/</span><br><span class="line">│   ├── pci</span><br><span class="line">│   ├── spi</span><br><span class="line">│   ├── usb</span><br><span class="line">├── class          按设备功能分类的设备模型</span><br><span class="line">│   ├── block</span><br><span class="line">│   ├── bluetooth</span><br><span class="line">│   ├── dma</span><br><span class="line">│   ├── gpio</span><br><span class="line">│   ├── i2c-adapter</span><br><span class="line">│   ├── i2c-dev</span><br><span class="line">│   ├── input</span><br><span class="line">│   ├── misc</span><br><span class="line">│   ├── phy</span><br><span class="line">│   ├── pwm</span><br><span class="line">│   ├── rtc</span><br><span class="line">│   ├── tty</span><br><span class="line">├── dev         按字符设备和块设备的major:minor指向真实设备(sys/devices)的链接</span><br><span class="line">│   ├── block</span><br><span class="line">│   └── char</span><br><span class="line">├── devices     含系统所有的设备，并根据设备挂接的总线类型组织成层次结构;</span><br><span class="line">├── firmware</span><br><span class="line">│   ├── acpi</span><br><span class="line">│   ├── dmi</span><br><span class="line">│   └── memmap</span><br><span class="line">├── fs</span><br><span class="line">├── hypervisor</span><br><span class="line">├── kernel      内核所有可调整参数位置</span><br><span class="line">├── module      所有驱动模块的模块参数等信息</span><br><span class="line">└── power       系统电源选项</span><br></pre></td></tr></table></figure>

<h2 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h2><p>总线、驱动和设备都对应sysfs 中的一个目录，实际上都算是kobject 的派生类，device 结构体直接包含了 kobject kobj 成员，而 bus_type和 device_driver 则透过 subsys_private、driver_private 间接包含了 kobject。每一个注册的kobject对象都对应 sysfs中的一个目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>      *name;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>   <span class="title">entry</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>      *<span class="title">parent</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>      *<span class="title">kset</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>   *<span class="title">ktype</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span>   *<span class="title">sd</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>      <span class="title">kref</span>;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>kobj_type 是/sys/下的属性文件，代表kobject 的属性，release()函数在 kobject 的引用计数为0时会被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">   <span class="type">void</span> (*release)(<span class="keyword">struct</span> kobject *kobj);</span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span>   <span class="comment">// 属性数组</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">   <span class="type">const</span> <span class="type">void</span> *(*namespace)(<span class="keyword">struct</span> kobject *kobj);</span><br><span class="line">   <span class="type">void</span> (*get_ownership)(<span class="keyword">struct</span> kobject *kobj, <span class="type">kuid_t</span> *uid, <span class="type">kgid_t</span> *gid);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sysfs_ops 包含对文件读写的函数指针，代表对属性文件的文件操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> &#123;</span></span><br><span class="line">   <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> kobject *, <span class="keyword">struct</span> attribute *, <span class="type">char</span> *);</span><br><span class="line">   <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> kobject *, <span class="keyword">struct</span> attribute *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="kset"><a href="#kset" class="headerlink" title="kset"></a>kset</h2><p>kset 是具有相同类型的 kobject 集合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">   <span class="type">spinlock_t</span> list_lock;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span>  <span class="comment">// 热插拔事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当驱动程序将 kobject 注册到设备驱动模型时，也就是调用 kobject_add()和 kobject_del()函数时，会产生热插拔事件，内核会根据 kobject 的 kset 指针找到所属的 kset 结构体，执行 uevent_ops 中的热插拔函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> &#123;</span></span><br><span class="line">   <span class="type">int</span> (* <span class="type">const</span> filter)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj);  <span class="comment">// 事件过滤，如果返回 0，将不传递事件到用户空间</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *(* <span class="type">const</span> name)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj);  <span class="comment">// 返回子系统的名字</span></span><br><span class="line">   <span class="type">int</span> (* <span class="type">const</span> uevent)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj,</span><br><span class="line">            <span class="keyword">struct</span> kobj_uevent_env *env);  <span class="comment">// 将用户空间需要的参数添加到环境变量中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">225</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
