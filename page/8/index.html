<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/linux/sysconf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/linux/sysconf/" class="post-title-link" itemprop="url">linux sys conf function</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:18:38" itemprop="dateModified" datetime="2022-06-08T20:18:38+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">c语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="passwd文件"><a href="#passwd文件" class="headerlink" title="passwd文件"></a>passwd文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *pw_name;        <span class="comment">/* Username*/</span></span><br><span class="line">  <span class="type">char</span> *pw_passwd;      <span class="comment">/* Hashed passphrase, if shadow database</span></span><br><span class="line"><span class="comment">                                   not in use (see shadow.h).  */</span></span><br><span class="line">  <span class="type">__uid_t</span> pw_uid;       <span class="comment">/* User ID.  */</span></span><br><span class="line">  <span class="type">__gid_t</span> pw_gid;       <span class="comment">/* Group ID.  */</span></span><br><span class="line">  <span class="type">char</span> *pw_gecos;       <span class="comment">/* Real name.  */</span></span><br><span class="line">  <span class="type">char</span> *pw_dir;         <span class="comment">/* Home directory.  */</span></span><br><span class="line">  <span class="type">char</span> *pw_shell;       <span class="comment">/* Shell program.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>口令文件在/etc/passwd，格式为：用户名:加密口令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpwnam_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> passwd *pwd, <span class="type">char</span> *buf, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> buflen, <span class="keyword">struct</span> passwd **result)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpwuid_r</span><span class="params">(<span class="type">uid_t</span> uid, <span class="keyword">struct</span> passwd *pwd, <span class="type">char</span> *buf, </span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> buflen, <span class="keyword">struct</span> passwd **result)</span>;</span><br></pre></td></tr></table></figure>

<p>根据用户名或UID来获取口令信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>getpwent可以查看整个口令文件，它返回一个passwd指针，并找到下一个记录，若出错或到达文件尾端则为返回NULL。setpwent定位到文件开始处，endpwent则关闭这些文件。</p>
<h2 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *gr_name;      <span class="comment">/* Group name.  */</span></span><br><span class="line">    <span class="type">char</span> *gr_passwd;        <span class="comment">/* Password.    */</span></span><br><span class="line">    <span class="type">__gid_t</span> gr_gid;     <span class="comment">/* Group ID.    */</span></span><br><span class="line">    <span class="type">char</span> **gr_mem;      <span class="comment">/* Member list. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getgrnam_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> group *grp,</span></span><br><span class="line"><span class="params">         <span class="type">char</span> *buf, <span class="type">size_t</span> buflen, <span class="keyword">struct</span> group **result)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getgrgid_r</span><span class="params">(<span class="type">gid_t</span> gid, <span class="keyword">struct</span> group *grp,</span></span><br><span class="line"><span class="params">         <span class="type">char</span> *buf, <span class="type">size_t</span> buflen, <span class="keyword">struct</span> group **result)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setgrent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endgrent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/images/linux/sysctl/get_sys_data.png" alt="get_sys_data"></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>对环境变量进行操作，影响的是当前进程及其后生成的子进程的环境，不会影响父进程的环境</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<p>getenv从环境中取一个环境变量的值，返回一个指向name关联的value字符串指针。</p>
<p>putenv取形式为name=value的字符串，将其放到环境变量中。如果name已经存在，则先删除其原来的定义。</p>
<p>setenv将name设置为value。如果name已存在，那么若overwrite非0，则首先删除其现存的定义;若overwrite为0，则不设置也不出错。</p>
<p>unsetenv删除name的定义，即使不存在也不出错。</p>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;  <span class="comment">/* The current (soft) limit.  */</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_max;  <span class="comment">/* The hard limit.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br></pre></td></tr></table></figure>

<p>更改资源限制时,须遵循下列三条规则:</p>
<ul>
<li>任何一个进程都可将一个软限制更改为小于或等于硬限制。</li>
<li>任何一个进程都可降低硬限制值，但它必须大于或等于软限制值。这种降低对普通用户而言不可逆反。</li>
<li>只有超级用户可以提高硬限制。</li>
</ul>
<p>一个无限量的限制由常数RLIM_INFINITY指定。resource参数取下列值之一:</p>
<ul>
<li>RLIMIT_CORE   core文件的最大字节数，若其值为0则阻止创建core文件。</li>
<li>RLIMIT_CPU    CPU时间的最大量值(秒)，当超过此软限制时，向该进程发送SIGXCPU信号。</li>
<li>RLIMIT_DATA   数据段的最大字节长度。这是初始化数据、非初始化数据以及堆的总和。</li>
<li>RLIMIT_FSIZE  可以创建的文件的最大字节长度。超过时，向该进程发送SIGXFSZ信号。</li>
<li>RLIMIT_MEMLOCK    锁定在存储器地址空间。</li>
<li>RLIMIT_NOFILE 每个进程能打开的最多文件数。</li>
<li>RLIMIT_NPROC  每个实际用户ID所拥有的最大子进程数。</li>
<li>RLIMIT_OFILE  与SVR4的RLIMIT_NOFILE相同。</li>
<li>RLIMIT_RSS    最大驻内存集字节长度(RSS)。如果物理存储器不够，内核将从进程处取回超过的部分。</li>
<li>RLIMIT_STACK  栈的最大字节长度。</li>
<li>RLIMIT_VMEM   可映照地址空间的最大字节长度。</li>
</ul>
<h2 id="sysconf"><a href="#sysconf" class="headerlink" title="sysconf"></a>sysconf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">sysconf</span><span class="params">(<span class="type">int</span> name)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">pathconf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> name)</span>;</span><br></pre></td></tr></table></figure>

<p>以_SC_开始的常数用作为sysconf的参数，而以_PC_开始的常数则作为pathconf或fpathconf的参数。</p>
<p>对于pathconf的参数pathname,fpathconf的参数filedes有很多限制:</p>
<ol>
<li>_PC_MAX_CANON,_PC_MAX_INPUT以及_PC_VDISABLE所涉及的文件必须是终端文件。</li>
<li>_PC_LINK_MAX所涉及的文件可以是文件或目录。如果是目录，则返回值用于目录本身。</li>
<li>_PC_NAME_MAX和_PC_NO_TRUNC所涉及的文件必须是目录，返回值用于该目录中的文件名。</li>
<li>_PC_PATH_MAX涉及的必须是目录。当所指定的目录是工作目录时，返回值是相对路径名的最大长度。</li>
<li>_PC_PIPE_BUF所涉及的文件必须是管道、FIFO或目录。在管道或FIFO情况下，返回值是对所涉及的管道或FIFO的限制值。对于目录返回值是对在该目录中创建的任一FIFO的限制值。</li>
<li>_PC_CHOWN_RESTRICTED必须是文件或目录。如果是目录则返回指明此选择项是否适用于该目录中的文件。</li>
<li>对于_SC_JOB_CONTROL、SC_SAVED_IDS、PC_CHOWN_RESTRICTED、PC_VDISABLE和_PC_NO_TRUNC的返回值若为-1(不改变errno),则表示不支持此功能。</li>
</ol>
<p><img src="/images/linux/sysctl/sysconf_name.png" alt="sysconf_name"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/c/filedir/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/c/filedir/" class="post-title-link" itemprop="url">linux 文件管理函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:18:38" itemprop="dateModified" datetime="2022-06-08T20:18:38+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">c语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p><img src="/images/linux/filedir/file_fs.png" alt="文件系统"><br><img src="/images/linux/filedir/inode.png" alt="i节点"></p>
<p>Linux 下的文件是通过索引节点(inode)来识别文件，硬链接是一个指向文件索引节点的指针。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;         <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">mode_t</span>    st_mode;        <span class="comment">/* protection */</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;       <span class="comment">/* number of hard links */</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;         <span class="comment">/* user ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>     st_gid;         <span class="comment">/* group ID of owner */</span></span><br><span class="line">    <span class="type">dev_t</span>     st_rdev;        <span class="comment">/* device ID (if special file) */</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;        <span class="comment">/* total size, in bytes */</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize;     <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">/* number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* time of last status change */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>stat函数返回一个与此命名文件有关的信息结构， fstat函数获得已在描述符filedes上打开的文件的有关信息。lstat函数类似于stat，但是当命名的文件是一个符号连接时，lstat返回该符号连接的有关信息，而不是由该符号连接引用的文件的信息。</p>
<p>软连接的长度是其所指向的文件名的长度。</p>
<p>修改时间(st_mtime)是文件内容最后一次被修改的时间。更改状态时间(st_ctime)是该文件的i节点最后一次被修改的时间。很多操作影响到 i节点，但并没有更改文件的实际内容:文件的存取许可权、用户ID、连接数等等。因为i节点中的所有信息都是与文件的实际内容分开存放的，所以，除了文件数据修改时间以外，还需要更改状态时间。</p>
<p><img src="/images/linux/filedir/file_time.png" alt="文件的时间"></p>
<p>ls命令按这三个时间值中的一个排序进行显示。按系统默认 (用-l或-t选择项调用时 )，它按文件的修改时间的先后排序显示。 -u选择项使其用存取时间排序， -c选择项则使其用更改状态时间排序。</p>
<p>表4-9中包含两列的原因，其中一列是与该文件(或目录)相关的三个时间，另一列是与所引用的文件(或目录)的父目录相关的三个时间。例如创建一个新文件影响到包含此新文件的目录，也影响该新文件的i节点。但读或写一个文件只影响该文件的i节点，而对父目录则无影响。</p>
<p><img src="/images/linux/filedir/time_effect_by_function.png" alt="函数对文件时间的作用"></p>
<h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>按实际用户ID和实际组ID进行存取许可权测试。成功返回0，失败返回-1。mode取值：</p>
<ul>
<li>R_OK 测试读许可权</li>
<li>W_OK 测试写许可权</li>
<li>X_OK 测试执行许可权</li>
<li>F_OK 测试文件是否存在</li>
</ul>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>;</span><br></pre></td></tr></table></figure>

<p>相对于系统umaks为0000来的，要把系统umask也算上。</p>
<p><img src="/images/linux/filedir/mode_t.png" alt="mode_t"></p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchmod</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>将指定的文件的长度截短为length。如果该文件以前的长度大于length，则超过length以外的数据就不能存取。如果以前的长度短于length，则超过部分的数据将读作’\0’。</p>
<h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<p>创建硬连接，只有root用户才可以创建到目录的硬连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>解除硬连接，并将引用的文件的连接计数减1。可以用作删除文件，只有当文件的连接计数为0，没有被进程打开，文件才能删除。</p>
<p>unlink的这种特性经常被程序用来确保即使是在程序崩溃时,它所创建的临时文件也不会遗留下来。进程用open或creat创建一个文件,然后立即调用unlink。因为该文件已经被打开了，所以不会将其内容删除。只有当进程关闭该文件或终止时，该文件的内容才被删除。</p>
<h3 id="symlink-readlink"><a href="#symlink-readlink" class="headerlink" title="symlink readlink"></a>symlink readlink</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>;</span><br></pre></td></tr></table></figure>

<p>创建软连接，不要求target已经存在，且target和linkpath不需要位于同一文件系统中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *buf, <span class="type">size_t</span> bufsiz)</span>;</span><br></pre></td></tr></table></figure>

<p>打开该连接本身，并读该连接中的名字，此函数组合了open,read和close的所有操作，如果此函数成功，则它返回读入buf的字节数，不包含终止符\0。</p>
<p><img src="/images/linux/filedir/link.png" alt="link"></p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="utime"><a href="#utime" class="headerlink" title="utime"></a>utime</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> actime;       <span class="comment">/* access time */</span></span><br><span class="line">    <span class="type">time_t</span> modtime;      <span class="comment">/* modification time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此函数的操作以及执行它所要求的优先权取决于times参数是否是NULL。</p>
<ul>
<li>如果times是一个空指针，则存取时间和修改时间两者都设置为当前时间。为了执行此操作必须满足下列两条件之一: (a)进程的有效用户ID必须等于该文件的所有者ID，(b)进程对该文件必须具有写许可权。</li>
<li>如果times是非空指针，则存取时间和修改时间被设置为times所指向的结构中的值。此时进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是一个超级用户进程。</li>
</ul>
<p>我们不能对更改状态时间st_ctime指定一个值，当调用utime函数时，此字段被自动更新。</p>
<h3 id="mkdir-rmdir"><a href="#mkdir-rmdir" class="headerlink" title="mkdir rmdir"></a>mkdir rmdir</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>创建一个新的空目录。 . 和.. 目录项是自动创建的。指定的文件存取许可权mode由进程的文件方式创建屏蔽字修改。至少要设置1个执行许可权位，以允许存取该目录中的文件名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>目录必须是空才能被删除。</p>
<h3 id="opendir"><a href="#opendir" class="headerlink" title="opendir"></a>opendir</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*resets the position of the directory stream dirp to the beginning of the directory.*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewinddir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span>          d_ino;       <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">off_t</span>          d_off;       <span class="comment">/* not an offset; see NOTES */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* length of this record */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* type of file; not supported</span></span><br><span class="line"><span class="comment">                                  by all filesystem types */</span></span><br><span class="line">    <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchdir</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">syncfs</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>将缓存的数据同步到磁盘文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/c/stdio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/c/stdio/" class="post-title-link" itemprop="url">linux standard io</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:18:38" itemprop="dateModified" datetime="2022-06-08T20:18:38+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">c语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>标准I/O提供了三种类型的缓存:</p>
<ul>
<li><p>全缓存，当填满标准I/O缓存后才进行实际I/O操作。对于驻在磁盘上的文件通常是由标准I/O库实施全缓存的。在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓存。</p>
</li>
<li><p>行缓存，当在输入和输出中遇到新行符时才执行I/O操作。当流涉及一个终端时(标准输入和标准输出)典型地使用行缓存。对于行缓存有两个限制：</p>
<ul>
<li>因为标准I/O库用来收集每一行的缓存的长度是固定的，只要填满了缓存，即使还没有写一个新行符，也进行I/O操作。</li>
<li>任何时候只要通过标准输入输出库要求从一个不带缓存的流，或者一个行缓存的流得到输入数据，都会造成刷新所有行缓存输出流。</li>
<li>不带缓存。标准I/O库不对字符进行缓存。标准出错流stderr通常是不带缓存的。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>setbuf函数打开或关闭缓存机制。为了带缓存进行I/O，参数buf必须指向一个长度为BUFSIZ的缓存，设置后通常该流是全缓存的，但如果该流与一个终端设备相关，某些系统可能将其设置为行缓存。为了关闭缓存，将buf设置为NULL。</p>
<p>setvbuf可以精确地设置缓存类型。这是依靠mode参数实现的:</p>
<ul>
<li>_IOFBF 全缓存</li>
<li>_IOLBF 行缓存</li>
<li>_IONBF 不带缓存</li>
</ul>
<p>如果指定一个不带缓存的流，则忽略buf和size参数。如果该流是带缓存的，而buf是NULL，则标准I/O库将自动地为该流分配适当长度的缓存。适当长度是由struct结构中的成员st_blksize的值。如果系统不能为该流决定此值(若此流涉及一个设备或一个管道)，则分配长度为BUFSIZ的缓存。</p>
<p><img src="/images/linux/stdio/setbuf.png" alt="setbuf"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="fflush"><a href="#fflush" class="headerlink" title="fflush"></a>fflush</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>刷新流 stream 的输出缓冲区。返回：若成功则为0，若出错则为EOF，并设置错误标识符。 若fp是NULL，则此函数刷新所有输出流。</p>
<h3 id="fopen-fclose"><a href="#fopen-fclose" class="headerlink" title="fopen fclose"></a>fopen fclose</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">FILE *<span class="title function_">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>fopen打开一个标准I/O流，返回:若成功则为文件指针，若出错则为NULL，并设置errno。mode参数指定对该I/O流的读、写方式:</p>
<table>
<thead>
<tr>
<th>字符串</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读方式打开文件，该文件必须存在</td>
</tr>
<tr>
<td>r+</td>
<td>以读/写方式打开文件，该文件必须存在</td>
</tr>
<tr>
<td>rb+</td>
<td>以读/写方式打开一个二进制文件，只允许读/写数据</td>
</tr>
<tr>
<td>rt+</td>
<td>以读/写方式打开一个文本文件，允许读和写</td>
</tr>
<tr>
<td>w</td>
<td>打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件</td>
</tr>
<tr>
<td>w+</td>
<td>打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件</td>
</tr>
<tr>
<td>a</td>
<td>以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）</td>
</tr>
<tr>
<td>a+</td>
<td>以附加方式打开可读/写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）</td>
</tr>
<tr>
<td>wb</td>
<td>以只写方式打开或新建一个二进制文件，只允许写数据</td>
</tr>
<tr>
<td>wb+</td>
<td>以读/写方式打开或新建一个二进制文件，允许读和写</td>
</tr>
<tr>
<td>wt+</td>
<td>以读/写方式打开或新建一个文本文件，允许读和写</td>
</tr>
<tr>
<td>at+</td>
<td>以读/写方式打开一个文本文件，允许读或在文本末追加数据</td>
</tr>
<tr>
<td>ab+</td>
<td>以读/写方式打开一个二进制文件，允许读或在文件末追加数据</td>
</tr>
</tbody></table>
<p><img src="/images/linux/stdio/io_mode.png" alt="io_mode"></p>
<ol>
<li>以 x 结尾的模式为独占模式，文件已存在或者无法创建（一般是路径不正确）都会导致 fopen 失败。文件以操作系统支持的独占模式打开。</li>
<li>上述的形态字符串都可以加入 b 字符用来告诉函数库以二进制模式打开文件。如果不加 b，表示默认加了 t，表示以文本模式打开文件。</li>
<li>由 fopen() 所建立的新文件会具有_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666) 权限，此文件权限也会参考umask值。</li>
<li>有些 C编译系统可能不完全提供所有这些功能，有的C版本不”r+”、”w+”、”a+”，而用”rw”、”wr”、”ar”等。</li>
<li>在Windows系统中，文本模式下，文件以”\r\n”代表换行。若以文本模式打开文件，并用 fputs 等函数写入换行符”\n”时，函数会自动在”\n”前面加上”\r”。即实际写入文件的是”\r\n”。</li>
<li>在类 Unix/Linux 系统中文本模式下，文件以”\n”代表换行。所以 Linux 系统中在文本模式和二进制模式下并无区别。</li>
</ol>
<p>fdopen可以将文件描述符转为文件指针，为写打开时并不截短该文件，因为描述符已被打开。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>关闭一个打开的流，返回:若成功则为0，若出错则为EOF。</p>
<h3 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc"></a>fgetc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>一次读一个字符，返回:若成功则为下一个字符，若已处文件尾端或出错则为EOF(-1)。fgetc不能实现为宏。<code>Ctrl+d</code>可产生1个EOF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>FILE对象中有出错标志和文件结束标志，feof和ferror可以用来判断这些标志，若条件为真返回非0，否则为0。clearerr则清除这两个标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>从一个流读之后，ungetc将字符再送回流中，返回:若成功则为c,若出错则为EOF。回送的字符，不一定要是上一次读到的字符。EOF不能回送。已经到达文件尾端时，仍可以回送一字符。</p>
<h3 id="fputc"><a href="#fputc" class="headerlink" title="fputc"></a>fputc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>

<p>fgetc不能实现为宏，返回:若成功则为c,若出错则为EOF。</p>
<h3 id="fgets-fputs"><a href="#fgets-fputs" class="headerlink" title="fgets fputs"></a>fgets fputs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p>fgets必须指定缓存的长度n，一直读到下一个新行符为止，但是不超过n-1个字符，读入的字符被送入缓存。该缓存以’\0’字符结尾。如若该行包括最后一个新行符的字符数超过n-1，则只返回一个不完整的行，而且缓存总是以’\0’字符结尾。对fgets的下一次调用会继续读该行。</p>
<p>gets已经被停用，因为不能指定缓存的长度，会造成缓存越界。gets并不将新行符存入缓存中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p>fputs将一个以’\0’终止的字符串写到指定的流，终止符’\0’不写出。</p>
<h3 id="fread-fwrite"><a href="#fread-fwrite" class="headerlink" title="fread fwrite"></a>fread fwrite</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb,FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>fread和fwrite返回读或写的对象数。对于读，如果出错或到达文件尾端，则此返回値小于nmemb，应调用ferror或feof判断是那一种情况。对于写，如果返回值小于nmemb，则出错。</p>
<p>当用来读写结构体时，应当考虑不同系统之间的结构体对齐方式，整数和浮点数的存储格式的不同。</p>
<h3 id="ftell-fseek"><a href="#ftell-fseek" class="headerlink" title="ftell fseek"></a>ftell fseek</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE *stream, <span class="type">fpos_t</span> *pos)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span>;</span><br></pre></td></tr></table></figure>

<p>ftell返回当前文件的位置指示，若出错则为-1。</p>
<p>fseek定位一个二进制文件，必须指定一个字节offset，whence是位移量的方式:</p>
<ul>
<li>SEEK_SET  表示从文件的起始位置开始</li>
<li>SEEK_CUR  表示从当前文件位置</li>
<li>SEEK_END  表示从文件的尾端</li>
</ul>
<p>对于文本文件，whence一定要是SEEK_SET，而且offset只能有两种值:0 表示文件起始位置；或ftell所返回的值。</p>
<p>rewind函数也可将一个流设置到文件的起始位置。</p>
<p>fgetpos将文件位置指示器的当前值存入由pos指向的对象中。以后调用fsetpos时，可以使用此值将流重新定位至该位置。</p>
<h3 id="fprintf-sprintf"><a href="#fprintf-sprintf" class="headerlink" title="fprintf sprintf"></a>fprintf sprintf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>格式化数据到流，成功返回输出字符数。</p>
<h3 id="fscanf-sscanf"><a href="#fscanf-sscanf" class="headerlink" title="fscanf sscanf"></a>fscanf sscanf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="fileno"><a href="#fileno" class="headerlink" title="fileno"></a>fileno</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>获得流的描述符。</p>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">tmpnam</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">tempnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dir, <span class="type">const</span> <span class="type">char</span> *pfx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> P_tmpdir</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> P_tmpdir <span class="string">&quot;/tmp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TMP_MAX</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TMP_MAX 238328</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>tmpnam下/tmp目录下产生一个有效路径名字符串，最多调用次数是TMP_MAX。该使用不安全，建议用mkstemp代替。</p>
<ul>
<li>若ptr是NULL，则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。下一次再调用tmpnam时，会重写该静态区。</li>
<li>若ptr不是NULL，则它指向长度至少是L_tmpnam个字符的数组。产生的路径名存放在该数组中，ptr也作为函数值返回。</li>
</ul>
<p>tmpfile创建一个临时二进制文件(类型wb+)，在关闭该文件或程序结束时会自动删除。</p>
<p>tempnam可以指定临时文件的目录和前缀。对于目录有四种不同的优先选择：</p>
<ol>
<li>如果定义了环境变量TMPDIR，则用作为目录。</li>
<li>如果参数directory非NULL，则用作为目录。</li>
<li>将&lt;stdio.h&gt;中的字符串P_tmpdir作为目录。</li>
<li>将/tmp作为目录。如果prefix非NULL，则它至少5个字节。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkostemp</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemps</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> suffixlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkostemps</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> suffixlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>创建一个惟一的临时文件，并返回文件的描述符，各文件路径，所以template必须是数组，且后6个字符为”XXXXXX”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/tool/regex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/tool/regex/" class="post-title-link" itemprop="url">Regex</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="left">转义符</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配输入字符串的开始位置</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入字符串的结束位置</td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除“<code>\n</code>之外的任何单个字符</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次，等价于{1,}</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次，等价于{0,1}</td>
</tr>
<tr>
<td align="center">*?</td>
<td align="left">匹配前面任意个表达式（尽可能少）</td>
</tr>
<tr>
<td align="center">+?</td>
<td align="left">匹配前面至少一个表达式（尽可能少）</td>
</tr>
<tr>
<td align="center">(pattern)</td>
<td align="left">匹配pattern并获取这一匹配，捕获并为括号内的字符隐式编号</td>
</tr>
<tr>
<td align="center">[abc]</td>
<td align="left">匹配集合中的任何字符</td>
</tr>
<tr>
<td align="center">[a-z]</td>
<td align="left">匹配范围中的任何字符</td>
</tr>
<tr>
<td align="center">[^abc]</td>
<td align="left">非字符集合，匹配未包含的任意字符</td>
</tr>
<tr>
<td align="center">[^a-z]</td>
<td align="left">非字符范围，匹配任何不在指定范围内的任意字符</td>
</tr>
<tr>
<td align="center">|</td>
<td align="left">两项之间匹配一个，使用时要加转义符</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">指定前一个字符出现次数</td>
</tr>
<tr>
<td align="center">{<em>n</em>,}</td>
<td align="left">其前面的字符出现不小于n次</td>
</tr>
<tr>
<td align="center">{<em>n</em>,<em>m</em>}</td>
<td align="left">其前面的字符至少出现n次，最多出现m次</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如，“<code>er\b</code>”可以匹配“<code>never</code>”中的“<code>er</code>”，但不能匹配“<code>verb</code>”中的“<code>er</code>”。</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">匹配非单词边界。“<code>er\B</code>”能匹配“<code>verb</code>”中的“<code>er</code>”，但不能匹配“<code>never</code>”中的“<code>er</code>”。</td>
</tr>
<tr>
<td align="center">\cx</td>
<td align="left">匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“<code>c</code>”字符。</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="left">匹配十进制字符，等价于[0-9]。</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="left">匹配一个非数字字符，等价于[^0-9]。</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="left">匹配一个换页符，等价于\x0c和\cL。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符，等价于\x0a和\cJ。</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符，等价于\x0d和\cM。</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等，等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配任何非空白字符，等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个制表符，等价于\x09和\cI。</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">匹配一个垂直制表符，等价于\x0b和\cK。</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配包括下划线的任何文字字符，等价于<code>[A-Za-z0-9_]</code></td>
</tr>
<tr>
<td align="center">\W</td>
<td align="left">匹配任何非单词字符，等价于“<code>[^A-Za-z0-9_]</code>”</td>
</tr>
<tr>
<td align="center">\u<em>n</em></td>
<td align="left">匹配<em>n</em>，其中<em>n</em>是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td>
</tr>
<tr>
<td align="center">\x<em>n</em></td>
<td align="left">匹配<em>n</em>，其中<em>n</em>为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<code>\x41</code>”匹配“<code>A</code>”。“<code>\x041</code>”则等价于“<code>\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。.</td>
</tr>
<tr>
<td align="center">(?:pattern)</td>
<td align="left">匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(</td>
</tr>
<tr>
<td align="center">(?=pattern)</td>
<td align="left">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95</td>
</tr>
<tr>
<td align="center">(?!pattern)</td>
<td align="left">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95</td>
</tr>
<tr>
<td align="center">(?&lt;=pattern)</td>
<td align="left">反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95</td>
</tr>
<tr>
<td align="center">(?&lt;!pattern)</td>
<td align="left">反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95</td>
</tr>
<tr>
<td align="center">*num*</td>
<td align="left">匹配<em>num</em>，其中<em>num</em>是一个正整数。对所获取的匹配的引用。例如，“<code>(.)\1</code>”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td align="center">*n*</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果*n<em>之前至少</em>n<em>个获取的子表达式，则</em>n<em>为向后引用。否则，如果</em>n<em>为八进制数字（0-7），则</em>n*为一个八进制转义值。</td>
</tr>
<tr>
<td align="center">*nm*</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果*nm<em>之前至少有</em>nm<em>个获得子表达式，则</em>nm<em>为向后引用。如果*nm</em>之前至少有<em>n</em>个获取，则<em>n</em>为一个后跟文字<em>m</em>的向后引用。如果前面的条件都不满足，若<em>n</em>和<em>m</em>均为八进制数字（0-7），则*nm<em>将匹配八进制转义值</em>nm*。</td>
</tr>
<tr>
<td align="center">*nml*</td>
<td align="left">如果<em>n</em>为八进制数字（0-3），且<em>m和l</em>均为八进制数字（0-7），则匹配八进制转义值<em>nm</em>l。</td>
</tr>
</tbody></table>
<p><img src="/images/code/regexp-metachar.png" alt="img"></p>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">ignore - 不区分大小写</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">global - 全局匹配</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">multi line - 多行匹配</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 s 之后, <strong>.</strong> 中包含换行符 <strong>\n</strong>。</td>
</tr>
</tbody></table>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">转义符</td>
</tr>
<tr>
<td align="left">(), (?:), (?=), []</td>
<td align="left">圆括号和方括号</td>
</tr>
<tr>
<td align="left">*, +, ?, {n}, {n,}, {n,m}</td>
<td align="left">限定符</td>
</tr>
<tr>
<td align="left">^, $, \任何元字符、任何字符</td>
<td align="left">定位点和序列（即：位置和顺序）</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td>
</tr>
</tbody></table>
<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><table>
<thead>
<tr>
<th align="center">用户名</th>
<th>/^[a-z0-9_-]{3,16}$/</th>
</tr>
</thead>
<tbody><tr>
<td align="center">密码</td>
<td>/^[a-z0-9_-]{6,18}$/</td>
</tr>
<tr>
<td align="center">十六进制值</td>
<td>/^#?([a-f0-9]{6}|[a-f0-9]{3})$/</td>
</tr>
<tr>
<td align="center">电子邮箱</td>
<td>/^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$/ /^[a-z\d]+(.[a-z\d]+)*@(<a href="-%5B%5Cda-z%5D">\da-z</a>?)+(.{1,2}[a-z]+)+$/</td>
</tr>
<tr>
<td align="center">URL</td>
<td>/^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-]*)*/?$/</td>
</tr>
<tr>
<td align="center">IP 地址</td>
<td>/((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/ /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</td>
</tr>
<tr>
<td align="center">HTML 标签</td>
<td>/^&lt;([a-z]+)([^&lt;]+)<em>(?:&gt;(.</em>)&lt;/\1&gt;|\s+/&gt;)$/</td>
</tr>
<tr>
<td align="center">删除代码\注释</td>
<td>(?&lt;!http:|\S)//.*$</td>
</tr>
<tr>
<td align="center">Unicode编码中的汉字范围</td>
<td>/^[\u2E80-\u9FFF]+$/</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/cpp/thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/cpp/thread/" class="post-title-link" itemprop="url">C++ thread</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-11 21:31:50" itemprop="dateModified" datetime="2022-06-11T21:31:50+08:00">2022-06-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">thread</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">thread</span>(<span class="type">const</span> thread&amp;) = <span class="keyword">delete</span>; <span class="comment">// 拷贝构造被禁用</span></span><br><span class="line"><span class="built_in">thread</span>(thread&amp;&amp; x) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(thread&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">id <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">native_handle_type <span class="title">native_handle</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>get_id()</code>: 获取线程 ID。<br><code>swap()</code>: 交换两个线程对象所代表的底层句柄。<br><code>native_handle()</code>: 返回线程句柄，与 Posix 标准的pthread函数配合使用。<br><code>joinable()</code>: 检查线程是否可被 join，活动的线程是可以被 join 的，由默认构造函数创建的线程是不能被 join 的。<br><code>join()</code>: 阻塞当前线程，直到由 <code>*this</code> 所标示的线程执行完毕才返回。当线程自己返回或pthread_exit时都不会释放线程堆栈和描述符，只有join后，这些资源才会被释放。<br><code>detach()</code>: 将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以单独进行。分离的线程不能被其他线程回收或杀死，它的资源由系统释放。调用 detach 函数之后：</p>
<ol>
<li><code>*this</code> 不再代表任何的线程执行实例。</li>
<li><code>joinable() == false</code>，会抛出 <code>std::system_error</code>异常。</li>
<li><code>get_id() == std::thread::id()</code></li>
</ol>
<p>std::thread 线程执行体可以是任何可调用的对象：</p>
<ol>
<li>普通函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">()</span> <span class="comment">//不带参数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std::string arg)</span> <span class="comment">//带参数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(callback)</span></span>; </span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(callback, <span class="string">&quot;test&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">callback</span> <span class="comment">// 不带参数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">callback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="built_in">callback</span>() &#123;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string arg)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t3</span><span class="params">(callback())</span></span>; </span><br><span class="line"><span class="function">std::thread <span class="title">t4</span><span class="params">(callback(), <span class="string">&quot;test&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>类成员函数</li>
</ol>
<p>因为回调函数需要是一个函数指针，而类没有实例对象，还没有分配内存地址，所以编译器不知道成员函数的存在。使用时必须在成员函数前面加<code>&amp;</code>符号，让编译器把对象的成员函数转换成函数指针，同时还要将对象作为第二个参数传入，告知调用者是谁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">callback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="built_in">entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">entity</span><span class="params">(<span class="type">const</span> std::string arg)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">callback obj;</span><br><span class="line"><span class="function">std::thread <span class="title">t5</span><span class="params">(&amp;callback::entity, &amp;obj)</span></span>;</span><br><span class="line"><span class="comment">// std::thread t5(&amp;callback::entity, this);</span></span><br><span class="line"><span class="function">std::thread <span class="title">t6</span><span class="params">(&amp;callback::entity,  &amp;obj, <span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// std::thread t6(&amp;callback::entity,  this, &quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::thread  <span class="title">t5</span><span class="params">(std::bind(&amp;callback::entity, &amp;obj))</span></span>;</span><br><span class="line"><span class="function">std::thread  <span class="title">t6</span><span class="params">(std::bind(&amp;callback::entity,  &amp;obj, <span class="string">&quot;test&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>lambda 函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t7</span><span class="params">([](T var1, T var2) &#123;&#125;, arg..)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="std-this-thread"><a href="#std-this-thread" class="headerlink" title="std::this_thread"></a>std::this_thread</h2><p><code>get_id()</code>: 获取线程 ID。<br><code>yield()</code>: 当前线程放弃时间片，操作系统调度另一线程继续执行。<br><code>sleep_until()</code>: 线程休眠至某个指定的时间点，该线程才被重新唤醒。<br><code>sleep_for()</code>: 线程休眠某个指定的时间片，该线程才被重新唤醒，不过由于线程调度等原因，实际休眠时间可能更长。</p>
<h2 id="线程本地变量"><a href="#线程本地变量" class="headerlink" title="线程本地变量"></a>线程本地变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        var++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread id [%d] var(%p) = %d\n&quot;</span>, std::this_thread::<span class="built_in">get_id</span>(), &amp;var, var); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(callback)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(callback)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统线程库使用<code>__thread</code>关键字来声明线程本地变量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/cpp/function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/cpp/function/" class="post-title-link" itemprop="url">C++ bind and function</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-09 19:51:44" itemprop="dateModified" datetime="2022-06-09T19:51:44+08:00">2022-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>bind是一个函数包装器，事先绑定一些参数到调用函数，可以用来将一个有参数的函数转换为一个无参的函数对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt; <span class="built_in">bind</span> (Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure>

<ul>
<li>fn: 可调用对象（函数对象、函数指针、函数引用）。</li>
<li>args: 要绑定的参数列表，未绑定的参数用<code>std::placeholders</code>的占位符<code>_1</code> <code>_2</code> <code>_3</code>…替换。</li>
</ul>
<p>绑定类成员函数时，第一个参数是对象的成员函数指针，因为编译器不会将对象的成员函数隐式转换成函数指针，所以必须在前面添加&amp;符号取地址。第二个参数表示对象的地址或引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a+b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line">  <span class="type">double</span> a, b;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a*b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binding functions:</span></span><br><span class="line">    <span class="keyword">auto</span> fn1 = std::<span class="built_in">bind</span>(Sum, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">fn1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fn2 = std::<span class="built_in">bind</span>(Sum, _1, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">fn2</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fn3 = std::<span class="built_in">bind</span>(Sum, _2, _1);</span><br><span class="line">    <span class="built_in">fn3</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*psum)(<span class="type">int</span>, <span class="type">int</span> );</span><br><span class="line">    psum = Sum;</span><br><span class="line">    <span class="keyword">auto</span> fn4 = std::<span class="built_in">bind</span>&lt;<span class="type">int</span>&gt;(psum, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">fn4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binding members:</span></span><br><span class="line">    MyPair pair &#123;<span class="number">10</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> bound_member_fn = std::<span class="built_in">bind</span> (&amp;MyPair::multiply, _1); <span class="comment">// returns x.multiply()</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bound_member_fn</span>(pair) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bound_member_data = std::<span class="built_in">bind</span> (&amp;MyPair::a, pair); <span class="comment">// returns pair.a</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bound_member_data</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="function"><a href="#function" class="headerlink" title="function()"></a>function()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">function</span>&lt;<span class="built_in">R</span>(Args...)&gt;</span><br></pre></td></tr></table></figure>

<p>function可以对普通函数、函数指针、函数对象、Lambda等进行封装，实现函数回调，它不能检查相等与否，只能对其判空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">testFun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> lamdaExps = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.类成员函数</span></span><br><span class="line"><span class="comment">// 2.类静态成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">classMemberFun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">staticMemberFun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 普通函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; functional = testFun;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">functional</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通函数: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通函数指针</span></span><br><span class="line">    functional = &amp;testFun;</span><br><span class="line">    ret = <span class="built_in">functional</span>(<span class="number">10</span> ,<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通函数指针: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line">    functional = lamdaExps;</span><br><span class="line">    ret = <span class="built_in">functional</span>(<span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lambda表达式: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仿函数</span></span><br><span class="line">    Functor testFunctor;</span><br><span class="line">    functional = testFunctor;</span><br><span class="line">    ret = <span class="built_in">functional</span>(<span class="number">10</span>, <span class="number">40</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;仿函数: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类成员函数（使用std::bind绑定类成员函数）</span></span><br><span class="line">    TestClass testObj;</span><br><span class="line">    functional = std::<span class="built_in">bind</span>(&amp;TestClass::classMemberFun, testObj, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line">    ret = <span class="built_in">functional</span>(<span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;类成员函数: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类静态成员函数</span></span><br><span class="line">    functional = TestClass::staticMemberFun;</span><br><span class="line">    ret = <span class="built_in">functional</span>(<span class="number">10</span>, <span class="number">60</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;类静态成员函数: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/linux/proc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/linux/proc/" class="post-title-link" itemprop="url">linux /proc/ directory</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:18:38" itemprop="dateModified" datetime="2022-06-08T20:18:38+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">c语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>/proc文件系统是一种虚拟文件系统，以文件系统目录和文件形式，提供一个指向内核数据结构的接口，通过它能够查看和改变各种系统属性，proc目录通常情况下是由系统自动挂载在/proc目录下，也可自行手动挂载。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t proc proc /proc</span><br></pre></td></tr></table></figure>

<h2 id="proc-pid"><a href="#proc-pid" class="headerlink" title="/proc/pid/"></a>/proc/pid/</h2><p>这些文件和目录记录的都是pid对应进程的信息。</p>
<ul>
<li><p>/proc/pid/attr/  提供了安全相关的属性，可读可写，以支持SELinux等安全模块，需配置CONFIG_SECURITY。</p>
<ul>
<li>/proc/pid/attr/current  当前的安全相关的属性。</li>
<li>/proc/pid/attr/exec  执行命令execve时设置的安全相关的属性。</li>
<li>/proc/pid/attr/fscreate  代表进程与文件有关的权限，包括open、mkdir、symlink、mknod。</li>
<li>/proc/pid/attr/keycreate  执行命令add_key时设置的安全相关的属性。</li>
<li>/proc/pid/attr/prev  最后一次执行命令execve时的安全相关的属性。</li>
<li>/proc/pid/attr/sockcreate  创建socket时设置的安全相关的属性。</li>
</ul>
</li>
<li><p>/proc/pid/auxv  ELF解释器信息，格式为一个unsigned long类型的ID加一个unsigned long类型的值，最后为两个0（man getauxval）。</p>
</li>
<li><p>/proc/pid/cgroup  进程所属的控制组，格式为冒号分隔的三个字段，分别是结构ID、子系统、控制组，需配置CONFIG_CGROUPS。</p>
</li>
<li><p>/proc/pid/clear_refs  只写，只用于进程的拥有者，清除用于估算内存使用量的PG_Referenced和ACCESSED/YOUNG，有四种策略，1表示清除相关的所有页，2表示清除相关的匿名页，3表示清除相关的映射文件的页，4表示清除相关的soft-dirty的页，需配置CONFIG_PROC_PAGE_MONITOR。</p>
</li>
<li><p>/proc/pid/cmdline  只读，保存启动进程的完整的命令行字符串，如果是僵尸进程，这个文件为空。</p>
</li>
<li><p>/proc/pid/comm  进程的命令名，不同的线程（man clone prctl pthread_setname_np）可能有不同的线程名，位置在“task/[tid]/comm”，名字长度超过TASK_COMM_LEN时会被截断。</p>
</li>
<li><p>/proc/pid/coredump_filter  coredump过滤器，如00000033（man core），不同的二进制位表示过滤不同的信息。</p>
</li>
<li><p>/proc/pid/cpuset  控制CPU和内存的节点（man cpuset）。</p>
</li>
<li><p>/proc/pid/cwd  符号链接到当前工作目录。</p>
</li>
<li><p>/proc/pid/environ  环境变量。</p>
</li>
<li><p>/proc/pid/exe  符号链接到启动进程的完整命令。</p>
</li>
<li><p>/proc/pid/fd / 包含当前的fd，这些fd符号链接到真正打开的文件。</p>
</li>
<li><p>/proc/pid/fdinfo / 包含当前fd的信息，不同类型的fd信息不同。</p>
</li>
<li><p>/proc/pid/io  IO信息。</p>
</li>
<li><p>/proc/pid/gid_map  从用户命名空间映射的组ID的信息（man user_namespaces）。</p>
</li>
<li><p>/proc/pid/limits  资源软、硬限制（man getrlimit）。</p>
</li>
<li><p>/proc/pid/map_files / 包括一些内存映射文件（man mmap），文件名格式为BeginAddress-EndAddress，符号链接到映射的文件，需要配置CONFIG_CHECKPOINT_RESTORE。</p>
</li>
<li><p>/proc/pid/maps  当前进程映射的内存区域以及访问权限。</p>
</li>
<li><p>/proc/pid/mem  可以通过open、read和lseek访问进程的内存页，不能被用户读取。</p>
</li>
<li><p>/proc/pid/mountinfo  挂载信息，格式为<code>36 35 98:0 /mnt1 /mnt2 rw,noatime master:1 - ext3 /dev/root rw,errors=continue</code>，以空格作为分隔符，从左到右各字段的意思分别是唯一挂载ID、父挂载ID、文件系统的设备主从号码、文件系统中挂载的根节点、相对于进程根节点的挂载点、挂载权限等挂载配置、可选配置、短横线表示前面可选配置的结束、文件系统类型、文件系统特有的挂载源或者为none、额外配置。</p>
</li>
<li><p>/proc/pid/mounts  挂载在当前进程的文件系统列表，格式参照（man fstab）。</p>
</li>
<li><p>/proc/pid/mountstats  挂载信息。</p>
</li>
<li><p>/proc/pid/ns / 保存了每个名字空间的入口，详见（man namespaces）。</p>
</li>
<li><p>/proc/pid/numa_maps  numa即Non Uniform Memory Access，详见（man numa）。</p>
</li>
<li><p>/proc/pid/oom_adj  调整OOM分数，OOM即Out Of Memory，发生OOM时OOM Killer根据OOM分数杀掉分数高的进程，默认值为0，会继承自父进程的设置。</p>
</li>
<li><p>/proc/pid/oom_score  OOM分数。</p>
</li>
<li><p>/proc/pid/oom_score_adj  OOM分值介于-1000到1000之间。</p>
</li>
<li><p>/proc/pid/pagemap  当前进程的虚拟内存页映射信息，需要配置CONFIG_PROC_PAGE_MONITOR。</p>
</li>
<li><p>/proc/pid/personality  进行执行域。</p>
</li>
<li><p>/proc/pid/root  链接到了当前进程的根目录。</p>
</li>
<li><p>/proc/pid/seccomp  seccomp模式下允许的系统调用只有read、write、_exit、sigreturn，Linux 2.6.23已弃用这个文件，由prctl替代。</p>
</li>
<li><p>/proc/pid/setgroups  详见（man user_namespaces）。</p>
</li>
<li><p>/proc/pid/smaps”  内存映射信息，类似于pmap命令，需要配置CONFIG_PROC_PAGE_MONITOR。</p>
</li>
<li><p>/proc/pid/stack  内核空间的函数调用堆栈，需要配置CONFIG_STACKTRACE。</p>
</li>
<li><p>/proc/pid/stat  进程状态信息，用于ps命令。</p>
</li>
<li><p>/proc/pid/statm  进程内存使用信息，以空格分隔的7个数字，从左到右分别表示程序总大小、常驻内存大小、共享内存页大小、text code、library、data + stack、dirty pages。</p>
</li>
<li><p>/proc/pid/status  可读性好的进程相关信息。</p>
</li>
<li><p>/proc/pid/syscall  系统调用相关信息，需要配置CONFIG_HAVE_ARCH_TRACEHOOK。</p>
</li>
<li><p>/proc/pid/task/  每个线程一个子目录，目录名为线程ID。</p>
</li>
<li><p>/proc/pid/timers  POSIT定时器列表，包括定时器ID、信号等信息。</p>
</li>
<li><p>/proc/pid/uid_map  用户ID映射信息，详见（man user_namespaces）。</p>
</li>
<li><p>/proc/pid/gid_map  组ID映射信息，详见（man user_namespaces）。</p>
</li>
<li><p>/proc/pid/wchan  进程休眠时内核中相应位置的符号表示，如do_wait。</p>
</li>
</ul>
<h3 id="proc-pid-maps"><a href="#proc-pid-maps" class="headerlink" title="/proc/pid/maps"></a>/proc/pid/maps</h3><h3 id="proc-pid-status"><a href="#proc-pid-status" class="headerlink" title="/proc/pid/status"></a>/proc/pid/status</h3><h3 id="proc-pid-stat"><a href="#proc-pid-stat" class="headerlink" title="/proc/pid/stat"></a>/proc/pid/stat</h3><p>关于进程的状态信息，主要是用于 ps 命令展示，每一行的含义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. pid %d 进程PID</span><br><span class="line">2. comm %s 可执行文件的文件名</span><br><span class="line">3. state %c 进程的状态,使用RSDZTW其中一个值表示.R表示正在运行,S表示因为中断休眠,D表示进程处于不可中断的睡眠, When a process will go to ‘D’ state?. Z表示僵尸进程,T表示正在被追踪或者停止,W表示现在正在进行叶交换.</span><br><span class="line">4. ppid %d 父进程PID</span><br><span class="line">5. grid %d 进程组ID</span><br><span class="line">6. session %d 进程的session id</span><br><span class="line">7. tty_nr %d 进程的控制终端</span><br><span class="line">8. tpgid %d 进程控制终端的前台进程id</span><br><span class="line">9. minflt %n 进程因为不需要从磁盘加载内存页而造成的次要故障数</span><br><span class="line">10. cminflt %u 进程等待子进程造成的次要故障数</span><br><span class="line">11. majflt %lu 进程需要从磁盘加载内存页造成的故障数</span><br><span class="line">12. cmajflt %lu 进程等待子进程造成的故障数</span><br><span class="line">13. utime %lu 进程在用户模式下被调度的时间</span><br><span class="line">14. stime %lu 进程在内核模式下被调度的时间</span><br><span class="line">15. cutime %ld 进程在用户模式下等待子进程的时间</span><br><span class="line">16. cstime %ld 进程在内核模式下等待子进程的时间</span><br><span class="line">17. nice %ld 参见 setpriority 位于19到-20之间.</span><br><span class="line">18. num_threads %ld 当前进程的线程数量</span><br><span class="line">19. vsize %lu 使用的虚拟内存</span><br><span class="line">20. rss %ld resident set szie的缩写,表示进程在实际内存中的页数,主要是包括了text,data,栈,不包括没有加载到内存中或者已经被换出去的内存大小</span><br><span class="line">21. rsslim %lu 进程rss的限制</span><br></pre></td></tr></table></figure>

<h2 id="proc-net"><a href="#proc-net" class="headerlink" title="/proc/net/"></a>/proc/net/</h2><p>网络伪文件系统相关。</p>
<ul>
<li>/proc/net/arp   包含了用于地址解析的内核ARP表的信息。</li>
<li>/proc/net/dev   dev虚拟文件系统显示网络状态的信息，包括发送和接受的数据包的数量，错误和冲突以及其他的统计信息，可通过ifconfig查看。</li>
<li>/proc/net/raw   存储的是RAW套接字表的信息。</li>
<li>/proc/net/snmp  保存的是SNMP代理的IP，ICMP以及UDP的管理信息。</li>
<li>/proc/net/tcp   保存的是系统中的TCP表的信息。</li>
<li>/proc/net/udp   保存的是系统中的UDP表的信息。</li>
<li>/proc/net/unix  显示当前系统所有的UNIX domain socket以及它们的状态信息。</li>
</ul>
<h2 id="proc-sys"><a href="#proc-sys" class="headerlink" title="/proc/sys/"></a>/proc/sys/</h2><p>系统变量相关信息</p>
<h2 id="proc-bus"><a href="#proc-bus" class="headerlink" title="/proc/bus/"></a>/proc/bus/</h2><p>已安装的总线</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>/proc/apm  高级电源管理（APM）版本信息及电池相关状态信息，通常由apm命令使用，需要配置CONFIG_APM。</li>
<li>/proc/buddyinfo  用于诊断内存碎片问题。</li>
<li>/proc/cmdline  系统启动时传递给Linux内核的参数，如lilo、grub等boot管理模块。</li>
<li>/proc/config.gz  内核编译配置选项，需要配置CONFIG_IKCONFIG_PROC。</li>
<li>/proc/crypto  内核加密API提供的加密列表。</li>
<li>/proc/cpuinfo  CPU和系统架构信息，lscpu命令使用这个文件。</li>
<li>/proc/devices  设备相关信息。</li>
<li>/proc/diskstats  每块磁盘设备的磁盘I/O统计信息列表。</li>
<li>/proc/dma  正在使用且注册的DMA通道信息列表。</li>
<li>/proc/driver/rtc  系统运行时配置。</li>
<li>/proc/execdomains  执行域列表。</li>
<li>/proc/fb  帧缓冲设备列表文件，包含帧缓冲设备的设备号和相关驱动信息，需要配置CONFIG_FB。</li>
<li>/proc/filesystems  内核支持的文件系统类型（man filesystems）。</li>
<li>/proc/fs  挂载的文件系统信息。</li>
<li>/proc/ide  用于IDE接口。</li>
<li>/proc/interrupts  每个CPU每个IO的中断信息。</li>
<li>/proc/iomem  IO内存映射信息。</li>
<li>/proc/ioports  IO端口信息。</li>
<li>/proc/kallsyms  用于动态链接和和模块绑定的符号定义。</li>
<li>/proc/kcore  系统使用的物理内存，以ELF核心文件格式存储，其文件大小为已使用的物理内存加4KB；这个文件用来检查内核数据结构的当前状态，通常由GBD调试工具使用。</li>
<li>/proc/kmsg  用来保存由内核输出的信息，dmsg命令使用这个文件。</li>
<li>/proc/kpagecount  每个物理页帧映射的次数，需要配置CONFIG_PROC_PAGE_MONITOR。</li>
<li>/proc/kpageflags  每个物理页帧的掩码，需要配置CONFIG_PROC_PAGE_MONITOR。</li>
<li>/proc/ksyms  同kallsyms。</li>
<li>/proc/loadavg  保存关于CPU和磁盘I/O的负载平均值。</li>
<li>/proc/locks  保存当前由内核锁定的文件的相关信息。</li>
<li>/proc/malloc  需要配置CONFIG_DEBUG_MALLOC。</li>
<li>/proc/mdstat  保存RAID相关的多块磁盘的当前状态信息</li>
<li>/proc/meminfo  系统内存使用统计，free命令使用了这个文件。</li>
<li>/proc/modules  系统加载的模块信息，相关命令为lsmod。</li>
<li>/proc/mounts  链接到了/self/mounts。</li>
<li>/proc/mtrr  Memory Type Range Registers。</li>
<li>/proc/partitions  分区信息。</li>
<li>/proc/pci  PCI接口设备。</li>
<li>/proc/profile  用于readprofile命令作性能分析。</li>
<li>/proc/scsi  SCSI接口设备。</li>
<li>/proc/scsi/scsi</li>
<li>/proc/scsi/[drivername]</li>
<li>/proc/self  链接到了当前进程所在的目录。</li>
<li>/proc/slabinfo  内核缓存信息，需要配置CONFIG_SLAB。</li>
<li>/proc/stat  系统信息统计。</li>
<li>/proc/swaps  交换分区及其空间利用信息。</li>
<li>/proc/sysrq-trigger  可写，触发系统调用。</li>
<li>/proc/sysvipc  包括msg、sem、shm三个文件，为System V IPC对象。</li>
<li>/proc/thread-self  链接到了当前进程下的task目录中的线程文件<code>/proc/self/task/tid</code>。</li>
<li>/proc/timer_list  还在运行着的定时器列表。</li>
<li>/proc/timer_stats  定时器状态。</li>
<li>/proc/tty  tty设备相关。</li>
<li>/proc/uptime  系统更新时间和进程空闲时间，单位是秒。</li>
<li>/proc/version  内核版本信息。</li>
<li>/proc/vmstat  虚拟内存统计信息，以键值对形式显示。</li>
<li>/proc/zoneinfo  内存区块信息，用于分析虚拟内存的行为。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/tool/gcc_warning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/tool/gcc_warning/" class="post-title-link" itemprop="url">gcc warning options</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/gcc/" itemprop="url" rel="index"><span itemprop="name">gcc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="告警开关"><a href="#告警开关" class="headerlink" title="告警开关"></a>告警开关</h2><p><code>-fsyntax-only</code>  检查代码中的语法错误，但除此之外不要做任何事情。</p>
<p><code>-w</code>  关闭所有警告消息。以<code>-W</code>开头开启特定的警告，以<code>-Wno-</code>开头关闭特定的警告。</p>
<p><code>-Werror</code>  将所有的警告当成错误进行处理。<code>-Werror=</code> 将指定的警告转换为错误。<code>-Wno-error</code>  取消编译选项-Werror。</p>
<p><code>-Wfatal-errors</code>  在发生第一个错误时中止编译。</p>
<p>具体的选项优先于不特定的选项，与命令行中的位置无关。对于相同特征的选项，最后一个生效。</p>
<h2 id="Wall"><a href="#Wall" class="headerlink" title="-Wall"></a>-Wall</h2><p>该选项相当于同时使用了下列所有的选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unused-function：遇到仅声明过但尚未定义的静态函数时发出警告。</span><br><span class="line">unused-label：遇到声明过但不使用的标号的警告。</span><br><span class="line">unused-parameter：从未用过的函数参数的警告。</span><br><span class="line">unused-variable：在本地声明但从未用过的变量的警告。</span><br><span class="line">unused-value：仅计算但从未用过的值得警告。</span><br><span class="line">Format：检查对printf和scanf等函数的调用，确认各个参数类型和格式串中的一致。</span><br><span class="line">implicit-int：警告没有规定类型的声明。</span><br><span class="line">implicit-function-：在函数在未经声明就使用时给予警告。</span><br><span class="line">char-subscripts：警告把char类型作为数组下标。这是常见错误，程序员经常忘记在某些机器上char有符号。</span><br><span class="line">missing-braces：聚合初始化两边缺少大括号。</span><br><span class="line">Parentheses：在某些情况下如果忽略了括号，编译器就发出警告。</span><br><span class="line">return-type：如果函数定义了返回类型，而默认类型是int型，编译器就发出警告。同时警告那些不带返回值的 return语句，如果他们所属的函数并非void类型。</span><br><span class="line">sequence-point：出现可疑的代码元素时，发出报警。</span><br><span class="line">Switch：如果某条switch语句的参数属于枚举类型，但是没有对应的case语句使用枚举元素，编译器就发出警告（在switch语句中使用default分支能够防止这个警告）。超出枚举范围的case语句同样会导致这个警告。</span><br><span class="line">strict-aliasing：对变量别名进行最严格的检查。</span><br><span class="line">unknown-pragmas：使用了不允许的#pragma。</span><br><span class="line">Uninitialized：在初始化之前就使用自动变量。</span><br></pre></td></tr></table></figure>

<p>但是以下警告项并不会生效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cast-align：一旦某个指针类型强制转换时，会导致目标所需的地址对齐边界扩展，编译器就发出警告。例如，某些机器上只能在2或4字节边界上访问整数，如果在这种机型上把char *强制转换成int *类型， 编译器就发出警告。</span><br><span class="line">sign-compare：将有符号类型和无符号类型数据进行比较时发出警告。</span><br><span class="line">missing-prototypes ：如果没有预先声明函数原形就定义了全局函数，编译器就发出警告。即使函数定义自身提供了函数原形也会产生这个警告。这样做的目的是检查没有在头文件中声明的全局函数。</span><br><span class="line">Packed：当结构体带有packed属性但实际并没有出现紧缩式给出警告。</span><br><span class="line">Padded：如果结构体通过充填进行对齐则给出警告。</span><br><span class="line">unreachable-code：如果发现从未执行的代码时给出警告。</span><br><span class="line">Inline：如果某函数不能内嵌（inline），无论是声明为inline或者是指定了-finline-functions 选项，编译器都将发出警告。</span><br><span class="line">disabled-optimization：当需要太长时间或过多资源而导致不能完成某项优化时给出警告。</span><br></pre></td></tr></table></figure>

<h2 id="Wextra"><a href="#Wextra" class="headerlink" title="-Wextra"></a>-Wextra</h2><p>启用一些额外警告标志。（此选项过去称为-W。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-Wclobbered  </span><br><span class="line">-Wcast-function-type  </span><br><span class="line">-Wempty-body  </span><br><span class="line">-Wignored-qualifiers</span><br><span class="line">-Wimplicit-fallthrough=3</span><br><span class="line">-Wmissing-field-initializers  </span><br><span class="line">-Wmissing-parameter-type (C only)  </span><br><span class="line">-Wold-style-declaration (C only)  </span><br><span class="line">-Woverride-init  </span><br><span class="line">-Wsign-compare (C only)</span><br><span class="line">-Wtype-limits  </span><br><span class="line">-Wuninitialized  </span><br><span class="line">-Wshift-negative-value (in C++03 and in C99 and newer)  </span><br><span class="line">-Wunused-parameter (only with -Wunused or -Wall)</span><br><span class="line">-Wunused-but-set-parameter (only with -Wunused or -Wall)</span><br></pre></td></tr></table></figure>

<h2 id="其他告警项"><a href="#其他告警项" class="headerlink" title="其他告警项"></a>其他告警项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-Wfatal-errors 发生第一个错误时中止编译</span><br><span class="line"></span><br><span class="line">-Wchkp  警告由指针界限检查器（ -fcheck-pointer-bounds ）发现的无效内存访问。</span><br><span class="line"></span><br><span class="line">-Wno-coverage-mismatch  如果使用-fprofile-use选项时反馈配置文件不匹配，则警告 。 如果在使用-fprofile-gen编译和使用-fprofile-use编译时源文件发生更改，则具有配置文件反馈的文件可能无法与源文件匹配，并且GCC无法使用配置文件反馈信息。 默认情况下，此警告已启用并被视为错误。 -Wno-coverage-mismatch可用于禁用警告或-Wno-error = coverage-mismatch可用于禁用该错误。 禁用此警告的错误可能会导致代码质量不佳，并且仅在非常小的更改情况下才有用，例如修复现有代码库的错误。 不建议完全禁用该警告。</span><br><span class="line"></span><br><span class="line">-Wno-cpp 禁止`#warning`指令发出的警告消息。（仅限于Objective-C，C ++，Objective-C ++和Fortran）</span><br><span class="line"></span><br><span class="line">-Wshadow  当一个局部变量遮盖住了另一个局部变量，或者全局变量时，给出警告。很有用的选项，建议打开。 -Wall 并不会打开此项。</span><br><span class="line"></span><br><span class="line">-Wpointer-arith  对函数指针或者void *类型的指针进行算术操作时给出警告。也很有用。 -Wall 并不会打开此项。</span><br><span class="line"></span><br><span class="line">-Wcast-qual  当强制转化丢掉了类型修饰符时给出警告。 -Wall 并不会打开此项。</span><br><span class="line"></span><br><span class="line">-Waggregate-return  如果定义或调用了返回结构体或联合体的函数，编译器就发出警告。</span><br><span class="line"></span><br><span class="line">-Winline  无论是声明为 inline 或者是指定了-finline-functions 选项，如果某函数不能内联，编译器都将发出警告。如果你的代码含有很多 inline 函数的话，这是很有用的选项。</span><br><span class="line"></span><br><span class="line">-Wundef  当一个没有定义的符号出现在`#if`中时，给出警告。</span><br><span class="line"></span><br><span class="line">-Wredundant-decls  如果在同一个可见域内某定义多次声明，编译器就发出警告，即使这些重复声明有效并且毫无差别。</span><br><span class="line"></span><br><span class="line">-Wstrict-prototypes  如果函数的声明或定义没有指出参数类型，编译器就发出警告。很有用的警告。</span><br><span class="line"></span><br><span class="line">-Wctor-dtor-privacy （C++ only）当一个类没有用时给出警告。因为构造函数和析构函数会被当作私有的。</span><br><span class="line"></span><br><span class="line">-Wnon-virtual-dtor （C++ only）当一个类有多态性，而又没有虚析构函数时，发出警告。-Wall会开启这个选项。</span><br><span class="line"></span><br><span class="line">-Wreorder （C++ only）如果代码中的成员变量的初始化顺序和它们实际执行时初始化顺序不一致，给出警告。</span><br><span class="line"></span><br><span class="line">-Wno-deprecated（C++ only）使用过时的特性时不要给出警告。</span><br><span class="line"></span><br><span class="line">-Woverloaded-virtual（C++ only）如果函数的声明隐藏住了基类的虚函数，就给出警告。</span><br><span class="line"></span><br><span class="line">-Winit-self (C, C++, Objective-C and Objective-C++ only)警告使用自己初始化的未初始化变量。 请注意，此选项只能与-Wuninitialized选项一起使用。</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/c/time/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/c/time/" class="post-title-link" itemprop="url">linux time function</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 20:18:38" itemprop="dateModified" datetime="2022-06-08T20:18:38+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">c语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p><strong>GMT</strong>格林威治时间(Greenwich Mean Time)。根据地球的自转和公转来计算时间，就是太阳横穿格林威治子午线（本初子午线）时的时间，也是0时区的标准时间，是老的时间计量标准。格林威治子午线是穿过英国伦敦格林威治天文台子午仪中心的一条经线，作为零度参考线。</p>
<p>UT根据原子钟计算出来的时间。</p>
<p><strong>UTC</strong>协调世界时(Coordinated Universal Time)。因为地球自转越来越慢，每年都会比前一年多出零点几秒，为了让基于原子钟的世界时和基于天文学的格林威治时间相差不至于太大，每隔几年协调世界时组织都会给世界时+1秒，并将所得到的时间称为UTC，这就是现在使用的世界标准时间。协调世界时不与任何地区位置相关，<strong>本地时间</strong>是 UTC+TimeZone，GMT = UTC+0。</p>
<p>北京时间(CST)所属时区: UTC/GMT +8。</p>
<p>Unix<strong>时间戳</strong>是从1970-01-01 00:00:00 +0000至今的秒数，不考虑闰秒。</p>
<p>世界时区的划分以本初子午线（穿过英国伦敦格林威治天文台子午仪中心的一条经线）为标准，向东12个时区，向西12个时区，子午线所在区为0时区，经度每向东或者向西间隔15°，就划分一个时区，共有24个时区，相邻时区的时间相差一个小时。</p>
<p>夏令时DST(Daylight Saving Time)，它是为节约能源而人为规定地方时间的制度。一般在天亮早的夏季人为将时间提前一小时。在施行夏令时的国家，一年里面有一天只有23小时（夏令时开始那一天），有一天有25小时（夏令时结束那一天），其他时间每天都是24小时。</p>
<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><h3 id="time"><a href="#time" class="headerlink" title="time()"></a>time()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">time_t</span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *tloc)</span>;</span><br></pre></td></tr></table></figure>

<p>返回从UTC至今所经过的秒数，如果tloc非空，会将返回值也存到该指针。</p>
<h3 id="ftime"><a href="#ftime" class="headerlink" title="ftime()"></a>ftime()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timeb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeb</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>         time;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> millitm;   <span class="comment">// ms</span></span><br><span class="line">    <span class="type">short</span>          timezonel; <span class="comment">// 为目前时区和Greenwich相差的时间，单位为分钟，东区为负</span></span><br><span class="line">    <span class="type">short</span>          dstflag;   <span class="comment">// 非0代表启用夏时制</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ftime</span><span class="params">(<span class="keyword">struct</span> timeb *tp)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="gettimeofday"><a href="#gettimeofday" class="headerlink" title="gettimeofday()"></a>gettimeofday()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>      tv_sec;     <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;    <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tz_minuteswest;     <span class="comment">/* minutes west of Greenwich */</span></span><br><span class="line">    <span class="type">int</span> tz_dsttime;         <span class="comment">/* type of DST correction */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*tz_dsttime 所代表的状态如下:*/</span> </span><br><span class="line">   DST_NONE     <span class="comment">/* not on DST */</span></span><br><span class="line">   DST_USA      <span class="comment">/* USA style DST */</span></span><br><span class="line">   DST_AUST     <span class="comment">/* Australian style DST */</span></span><br><span class="line">   DST_WET      <span class="comment">/* Western European DST */</span></span><br><span class="line">   DST_MET      <span class="comment">/* Middle European DST */</span></span><br><span class="line">   DST_EET      <span class="comment">/* Eastern European DST */</span></span><br><span class="line">   DST_CAN      <span class="comment">/* Canada */</span></span><br><span class="line">   DST_GB       <span class="comment">/* Great Britain and Eire */</span></span><br><span class="line">   DST_RUM      <span class="comment">/* Romania */</span></span><br><span class="line">   DST_TUR      <span class="comment">/* Turkey */</span></span><br><span class="line">   DST_AUSTALT  <span class="comment">/* Australian style with shift in 1986 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="clock-gettime"><a href="#clock-gettime" class="headerlink" title="clock_gettime()"></a>clock_gettime()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>   tv_sec;        <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span>     tv_nsec;       <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">(<span class="type">clockid_t</span> clk_id, <span class="keyword">struct</span> timespec *tp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_getres</span><span class="params">(<span class="type">clockid_t</span> clk_id, <span class="keyword">struct</span> timespec *res)</span>;</span><br></pre></td></tr></table></figure>

<p>clk_id 用于指定计时时钟的类型:</p>
<ul>
<li><p><code>CLOCK_REALTIME</code>/<code>CLOCK_REALTIME_COARSE</code> 系统实时时间，即从UTC开始计时的秒数，随系统实时时间改变而改变，包括通过系统函数手动调整系统时间，例如 settime()、settimeofday()，或者通过 adjtime()、adjtimex() 或者 NTP 调整时间。</p>
</li>
<li><p><code>CLOCK_MONOTONIC</code>/<code>CLOCK_MONOTONIC_COARSE</code> 从系统启动开始计时，不受系统时间被用户改变的影响，但会受像 adjtime() 或者 NTP 之类渐进调整的影响。</p>
</li>
<li><p><code>CLOCK_MONOTONIC_RAW</code> 与上述的 CLOCK_MONOTONIC 相同，只是不会受 adjtime() 以及 NTP 的影响。</p>
</li>
<li><p><code>CLOCK_PROCESS_CPUTIME_ID</code> 本进程到当前代码系统 CPU 花费的时间。</p>
</li>
<li><p><code>CLOCK_THREAD_CPUTIME_ID</code> 本线程到当前代码系统 CPU 花费的时间。</p>
</li>
</ul>
<h3 id="clock"><a href="#clock" class="headerlink" title="clock()"></a>clock()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回程序执行使用的时钟时间*/</span></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">clock</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h2><h3 id="ctime-asctime"><a href="#ctime-asctime" class="headerlink" title="ctime asctime"></a>ctime asctime</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转换为本地时间，使用标准格式 */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将时间格式转为字符串，不修改时区，使用标准格式 */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime_r</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm, <span class="type">char</span> *buf)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="mktime"><a href="#mktime" class="headerlink" title="mktime()"></a>mktime()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;         <span class="comment">/* seconds [0, 59] */</span></span><br><span class="line">    <span class="type">int</span> tm_min;         <span class="comment">/* minutes [0, 59] */</span></span><br><span class="line">    <span class="type">int</span> tm_hour;        <span class="comment">/* hours [0, 23] */</span></span><br><span class="line">    <span class="type">int</span> tm_mday;        <span class="comment">/* day of the month [1, 31] */</span></span><br><span class="line">    <span class="type">int</span> tm_mon;         <span class="comment">/* month [0, 11] */</span></span><br><span class="line">    <span class="type">int</span> tm_year;        <span class="comment">/* year now.year - 1900 */</span></span><br><span class="line">    <span class="type">int</span> tm_wday;        <span class="comment">/* day of the week, [0, 6] 0-&gt;sunday */</span></span><br><span class="line">    <span class="type">int</span> tm_yday;        <span class="comment">/* day in the year [0, 365] */</span></span><br><span class="line">    <span class="type">int</span> tm_isdst;       <span class="comment">/* daylight saving time */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure>

<p>tm_isdst是夏令时：</p>
<ul>
<li>0 完全不考虑夏令时的问题，直接将日历时间转换为秒数；</li>
<li>1 考虑夏令时。</li>
<li>-1 自动根据时区信息进行判断。</li>
</ul>
<p>注意在使用前，需要将 struct tm 结构体清空，否则不需要设置的字段 (如 tm_isdst ) 会有脏数据。</p>
<p>实际上程序比较怕时间回退，那么关于夏令时比较坑的是，夏令时的停止，此时时钟会向后回拨一次，也就是说，同一个小时的时间点出现了两次。</p>
<p>例如 CET (欧洲中部时间) 在 2016-10-30 02:59:59 下一秒会跳转到 2016-10-30 02:00:00 ，也就是说 02:00:00 到 02:59:59 这一个小时的时间窗出现了两次。</p>
<p>那么，此时，如果要获取到中间的时间窗，在使用 mktime() 时就需要手动配置其中的 tm_isdst 字段。</p>
<p>mktime() 会忽略 tm_wday 以及 tm_yday 字段，会使用 tm_isdst 判断是否采用夏令时，同时会根据其它字段来修改 tm_wday tm_yday 字段，同时其它字段如果超过了范围则会修正。</p>
<h3 id="gmtime-localtime"><a href="#gmtime-localtime" class="headerlink" title="gmtime() localtime()"></a>gmtime() localtime()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将时间戳转换为GMT时区的标准时间 */</span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将时间戳转换为本地时区的时间格式 */</span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="strftime-strptime"><a href="#strftime-strptime" class="headerlink" title="strftime() strptime()"></a>strftime() strptime()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将时间按格式化字符串转换为字符串 */</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> max, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strptime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *format, <span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">%a 星期几的简写</span><br><span class="line">%A 星期几的全称</span><br><span class="line">%b 月份的简写</span><br><span class="line">%B 月份的全称</span><br><span class="line">%c 标准的日期的时间串</span><br><span class="line">%C 年份的前两位数字</span><br><span class="line">%d 十进制表示的每月的第几天</span><br><span class="line">%D 月/天/年</span><br><span class="line">%e 在两字符域中，十进制表示的每月的第几天</span><br><span class="line">%F 年-月-日</span><br><span class="line">%g 年份的后两位数字，使用基于周的年</span><br><span class="line">%G 年份，使用基于周的年</span><br><span class="line">%h 简写的月份名</span><br><span class="line">%H 24小时制的小时</span><br><span class="line">%I 12小时制的小时</span><br><span class="line">%j 十进制表示的每年的第几天</span><br><span class="line">%m 十进制表示的月份</span><br><span class="line">%M 十时制表示的分钟数</span><br><span class="line">%n 新行符</span><br><span class="line">%p 本地的AM或PM的等价显示</span><br><span class="line">%r 12小时的时间</span><br><span class="line">%R 显示小时和分钟：hh:mm</span><br><span class="line">%S 十进制的秒数</span><br><span class="line">%t 水平制表符</span><br><span class="line">%T 显示时分秒：hh:mm:ss</span><br><span class="line">%u 每周的第几天，星期一为第一天 （值从1到7，星期一为1）</span><br><span class="line">%U 第年的第几周，把星期日作为第一天（值从0到53）</span><br><span class="line">%V 每年的第几周，使用基于周的年</span><br><span class="line">%w 十进制表示的星期几（值从0到6，星期天为0）</span><br><span class="line">%W 每年的第几周，把星期一做为第一天（值从0到53）</span><br><span class="line">%x 标准的日期串</span><br><span class="line">%X 标准的时间串</span><br><span class="line">%y 不带世纪的十进制年份（值从0到99）</span><br><span class="line">%Y 带世纪部分的十制年份</span><br><span class="line">%z，%Z 时区名称，如果不能得到时区名称则返回空字符。</span><br><span class="line">%% 百分号</span><br></pre></td></tr></table></figure>

<p><img src="/images/cpp/time_function.bmp" alt="时间转换函数"></p>
<h2 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*返回 time1 和 time2 之间相差的秒数 (time1-time2)*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">difftime</span><span class="params">(<span class="type">time_t</span> time1, <span class="type">time_t</span> time2)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_settime</span><span class="params">(<span class="type">clockid_t</span> clk_id, <span class="type">const</span> <span class="keyword">struct</span> timespec *tp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">settimeofday</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timeval *tv, <span class="type">const</span> <span class="keyword">struct</span> timezone *tz)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置系统的时间，不过需要超级用户的权限*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stime</span><span class="params">(<span class="type">time_t</span> *t)</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/tool/gcc_options/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/tool/gcc_options/" class="post-title-link" itemprop="url">gcc compile and link options</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 16:05:44" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 17:21:31" itemprop="dateModified" datetime="2022-06-08T17:21:31+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/gcc/" itemprop="url" rel="index"><span itemprop="name">gcc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">--help</span><br><span class="line">--target-help</span><br><span class="line">显示 gcc 帮助说明。‘target-help’是显示目标机器特定的命令行选项。</span><br><span class="line"></span><br><span class="line">--version</span><br><span class="line">显示 gcc 版本号和版权信息。</span><br><span class="line"></span><br><span class="line">-wall</span><br><span class="line">显示警告信息；</span><br><span class="line"></span><br><span class="line">-o outfile</span><br><span class="line">输出到指定的文件。</span><br><span class="line"></span><br><span class="line">-x language</span><br><span class="line">指明使用的编程语言，包括：c c++ assembler none 。 ‘none’意味着恢复默认行为，即根据文件的扩展名猜测源文件的语言。</span><br><span class="line"></span><br><span class="line">-v</span><br><span class="line">打印较多信息，显示编译器调用的程序。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-#</span><span class="language-bash"><span class="comment">##</span></span></span><br><span class="line">与 -v 类似，但选项被引号括住，并且不执行命令。</span><br><span class="line"></span><br><span class="line">-E</span><br><span class="line">仅作预处理，不进行编译、汇编和链接。</span><br><span class="line"></span><br><span class="line">-S</span><br><span class="line">仅编译到汇编语言，不进行汇编和链接。</span><br><span class="line"></span><br><span class="line">-c</span><br><span class="line">仅编译、汇编到目标代码，不进行链接。</span><br><span class="line"></span><br><span class="line">-C</span><br><span class="line">告诉预处理器不要丢弃注释，配合-E选项使用。</span><br><span class="line"></span><br><span class="line">-P</span><br><span class="line">告诉预处理器不要产生#line命令，配合-E选项使用。</span><br><span class="line"></span><br><span class="line">-pipe</span><br><span class="line">使用管道代替临时文件。</span><br><span class="line"></span><br><span class="line">-combine</span><br><span class="line">将多个源文件一次性传递给汇编器。</span><br><span class="line"></span><br><span class="line">-fsanitize=address</span><br><span class="line">gcc从4.8版本起，集成了Address Sanitizer工具，可以用来检查内存访问的错误，编译时指定`-fsanitize=address -g`，可以检测内存泄漏、堆栈和全局内存越界访问、free后继续使用、局部内存被外层使用和Initialization order bugs问题。</span><br></pre></td></tr></table></figure>

<h2 id="链接选项"><a href="#链接选项" class="headerlink" title="链接选项"></a>链接选项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-l library</span><br><span class="line">-llibrary</span><br><span class="line">进行链接时搜索名为library的库。</span><br><span class="line"></span><br><span class="line">-Ldir</span><br><span class="line">把dir 加入到搜索库文件的路径列表中。</span><br><span class="line"></span><br><span class="line">-Idir</span><br><span class="line">把dir 加入到搜索头文件的路径列表中。</span><br><span class="line"></span><br><span class="line">-Dname</span><br><span class="line">预定义一个名为name 的宏，值为1。</span><br><span class="line"></span><br><span class="line">-Dname=definition</span><br><span class="line">预定义名为name ，值为definition 的宏。</span><br><span class="line"></span><br><span class="line">-ggdb</span><br><span class="line">-ggdblevel</span><br><span class="line">为调试器 gdb 生成调试信息。level 可以为1，2，3，默认值为2。</span><br><span class="line"></span><br><span class="line">-g</span><br><span class="line">-glevel</span><br><span class="line">生成操作系统本地格式的调试信息，level 取值同上。</span><br><span class="line"></span><br><span class="line">-s</span><br><span class="line">去除可执行文件中的符号表和重定位信息。用于减小可执行文件的大小。</span><br><span class="line"></span><br><span class="line">-static</span><br><span class="line">禁止使用动态库</span><br><span class="line"></span><br><span class="line">-share</span><br><span class="line">尽量使用动态库</span><br><span class="line"></span><br><span class="line">-nostdlib</span><br><span class="line">不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器。</span><br><span class="line"></span><br><span class="line">-rdynamic</span><br><span class="line">指示连接器把所有符号都添加到动态符号表（.dynsym）里，以便那些使用符号表的函数使用，如dlopen() 或 backtrace()。</span><br></pre></td></tr></table></figure>

<h2 id="优化项"><a href="#优化项" class="headerlink" title="优化项"></a>优化项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-O0 禁止编译器进行优化。默认为此项。</span><br><span class="line">-O1 尝试优化编译时间和可执行文件大小。</span><br><span class="line"></span><br><span class="line">-O2 更多的优化，会尝试几乎全部的优化功能，但不会进行“空间换时间”的优化方法。</span><br><span class="line"></span><br><span class="line">-O3 在 -O2 的基础上再打开一些优化选项：-finline-functions， -funswitch-loops 和 -fgcse-after-reload。</span><br><span class="line"></span><br><span class="line">-Os 对生成文件大小进行优化。它会打开 -O2 开的全部选项，除了会那些增加文件大小的。</span><br></pre></td></tr></table></figure>

<h2 id="指定标准"><a href="#指定标准" class="headerlink" title="指定标准"></a>指定标准</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-ansi 支持符合ANSI标准的C程序。这样就会关闭GNU C中某些不兼容ANSI C的特性。</span><br><span class="line"></span><br><span class="line">-std=c89 指明使用标准 ISO C90 作为标准来编译程序。</span><br><span class="line"></span><br><span class="line">-std=c99 指明使用标准 ISO C99 作为标准来编译程序。</span><br><span class="line"></span><br><span class="line">-std=c++98 指明使用标准 C++98 作为标准来编译程序。</span><br><span class="line"></span><br><span class="line">-std=gnu9x 使用 ISO C99 再加上 GNU 的一些扩展。</span><br><span class="line"></span><br><span class="line">-fno-asm 不把asm, inline或typeof当作关键字，因此这些词可以用做标识符。用 __asm__， __inline__和__typeof__能够替代它们。 `-ansi&#x27; 隐含声明了`-fno-asm&#x27;。</span><br><span class="line"></span><br><span class="line">-fgnu89-inline 告诉编译器在 C99 模式下看到 inline 函数时使用传统的 GNU 句法。</span><br></pre></td></tr></table></figure>

<h2 id="C选项"><a href="#C选项" class="headerlink" title="C选项"></a>C选项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-pedantic</span><br><span class="line">以ANSI/ISO C标准列出的所有警告</span><br><span class="line"></span><br><span class="line">-fsigned-char</span><br><span class="line">把char定义为有符号类型，如同signed char。</span><br><span class="line"></span><br><span class="line">-funsigned-char</span><br><span class="line">把char定义为无符号类型，如同unsigned char。</span><br><span class="line"></span><br><span class="line">-traditional</span><br><span class="line">尝试支持传统C编译器的某些方面。详见GNU C手册。</span><br><span class="line"></span><br><span class="line">-fno-builtin</span><br><span class="line">-fno-builtin-function</span><br><span class="line">不接受没有 __builtin_ 前缀的函数作为内建函数。</span><br><span class="line"></span><br><span class="line">-trigraphs</span><br><span class="line">支持ANSI C的三联符（ trigraphs）。-ansi选项隐含声明了此选项。</span><br><span class="line"></span><br><span class="line">-fsigned-bitfields</span><br><span class="line">-funsigned-bitfields</span><br><span class="line">如果没有明确声明signed或unsigned修饰符，这些选项用来定义有符号位域或无符号位域。缺省情况下，位域是有符号的，因为它们继承的基本整数类型，如int，是有符号数。</span><br><span class="line"></span><br><span class="line">-fno-strict-aliasing</span><br><span class="line">启用严格别名规则，“-fno-strict-aliasing”表示禁用严格别名规则，当gcc的编译优化参数为“-O2”、“-O3”和“-Os”时，默认会打开“-fstrict-aliasing”。</span><br></pre></td></tr></table></figure>

<h2 id="C-选项"><a href="#C-选项" class="headerlink" title="C++选项"></a>C++选项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-fsyntax-only</span><br><span class="line">检查代码中的语法错误，但除此之外不要做任何事情。</span><br><span class="line"></span><br><span class="line">-ffor-scope</span><br><span class="line">从头开始执行程序，也允许进行重定向。</span><br><span class="line"></span><br><span class="line">-fno-rtti</span><br><span class="line">关闭对 dynamic_cast 和 typeid 的支持。如果你不需要这些功能，关闭它会节省一些空间。</span><br></pre></td></tr></table></figure>

<h2 id="机器选项"><a href="#机器选项" class="headerlink" title="机器选项"></a>机器选项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-mtune=cpu-type</span><br><span class="line">为指定类型的 CPU 生成代码。cpu-type 可以是：i386，i486，i586，pentium，i686，pentium4 等等。</span><br><span class="line"></span><br><span class="line">-msse</span><br><span class="line">-msse2</span><br><span class="line">-mmmx</span><br><span class="line">-mno-sse</span><br><span class="line">-mno-sse2</span><br><span class="line">-mno-mmx</span><br><span class="line">使用或者不使用MMX，SSE，SSE2指令。</span><br><span class="line"></span><br><span class="line">-m32</span><br><span class="line">-m64</span><br><span class="line">生成32位/64位机器上的代码。</span><br><span class="line"></span><br><span class="line">-mpush-args</span><br><span class="line">-mno-push-args</span><br><span class="line">（不）使用 push 指令来进行存储参数。默认是使用。</span><br><span class="line"></span><br><span class="line">-mregparm=num</span><br><span class="line">当传递整数参数时，控制所使用寄存器的个数。</span><br></pre></td></tr></table></figure>

<h2 id="依赖文件"><a href="#依赖文件" class="headerlink" title="依赖文件"></a>依赖文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-M</span><br><span class="line">生成文件的依赖关系，依赖项是源文件中引用的所有头文件，同时也把一些标准库的头文件包含了进来。</span><br><span class="line"></span><br><span class="line">-MM</span><br><span class="line">生成文件的依赖关系，和 -M 类似，但不包含标准库的头文件。</span><br><span class="line"></span><br><span class="line">-MG</span><br><span class="line">要求把缺失的头文件按存在对待，并且假定他们和源文件在同一目录下，必须和`-M`选项一起用。</span><br><span class="line"></span><br><span class="line">-MF [file]</span><br><span class="line">当使用了-M或-MM选项时，则把依赖关系写入名为file的文件中。若同时也使用了-MD或-MMD,-MF将覆写输出的依赖文件的名称 。</span><br><span class="line"></span><br><span class="line">-MD</span><br><span class="line">等同于 -M -MF file，但是默认关闭了 -E 选项。其输出的文件名是基于 -o 选项，若给定了 -o 选项，则输出的文件名是 -o 指定的文件名，并添加 .d 后缀，若没有给定，则输入的文件名作为输出的文件名，并添加 .d 后缀，同时继续指定的编译工作。</span><br><span class="line"></span><br><span class="line">-MMD</span><br><span class="line">类似于-MD”，但是输出的依赖文件中，不包含标准头文件。</span><br><span class="line"></span><br><span class="line">-MP</span><br><span class="line">生成的依赖文件里面，依赖规则中的所有 .h 依赖项都会在该文件中生成一个伪目标，其不依赖任何其他依赖项。该伪规则将避免删除了对应的头文件而没有更新Makefile去匹配新的依赖关系而导致 make 出错的情况出现。</span><br><span class="line"></span><br><span class="line">-MT Target</span><br><span class="line">在生成的依赖文件中，指定依赖规则中的目标。</span><br></pre></td></tr></table></figure>

<h2 id="其他项"><a href="#其他项" class="headerlink" title="其他项"></a>其他项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-finline-functions</span><br><span class="line">把所有简单的函数内联进调用者。编译器会探索式地决定哪些函数足够简单，值得做这种内联。</span><br><span class="line"></span><br><span class="line">-fstrict-aliasing</span><br><span class="line">施加最强的别名规则（aliasing rules）。</span><br><span class="line"></span><br><span class="line">-fPIC</span><br><span class="line">告诉编译器产生与位置无关代码，在产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。如果不加-fPIC，则加载.so文件的代码段时，代码段引用的数据对象需要重定位， 重定位会修改代码段的内容，这就造成每个使用这个.so文件代码段的进程在内核里都会生成这个.so文件代码段的拷贝。</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">202</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
