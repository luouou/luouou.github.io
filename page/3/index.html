<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="nullptr">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ubun2">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>nullptr</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nullptr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吾生也有涯 而知也无涯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/kernel/mmu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/kernel/mmu/" class="post-title-link" itemprop="url">内存管理单元MMU</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-01 18:57:32" itemprop="dateCreated datePublished" datetime="2023-03-01T18:57:32+08:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内存管理单元(MMU)的作用是控制和管理多个进程，使之能够安全的共享主内存区域，为各进程实现虚拟地址和物理地址转换、内存访问权限保护等功能，这将使得操作系统能单独为系统的每个用户进程分配独立的内存空间并保证用户空间不能访问内核空间的地址。</p>
<p>在 32 位系统上，Linux 内核将 4G 空间分为 1G 内核空间(3<del>4G)和 3G(0</del>3G)用户空间，通过内存管理，每个进程都可以使用 3G 的用户空间。</p>
<p><img src="/images/kernel/kernel/mmu.png" alt="mmu"></p>
<h2 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h2><p><strong>逻辑地址</strong>是由程式产生的和段相关的偏移地址部分。机器语言指令中出现的内存地址，都是逻辑地址。编译器编译程序时，会为程序生成代码段和数据段，然后将所有代码放到代码段中，将所有数据放到数据段中。最后程序中的每句代码和每条数据都会有自己的逻辑地址。</p>
<p><strong>线性地址</strong>是逻辑地址到物理地址变换之间的中间物。段中的偏移地址，加上段基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址能再变换成物理地址。</p>
<p>CPU加载程序后，会为程序分配代码段内存和数据段内存，代码段内存的基址保存在CS中，数据段内存的基址保存在DS中。</p>
<p><strong>物理地址</strong>是CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果没有启用分页机制，物理地址等于线性地址。</p>
<p><strong>虚拟地址与物理地址转化</strong></p>
<p>要将一个逻辑地址转换为物理地址，需要两步：首先利用段式内存管理单元将逻辑地址转换成线性地址，再利用页式内存管理单元，把线性地址转换为物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">phys_addr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*内核虚拟地址转化为物理地址*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">phys_addr_t</span> <span class="title function_">virt_to_phys</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __virt_to_phys((<span class="type">unsigned</span> <span class="type">long</span>)(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*物理地址转化为内核虚拟地址*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">phys_to_virt</span><span class="params">(<span class="type">phys_addr_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)__phys_to_virt(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h2><p>因为intel的CPU有20位的地址总线，而寄存器16位，要寻址2^20^=1M的内存空间，只能采用分段管理。线性地址 = 段基址 * 16 + 逻辑地址</p>
<h2 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h2><p>CPU的页式内存管理单元负责把线性地址转换为物理地址。从管理和效率的角度出发，线性地址被分为固定长度单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，用4KB为一个页来划分，整个线性地址就被划分为共有2^20^个页的数组，我们称之为页目录。目录中的每一个目录项，就是对应的页的地址。这个数组有2^20^个成员，每个成员是一个地址（32位机，一个地址4字节），那么要表示这个数组，就要4MB的内存空间。为了节省空间，引入二级管理模式来组织分页单元。</p>
<p><img src="/images/kernel/kernel/mmu_page.jpg" alt="img"></p>
<p><strong>每个进程都有其独立的虚似内存，拥有惟一的页目录和页表</strong>，它的地址放在CPU的cr3寄存器中，是进行地址转换的开始点。每一个32位的线性地址被划分为三部分：页目录索引(10位)、页表索引(10位)、偏移(12位) 。依据以下步骤进行转换：</p>
<ol>
<li><p>从cr3中取出进程的页目录地址。</p>
</li>
<li><p>根据线性地址的页目录索引，找到页表地址。</p>
</li>
<li><p>根据线性地址的页表索引，在页表中找到页的起始地址。</p>
</li>
<li><p>将页的起始地址与线性地址中的偏移相加。</p>
</li>
</ol>
<p>在二级管理模式中，页目录共有2^10^项，每项有2^10^个页表，每个页中可寻址2^12^个字节，2^10^ * 2^10^ * 2^12^ = 2^32^ = 4GB。能够表示4G的地址。同时页目录项和页表项共占空间 (2^10 * 4 + 2 ^10 *4) = 8KB，节省了空间。</p>
<p><strong>Linux的页式内存管理</strong></p>
<p>有些CPU，还有三级，甚至四级架构，Linux为了在更高层次提供抽像，为每个CPU提供统一的界面。提供了一个四层页管理架构，来兼容这些二级、三级、四级管理架构的CPU。这四级分别为： 页全局目录PGD、页上级目录PUD、页中间目录PMD、页表PT。 整个转换依据硬件转换原理，多了二次数组的索引。</p>
<p><img src="/images/kernel/kernel/mmu_page2.jpg" alt="img"></p>
<p>逻辑地址、线性地址和物理地址之间的变换过程如下图所示：</p>
<p><img src="/images/kernel/kernel/mem_t.jpg" alt="虚拟地址、线性地址和物理地址的转换"></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>Linux采用虚拟内存管理技术，使得每个进程都有独立的进程地址空间，Linux将4GB的虚拟内存空间分成两个部分：0 ~ 3GB属于用户空间，3 ~ 4GB 属于内核空间。用户进程只能访问用户空间，只能通过系统调用访问内核空间。</p>
<p><img src="/images/kernel/kernel/user_space.png" alt="img"></p>
<p>用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。</p>
<p>内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。</p>
<p>进程 fork(),execve(),malloc()等操作分配的内存仅仅是虚拟内存。只有当进程真正去访问地址时，才会产生缺页异常，内核才会为进程分配物理页，并建立对应的页表。</p>
<h2 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h2><p>ARM处理器分为7种工作模式:</p>
<ul>
<li>用户模式(usr)：大多数的应用程序运行在用户模式下,当处理器运行在用户模式下时,某些被保护的系统资源是不能被访问的。</li>
<li>快速中断模式(fiq)：用于高速数据传输或通道处理。</li>
<li>外部中断模式(irq)：用于通用的中断处理。</li>
<li>管理模式(svc)：操作系统使用的保护模式。</li>
<li>数据访问终止模式(abt)：当数据或指令预取终止时进入该模式,可用于虚拟存储及存储保护。</li>
<li>系统模式(sys)：运行具有特权的操作系统任务。</li>
<li>未定义指令中止模式(und)：当未定义的指令执行时进入该模式,可用于支持硬件协处理器的软件仿真。</li>
</ul>
<p>Linux为了保护内核的安全，只使用处理器的2个模式，把系统分成了2部分。内核可进行任何操作，特权指令只能在内核态使用，从而起到保护作用。而应用程序则被禁止对硬件的直接访问和对内存的未授权访问。内核空间和用户空间使用不同的地址空间。用户空间只能通过系统调用和硬件中断转移到内核空间。</p>
<p>Linux 中 1GB 的内核地址空间又被划分为物理内存映射区、虚拟内存分配区、高端页面映射区、专用页面映射区和系统保留映射区这几个区域。</p>
<p>物理内存映射区是从3G开始最896MB的线性空间，物理内存顺序映射在这个区域中，虚拟地址 = 3G + 物理地址。</p>
<p>动态内存映射区由vmalloc()分配，其线性空间连续，但物理空间不一定连续，可能处于低端内存，也可能处于高端内存。</p>
<p>超过直接映射区896MB的那部分内存称为高端内存，内核在存取高端内存时必须将它们映射到高端页面映射区。内核空间最顶部 FIXADDR_TOP~4GB 的区域作为保留区。</p>
<p>内核空间与用户空间的内存不能直接互访，必需借助函数 <code>copy_from_user()</code>完成用户空间到内核空间的拷贝，以及<code>copy_to_user()</code>完成内核空间到用户空间的拷贝。如果要复制的内存是简单类型，如char、int、long等，则可以使用<code>put_user()</code>和<code>get_user()</code>。宏__user 是一个指向用户空间地址的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __user  __attribute__((noderef, address_space(1)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> __user *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line"></span><br><span class="line">put_user(val, <span class="type">void</span> __user *ptr); <span class="comment">/* 内核→用户 */</span></span><br><span class="line">get_user(val, <span class="type">void</span> __user *ptr); <span class="comment">/* 用户→内核 */</span></span><br></pre></td></tr></table></figure>

<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *objp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">kzalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">return</span> kmalloc(size, flags | __GFP_ZERO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kmalloc在物理内存映射区域申请一个连续存储空间，保留内存原有的数据，不清零。分配的内存最小32Byte，最大128KB。flags参数：</p>
<ul>
<li>GFP_ATOMIC  原子性分配内存，分配内存的过程不会被高优先级进程或中断打断。若不存在空闲页，则不等待，直接返回。</li>
<li>GFP_KERNEL  在内核空间的进程中申请内存，若不存在空闲页会引起阻塞，因此不能在中断上下文或持有自旋锁时使用。</li>
<li>GFP_DMA  给DMA控制器分配内存（DMA要求分配虚拟地址和物理地址连续）。</li>
</ul>
<p>kzalloc() 会对申请到的内存内容清零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>

<p>vmalloc() 能在高端内存区分配，用来分配虚拟地址空间连续，而物理地址不一定连续的内存。常用于申请大内存空间。因为要建立新的页表，将不连续的物理内存映射成连续的虚拟内存，所以开销比较大。分配内存时则可能产生阻塞，因此不能从中断上下文调用。</p>
<h2 id="I-O端口"><a href="#I-O端口" class="headerlink" title="I/O端口"></a>I/O端口</h2><p>设备通常会提供一组寄存器来用于控制设备、读写设备和获取设备状态，即控制寄存器、数据寄存器和状态寄存器。这些寄存器可能位于 I/O 空间，也可能位于内存空间。当位于 I/O 空间时，通常被称为 I/O 端口，端口号标识了外设的寄存器地址。位于内存空间时，对应的内存空间被称为 I/O 内存。内存空间是必须的，而 I/O 空间是可选的。</p>
<p>I/O 端口访问的一种途径是直接使用 I/O 端口操作函数，在设备打开或驱动模块被加载时申请<br>I/O 端口区域，之后使用 inb()、outb()等进行端口访问，最后在设备关闭或驱动被卸载时释放 I/O<br>端口范围。</p>
<img src=".img/mem/io_port.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">request_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">release_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>request_region()函数向内核申请n个端口，这些端口从start开始，name 参数为设备的名称。如果返回NULL，则意味着申请端口失败。可以用来检查申请的资源是否可用，如果申请成功，则将其标志为已经使用，其他驱动再申请该资源时就会失败。</p>
<p>release_region()函数用来释放申请的IO资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读写字节端口(8 位宽)*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">inb</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte, <span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写字端口(16 位宽)*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">inw</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outw</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> word, <span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写长字端口(32 位宽)*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">inl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> longword, <span class="type">unsigned</span> <span class="type">long</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写一串字节*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insb</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsb</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写一串字*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insw</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsw</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读写一串长字*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><code>/proc/ioports</code>显示使用request_region( )分配的IO端口的情况。</p>
<h2 id="I-O内存"><a href="#I-O内存" class="headerlink" title="I/O内存"></a>I/O内存</h2><p>I/O 内存的访问步骤：首先是调用 request_mem_region()申请资源，接着将寄存器地址通过 ioremap()映射到内核空间虚拟地址，之后就可以通过 Linux 设备访问编程接口访问这些设备的寄存器了。访问完成后，应对 ioremap()申请的虚拟地址进行释放，并释放 release_mem_<br>region()申请的 I/O 内存资源。</p>
<p><img src="/images/kernel/mem/io_mem.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">request_mem_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">release_mem_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __iomem *<span class="title function_">ioport_map</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> port, <span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioport_unmap</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __iomem *<span class="title function_">ioremap</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> physaddr, <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">void</span> __iomem * <span class="title function_">ioremap_nocache</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iounmap</span><span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span>;</span><br></pre></td></tr></table></figure>

<p>ioremap()函数将设备所处的物理地址映射到虚拟地址。</p>
<p>ioremap_nocache()返回一个线性地址，此时CPU可以访问设备的内存空间。<em>phys_addr</em>要映射的物理地址 ；<em>size</em>要映射资源的大小。返回的映射地址必须使用<code>iounmap</code>来释放。</p>
<p>ioport_map()函数可以把 port 开始的 count 个连续的 I/O 端口重映射为一段内存空间，然后就可以在其返回的地址上像访问 I/O 内存一样访问这些 I/O 端口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读I/O内存*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ioread8</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ioread16</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ioread32</span><span class="params">(<span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">readb</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> __force *)addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">readw</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> le16_to_cpu(*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> __force *)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">readl</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> le32_to_cpu(*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> __force *)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*写I/O内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8</span><span class="params">(u8 val, <span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8</span><span class="params">(u16 val, <span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8</span><span class="params">(u32 val, <span class="type">void</span> __iomem *addr)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*读一串 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ioread8_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioread16_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioread32_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写一串 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite8_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite16_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iowrite32_rep</span><span class="params">(<span class="type">void</span> __iomem *addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*复制 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy_fromio</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *from, <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy_toio</span><span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">long</span> count)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置 I/O 内存*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memset_io</span><span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr, <span class="type">unsigned</span> <span class="type">char</span> val, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><code>/proc/iomem</code>文件记录物理地址的分配情况，这些地址范围是通过 requset_mem_region 函数申请得到的。</p>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA 是一种无需 CPU 的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制。因为DMA的目的地址与Cache 所缓存的内存地址可能重叠，所以要禁止 DMA 目标地址范围内内存的Cache 功能。</p>
<p>DMA 操作在整个常规内存区域进行，DMA 的硬件使用总线地址而非物理地址。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/hardware/memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/hardware/memory/" class="post-title-link" itemprop="url">存储器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-01 18:57:32" itemprop="dateCreated datePublished" datetime="2023-03-01T18:57:32+08:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hardware/" itemprop="url" rel="index"><span itemprop="name">hardware</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>ROM(Read Only Memory)程序存储器，在掉电之后仍然可以保持数据，用于存储各种固化程序和数据。</p>
<p><strong>PROM</strong> (Programmable ROM，可编程ROM)，写入时，烧录器通过高电压在芯片内永久地烧断或者建立内部连接（熔丝或反熔丝），因此只能一次编程。</p>
<p><strong>EPROM</strong> (Erasable Programmable ROM，可擦去可编程ROM)，使用紫外线照射此类型的ROM可以抹去其中的数据。</p>
<p><strong>EEPROM</strong> (Electrically Erasable Programmable ROM，电可擦去可编程ROM)，使用电来对其进行擦写，常用于电脑系统的BIOS。</p>
<h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p>RAM(Random Access Memory)随机访问存储器，存储单元的内容可按照需要随机取出或存入，且存取的速度与存储单元的位置无关。在掉电之后就丢失数据，主要用来存储程序中用到的变量。</p>
<p><strong>DRAM</strong> (Dynamic RAM/DRAM)动态随机存储器，DRAM保留数据的时间很短，需要周期性地刷新。计算机内存就是DRAM的。</p>
<p>DRAM利用MOS管的栅电容上的电荷来存储信息，存储单元存储的是0还是1取决于电容是否有电荷，有电荷代表1，无电荷代表0。由于栅极会漏电，所以每隔一定的时间就需要一个刷新机构给这些栅电容补充电荷，这个就叫动态刷新。刷新操作定期对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电；若电量小于1/2，则认为其代表0，并把电容放电，以此来保持数据的连续性。由于它只使用一个MOS管来存信息，所以集成度可以很高，容量能够做的很大。</p>
<p><strong>SRAM</strong> (Static Random-Access Memory)静态随机存取存储器，只要保持通电，里面储存的数据就可以一直保持，不需要动态刷新，对任何数据访问的时间都是固定的。需要与CPU时钟同步</p>
<p>SRAM的优点是只要器件不掉电，存储内容就不丢失，工作速度快。缺点是集成度低、功耗大、价格高。CPU Cache就是这种。</p>
<h2 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h2><p>Flash 存储器（FLASH EEPROM）又称闪存，快闪。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备EEPROM的性能，还不会断电丢失数据同时可以快速读取数据。它于EEPROM的最大区别是，FLASH按扇区操作，而EEPROM按照字节操作。FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因此适合用于做程序存储器。</p>
<p>flash是非易失存储器，可以对称为块的存储器单元块进行擦写和再编程。任何flash器件的写入操作只能在空或已擦除的单元内进行，所以在进行写入操作之前必须先执行擦除。擦除的过程就是把所有位都写为1的过程，以块为单位，块内的所有字节变为0xFF。</p>
<h3 id="Nor-Flash"><a href="#Nor-Flash" class="headerlink" title="Nor Flash"></a>Nor Flash</h3><ul>
<li>支持随机访问，具有XIP（eXecute In Place）特性，可以像普通ROM一样执行程序。</li>
<li>存储的内容可以直接映射到 CPU 地址空间，不需要拷贝到 RAM 中即可被 CPU 访问。</li>
<li>读操作快，但擦除和写操作慢。</li>
<li>容量小，块大小范围：64~128KB。</li>
<li>带有SRAM接口，有足够的地址引脚来寻址，可以很容易地存取其内部的每一个字节。</li>
<li>最大擦写次数是十万次。</li>
</ul>
<p>Nor Flash根据数据传输的位数可以分为并行（Parallel，即地址线和数据线直接和处理器相连）和串行（SPI，即通过SPI接口和处理器相连）。早期Norflash的接口是parallel的形式，即把数据线和地址线并排与IC的管脚连接。但是后来发现不同容量的Norflash不能硬件上兼容（数据线和地址线的数量不一样），并且封装比较大，占用了较大的PCB板位置，后来逐渐被串行接口的SPI Norflash所取代，至于现在说起NOR flash都直接以SPI flash来代称。</p>
<p>spi flash 接口定义：</p>
<ul>
<li>Standard SPI: CLK, /CS, DI, DO, /WP, /Hold</li>
<li>Dual SPI: CLK, /CS, IO0, IO1, /WP, /Hold</li>
<li>Quad SPI: CLK, /CS, IO0, IO1, IO2, IO3</li>
</ul>
<h3 id="Nand-Flash"><a href="#Nand-Flash" class="headerlink" title="Nand Flash"></a>Nand Flash</h3><ul>
<li>使用串行接口传送控制、地址和数据信息。</li>
<li>读比nor flash慢，擦除和写都快，读和写操作都采用512字节的块。</li>
<li>容量大，块大小范围：8~64KB。</li>
<li>每个块的最大擦写次数是一百万次。</li>
<li>坏块是随机分布的，需要坏块处理。</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">Nor</th>
<th align="center">Nand</th>
</tr>
</thead>
<tbody><tr>
<td align="left">成本</td>
<td align="center">单位容量较贵</td>
<td align="center">单位容量较便宜</td>
</tr>
<tr>
<td align="left">体积</td>
<td align="center">单位容量体积更大</td>
<td align="center">单位容量体积更小</td>
</tr>
<tr>
<td align="left">寿命擦写次数</td>
<td align="center">10万次</td>
<td align="center">100万次</td>
</tr>
<tr>
<td align="left">擦除单元</td>
<td align="center">Sector</td>
<td align="center">Block</td>
</tr>
<tr>
<td align="left">写入单元</td>
<td align="center">Page</td>
<td align="center">Page</td>
</tr>
<tr>
<td align="left">读取单元</td>
<td align="center">字节</td>
<td align="center">Page</td>
</tr>
<tr>
<td align="left">擦写速度</td>
<td align="center">较慢</td>
<td align="center">较快</td>
</tr>
<tr>
<td align="left">读取速度</td>
<td align="center">较快</td>
<td align="center">较慢</td>
</tr>
<tr>
<td align="left">坏块</td>
<td align="center">较少（可靠性高）</td>
<td align="center">较多（可靠性低）</td>
</tr>
<tr>
<td align="left">是否支持XIP</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
</tbody></table>
<p>由于Flash固有的电器特性，在读写数据过程中会偶然产生1位或几位数据错误，即<strong>位反转</strong>。Nand Flash发生位反转的几率要远大于Nor Flash，应采用错误探测/错误更正(EDC/ECC)算法。</p>
<p>XIP(eXecute In Place)芯片内执行，指应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。flash内执行是指nor flash 不需要初始化，可以直接在flash内执行代码。但往往只执行部分代码，比如初始化RAM。</p>
<p>NOR与NAND特性的差别，主要是由于其内部地址/数据线是否分开导致的。由于 NOR的地址线和数据线分开，它可以按字节读写数据，符合 CPU 的指令译码执行要求，所以假如 NOR上存储了代码指令， CPU 给NOR一个地址， NOR 就能向CPU 返回一个数据让 CPU 执行，中间不需要额外的处理操作。</p>
<p>而由于 NAND 的数据和地址线共用，只能按块来读写数据，假如 NAND 上存储了代码指令， CPU 给 NAND 地址后，它无法直接返回该地址的数据，所以不符合指令译码要求。 即不支持立即执行的特性(eXecute In Place)，若代码存储在NAND上，可以先把它加载到RAM存储器上，再由CPU执行。</p>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘(Hard Disk Drive，HDD)靠磁性盘片记录二进制数据。</p>
<p><img src="/images/hardware/disk/hdd.jpg" alt="img"></p>
<p>硬盘片的盘面上有一层涂得很薄的磁性材料。写入数据时，通电的磁头会形成磁场，在磁性材料层上留下一个一个小磁化区，每个被磁化的区域代表二进制的1。读取数据时，磁头扫过磁化区的时候能感受到微小的磁场变化。</p>
<p>当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道(Track)。划分分区时，分区大小必须以磁道为参考，一个分区必须包含一个或多个整数磁道，不能只占半个磁道。也就是说如果磁盘有两个磁道，最多只能分成2个分区。</p>
<p>在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面(Cylinder)。</p>
<p>磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区(Sector)。硬盘的第一个扇区，叫做引导扇区。磁盘上数据读写的最小单位。</p>
<p>操作系统内核中的文件管理系统会将硬盘的扇区组合成<strong>簇</strong>(Data Cluster)，操作系统会记录文件所在簇的编号(文件数据分布在哪几个扇区)，方便查找并读写。</p>
<p>机械硬盘通过磁头读取旋转的盘片来传输数据，而盘片的转速RPM(Round Per Minute，每分钟的转数)直接决定了硬盘读取和写入数据的速度。磁盘在写入数据时，会使用磁盘缓存暂时存储数据。</p>
<h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>RAID(独立硬盘冗余阵列，Redundant Array of Independent Disks)，简称磁盘阵列。利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或数据冗余，或是两者同时提升。</p>
<ul>
<li><strong>RAID0</strong></li>
</ul>
<p>RAID0 是一种非常简单的的方式，它将多块磁盘组合在一起形成一个大容量的存储。当我们要写数据的时候，会将数据分为N份，以独立的方式实现N块磁盘的读写，那么这N份数据会同时并发的写到磁盘中，读写性能理论上是单块磁盘的N倍。</p>
<p>但RAID0的问题是，它并不提供数据校验或冗余备份，因此一旦某块磁盘损坏了，数据就直接丢失，无法恢复了。因此RAID0就不可能用于高要求的业务中，但可以用在对可靠性要求不高，对读写性能要求高的场景中。</p>
<ul>
<li><strong>RAID1</strong></li>
</ul>
<p>RAID1 是磁盘阵列中单位成本最高的一种方式。因为它的原理是在往磁盘写数据的时候，将同一份数据无差别的写两份到磁盘，分别写到工作磁盘和镜像磁盘，对数据做了冗余备份，但它的实际空间使用率只有50%了，是一种比较昂贵的方案。</p>
<ul>
<li><strong>RAID3</strong></li>
</ul>
<p>RAID3的方式是：将数据按照RAID0的形式，分成多份同时写入多块磁盘，但是还会另外留出一块磁盘用于写奇偶校验码，一旦某一块磁盘坏掉了，就可以利用那块校验码磁盘去恢复数据。但是由于任何数据的写入都会要去更新这块磁盘，导致这块磁盘的读写是最频繁的，也就非常的容易损坏。</p>
<ul>
<li><strong>RAID5</strong></li>
</ul>
<p>RAID5对RAID3进行了改进，是一种存储性能、数据安全、存储成本兼顾的方案。</p>
<p>在RAID5模式中，不再需要用单独的磁盘写校验码了。它把校验码信息分布到各个磁盘上。例如，总共有N块磁盘，那么会将要写入的数据分成N份，并发的写入到N块磁盘中，同时还将数据的校验码信息也写入到这N块磁盘中，数据与对应的校验码信息必须得分开存储在不同的磁盘上。一旦某一块磁盘损坏了，就可以用剩下的数据和对应的奇偶校验码信息去恢复损坏的数据。</p>
<p><img src="/images/hardware/disk/RAID5.jpg" alt="img"></p>
<p>RAID5的方式，最少需要三块磁盘来组建磁盘阵列，允许最多同时坏一块磁盘。如果有两块磁盘同时损坏了，那数据就无法恢复了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/fs/VFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/fs/VFS/" class="post-title-link" itemprop="url">虚拟文件系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-01 18:57:32" itemprop="dateCreated datePublished" datetime="2023-03-01T18:57:32+08:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux 内核支持众多的逻辑文件系统,如 Ext2、Ext3、Ext4、btrfs、NFS、VFAT 等。<br>VFS 则是 Linux 基于各种逻辑文件系统抽象出的一种内存中的文件系统,隐藏了各种硬件设<br>备细节,为用户提供统一的操作接口,使用户访问各种不同文件系统和设备时,不用区分具<br>体的逻辑文件系统。</p>
<p>虚拟文件系统(VFS)隐藏各种了硬件的具体细节，为所有的设备提供了统一的接口，使用户访问各种不同文件系统和设备时，不用区分具体的逻辑文件系统。</p>
<p><img src="/images/kernel/kernel/VFS.webp" alt="img"></p>
<p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。文件系统层之下是缓冲区缓存，这个缓存层通过将数据保留一段时间。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p>
<p>文件系统使用超级块super block 存放文件系统相关信息，使用索引节点inode存放文件的物理信息，使用目录项dentry存放文件的逻辑信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/16/cpu/TrustZone/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/cpu/TrustZone/" class="post-title-link" itemprop="url">TrustZone</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 22:34:36" itemprop="dateCreated datePublished" datetime="2023-02-16T22:34:36+08:00">2023-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TrustZone是ARM针对消费电子设备设计的一种硬件架构，其目的是为消费电子产品构建一个安全框架来抵御各种可能的攻击。</p>
<p>TrustZone在概念上将SoC的硬件和软件资源划分为Secure World和Normal World两个世界，所有需要保密的操作在安全世界执行（如指纹识别、密码处理、数据加解密、安全认证等），其余操作在非安全世界执行（如用户操作系统、各种应用程序等），安全世界和非安全世界通过一个名为Monitor Mode的模式进行转换。</p>
<p>实现TrustZone需要组件有：</p>
<ul>
<li>AMBA3 AXI总线，安全机制的基础设施。</li>
<li>虚拟化的ARM Core，虚拟安全和非安全核。</li>
<li>TZPC (TrustZone Protection Controller)，根据需要控制外设的安全特性。</li>
<li>TZASC (TrustZone Address Space Controller)，对内存进行安全和非安全区域划分和保护。</li>
<li>TZMA (TrustZone Memory Adapter)，片上ROM或RAM安全区域和非安全区域的划分和保护，可选。</li>
<li>AXI-to-APB bridge，桥接APB总线，配合TZPC使APB总线外设支持TrustZone安全特性，可选。</li>
</ul>
<p><img src="/images/cpu/arm/TrusZone.png" alt="img"></p>
<h2 id="总线设计"><a href="#总线设计" class="headerlink" title="总线设计"></a>总线设计</h2><p>AMBA3 AXI(AMBA3 Advanced eXtensible Interface)系统总线作为TrustZone的基础架构设施，提供了安全世界和非安全世界的隔离机制，确保非安全核只能访问非安全世界的系统资源，而安全核能访问所有资源。</p>
<p>AMBA-AXI总线的扩展，增加了标志secure读和写地址线：AWPROT[1]和ARPROT[1]。</p>
<p>TrustZone 在系统总线上针对每一个信道的读写增加了一个额外的控制信号位，这个控制位叫做Non-Secure或者NS位。所有非安全世界的主设备在操作时必须将信号的NS位置高，而NS位置高又使得其无法访问总线上安全世界的从设备，简单来说就是对非安全世界主设备发出的地址信号进行解码时在安全世界中找不到对应的从设备，从而导致操作失败。当然，非安全世界的主设备尝试访问安全世界的从设备会引发访问错误。</p>
<p>在TrustZone出现前，ARM的外设基于AMBA2 APB (Advanced Peripheral Bus)总线协议，由于APB总线的设备不支持AXI总线的NS控制信号，所以AXI到APB总线需要AXI-to-APB bridge设备连接。AXI-to-APB bridge负责管理APB总线设备的安全事宜，其会拒绝不合理的安全请求，保证这些请求不会被转发到相应的外设。</p>
<h2 id="处理器设计"><a href="#处理器设计" class="headerlink" title="处理器设计"></a>处理器设计</h2><p>TrustZone将每个物理核虚拟为两个核，非安全核，运行非安全世界的代码；和安全核，运行安全世界的代码。两个虚拟的核以基于时间片的方式运行，根据需要实时占用物理核，并通过Monitor Mode实现了同一CPU上两个操作系统间的切换。</p>
<p>安全世界和非安全世界都有自己的虚拟MMU，各自管理物理地址的映射。实际上只是两个世界都有一份TTBR0、TTBR1、TTBCR寄存器，因此就会对应两个MMU表。尽管MMU有两套，但TBL缓存硬件上只有一套，因此TBL对于两个世界来说是共享的，其通过NS位来标志其每一项具体属于哪一个世界。这样在两个世界间进行切换时不再需要重新刷新TLB，提高执行效率。</p>
<p>Cache也是两个世界共享，具体Cache数据属于哪一个世界也由其NS位指定，在世界间切换也不需要刷新Cache。</p>
<p>在gicv2、gicv3的版本中，都增加了对安全扩展的支持:</p>
<p>在gicv2/gicv3中，支持了安全中断，配置有如下：<br>gicv2分组</p>
<ul>
<li>group0：安全中断，由nFIQ驱动</li>
<li>group1：非安全中断，由nIRQ驱动</li>
</ul>
<p>gicv3分组</p>
<ul>
<li>group0：安全中断</li>
<li>non-secure group1：非安全中断</li>
<li>secure group1：安全中断</li>
</ul>
<h2 id="隔离机制"><a href="#隔离机制" class="headerlink" title="隔离机制"></a>隔离机制</h2><p>内存隔离和保护通过总线组件TZASC和TZMA的设置来实现。</p>
<ul>
<li><p>TZASC (TrustZone Address Space Controller)可以把外部DDR分成多个区域，每个区域可以单独配置为安全或非安全区域，非安全世界的代码和应用只能访问非安全区域。TZASC只能用于内存设备，不适合用于配置块设备，如Nand Flash。</p>
</li>
<li><p>TZMA (TrustZone Memory Adapter)可以把片上ROM和SRAM隔离出安全和非安全区域。TZMA最大可以将片上存储的低2MB配置为安全区域，其余部分配置为非安全区域。大小划分上，片上安全区域可以在芯片出厂前设置为固定大小，或运行时通过TZPC动态配置。TZMA使用上有些限制，其不适用于外部内存划分，而且也只能配置一个安全区域。</p>
</li>
</ul>
<p>在外设上需要TZPC (TrustZone Protection Controller) 来向APB总线上的设备提供类似AXI上的NS控制信号。由于TZPC可以在运行时动态设置，这就决定了外设的安全特性是动态变化的，例如键盘平时可以作为非安全的输入设备，在输入密码时可以配置为安全设备，只允许安全世界访问。</p>
<h2 id="安全启动"><a href="#安全启动" class="headerlink" title="安全启动"></a>安全启动</h2><p>系统上电复位后，先从安全世界开始执行。安全世界会对非安全世界的bootloader进行验证，确保非安全世界执行的代码经过授权而没有被篡改过。然后非安全世界的bootloader会加载非安全世界的OS，完成整个系统的启动。下一级的安全依赖于上一级的验证，逐级的验证构成了整个系统的信任链。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/16/cpu/armv7_reg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/cpu/armv7_reg/" class="post-title-link" itemprop="url">ARMv7 寄存器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 22:34:36" itemprop="dateCreated datePublished" datetime="2023-02-16T22:34:36+08:00">2023-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index"><span itemprop="name">cpu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/cpu/arm/armv7_reg.jpg" alt="img"></p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>通用寄存器包括R0-R15，均为32位寄存器，可以分为3类：</p>
<p><img src="/images/cpu/arm/armv7_reg.png" alt="img"></p>
<p><strong>未分组寄存器(R0-R7)</strong></p>
<p>在所有运行模式下，未分组寄存器都指向同一个物理寄存器。在中断或异常处理进行异常模式转换时，由于不同的处理器运行模式均使用相同的物理寄存器，所以可能造成寄存器中数据的破坏。</p>
<p><strong>分组寄存器(R8-R14)</strong></p>
<p>对于分组寄存器，他们每次所访问的物理寄存器都与当前的处理器运行模式相关。</p>
<p>R13堆栈指针寄存器SP，保存堆栈的栈顶地址，用户也可以使用其他寄存器存放堆栈指针，但在Thumb指令集下，某些指令强制要求使用R13存放堆栈指针。</p>
<p>R14链接寄存器LR（Link Register），保存调用子程序的返回地址。当执行子程序时，R14可得到R15（PC）的备份，执行完子程序后，又将R14的值复制回PC。</p>
<p><strong>程序计数器PC（R15）</strong></p>
<p>程序计数器（PC），在ARM状态下，位[1:0]为0，位[31:2]用于保存PC；在Thumb状态下,位[0]为0，位[31:1]用于保存PC。</p>
<p>由于ARM体系结构采用了多级流水线技术，对于ARM指令集而言，PC总是指向当前指令的下两条指令的地址，即PC的值为当前指令的地址值加8个字节。</p>
<h2 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h2><ul>
<li>CPSR（Current Program Status Register）当前程序状态寄存器1个。</li>
<li>SPSR（Saved Progarm Status Register）备份程序状态寄存器6个，用于异常发生时保存CPSR的值，异常退出时恢复CPSR。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/16/kernel/kernel_make/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/kernel/kernel_make/" class="post-title-link" itemprop="url">kernel make and menuconfig</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 22:34:36" itemprop="dateCreated datePublished" datetime="2023-02-16T22:34:36+08:00">2023-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>指定交叉工具和平台。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- ARCH=arm defconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- ARCH=arm menuconfig</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul>
<li>屏蔽编译信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &gt; /dev/null</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>make -j&lt;n&gt;</code>参数加速编译</p>
</li>
<li><p>指定编译某些模块</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make M=drivers/i2c/ modules</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 verbose 模式，将每一步执行的命令都打印出来，并重定向到一个文件中去，这样以后可以方便地查找模块之间的依赖关系。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make V=1 &gt; ~/bak.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 ccache 提高编译速度，使用 ccache时，需要更改源码树根目录下面的 Makefile 文件，在 CC 和 HOSTCC 变量的定义前添加 ccache。<a target="_blank" rel="noopener" href="http://ccache.samba.org/">ccache主页</a>。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC = ccache <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">HOSTCC = ccache gcc</span><br></pre></td></tr></table></figure>

<p><img src="/images/kernel/kernel/vmlinux.bmp" alt="img"></p>
<h2 id="编译文档"><a href="#编译文档" class="headerlink" title="编译文档"></a>编译文档</h2><p>使用下面的一些命令可以在 Documentation/DocBook/目录下，生成一些文档。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make htmldocs //生成 HTML 文件</span><br><span class="line">make pdfdocs  //生成 PDF 文件</span><br><span class="line">make psdocs   //生成 Postscript 文件</span><br><span class="line">make mandocs  //生成 Kernel API 手册</span><br><span class="line">make installmandocs //将 Kernel API 手册页安装到 man 程序能够找到的目录中</span><br></pre></td></tr></table></figure>

<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>1.缺少libncurses5-dev</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig requires the ncurses libraries.</span><br></pre></td></tr></table></figure>

<p>2.没有安装u-boot-tools</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkimage command not found – U-Boot images will not be built</span><br></pre></td></tr></table></figure>

<p>3.源文件编译生成的.o文件和模块目标文件xxx.o重名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module license &#x27;unspecified&#x27; taints kernel.</span><br><span class="line">Disabling lock debugging due to kernel taint</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/16/tool/gcc-name/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/tool/gcc-name/" class="post-title-link" itemprop="url">交叉编译工具链命名规则</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 22:34:36" itemprop="dateCreated datePublished" datetime="2023-02-16T22:34:36+08:00">2023-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/gcc/" itemprop="url" rel="index"><span itemprop="name">gcc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>交叉编译工具链是一个由编译器、连接器和解释器组成的综合开发环境，交叉编译工具链主要由binutils、gcc和glibc三个部分组成。有时出于减小 libc 库大小的考虑，也可以用别的 c 库来代替 glibc，例如 uClibc、dietlibc 和 newlib。</p>
<p>从授权上分为免费授权版和付费授权版。免费版目前有三大主流工具商提供，第一是GNU（提供源码，自行编译制作），下载地址：<a target="_blank" rel="noopener" href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads%E3%80%82%E7%AC%AC%E4%BA%8C%E6%98%AF">https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads。第二是</a> Codesourcery，第三是Linora。收费版有ARM原厂提供的armcc、IAR提供的编译器等等。</p>
<p>交叉编译工具链的命名规则为：arch [-vendor] [-kernel] [-system]</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>体系架构, 如ARM, MIPS</td>
</tr>
<tr>
<td>vendor</td>
<td>工具链提供商，也可以是处理器核型号</td>
</tr>
<tr>
<td>kernel</td>
<td>目标内核：Linux和bare-metal（裸机）</td>
</tr>
<tr>
<td>system</td>
<td>库函数和目标系统：gnu，eabi，uclibc</td>
</tr>
</tbody></table>
<p>根据对操作系统的支持与否，ARM gcc可分为支持和不支持操作系统，如：</p>
<ul>
<li><p>arm-none-eabi：这个是没有操作系统的，不支持那些跟操作系统关系密切的函数如fork()。</p>
</li>
<li><p>arm-none-linux-eabi 用于Linux系统，使用Glibc。</p>
</li>
</ul>
<p>ABI(Application Binary Interface)二进制应用程序接口，描述了应用程序和操作系统之间或其他应用程序的低级接口。</p>
<p>OABI(Old Application Binary Interface)是老的ABI。</p>
<p>EABI(Embedded Application Binary Interface)是嵌入式的ABI，指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。允许使用特权指令，不需要动态链接，并且使用更紧凑的堆栈帧组织用来节省内存。</p>
<p>system中gnu的值，其实是glibc的意思。</p>
<ul>
<li>gnu      = glibc+oabi</li>
<li>gnueabi  = glibc + eabi</li>
<li>uclibc   = uclibc + oabi</li>
</ul>
<p>arm-none-eabi-gcc（ARM architecture，no vendor，not target an operating system，complies with the ARM EABI）<br>用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application），一般适合 ARM7、Cortex-M 和 Cortex-R 内核的芯片使用。</p>
<p>arm-none-linux-gnueabi-gcc(ARM architecture, no vendor, creates binaries that run on the Linux operating system, and uses the GNU EABI)主要用于基于ARM架构的Linux系统，可用于编译 ARM 架构的 u-boot、Linux内核、linux应用等。适合ARM9、ARM11、Cortex-A 内核，带有 Linux 操作系统的芯片。</p>
<p>arm-linux-gnueabi-gcc 和 arm-linux-gnueabihf-gcc两个交叉编译器分别适用于 armel 和 armhf 两个不同的架构，armel 和 armhf 这两种架构在对待浮点运算采取了不同的策略（有 fpu 的 arm 才能支持这两种浮点运算策略）。其实这两个交叉编译器只不过是 gcc 的选项 -mfloat-abi 的默认值不同：</p>
<table>
<thead>
<tr>
<th>浮点数配置</th>
<th>架构</th>
<th>对应编译器类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>soft</td>
<td>无</td>
<td>无</td>
<td>不用fpu进行浮点计算, 即使有fpu浮点运算单元也不用, 而是使用软件模式</td>
</tr>
<tr>
<td>softfp</td>
<td>armel架构</td>
<td>arm-linux-gnueabi-gcc</td>
<td>用fpu计算, 但是传参数用普通寄存器传, 这样中断的时候, 只需要保存普通寄存器, 中断负荷小, 但是参数需要转换成浮点的再计算</td>
</tr>
<tr>
<td>hard</td>
<td>armhf架构</td>
<td>arm-linux-gnueabihf-gcc</td>
<td>用fpu计算, 传参数也用fpu中的浮点寄存器传, 省去了转换, 性能最好, 但是中断负荷高</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/31/algo/tree-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/31/algo/tree-code/" class="post-title-link" itemprop="url">二叉树算法题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-31 22:09:51 / 修改时间：22:21:32" itemprop="dateCreated datePublished" datetime="2022-12-31T22:09:51+08:00">2022-12-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">MaxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">MaxDepth</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MAX</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Flip</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Flip</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">Flip</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相同的二叉树"><a href="#相同的二叉树" class="headerlink" title="相同的二叉树"></a>相同的二叉树</h2><p>(1)如果两棵树的根结点都为空，则两棵树相同。<br>(2)如果两棵树的根结点有一个为空，则两棵树必然不相同。<br>(3)如果两棵树都不为空，则判断根结点的值是否相同，不相同则这两棵树必然不相同。<br>(4)如果两棵树根结点的值相同，则需要判断两棵树的左右子树是否相同，如果相同则这两棵树相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == q &amp;&amp; p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;                                                            <span class="comment">//(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                                                           <span class="comment">//(2)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                                                           <span class="comment">//(3)</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);      <span class="comment">//(4)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="另一棵树的子树"><a href="#另一棵树的子树" class="headerlink" title="另一棵树的子树"></a>另一棵树的子树</h2><p>判断一棵树是否为另一棵树的子树我们可以基于判断两棵树是否相同去做。<br>(1)如果<code>root</code>与<code>subRoot</code>的地址相同，则说明两棵树是同一棵树，那么<code>subRoot</code>肯定是<code>root</code>的子树。<br>(2)如果<code>root</code>与<code>subRoot</code>有一棵树是空，那么<code>subRoot</code>必然不是<code>root</code>的子树。<br>(3)如果<code>root</code>与<code>subRoot</code>相同，那么<code>subRoot</code>肯定是<code>root</code>的子树。<br>(4)如果<code>root</code>的子树含有与<code>subRoot</code>相同的树，那么<code>subRoot</code>肯定是<code>root</code>的子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="comment">//判断两棵树是否相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == q &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == subRoot) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || subRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//整棵树是否与subRoot相同</span></span><br><span class="line">        <span class="keyword">if</span> (isSameTree(root, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//subRoot是否是左子树的子树</span></span><br><span class="line">        <span class="keyword">if</span> (isSubtree(root.left, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//subRoot是否是右子树的子树</span></span><br><span class="line">        <span class="keyword">if</span> (isSubtree(root.right, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//上面都不满足，则subRoot不是该树的子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>判断一棵树是否是对称二叉树，其实就是判断这棵树的左右子树是否相同，如果相同则该二叉树对称，反之不对称，当然如果这棵二叉树是空树，那这棵树也是对称的。所以这又回到比较两棵树是否相等这个题目上去了。<br>(1)如果二叉树为空，返回<code>true</code>。<br>(2)比较左右子树是否相等，相等返回<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//(2)判断左右子树是否相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetricChild</span><span class="params">(TreeNode leftTree,TreeNode rightTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftTree == rightTree &amp;&amp; leftTree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftTree == <span class="literal">null</span> || rightTree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftTree.val != rightTree.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricChild(leftTree.left, rightTree.right) &amp;&amp; isSymmetricChild(leftTree.right, rightTree.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">//(1)</span></span><br><span class="line">        <span class="keyword">return</span> isSymmetricChild(root.left,root.right);<span class="comment">//(2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h2><p>(1)如果树为空，则这棵树是平衡二叉树。<br>(2)获取该树左右子树的高度差的绝对值，如果大于1，则这棵树肯定不是平衡二叉树。<br>(3)如果高度差绝对值不大于1，再判断该树的左右子树是否都是平衡二叉树，如果是，则这一整棵树是平衡二叉树。</p>
<p>所以这道题最终回到了求二叉树的高度上来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//获取二叉树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDeep</span><span class="params">(TreeNode subtree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subtree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDeep(subtree.left), maxDeep(subtree.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;            <span class="comment">//(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Math.abs(maxDeep(root.left) - maxDeep(root.right));       <span class="comment">//(2)</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right)) &#123;  <span class="comment">//(3)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h2><p>当遍历当前层时如果遇到空节点，如果该空节点右侧还有节点，说明该树一定不是完全二叉树，直接返回false，遍历完返回true；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">isCompleteTree</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 层次遍历方法</span></span><br><span class="line">        <span class="comment">// 标记空节点</span></span><br><span class="line">        boolean target = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.<span class="built_in">offer</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            TreeNode cur = queue.<span class="built_in">poll</span>();</span><br><span class="line">            <span class="comment">//如果当前结点为空结点，将标记位left设置为false</span></span><br><span class="line">            <span class="keyword">if</span>(cur == null)&#123;</span><br><span class="line">                target = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">// 遇到空节点直接返回false</span></span><br><span class="line">                <span class="keyword">if</span>(target == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                queue.<span class="built_in">offer</span>(cur.left);</span><br><span class="line">                queue.<span class="built_in">offer</span>(cur.right);</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断二叉搜索树"><a href="#判断二叉搜索树" class="headerlink" title="判断二叉搜索树"></a>判断二叉搜索树</h2><p>提前设置最小值pre<br>1、先判断空<br>2、进行递归左子树，如果不满足，返回false<br>3、判断当前root值和pre值大小，如果root&lt;pre,则返回false<br>4、更新pre值<br>5、然后递归右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param root TreeNode类 </span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> pre = Integer.MIN_VALUE; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValidBST</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先判断为空</span></span><br><span class="line">        <span class="keyword">if</span>(root ==null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isValidBST</span>(root.left))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 更新最值</span></span><br><span class="line">        pre = root.val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36317312/article/details/124026664">https://blog.csdn.net/qq_36317312/article/details/124026664</a></p>
<p><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-172f0/">https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-172f0/</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/357408">https://bbs.huaweicloud.com/blogs/357408</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/17/algo/tree_search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/17/algo/tree_search/" class="post-title-link" itemprop="url">二叉搜索树</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-17 11:15:01" itemprop="dateCreated datePublished" datetime="2022-12-17T11:15:01+08:00">2022-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-31 19:38:57" itemprop="dateModified" datetime="2022-12-31T19:38:57+08:00">2022-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>二叉搜索树（Binary Search Tree， BST）支持动态数据集合的快速插入、删除、查找操作，是一棵空树或者有如下性质的二叉树：</p>
<ul>
<li>若任意节点的左子树不空，其左子树中的每个节点的值都小于这个节点的值；</li>
<li>若任意节点的右子树不空，其右子树每个节点的值都大于这个节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ul>
<p>不管操作是插入、删除还是查找，其时间复杂度其实都跟树的高度成正比， O(height)。</p>
<p>将二叉搜索树进行中序亢奋可以等到由小到大的顺序排序。</p>
<p><strong>查找操作</strong></p>
<p>先取根节点，如果它等于要查找的数据就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<p><img src="/images/code/algo/tree/findtree.png" alt="二叉搜索树"></p>
<p><strong>插入操作</strong></p>
<p>二叉查找树的插入过程需要从根节点开始，依次比较要插入的数据和节点的大小关系：</p>
<ol>
<li><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</p>
</li>
<li><p>如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
</li>
</ol>
<p><img src="/images/code/algo/tree/findtree-add.png" alt="img"></p>
<p><strong>删除操作</strong></p>
<p>针对要删除节点的子节点个数的不同需要分2种情况来处理:</p>
<ol>
<li><p>如果要删除的节点只有一个子节点或没有子节点，只需要要将要删除节点的父节点的指针指向要删除节点的子节点。比如下图中删除节点 55、 13。</p>
</li>
<li><p>如果要删除的节点有两个子节点。需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再按照上面方法删除掉这个最小节点。比如下图中的删除节点 18。（用左子树的最大节点进行替换也可以）。</p>
</li>
</ol>
<p><img src="/images/code/algo/tree/findtree-del.png" alt="img"></p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>为了解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。平衡二叉查找树就是让整棵树左右看起来比较平衡，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p>
<p>任何节点的左右子树高度相差不超过 1，完全二叉树、满二叉树都是平衡二叉树，非完全二叉树有可能是平衡二叉树。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一颗特殊的二叉查找树，除了二叉查找树的要求外，它还具有以下特性：</p>
<ul>
<li>每个节点是黑色或者红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点(NIL，空节点)是黑色。</li>
<li>从根节点到叶子节点，不会出现两个连续的红色节点。如果一个节点是红色的，则它的子节点必是黑色。</li>
<li>从任何节点到叶子节点，这条路径上有相同数目的黑色节点。</li>
</ul>
<p><strong>旋转</strong></p>
<p>左旋就是当新加入节点之后，树的高度及颜色不再满足红黑树定义规则后；将不满足的节点进行左旋转，使得它取代之前它的父节点，同时它的父节点变为它的左子节点，最后调整颜色的过程。</p>
<p><img src="/images/code/algo/tree/rbtree.png" alt="img"></p>
<p>对x左旋，意味着降低x节点的高度，将x变成一个左节点，提升x节点右节点y的高度。</p>
<ol>
<li>x的右子树指向y的左子树</li>
<li>本来指向x结点的父指针，改成指向y</li>
<li>y的左子树指向x结点</li>
</ol>
<p><img src="/images/code/algo/tree/rbtree2.png" alt="img"></p>
<p>右旋就是以某节点为中心进行向右的旋转，取代并成为之前自己的父节点，然后把之前的父节点变为自己的右子节点，最后调整颜色的过程。</p>
<ol>
<li>x的左子树指向y的右子树</li>
<li>本来指向x结点的父指针，改成指向y</li>
<li>y的右子树指向x结点</li>
</ol>
<hr>
<h2 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h2><p>带权路径最短的二叉树称为哈夫曼树或最优二叉树。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuqinglong/p/9709048.html">https://www.cnblogs.com/wuqinglong/p/9709048.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/11/algo/divided/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ubun2">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nullptr">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/11/algo/divided/" class="post-title-link" itemprop="url">分治算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-11 19:04:14" itemprop="dateCreated datePublished" datetime="2022-12-11T19:04:14+08:00">2022-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-31 19:05:31" itemprop="dateModified" datetime="2022-12-31T19:05:31+08:00">2022-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>分治算法的基本思想是将一个规模为N的问题，分解为K个规模较小的子问题，这些子问题相互独立且原问题性质相同。分而治之，逐个击破，递归解决子问题，然后合并得到原问题的解。</p>
<h2 id="二分法搜索"><a href="#二分法搜索" class="headerlink" title="二分法搜索"></a>二分法搜索</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (min &lt;= max) &#123;</span><br><span class="line">        mid = (min + max) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; data) &#123;</span><br><span class="line">            max = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; data) &#123;</span><br><span class="line">            min = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种取中位数的方式，当 min 和 max 很大的时候，会出现溢出的情况，从而导致数组访问出错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid = (min + max) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>改进的办法是将加法变成减法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止溢出</span></span><br><span class="line">mid =  min + (max - min) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="寻找假币"><a href="#寻找假币" class="headerlink" title="寻找假币"></a>寻找假币</h2><p>有N个硬币，其中有一个质量较轻的假币，如何通过一个天平将假币挑出。</p>
<p>将硬币分成2份去称，轻的寻一半包含假币，再将轻的那一份又分为2份，直到最后剩下两枚，轻的那一枚即为假币。考虑到硬币个数为奇数的情况，照样分为两半，剩下一个多余的，如果两半相等，多余那个就是假币，否则处理那两半。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FakeCoin</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = end - start + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; end &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> coins[start] &lt; coins[end] ? start : end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = num / <span class="number">2</span> + start;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; mid; ++i) &#123;</span><br><span class="line">            left += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &lt;= end; ++i) &#123;</span><br><span class="line">            right += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot;) --&gt; &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, mid, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; mid; ++i) &#123;</span><br><span class="line">            left += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">            right += coins[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot;) --&gt; &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FakeCoin</span>(coins, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; coins = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; coins = &#123;1, 1, 1, 1, 0, 1, 1, 1, 1&#125;;</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt; coins = &#123;1, 1, 1, 1, 1, 1, 1, 1, 0&#125;;</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">FakeCoin</span>(coins, <span class="number">0</span>, coins.<span class="built_in">size</span>() - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p>从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的3个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。</p>
<p>实现汉诺塔算法只需要以下三个步骤：</p>
<p>​ 1.利用目标柱为媒介，将上面n-1个圆盘从原始柱暂时移动到辅助柱</p>
<p>​ 2.将原始柱上的最后一个最大的圆盘移动到目标柱上</p>
<p>​ 3.将暂存在辅助柱上的n-1个柱子全部移动到目标柱上</p>
<p><img src="/images/code/algo/hanoi.png" alt="汉诺塔"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">char</span> src, <span class="type">char</span> dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;move &quot;</span> &lt;&lt; src &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; dest &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> src, <span class="type">char</span> dest, <span class="type">char</span> tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">Move</span>(src, dest);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Hanoi</span>(n - <span class="number">1</span>, src, tmp, dest);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Move</span>(src, dest);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Hanoi</span>(n - <span class="number">1</span>, tmp, dest, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ubun2</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">226</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ubun2</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
