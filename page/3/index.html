<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/async/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/async/" class="post-title-link" itemprop="url">linux async</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:18:30" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dev/" itemprop="url" rel="index"><span itemprop="name">dev</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>TOC<br>{:toc}</li>
</ul>
<h2 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h2><p>异步通知是应用程序不需要一直查询设备状态，一旦设备就绪，则主动通知应用程序。为了使设备支持异步通知机制，驱动程序中涉及 3 项工作：</p>
<ul>
<li><p>支持 F_SETOWN 命令，能在这个控制命令处理中设置 filp-&gt;f_owner 为对应进程 ID。不<br>过此项工作已由内核完成，设备驱动无需处理。</p>
</li>
<li><p>支持 F_SETFL 命令的处理，当应用改变 FASYNC 标志时，驱动程序中的fasync()函数将得以执行。</p>
</li>
<li><p>在设备资源可获得时，激发相应的信号。</p>
</li>
</ul>
<p><img src="/images/kernel/async/async.png" alt="async"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理 FASYNC 标志变更 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fasync_helper</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> mode, <span class="keyword">struct</span> fasync_struct **fa)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kill_fasync</span><span class="params">(<span class="keyword">struct</span> fasync_struct **fp, <span class="type">int</span> sig, <span class="type">int</span> band)</span></span><br></pre></td></tr></table></figure>

<p>驱动中要实现fasync()函数，当应用改变 FASYNC 标志时，驱动程序中的fasync()函数将得以执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxx_object</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">return</span> fasync_helper(fd, filp, mode, &amp;dev-&gt;async_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设备资源可以获得时，应该调用 kill_fasync()释放 SIGIO 信号，可读时band参数设置为 <code>POLL_IN</code>，可写时设置为 <code>POLL_OUT</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 产生异步读信号 */</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;async_queue)</span><br><span class="line">&#123;</span><br><span class="line">    kill_fasync(&amp;dev-&gt;async_queue, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在设备驱动的 release()函数中，应调用设备驱动的 fasync()函数将文件从异步通知的列表中删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    xxx_fasync(<span class="number">-1</span>, file, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/udev/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/udev/" class="post-title-link" itemprop="url">udev</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:18:30" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>TOC<br>{:toc}</li>
</ul>
<h2 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h2><p>udev 完全在用户态工作，利用设备加入或移除时内核所发送的热插拔事件(hotplug event)来工作。在热插拔时，设备的详细信息会由内核输出到位于/sys 的sysfs 文件系统。udev 的设备命名策略、权限控制和事件处理都是在用户态下完成的，它利用 sysfs 中的信息来进行创建设备文件节点等工作。</p>
<p>udev 根据系统中硬件设备的状态动态更新、创建和删除设备文件，进行设备文件的等，因此/dev 目录下只包含系统中真正存在的设备。linux在设备被发现的时候加载驱动模块。</p>
<p>udev主页 <a target="_blank" rel="noopener" href="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html">http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html</a></p>
<p>udev包下载 <a target="_blank" rel="noopener" href="http://www.us.kernel.org/pub/linux/utils/kernel/hotplug/">http://www.us.kernel.org/pub/linux/utils/kernel/hotplug/</a></p>
<p>udev 的设计目标如下：</p>
<ul>
<li>在用户空间中执行。</li>
<li>动态建立/删除设备文件。</li>
<li>允许每个人都不用关心主/次设备号。</li>
<li>提供 LSB 标准名称，如果需要，可提供固定的名称。</li>
</ul>
<p>udev 以 3 个分割的子计划发展：namedev、libsysfs 和 udev。namedev 为设备命名子系统；libsysfs 提供访问 sysfs 文件系统从中获取信息的标准接口；udev 提供/dev 设备节点文件的动态创建和删除策略，负责与 namedev 和 libsysfs 库交互的任务，当/sbin/hotplug程序被内核调用时，udev 将被运行。udev 的工作过程如下：</p>
<ol>
<li><p>当内核检测到在系统中出现了新设备后，内核会在 sysfs 文件系统中为该新设备生成新的记录并导出一些设备特定的信息及所发生的事件。</p>
</li>
<li><p>udev 获取内核导出的信息，它调用 namedev 决定应该给该设备指定的名称，如果是新插入设备，udev 将调用 libsysfs 决定应该为该设备的设备文件指定的主/次设备号，并用分析获得的设备名称和主/次设备号创建/dev 中的设备文件;如果是设备移除，则之前已经被创建的/dev 文件将被删除。</p>
</li>
</ol>
<p>namedev 中使用 5 步序列来决定指定设备的命名：</p>
<ol>
<li><p>标签(label)/序号(serial):这一步检查设备是否有惟一的识别记号，例如 USB 设备有惟一的 USB 序号，SCSI 有惟一的 UUID。如果 namedev 找到与这种惟一编号相对应的规则，它将使用该规则提供的名称。</p>
</li>
<li><p>设备总线号:这一步会检查总线设备编号，对于不可热插拔的环境，这一步足以辨别设备。例如，PCI 总线编号在系统的使用期间内很少变更。如果 namedev 找到相对应的规则，规则中的名称就会被使用。</p>
</li>
<li><p>总线上的拓扑:当设备在总线上的位置匹配用户指定的规则时，就会使用该规则指定的名称。</p>
</li>
<li><p>替换名称:当内核提供的名称匹配指定的替代字符串时，就会使用替代字符串指定的名称。</p>
</li>
<li><p>内核提供的名称:如果以前的几个步骤都没有被提供，默认的内核将被指定给该设备。</p>
</li>
</ol>
<h2 id="udev规则文件"><a href="#udev规则文件" class="headerlink" title="udev规则文件"></a>udev规则文件</h2><p>udev 的规则文件以行为单位，以“#”开头的行代表注释行。其余的每一行代表一个规则。每个规则分成一个或多个匹配和赋值部分。匹配部分用匹配专用的关键字来表示，相应的赋值部分用赋值专用的关键字来表示。匹配关键字包括:ACTION(行为)、KERNEL(匹配内核设备名)、BUS(匹配总线类型)、SYSFS(匹配从 sysfs 得到的信息，比如 label、vendor、USB 序列号)、SUBSYSTEM(匹配子系统名)等，赋值关键字包括:NAME(创建的设备文件名)、SYMLINK(符号创建链接名)、OWNER(设置设备的所有者)、GROUP(设置设备的组)、IMPORT(调用外部程序)等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, SYSFS&#123;address&#125;==&quot;00:0d:87:f6:59:f3&quot;, IMPORT=&quot;/sbin/rename_netiface %k eth0&quot;</span><br></pre></td></tr></table></figure>

<h2 id="udevadm"><a href="#udevadm" class="headerlink" title="udevadm"></a>udevadm</h2><p>udevadm可用于控制服务、 请求内核事件、管理事件队列、进行简单的调试。</p>
<ul>
<li><p><code>-d</code>, <code>--debug</code></p>
<p>在标准错误(STDERR)上显示调试信息。 <strong>udevadm test</strong> 与 <strong>udevadm test-builtin</strong> 命令隐含了此选项。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-info-options-devpath-file-unit…"><a href="#udevadm-info-options-devpath-file-unit…" class="headerlink" title="udevadm info [options] [devpath|file|unit…]"></a>udevadm info [<em>options</em>] [<em>devpath</em>|<em>file</em>|<em>unit</em>…]</h3><p>从udev数据库中提取设备信息。</p>
<p>位置参数用于指定一个或多个设备，它可以是 一个设备名(必须以 <code>/dev/</code> 开头)、 一个 sys 路径(必须以 <code>/sys/</code> 开头)、 一个设备单元(必须以 “<code>.device</code>“ 结尾)。详见 <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd.device.html#">systemd.device(5)</a> 手册。</p>
<ul>
<li><p><code>-q</code>, <code>--query=*TYPE*</code></p>
<p>提取特定类型的设备信息。 <em>TYPE</em> 可以是下列值之一： <code>name</code>, <code>symlink</code>, <code>path</code>, <code>property</code>, <code>all</code>(默认值)</p>
</li>
<li><p><code>-p</code>, <code>--path=*DEVPATH*</code></p>
<p>该设备在 <code>/sys</code> 目录下的路径(例如 <code>[/sys]/class/block/sda</code>)。 因为此选项是位置参数以 <code>/sys/</code> 开头时的替代， 所以通常将 <strong>udevadm info –path=/class/block/sda</strong> 直接简写为 <strong>udevadm info /sys/class/block/sda</strong></p>
</li>
<li><p><code>-n</code>, <code>--name=*FILE*</code></p>
<p>设备节点或软连接的名称(例如 <code>[/dev]/sda</code>)。 因为此选项是位置参数以 <code>/dev/</code> 开头时的替代， 所以通常将 <strong>udevadm info –name=sda</strong> 直接简写为 <strong>udevadm info /dev/sda</strong></p>
</li>
<li><p><code>-r</code>, <code>--root</code></p>
<p>以绝对路径显示 <code>--query=name</code> 与 <code>--query=symlink</code> 的查询结果</p>
</li>
<li><p><code>-a</code>, <code>--attribute-walk</code></p>
<p>按照udev规则的格式，显示所有可用于匹配该设备的sysfs属性： 从该设备自身开始，沿着设备树向上回溯(一直到树根)， 显示沿途每个设备的sysfs属性。</p>
</li>
<li><p><code>-x</code>, <code>--export</code></p>
<p>以 键=’值’ 的格式输出此设备的属性(注意，值两边有单引号界定)。 仅在指定了 <code>--query=property</code> 或 <code>--device-id-of-file=*FILE*</code> 的情况下才有效。</p>
</li>
<li><p><code>-P</code>, <code>--export-prefix=*NAME*</code></p>
<p>在输出的键名前添加一个前缀。 此选项隐含了 <code>--export</code></p>
</li>
<li><p><code>-d</code>, <code>--device-id-of-file=*FILE*</code></p>
<p>显示 <em>FILE</em> 文件所在底层设备的主/次设备号。 如果使用了此选项，那么将忽略所有位置参数。</p>
</li>
<li><p><code>-e</code>, <code>--export-db</code></p>
<p>导出udev数据库的全部内容</p>
</li>
<li><p><code>-c</code>, <code>--cleanup-db</code></p>
<p>清除udev数据库</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-trigger-options-devpath-file-unit"><a href="#udevadm-trigger-options-devpath-file-unit" class="headerlink" title="udevadm trigger [options] [devpath|file|unit]"></a>udevadm trigger [<em>options</em>] [<em>devpath</em>|<em>file</em>|<em>unit</em>]</h3><p>强制内核触发设备事件，主要用于重放内核初始化过程中的冷插(coldplug)设备事件。</p>
<p>接受一个用于指定设备的位置参数。参见前面对 <strong>info</strong> 的描述。</p>
<ul>
<li><p><code>-v</code>, <code>--verbose</code></p>
<p>显示被触发的设备列表</p>
</li>
<li><p><code>-n</code>, <code>--dry-run</code></p>
<p>并不真正触发设备事件</p>
</li>
<li><p><code>-t</code>, <code>--type=*TYPE*</code></p>
<p>仅触发特定类型的设备， TYPE 可以是下列值之一： <strong>devices</strong>(默认值), <strong>subsystems</strong></p>
</li>
<li><p><code>-c</code>, <code>--action=*ACTION*</code></p>
<p>指定触发哪种类型的设备事件，ACTION 可以是下列值之一： <strong>add</strong>, <strong>remove</strong>, <strong>change</strong>(默认值)</p>
</li>
<li><p><code>-s</code>, <code>--subsystem-match=*SUBSYSTEM*</code></p>
<p>仅触发属于 <em>SUBSYSTEM</em> 子系统的设备事件。 可以在 <em>SUBSYSTEM</em> 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，所有匹配的子系统中的设备都会被触发。</p>
</li>
<li><p><code>-S</code>, <code>--subsystem-nomatch=*SUBSYSTEM*</code></p>
<p>不触发属于 <em>SUBSYSTEM</em> 子系统的设备事件。 可以在 <em>SUBSYSTEM</em> 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则， 也就是说，只有不匹配所有指定子系统的设备才会被触发。</p>
</li>
<li><p><code>-a</code>, <code>--attr-match=*ATTRIBUTE*=*VALUE*</code></p>
<p>仅触发那些在设备的sysfs目录中存在 ATTRIBUTE 文件的设备事件。 如果同时还指定了”=VALUE”，那么表示仅触发那些 ATTRIBUTE 文件的内容匹配 VALUE 的设备事件。 注意，可以在 VALUE 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则， 也就是说，只有匹配所有指定属性的设备才会被触发。</p>
</li>
<li><p><code>-A</code>, <code>--attr-nomatch=*ATTRIBUTE*=*VALUE*</code></p>
<p>不触发那些在设备的sysfs目录中存在 ATTRIBUTE 文件的设备事件。 如果同时还指定了”=VALUE”，那么表示不触发那些 ATTRIBUTE 文件的内容匹配 VALUE 的设备事件。 注意，可以在 VALUE 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则， 也就是说，只有不匹配所有指定属性的设备才会被触发。</p>
</li>
<li><p><code>-p</code>, <code>--property-match=*PROPERTY*=*VALUE*</code></p>
<p>仅触发那些设备的 PROPERTY 属性值匹配 VALUE 的设备事件。注意，可以在 VALUE 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，匹配任意一个属性值的设备都会被触发。</p>
</li>
<li><p><code>-g</code>, <code>--tag-match=*PROPERTY*</code></p>
<p>仅触发匹配 PROPERTY 标签的设备事件。如果多次使用此选项， 那么表示以 AND 逻辑连接每个匹配规则，也就是说，只有匹配所有指定标签的设备才会被触发。</p>
</li>
<li><p><code>-y</code>, <code>--sysname-match=*SYSNAME*</code></p>
<p>仅触发设备sys名称(也就是该设备在 <code>/sys</code> 路径下最末端的文件名)匹配 <em>SYSNAME</em> 的设备事件。 注意，可以在 <em>SYSNAME</em> 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，匹配任意一个sys名称的设备都会被触发。</p>
</li>
<li><p><code>--name-match=*DEVPATH*</code></p>
<p>触发给定设备及其所有子设备的事件。<em>DEVPATH</em> 是该设备在 <code>/dev</code> 目录下的路径。 如果多次使用此选项，那么仅以最后一个为准。</p>
</li>
<li><p><code>-b</code>, <code>--parent-match=*SYSPATH*</code></p>
<p>触发给定设备及其所有子设备的事件。<em>SYSPATH</em> 是该设备在 <code>/sys</code> 目录下的路径。 如果多次使用此选项，那么仅以最后一个为准。</p>
</li>
<li><p><code>-w</code>, <code>--settle</code></p>
<p>除了触发设备事件之外，还要等待这些事件完成。 注意，此选项仅等待该命令自身触发的事件完成， 而 <strong>udevadm settle</strong> 则要一直等到 所有设备事件全部完成。</p>
</li>
<li><p><code>--wait-daemon[=*SECONDS*]</code></p>
<p>在触发设备事件之前，等待 systemd-udevd 守护进程完成初始化。 默认等待 5 秒之后超时(可以使用 <em>SECONDS</em> 参数修改)。 此选项等价于在 <strong>udevadm trigger</strong> 命令之前先使用 <strong>udevadm control –ping</strong> 命令。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<p>可以直接使用 以 <code>/sys</code> 或 <code>/dev</code> 开头的绝对路径来指定目标设备。</p>
<h3 id="udevadm-settle-options"><a href="#udevadm-settle-options" class="headerlink" title="udevadm settle [options]"></a>udevadm settle [<em>options</em>]</h3><p>监视udev事件队列，并且在所有事件全部处理完成之后退出。</p>
<ul>
<li><p><code>-t</code>, <code>--timeout=*SECONDS*</code></p>
<p>最多允许花多少秒等候事件队列清空。 默认值是120秒。 设为 0 表示仅检查事件队列是否为空， 并且立即返回。</p>
</li>
<li><p><code>-E</code>, <code>--exit-if-exists=*FILE*</code></p>
<p>如果 FILE 文件存在，则停止等待。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-control-option"><a href="#udevadm-control-option" class="headerlink" title="udevadm control option"></a>udevadm control <em>option</em></h3><p>控制udev守护进程(systemd-udevd)的内部状态。</p>
<ul>
<li><p><code>-e</code>, <code>--exit</code></p>
<p>向 systemd-udevd 发送”退出”信号并等待其退出。因为 <code>systemd-udevd.service</code> 中含有 <code>Restart=always</code> ，所以此选项实际是重启了 systemd-udevd 。 如果你想停止 <code>systemd-udevd.service</code> ，那么应该使用：<code>systemctl stop systemd-udevd-control.socket systemd-udevd-kernel.socket systemd-udevd.service</code></p>
</li>
<li><p><code>-l</code>, <code>--log-priority=*value*</code></p>
<p>设置 <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd-udevd.service.html#">systemd-udevd.service(8)</a> 的内部日志等级。 可以用数字或文本表示： r<code>emerg</code>(0), <code>alert</code>(1), <code>crit</code>(2), <code>err</code>(3), <code>warning</code>(4), <code>notice</code>(5), <code>info</code>(6), <code>debug</code>(7)</p>
</li>
<li><p><code>-s</code>, <code>--stop-exec-queue</code></p>
<p>向 systemd-udevd 发送”禁止处理事件”信号， 这样所有新发生的事件都将进入等候队列。</p>
</li>
<li><p><code>-S</code>, <code>--start-exec-queue</code></p>
<p>向 systemd-udevd 发送”开始处理事件”信号，也就是开始处理事件队列中尚未处理的事件。</p>
</li>
<li><p><code>-R</code>, <code>--reload</code></p>
<p>向 systemd-udevd 发送”重新加载”信号，也就是重新加载udev规则与各种数据库(包括内核模块索引)。 注意，重新加载之后并不影响已经存在的设备， 但是新的配置将会应用于所有将来发生的新设备事件。</p>
</li>
<li><p><code>-p</code>, <code>--property=*KEY*=*value*</code></p>
<p>为所有将来发生的新设备事件统一设置一个全局的 KEY 属性，并将其值设为 value</p>
</li>
<li><p><code>-m</code>, <code>--children-max=</code><em>value</em></p>
<p>设置最多允许 systemd-udevd 同时处理多少个设备事件。</p>
</li>
<li><p><code>--ping</code></p>
<p>向 systemd-udevd 发送一个”ping”消息并等待应答。用于检查 systemd-udevd 守护进程是否仍在正常运行。</p>
</li>
<li><p><code>-t</code>, <code>--timeout=</code><em>seconds</em></p>
<p>等候 systemd-udevd 应答的最大秒数。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-monitor-options"><a href="#udevadm-monitor-options" class="headerlink" title="udevadm monitor [options]"></a>udevadm monitor [<em>options</em>]</h3><p>监视内核发出的设备事件(以”KERNEL”标记)， 以及udev在处理完udev规则之后发出的事件(以”UDEV”标记)，并在控制台上输出事件的设备路径(devpath)。 可用于分析udev处理设备事件所花的时间(比较”KERNEL”与”UDEV”的时间戳)。</p>
<ul>
<li><p><code>-k</code>, <code>--kernel</code></p>
<p>仅显示”KERNEL”事件</p>
</li>
<li><p><code>-u</code>, <code>--udev</code></p>
<p>仅显示”UDEV”事件</p>
</li>
<li><p><code>-p</code>, <code>--property</code></p>
<p>同时还显示事件的各属性</p>
</li>
<li><p><code>-s</code>, <code>--subsystem-match=*subsystem[/devtype]*</code></p>
<p>根据 subsystem[/devtype] 对事件(包括 kernel uevent 与 udev event)进行过滤，仅显示与”子系统[/设备类型]”匹配的”UDEV”事件。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，所有指定子系统中的设备都会被监视。</p>
</li>
<li><p><code>-t</code>, <code>--tag-match=*string*</code></p>
<p>根据设备标签对事件(仅 udev event)进行过滤，仅显示与”标签”匹配的”UDEV”事件。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，拥有任一指定标签的设备都会被监视。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-test-options-devpath"><a href="#udevadm-test-options-devpath" class="headerlink" title="udevadm test [options] [devpath]"></a>udevadm test [<em>options</em>] [<em>devpath</em>]</h3><p>模拟一个设备事件，并输出调试信息。</p>
<ul>
<li><p><code>-a</code>, <code>--action=*ACTION*</code></p>
<p>指定模拟哪种类型的设备事件，ACTION 可以是下列值之一：<strong>add</strong>(默认值), <strong>remove</strong>, <strong>change</strong></p>
</li>
<li><p><code>-N</code>, <code>--resolve-names=early|late|never</code></p>
<p>指定 udevadm 何时解析用户与组的名称： <code>early</code>(默认值) 表示在规则的解析阶段； <code>late</code> 表示在每个事件发生的时候； <code>never</code> 表示从不解析， 所有设备的属主与属组都是 root 。</p>
</li>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h3 id="udevadm-test-builtin-options-command-devpath"><a href="#udevadm-test-builtin-options-command-devpath" class="headerlink" title="udevadm test-builtin [options] [command] [devpath]"></a>udevadm test-builtin [<em>options</em>] [<em>command</em>] [<em>devpath</em>]</h3><p>针对 <em>DEVPATH</em>设备 运行一个内置的 <em>COMMAND</em> 命令， 并输出调试信息。</p>
<ul>
<li><p><code>-h</code>, <code>--help</code></p>
<p>显示简短的帮助信息并退出。</p>
</li>
</ul>
<h2 id="mdev"><a href="#mdev" class="headerlink" title="mdev"></a>mdev</h2><p>mdev 是udev的轻量级版本，集成于 busybox中。为了使用mdev 功能，/etc/init.d/rcS 包含的如下内容:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/bin/mount -t sysfs sysfs /sys</span><br><span class="line">/bin/mount -t tmpfs mdev /dev</span><br><span class="line">echo /bin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure>

<p><code>echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</code>的含义是当有热插拔事件产生时，内核会调用mdev。这时mdev扫描/sys 中所有的类设备目录，通过环境变量中的ACTION 和 DEVPATH，来确定此次热插拔事件的动作以及影响了/sys 中的那个目录。而<code>mdev -s</code>是自动扫描/sys 中所有的类设备目录。如果在目录中含有名为“dev”的文件，且文件中包含的是设备号，则mdev 就利用这些信息为该设备在/dev 下创建设备节点文件。</p>
<p>修改/etc/mdev.conf 文件可以修改mdev 的规则。</p>
<hr>
<p><a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/udevadm.html">http://www.jinbuguo.com/systemd/udevadm.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/sysfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/sysfs/" class="post-title-link" itemprop="url">sysfs</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:18:30" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>TOC<br>{:toc}</li>
</ul>
<h2 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h2><p>sysfs 是一个基于内存的虚拟文件系统，作用是将内核信息以文件的方式提供给用户程序使用。它把连接在系统上的设备和总线组织成为一个分级的文件，供用户空间存取；向用户空间导出内核数据结构以及它们的属性，以展示设备驱动模型中各组件的层次关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/sys/</span><br><span class="line">├── block     包含系统中发现的块设备;</span><br><span class="line">├── bus       包含内核注册的总线;</span><br><span class="line">├── class     包含注册到内核的设备类;</span><br><span class="line">├── bus       按总线类型分类</span><br><span class="line">│   ├── i2c</span><br><span class="line">│   │   ├── drivers</span><br><span class="line">│   │   └── devices   包含总线下的所有设备</span><br><span class="line">│   │       ├──i2c-0 -&gt; ../../../devices/pci0000:00/0000:00:02.0/i2c-0/</span><br><span class="line">│   │       └──i2c-1 -&gt; ../../../devices/pci0000:00/0000:00:02.0/i2c-1/</span><br><span class="line">│   ├── pci</span><br><span class="line">│   ├── spi</span><br><span class="line">│   ├── usb</span><br><span class="line">├── class          按设备功能分类的设备模型</span><br><span class="line">│   ├── block</span><br><span class="line">│   ├── bluetooth</span><br><span class="line">│   ├── dma</span><br><span class="line">│   ├── gpio</span><br><span class="line">│   ├── i2c-adapter</span><br><span class="line">│   ├── i2c-dev</span><br><span class="line">│   ├── input</span><br><span class="line">│   ├── misc</span><br><span class="line">│   ├── phy</span><br><span class="line">│   ├── pwm</span><br><span class="line">│   ├── rtc</span><br><span class="line">│   ├── tty</span><br><span class="line">├── dev         按字符设备和块设备的major:minor指向真实设备(sys/devices)的链接</span><br><span class="line">│   ├── block</span><br><span class="line">│   └── char</span><br><span class="line">├── devices     含系统所有的设备，并根据设备挂接的总线类型组织成层次结构;</span><br><span class="line">├── firmware</span><br><span class="line">│   ├── acpi</span><br><span class="line">│   ├── dmi</span><br><span class="line">│   └── memmap</span><br><span class="line">├── fs</span><br><span class="line">├── hypervisor</span><br><span class="line">├── kernel      内核所有可调整参数位置</span><br><span class="line">├── module      所有驱动模块的模块参数等信息</span><br><span class="line">└── power       系统电源选项</span><br></pre></td></tr></table></figure>

<h2 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h2><p>总线、驱动和设备都对应sysfs 中的一个目录，实际上都算是kobject 的派生类，device 结构体直接包含了 kobject kobj 成员，而 bus_type和 device_driver 则透过 subsys_private、driver_private 间接包含了 kobject。每一个注册的kobject对象都对应 sysfs中的一个目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>      *name;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>   <span class="title">entry</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>      *<span class="title">parent</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>      *<span class="title">kset</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>   *<span class="title">ktype</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span>   *<span class="title">sd</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>      <span class="title">kref</span>;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>kobj_type 是/sys/下的属性文件，代表kobject 的属性，release()函数在 kobject 的引用计数为0时会被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">   <span class="type">void</span> (*release)(<span class="keyword">struct</span> kobject *kobj);</span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span>   <span class="comment">// 属性数组</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">   <span class="type">const</span> <span class="type">void</span> *(*namespace)(<span class="keyword">struct</span> kobject *kobj);</span><br><span class="line">   <span class="type">void</span> (*get_ownership)(<span class="keyword">struct</span> kobject *kobj, <span class="type">kuid_t</span> *uid, <span class="type">kgid_t</span> *gid);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sysfs_ops 包含对文件读写的函数指针，代表对属性文件的文件操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> &#123;</span></span><br><span class="line">   <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> kobject *, <span class="keyword">struct</span> attribute *, <span class="type">char</span> *);</span><br><span class="line">   <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> kobject *, <span class="keyword">struct</span> attribute *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="kset"><a href="#kset" class="headerlink" title="kset"></a>kset</h2><p>kset 是具有相同类型的 kobject 集合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">   <span class="type">spinlock_t</span> list_lock;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span>  <span class="comment">// 热插拔事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当驱动程序将 kobject 注册到设备驱动模型时，也就是调用 kobject_add()和 kobject_del()函数时，会产生热插拔事件，内核会根据 kobject 的 kset 指针找到所属的 kset 结构体，执行 uevent_ops 中的热插拔函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> &#123;</span></span><br><span class="line">   <span class="type">int</span> (* <span class="type">const</span> filter)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj);  <span class="comment">// 事件过滤，如果返回 0，将不传递事件到用户空间</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *(* <span class="type">const</span> name)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj);  <span class="comment">// 返回子系统的名字</span></span><br><span class="line">   <span class="type">int</span> (* <span class="type">const</span> uevent)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj,</span><br><span class="line">            <span class="keyword">struct</span> kobj_uevent_env *env);  <span class="comment">// 将用户空间需要的参数添加到环境变量中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/devfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/devfs/" class="post-title-link" itemprop="url">devfs</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:18:30" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>TOC<br>{:toc}</li>
</ul>
<p>devfs(设备文件系统)是由Linux 2.4 内核引入。</p>
<ul>
<li>可以通过程序在设备初始化时在/dev 目录下创建设备文件，卸载设备时将它删除。</li>
<li>设备驱动程序可以指定设备名、所有者和权限位，用户空间程序仍可以修改所有者和权限位。</li>
<li>不再需要为设备驱动程序分配主设备号以及处理次设备号，给register_chrdev()传递0，以获得可用的主设备号，并在devfs_register()中指定次设备号。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/debug/" class="post-title-link" itemprop="url">kernel debug</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:18:30" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>TOC<br>{:toc}</li>
</ul>
<h2 id="WARN-ON"><a href="#WARN-ON" class="headerlink" title="WARN_ON"></a>WARN_ON</h2><p>内核要开启General setup-&gt;Configure standard kernel features-&gt;BUG() support</p>
<p>BUG_ON会引发oops，导致栈的回溯和错误信息的打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUG_ON(condition) do &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely((condition)!=<span class="number">0</span>)) </span><br><span class="line">           BUG(); </span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>WARN_ON则是调用dump_stack，打印堆栈信息，不会OOPS</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WARN_ON(condition) do &#123; </span></span><br><span class="line">      <span class="keyword">if</span> (unlikely((condition)!=<span class="number">0</span>)) &#123; </span><br><span class="line">         printk(<span class="string">&quot;Badness in %s at %s:%d/n&quot;</span>, __FUNCTION__, __FILE__,__LINE__); </span><br><span class="line">         dump_stack(); </span><br><span class="line">        &#125; </span><br><span class="line"> &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="printk"><a href="#printk" class="headerlink" title="printk"></a>printk</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG     <span class="string">&quot;&lt;0&gt;&quot;</span> <span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ALERT     <span class="string">&quot;&lt;1&gt;&quot;</span> <span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CRIT      <span class="string">&quot;&lt;2&gt;&quot;</span> <span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ERR       <span class="string">&quot;&lt;3&gt;&quot;</span> <span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_WARNING   <span class="string">&quot;&lt;4&gt;&quot;</span> <span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_NOTICE    <span class="string">&quot;&lt;5&gt;&quot;</span> <span class="comment">/* normal but significant condition */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_INFO      <span class="string">&quot;&lt;6&gt;&quot;</span> <span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEBUG     <span class="string">&quot;&lt;7&gt;&quot;</span> <span class="comment">/* debug-level messages */</span></span></span><br></pre></td></tr></table></figure>

<p>查看当前控制台的打印级别 <code>cat /proc/sys/kernel/printk</code></p>
<blockquote>
<p>4    4    1    7</p>
</blockquote>
<p>分别表示：</p>
<ul>
<li>控制台日志级别：优先级高于该值的消息将被打印至控制台;</li>
<li>默认的消息日志级别：将用该优先级来打印没有优先级的消息;</li>
<li>最低的控制台日志级别：控制台日志级别可被设置的最小值(最高优先级);</li>
<li>默认的控制台日志级别：控制台日志级别的缺省值;</li>
</ul>
<p>修改打印</p>
<blockquote>
<p>echo “新的打印级别  4    1    7” &gt;/proc/sys/kernel/printk</p>
</blockquote>
<p>打印级别不够的信息会被写到日志中，可通过<code>dmesg</code>命令来查看。</p>
<h2 id="Sparse"><a href="#Sparse" class="headerlink" title="Sparse"></a>Sparse</h2><p>Sparse通过 gcc 的扩展属性 <strong>attribute</strong> 以及自己定义的 <strong>context</strong> 来对代码进行静态检查。</p>
<table>
<thead>
<tr>
<th><strong>宏名称</strong></th>
<th><strong>宏定义</strong></th>
<th><strong>检查点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>__bitwise</td>
<td><strong>attribute</strong>((bitwise))</td>
<td>确保变量是相同的位方式(bit-endian, little-endiandeng)</td>
</tr>
<tr>
<td>__user</td>
<td><strong>attribute</strong>((noderef, address_space(1)))</td>
<td>指针地址必须在用户地址空间初始化，不能指向内核地址空间, 设备地址空间</td>
</tr>
<tr>
<td>__kernel</td>
<td><strong>attribute</strong>((noderef, address_space(0)))</td>
<td>指针地址必须在内核地址空间初始化</td>
</tr>
<tr>
<td>__iomem</td>
<td><strong>attribute</strong>((noderef, address_space(2)))</td>
<td>指针地址必须在设备地址空间初始化</td>
</tr>
<tr>
<td>__safe</td>
<td><strong>attribute</strong>((safe))</td>
<td>变量可以为空</td>
</tr>
<tr>
<td>__force</td>
<td><strong>attribute</strong>((force))</td>
<td>变量可以进行强制转换</td>
</tr>
<tr>
<td>__nocast</td>
<td><strong>attribute</strong>((nocast))</td>
<td>参数类型与实际参数类型必须一致</td>
</tr>
<tr>
<td>__acquires(x)</td>
<td><strong>attribute</strong>((context(x, 0, 1)))</td>
<td>参数x 在执行前引用计数必须是0，执行后，引用计数必须为1</td>
</tr>
<tr>
<td>__releases(x)</td>
<td><strong>attribute</strong>((context(x, 1, 0)))</td>
<td>与 __acquires(x) 相反</td>
</tr>
<tr>
<td>__acquire(x)</td>
<td><strong>context</strong>(x, 1)</td>
<td>参数x 的引用计数 + 1</td>
</tr>
<tr>
<td>__release(x)</td>
<td><strong>context</strong>(x, -1)</td>
<td>与 __acquire(x) 相反</td>
</tr>
<tr>
<td>__cond_lock(x,c)</td>
<td>((c) ? ({ __acquire(x); 1; }) : 0)</td>
<td>参数c 不为0时,引用计数 + 1, 并返回1</td>
</tr>
</tbody></table>
<p>其中 <code>__acquires(x)</code>  和<code>__releases(x)</code>，  <code>__acquire(x)</code>和  <code>__release(x)</code> 必须配对使用, 否则 Sparse 会给出警告。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/list/" class="post-title-link" itemprop="url">linux kernel list</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:18:30" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>TOC<br>{:toc}</li>
</ul>
<p>Linux内核中使用了大量的链表结构来组织数据，代码实现在include/linux/list.h中。</p>
<h2 id="list-head"><a href="#list-head" class="headerlink" title="list_head"></a>list_head</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>list_head本身没有任何数据内容，只有两个方向指针prev和next，而自定义的数据结点结构体只要包含list_head指针，就可以使用 list提供的所有接口函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span>    data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*声明一个链表头，它的next、prev指针都初始化为指向自己*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化已经定义过的链表*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">INIT_LIST_HEAD</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-add"><a href="#list-add" class="headerlink" title="list_add"></a>list_add</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add(<span class="keyword">struct</span> list_head *new_entry,</span><br><span class="line">       <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">       <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = new_entry;</span><br><span class="line">    new_entry-&gt;next = next;</span><br><span class="line">    new_entry-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = new_entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *new_entry, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_add(new_entry, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add_tail</span><span class="params">(<span class="keyword">struct</span> list_head *new_entry, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_add(new_entry, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-del"><a href="#list-del" class="headerlink" title="list_del"></a>list_del</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del(<span class="keyword">struct</span> list_head * prev, <span class="keyword">struct</span> list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_POISON1  ((void *) 0x00100100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_POISON2  ((void *) 0x00200200)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_del</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">    entry-&gt;next = (<span class="keyword">struct</span> list_head *)LIST_POISON1;</span><br><span class="line">    entry-&gt;prev = (<span class="keyword">struct</span> list_head *)LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-replace"><a href="#list-replace" class="headerlink" title="list_replace"></a>list_replace</h2><p>新节点替换老节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_replace</span><span class="params">(<span class="keyword">struct</span> list_head *old,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> list_head *new_entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    new_entry-&gt;next = old-&gt;next;</span><br><span class="line">    new_entry-&gt;next-&gt;prev = new_entry;</span><br><span class="line">    new_entry-&gt;prev = old-&gt;prev;</span><br><span class="line">    new_entry-&gt;prev-&gt;next = new_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-move"><a href="#list-move" class="headerlink" title="list_move"></a>list_move</h2><p>移动节点到另一个链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_move</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_del_entry(<span class="built_in">list</span>);</span><br><span class="line">    list_add(<span class="built_in">list</span>, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_move_tail</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_del_entry(<span class="built_in">list</span>);</span><br><span class="line">    list_add_tail(<span class="built_in">list</span>, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-empty"><a href="#list-empty" class="headerlink" title="list_empty"></a>list_empty</h2><p>判断这个链表的头指针 head的next是否指向它自己，如果是，则说明为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">list_empty</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="list-entry"><a href="#list-entry" class="headerlink" title="list_entry"></a>list_entry</h2><p>获取链表中某个节点的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset_of(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;\</span></span><br><span class="line"><span class="meta">    const __typeof__( ((type *)0)-&gt;member ) *__mptr = (ptr); \</span></span><br><span class="line"><span class="meta">    (type *)( (char *)__mptr - offset_of(type,member) ); &#125;)</span></span><br></pre></td></tr></table></figure>

<p>获取链表中第一个节点的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_first_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    list_entry((ptr)-&gt;next, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_last_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    list_entry((ptr)-&gt;prev, type, member)</span></span><br></pre></td></tr></table></figure>

<h2 id="list-for-each"><a href="#list-for-each" class="headerlink" title="list_for_each"></a>list_for_each</h2><p>遍历整个链表，pos只是一个临时的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_prev(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev; pos != (head); pos = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>

<h2 id="list-for-each-safe"><a href="#list-for-each-safe" class="headerlink" title="list_for_each_safe"></a>list_for_each_safe</h2><p>遍历链表，如果在遍历的过程中涉及到节点的删除操作，则需要使用这个函数，这个函数中有个中间节点 n 作为临时存储区，更加安全。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_prev_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev, n = pos-&gt;prev; \</span></span><br><span class="line"><span class="meta">         pos != (head); \</span></span><br><span class="line"><span class="meta">         pos = n, n = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>

<h2 id="list-for-each-entry"><a href="#list-for-each-entry" class="headerlink" title="list_for_each_entry"></a>list_for_each_entry</h2><p>节点结构遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry(head, __typeof__(*pos), member); \</span></span><br><span class="line"><span class="meta">         &amp;pos-&gt;member != (head);                    \</span></span><br><span class="line"><span class="meta">         pos = list_next_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry_reverse(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_last_entry(head, __typeof__(*pos), member); \</span></span><br><span class="line"><span class="meta">         &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">         pos = list_prev_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry_safe(pos, n, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry(head, __typeof__(*pos), member), \</span></span><br><span class="line"><span class="meta">            n = list_next_entry(pos, member); \</span></span><br><span class="line"><span class="meta">         &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">         pos = n, n = list_next_entry(n, member))</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/string/" class="post-title-link" itemprop="url">string functions</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:18:30" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>TOC<br>{:toc}</li>
</ul>
<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* des, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert((des!=<span class="literal">NULL</span>) &amp;&amp; (src!=<span class="literal">NULL</span>)); </span><br><span class="line">    <span class="type">char</span> *address = des;  </span><br><span class="line">    <span class="keyword">while</span>((*des++ = *src++) != <span class="string">&#x27;\0&#x27;</span>)  </span><br><span class="line">        ;  </span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>源指针所指的字符串内容是不能修改的，因此应该声明为 const 类型。</li>
<li>要判断源指针和目的指针为空的情况，这里使用<code>assert</code>。</li>
<li>要用一个临时变量保存目的串的首地址，最后返回这个首地址。</li>
<li>函数返回 char* 的目的是为了支持链式表达式，即strcpy可以作为其他函数的实参。</li>
</ul>
<h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* des, <span class="type">const</span> <span class="type">char</span>* src)</span>   <span class="comment">// const表明为输入参数 </span></span><br><span class="line">&#123;  </span><br><span class="line">    assert((des!=<span class="literal">NULL</span>) &amp;&amp; (src!=<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">char</span>* address = des;</span><br><span class="line">    <span class="keyword">while</span>(*des != <span class="string">&#x27;\0&#x27;</span>)  <span class="comment">// 移动到字符串末尾</span></span><br><span class="line">        ++des;</span><br><span class="line">    <span class="keyword">while</span>(*des++ = *src++)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert((s1!=<span class="literal">NULL</span>) &amp;&amp; (s2!=<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(*s1 == *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s1 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s1 - *s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>若s1==s2，返回零；</li>
<li>若s1&gt;s2，返回正数；</li>
<li>若s1&lt;s2，返回负数。</li>
</ul>
<p>两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇\0为止。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/socket/" class="post-title-link" itemprop="url">socket</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:18:30" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/socket/" itemprop="url" rel="index"><span itemprop="name">socket</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>TOC<br>{:toc}</li>
</ul>
<p>套接字用一个相关描述{协议、本地地址、本地端口、远程地址、远程端口}来表示，套接字有3种类型：</p>
<ul>
<li>流式套接字，提供可靠的、面向连接的通信流，使用TCP协议，从而保证了数据传输的正确性和顺序性。</li>
<li>数据报套接字，定义了一种无连接的服务，使用UDP协议，数据通过相互独立的报文进行传输，是无序的，并且不保证是可靠、无差错的。</li>
<li>原始套接字，允许对底层协议如IP或ICMP进行直接访问。</li>
</ul>
<p>描述符是应用程序用来识别套接字的机制，IP 地址和端口号是客户端和服务器之间用来识别对方套接字的机制。</p>
<h2 id="ip地址转换"><a href="#ip地址转换" class="headerlink" title="ip地址转换"></a>ip地址转换</h2><p>网络上数据以大端模式传输，因此需要对网络字节序和主机字节序进行相互转化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> ai_family, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> ai_family, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>inet_pton()函数是将点分十进制地址映射为二进制地址， inet_ntop()函数是将二进制地址映射为点分十进制地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure>

<p>inet_addr 将IPv4点分十进制地址转化为二进制地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> h_errno;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *h_name;         <span class="comment">/* Official name of host.  */</span></span><br><span class="line">  <span class="type">char</span> **h_aliases;     <span class="comment">/* Alias list.  */</span></span><br><span class="line">  <span class="type">int</span> h_addrtype;       <span class="comment">/* Host address type.  */</span></span><br><span class="line">  <span class="type">int</span> h_length;         <span class="comment">/* Length of address.  */</span></span><br><span class="line">  <span class="type">char</span> **h_addr_list;       <span class="comment">/* List of addresses from name server.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_MISC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span>    h_addr  h_addr_list[0] <span class="comment">/* Address, for backward compatibility.*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>       <span class="comment">/* for AF_INET */</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr,</span></span><br><span class="line"><span class="params">                             <span class="type">socklen_t</span> len, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure>

<p>gethostbyname将主机名或域名转化为IP地址，gethostbyaddr 则将IP地址转化为主机名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>              ai_flags;</span><br><span class="line">    <span class="type">int</span>              ai_family;</span><br><span class="line">    <span class="type">int</span>              ai_socktype;</span><br><span class="line">    <span class="type">int</span>              ai_protocol;</span><br><span class="line">    <span class="type">socklen_t</span>        ai_addrlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span></span><br><span class="line">    <span class="type">char</span>            *ai_canonname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **res)</span>;</span><br></pre></td></tr></table></figure>

<p>getaddrinfo能实现自动识别IPv4和IPv6地址</p>
<h2 id="socket创建"><a href="#socket创建" class="headerlink" title="socket创建"></a>socket创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>       </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p>socket建立一个socket连接。建立socket连接之后，可对sockaddr 或sockaddr_in结构进行初始化，以保存所建立的socket地址信息。<br>domain协议族：</p>
<ul>
<li>AF_INET:IPv4协议</li>
<li>AF_INET6:IPv6协议</li>
<li>AF_LOCAL:UNIX 域协议</li>
<li>AF_ROUTE:路由套接字</li>
<li>AF_KEY:密钥套接字</li>
<li>AF_LINK:链路地址协议</li>
</ul>
<p>type套接字类型：</p>
<ul>
<li>SOCK_STREAM  流套接字</li>
<li>SOCK_DGRAM  数据报套接字</li>
<li>SOCK_RAW  原始套接字</li>
</ul>
<p>protocol为0，原始套接字除外。</p>
<h2 id="socket连接"><a href="#socket连接" class="headerlink" title="socket连接"></a>socket连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/*14 字节的协议地址,包含该 socket 的 IP 地址和端口号。*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INADDR_ANY      ((in_addr_t) 0x00000000)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_port; <span class="comment">/*端口号*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/*IP地址，为0表示允许任何地址*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/*填充 0 以保持与 struct sockaddr 同样大小*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>sockaddr 和sockaddr_in结构体都是用来保存socket信息，两者数据类型等效，可以相互转化。服务端设置ip时， 用INADDR_ANY 会自动获取当前服务器的IP。</p>
<p>bind将本地IP地址绑定到端口号。不能绑定其他IP 地址。它主要用于TCP 的连接，而在UDP连接则无必要。</p>
<p>listen 创建一个等待队列，用来存放未处理的客户端连接请求。backlog参数指定请求队列中允许的最大请求数，默认为5。</p>
<p>accept 函数从请求队列中取出第一个未处理的连接请求。</p>
<p>connect函数在TCP中用于bind之后的client端与服务器端建立连接，而在UDP中由于没有bind函数，因此用 connect()有点类似 bind()函数的作用。</p>
<h2 id="socket读写"><a href="#socket读写" class="headerlink" title="socket读写"></a>socket读写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span>                    <span class="comment">/* Scatter/gather array items */</span></span><br><span class="line">   <span class="type">void</span>  *iov_base;              <span class="comment">/* Starting address */</span></span><br><span class="line">   <span class="type">size_t</span> iov_len;               <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>         *msg_name;       <span class="comment">/* optional address */</span></span><br><span class="line">   <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">/* size of address */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* scatter/gather array */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">   <span class="type">void</span>         *msg_control;    <span class="comment">/* ancillary data, see below */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_controllen; <span class="comment">/* ancillary data buffer len */</span></span><br><span class="line">   <span class="type">int</span>           msg_flags;      <span class="comment">/* flags on received message */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>send和recv分别用于发送和接收数据。</p>
<p>sendto和recvfrom，当用在TCP时，后面的几个与地址有关参数不起作用，函数作用等同于send和recv。当用在UDP时，可以在之前没有使用connect的情况下，自动寻找指定地址并进行连接。</p>
<p><img src="/images/net/tcpip/socket.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/pthread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/pthread/" class="post-title-link" itemprop="url">linux pthread</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:18:30" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>TOC<br>{:toc}</li>
</ul>
<p>进程是系统中程序执行和资源分配的基本单位。每个进程都拥有自己的数据段、代码段和堆栈段，这就造成进程在进行切换时需要消耗更多的处理器空转时间。为了减少上下文切换开销，进程在演化中出现了另一个概念——线程。</p>
<p>线程处理器调度的最小单元。线程可以访问进程的内存空间和资源，并与同一进程中的其他线程共享，因此线程的上下文切换的开销比创建进程小很多。同进程一样，线程也将相关的执行状态和存储变量放在线程控制表内。一个进程可以有多个线程，也就是有多个线程控制表及堆栈寄存器，但却共享一个用户地址空间。由于线程共享了进程的资源和地址空间，因此任何线程对系统资源的操作都会给其他线程带来影响，必须考虑线程间资源访问的同步与互斥问题。</p>
<p>线程按照其调度者可以分为用户级线程和核心级线程两种。现在大多数系统都采用用户级线程与核心级线程并存的方法。一个用户级线程可以对应一个或几个核心级线程，这样既可满足多处理机系统的需要，也可以最大限度地减少调度开销。</p>
<ul>
<li><p>用户级线程主要解决的是上下文切换的问题，它的调度算法和调度过程全部由用户自行选择决定，在运行时不需要内核支持。系统往往会提供一个用户空间的线程库，该线程库提供了线程的创建、调度和撤销等功能，而内核仍然仅对进程进行管理。如果一个进程中的某一个线程调用了一个阻塞的系统调用函数，那么该进程包括该进程中的其他所有线程也同时被阻塞。这种用户级线程的主要缺点是在一个进程中的多个线程的调度中无法发挥多处理器的优势。</p>
</li>
<li><p>内核级线程允许不同进程中的线程按照同一相对优先调度方法进行调度，这样就可以发挥多处理器的并发优势。</p>
</li>
</ul>
<p>线程机制大大加快上下文切换速度，而且节省很多资源。但是因为在用户态和内核态均要实现调度管理，所以会增加实现的复杂度和引起优先级翻转的可能性。一个多线程程序的同步设计与调试也会增加程序实现的难度。</p>
<p>gcc在编译时要链接libpthread库<code>-lpthread</code>。</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread_create 创建线程，确定调用该线程函数的入口点。thread参数是线程标识符。attr是线程属性设置，通常取为 NULL。start_routine参数是线程函数的起始地址，一个指向void 的指针作为参数和返回值的函数指针。arg是传递给start_routine 的参数。</p>
<p>pthread_exit 退出线程。retval参数是线程结束时的返回值，可由其他函数如 pthread_join()来获取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread_join 用来同步终止并释放线程资源，将当前线程挂起来等待线程的结束。这个函数是一个线程阻塞的函数,调用它的函数将一直等待到被等待的线程结束为止,当函数返回时,被等待线程的资源就被收回。<br>retval参数是用户定义的指针，用来存储被等待线程结束时的返回值(不为NULL时)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread_cancel 在别的线程中终止另一个线程的执行。但在被取消的线程的内部需要调用 pthread_setcancel()函数和 pthread_setcanceltype()函数设置自己的取消状态。</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁是用一种简单的加锁方法来控制对共享资源按顺序进行原子操作。这个互斥锁只有两种状态，也就是上锁和解锁。在同一时刻只能有一个线程掌握某个互斥锁，拥有上锁状态的线程能够对共享资源进行操作。若其他线程希望上锁一个已经被上锁的互斥锁，则该线程就会挂起，直到上锁的线程释放掉互斥锁为止。</p>
<p>互斥锁可以分为快速互斥锁、递归互斥锁和检错互斥锁。这三种锁的区别主要在于其他未占有互斥锁的线程在希望得到互斥锁时是否需要阻塞等待。快速锁是指调用线程会阻塞，直至拥有互斥锁的线程解锁为止。递归互斥锁能够成功地返回，并且在调用线程互斥上多次加锁。检错互斥锁则为快速互斥锁的非阻塞版本，它会立即返回并返回一个错误信息。默认为快速互斥锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span> <span class="params">(<span class="keyword">struct</span> __pthread_mutex *__restrict __mutex,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *__restrict __attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span> <span class="params">(<span class="keyword">struct</span> __pthread_mutex *__mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread_mutex_init 创建互斥锁，attr参数：</p>
<ul>
<li>PTHREAD_MUTEX_INITIALIZER  创建快速互斥锁</li>
<li>PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP  创建递归互斥锁</li>
<li>PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP  创建检错互斥锁</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>

<p>sem_init 用于创建一个信号量，并初始化它的值。</p>
<p>sem_wait 和sem_trywait 都相当于P 操作，在信号量大于零时它们都能将信号量的值-1，区别在于若信号量小于零，sem_wait 会阻塞进程，而sem_trywait 则会立即返回。</p>
<p>sem_post 相当于V 操作，它将信号量的值加一同时发出信号来唤醒等待的进程。</p>
<p>sem_getvalue 用于得到信号量的值。</p>
<p>sem_destroy 用于删除信号量。</p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>pthread_create()函数的第二个参数attr 表示线程的属性。值设为NULL，<br>也就是采用默认属性，系统默认为非绑定、非分离、缺省1M的堆栈以及与父进程同样级别的优先级。</p>
<p>绑定属性的线程可以保证在需要的时候总有一个内核线程与之对应。<br>非绑定属性就是指用户线程和内核线程的关系不是始终固定的,而是由系统来控制分配。</p>
<p>分离属性是在一个线程结束时立即释放它所占有的系统资源，这个线程运行非常快，可能在pthread_create()<br>函数返回之前就终止了，系统就可能将线程号和系统资源移交给其他的线程使用，从而导致出错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scheduling algorithms.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_OTHER 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_FIFO  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_RR    2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> &#123;</span></span><br><span class="line">   <span class="type">int</span> sched_priority;     <span class="comment">/* Scheduling priority */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setscope</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> scope)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getscope</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *scope)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setschedpolicy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getschedpolicy</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *policy)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setschedparam</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getschedparam</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="keyword">struct</span> sched_param *param)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread_attr_init 初始化线程属性。pthread_attr_destroy 对分配的属性结构指针进行清理和回收。</p>
<p>pthread_attr_setscope 设置绑定属性：</p>
<ul>
<li>PTHREAD_SCOPE_SYSTEM  绑定</li>
<li>PTHREAD_SCOPE_PROCESS  非绑定</li>
</ul>
<p>pthread_attr_setdetachstate 设置线程分离属性：</p>
<ul>
<li>PTHREAD_CREATE_DETACHED  分离</li>
<li>PTHREAD _CREATE_JOINABLE  非分离</li>
</ul>
<p>pthread_attr_getschedparam 获取线程优先级。pthread_attr_setschedparam 设置线程优先级，设置之前可用sched_get_priority_max() 确定优先级的取値范围。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_max</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_min</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/07/process/" class="post-title-link" itemprop="url">linux process in user</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-07 16:05:44 / Modified: 16:18:30" itemprop="dateCreated datePublished" datetime="2022-06-07T16:05:44+08:00">2022-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>TOC<br>{:toc}</li>
</ul>
<p>进程是系统进行资源分配和调度的单位。</p>
<h2 id="进程空间"><a href="#进程空间" class="headerlink" title="进程空间"></a>进程空间</h2><p><img src="/images/linux/process/mem.jpeg" alt="进程空间"></p>
<ul>
<li><p>未初始化数据段(.bss)：Block Storage Start，存放未初始化或初始化为0的全局变量，未初始化的静态变量。bss段的变量只占用运行时的内存空间，而不占用文件空间。在程序开始执行之前，内核将此段初始化为0。.bss段占据的大小存放在ELF文件格式中的段表(Section Table)中，段表存放了各个段的各种信息，比如段的名字、段的类型、段在elf文件中的偏移、段的大小等信息。同时符号存放在符号表.symtab中。</p>
</li>
<li><p>初始化数据段(.data)：存放初始化非0的全局变量，初始化的静态变量。既占用运行时的内存空间，又占用文件空间。</p>
</li>
<li><p>代码段：只读，包含程序代码（.init和.text）和只读数据（.rodata），存储机器码序列、全局常量、代码、字符串常量。</p>
</li>
<li><p>栈：从高地址往低地址向下增长，存放局部变量、局部常量、函数参数、返回值、函数调用时返回地址、调用者的环境信息。</p>
</li>
<li><p>堆：从低地址往高低至增长，动态分配的内存。</p>
</li>
</ul>
<p>可以用<code>cat /proc/self/maps</code>查看程序运行时空间的分配情况，每个区间都有4个属性：</p>
<ul>
<li>r  表示可以读取;</li>
<li>w  表示可以修改;</li>
<li>x  表示可以执行;</li>
<li>p/s 表示是否为共享内存;</li>
</ul>
<p><code>size</code>命令可以查看可执行文件的正文段、数据段和 b s s段的长度(单位:字节)。</p>
<p>数据段和代码段分离，数据和指令被映射到两个虚拟内存区域，数据段对进程来说可读写，代码段是只读，这样可以防止程序的指令被改写。现代CPU缓存一般被设计成数据缓存和指令缓存分离，分开对CPU缓存命中率有好处。代码段是可以共享的，数据段是私有的，当运行多个程序的副本时，只需要保存一份代码段。</p>
<p>栈容易溢出是因为栈内存有限，递归次数多了，局部数据占用的内存直到整个递归结束才会被释放，很容易就导致栈溢出。</p>
<h2 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>getpid返回调用进程的进程号，Linux 内核限制进程号需小于等于 32767。</p>
<p>getppid返回目前进程的父进程的进程号。可通过查看/proc/pid/status 的PPid字段，可以获知每个进程的父进程。任何进程都可使用符号链接/proc/self 来访问其自己的/proc/pid/ 目录。</p>
<h2 id="进程调度函数"><a href="#进程调度函数" class="headerlink" title="进程调度函数"></a>进程调度函数</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">vfork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>fork创建的新进程被称为子进程(child process)。该函数被调用一次，但返回两次。可通过返回值来区分父、子进程。在父进程中返回新创建子进程的进程 ID，而在子进程中则返回 0，子进程可调用getpid以获取自身的进程 ID，调用getppid以获取父进程ID。</p>
<p>子进程从父进程处继承了整个进程的地址空间,包括进程上下文、代码段、进程堆栈、内存信息、打开的文件描述符、信号控制设定、进程优先级、进程组号、当前工作目录、根目录、资源限制、环境变量、标准IO的缓存数据和控制终端等，而子进程所独有的只有它的进程号、资源使用和计时器等。这两个进程将执行相同的程序文本段，但却各自拥有不同的栈段、数据段以及堆段拷贝。子进程的栈、数据以及栈段开始时是对父进程内存相应各部分的完全复制，每个进程均可修改各自的栈数据、以及堆段中的变量，而并不影响另一进程。子进程的tms_utime、tms_stime、tms_cutime以及tms_ustime设置为0，子进程不继承父进程设置的锁。</p>
<p>vfork用于创建一个新进程，但并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec或exit，不会存访该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。(如果调用这两个函数之前子进程依赖于父进程，会导致死锁)</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br></pre></td></tr></table></figure>

<p>使进程停止运行，清除其使用清理I/O缓冲的内存空间，并清除其在内核中的各种数据结构。</p>
<p>status为<code>EXIT_FAILURE</code>程序异常退出，<code>EXIT_SUCCESS</code>正常退出。</p>
<p>exit()和_exit()的区别在于exite x i t会执行一些清除处理(包括调用执行各终止处理程序，关闭所有标准 I / O流。</p>
<h3 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>在进程终止后，以登记的相反顺序调用注册的终止处理函数。</p>
<h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>abort产生SIGABRT信号，如进程越出其地址空间访问存储单元或者除以0。</p>
<p>对于其父进程已经终止的进程，它们的父进程都改变为init进程，进程ID为1。</p>
<h3 id="wait-waitpid"><a href="#wait-waitpid" class="headerlink" title="wait waitpid"></a>wait waitpid</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>wait使其调用者阻塞，直到一个子进程终止，并返回其进程号。如果该父进程没有子进程或者他的子进程已经结束，则立即返回。</p>
<p>waitpid的pid参数：</p>
<ul>
<li>&gt;0 只等待进程ID等于pid 的子进程，只要子进程还没结束，就会一直等下去；</li>
<li>-1 等待任何一个子进程退出，和wait一样；</li>
<li>0 等待其组ID相同的任一子进程；</li>
<li>&lt;-1 等待其组ID等于pid的绝对值的任一子进程；</li>
</ul>
<p>waitpid的options参数：</p>
<ul>
<li>WNOHANG 若由pid指定的子进程不立即可用，则不阻塞并返回0；</li>
<li>WUNTRACED 若实现某支持作业控制，则由pid指定的任一子进程状态已暂停，且其状态自暂停以来还未报告过，则返回其状态；</li>
<li>0 同wait阻塞父进程，等待子进程退出；</li>
</ul>
<p>如果不关心终止状态，可将该status参数指定为NULL，可用宏检查status的状态。</p>
<p><img src="/images/linux/process/wait_status.png" alt="wait_status"></p>
<p>如果一个进程希望等待一个子进程终止，则它必须调用wait函数。如果一个进程要等待其父进程终止，则可使用下列形式的循环:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... (<span class="type">char</span> *)<span class="literal">NULL</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... (<span class="type">char</span> *) <span class="literal">NULL</span>, <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... (<span class="type">char</span> *)<span class="literal">NULL</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<p>当进程调用exec时并不创建新进程，前后的进程ID并未改变，只是用另一个新程序替换了当前进程的正文、数据、堆和栈段。</p>
<p>这些函数，字母带p表示该函数取file作为参数，并且用PATH环境变量寻找可执行文件。字母l表示该函数取一个参数表，每个char指针都是一个命令行参数，参数表以空指针结尾。v表示取argv数组中的内容为命令行参数。字母e表示环境变量为envp数组，而不使用当前环境。</p>
<h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure>

<p>执行command内容的shell命令。</p>
<h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> &#123;</span></span><br><span class="line">   <span class="type">clock_t</span> tms_utime;  <span class="comment">/* user time */</span></span><br><span class="line">   <span class="type">clock_t</span> tms_stime;  <span class="comment">/* system time */</span></span><br><span class="line">   <span class="type">clock_t</span> tms_cutime; <span class="comment">/* user time of children */</span></span><br><span class="line">   <span class="type">clock_t</span> tms_cstime; <span class="comment">/* system time of children */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">times</span><span class="params">(<span class="keyword">struct</span> tms *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>获取进程的系统CPU时间和用户CPU时间，返回当时的系统时钟计数。</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>每个进程组有一个组长进程。组长进程的标识是其进程组 I D等于其进程I D。进程组组长可以创建一个进程组,创建该组中的进程,然后终止。只要在某个进程组中有一个进程存在,则该进程组就存在,这与其组长进程是否终止无关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;                 <span class="comment">/* POSIX.1 version */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">pid_t</span> pid)</span>;            <span class="comment">/* BSD version */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;                   <span class="comment">/* System V version */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;  <span class="comment">/* BSD version */</span></span><br></pre></td></tr></table></figure>

<p>setpgid将pid进程的进程组ID设置为pgid。如果pid和pgid相等,则由pid指定的进程变成进程组组长。如果pid是0,则使用调用者的进程ID。如果pgid是0,则由pid指定的进程ID被用作为进程组ID。</p>
<p>一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec后,它就不再能改变该子进程的进程组ID。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>如果调用此函数的进程不是一个进程组的组长，则创建一个新会话期，则返回进程组ID。</p>
<ul>
<li>此进程变成该新会话期的会话期首进程。</li>
<li>此进程成为一个新进程组的组长进程。新进程组ID是此进程的进程ID。</li>
<li>此进程没有控制终端。如果在调用setsid之前此进程有一个控制终端，那么这种联系也被解除。</li>
</ul>
<p>如果调用进程已经是一个进程组的组长，则返回-1。</p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>守护进程(daemon)是一种在系统引导装入时起动,在系统关闭时终止。在后台运行没有控制终端的进程。创建守护进程的步骤为：</p>
<ol>
<li><p>首先调用fork，然后使父进程exit。这样做实现了下面几点:<br>(a)如果精灵进程是由一条shell命令起动的，那么父进程终止使得shell认为这条命令已经执行完成。<br>(b)进程继承了父进程的进程组ID，其进程ID则是新分配的，这就保证了子进程不是一个进程组的首进程。这是setsid调用的必要前提条件。</p>
</li>
<li><p>调用setsid以创建一个新对话期。使调用进程：(a)成为新对话期的首进程，(b)成为一个新进程组的首进程，(c)没有控制终端。</p>
</li>
<li><p>将当前工作目录更改为根目录。保证工作目录所在的文件系统不能被卸载。</p>
</li>
<li><p>将文件权限掩码设置为0，方便进程操作文件。</p>
</li>
<li><p>关闭不再需要的文件描述符。从父进程那里继承打开了的文件，可能永远不会被守护进程读或写，但一样消耗系统资源，而且可能导致所在的文件系统无法被卸载。</p>
</li>
</ol>
<p>守护进程没有控制终端，所以不能将错误信息输出到控制终端。可以使用syslog服务将程序中的出错信息输入到系统日志文件/var/log/syslog。</p>
<p>syslog是linux中的系统日志管理服务，通过守护进程syslogd来维护，该守护进程在启动时会读配置文件/etc/syslog.conf，该文件决定了不同种类的消息会发送向何处。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> option, <span class="type">int</span> facility)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>openlog用于打开系统日志服务的一个连接。ident参数定义消息的标签字符串，option参数：</p>
<ul>
<li>LOG_CONS  如果消息无法送到系统日志服务，则直接输出到系统控制终端</li>
<li>LOG_NDELAY  立即打开系统日志服务的连接。在正常情况下，直接发送到第一条消息时才打开连接</li>
<li>LOG_PERROR  将日志消息发送给 s y s l o g和stderr。</li>
<li>LOG_PID  消息中包含进程的PID</li>
</ul>
<p>facility参数指定程序发送的消息类型：</p>
<ul>
<li>LOG_AUTHPRIV  安全/授权信息</li>
<li>LOG_CRON  时间守护进程(cron 及 at)函数传入值</li>
<li>LOG_DAEMON  其他系统守护进程</li>
<li>LOG_KERN  内核信息</li>
<li>LOG_LOCAL[0~7]  保留</li>
<li>LOG_LPR  行打印机子系统</li>
<li>LOG_MAIL  邮件子系统</li>
<li>LOG_NEWS  新闻子系统</li>
<li>LOG_SYSLOG  syslogd 内部所产生的信息</li>
<li>LOG_USER  一般使用者等级信息</li>
<li>LOG_UUCP  UUCP 子系统</li>
</ul>
<p>syslog是用于向日志文件中写入消息，format参数规定消息输出格式等。priority参数指定消息等级：</p>
<ul>
<li>LOG_EMERG  紧急(系统不可使用)</li>
<li>LOG_ALERT  需要立即采取措施</li>
<li>LOG_CRIT  重要情况</li>
<li>LOG_ERR  错误消息</li>
<li>LOG_WARNING  警告消息</li>
<li>LOG_NOTICE  正常情况,但也是重要情况</li>
<li>LOG_INFO  信息消息</li>
<li>LOG_DEBUG  调试信息</li>
</ul>
<p>closelog是用于关闭系统日志服务的连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">daemon_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开系统日志服务 */</span></span><br><span class="line">    openlog(<span class="string">&quot;daemon_syslog&quot;</span>, LOG_PID, LOG_DAEMON);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建新的会话组*/</span></span><br><span class="line">    ret = setsid();</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        syslog(LOG_ERR, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*关闭父进程的文件描述符*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; getdtablesize(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        close(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syslog(LOG_INFO, <span class="string">&quot;daemon init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">daemon_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    closelog();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="终端登陆"><a href="#终端登陆" class="headerlink" title="终端登陆"></a>终端登陆</h2><p>系统启动时，内核创建init进程。init进程使系统进入多用户状态。init读文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork，生成的子进程则执行程序/sbin/getty。然后getty执行/bin/login。</p>
<h2 id="网络登陆"><a href="#网络登陆" class="headerlink" title="网络登陆"></a>网络登陆</h2><p>init调用一个shell，使其执行shell脚本etc/rc。由此shell脚本起动一个精灵进程inetd。一旦此shell脚本终止，inetd的父进程就变成init。inetd等待TCP/IP连接请求到达主机，而当一个连接请求到达时，它执行一次fork，然后该子进程执行相应的程序。</p>
<h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>一个会话期可以有一个单独的控制终端。这通常是我们在其上登录的终端设备(终端登录情况)或伪终端设备(网络登录情况)。建立与控制终端连接的会话期首进程被称之为控制进程。</p>
<p>一个会话期中的几个进程组可被分成一个前台进程组以及多个后台进程组。如果一个会话期有一个控制终端，则它有一个前台进程组，其他进程组则为后台进程组。无论何时键入中断键都会将中断信号或退出信号送至前台进程组的所有进程。如果终端界面检测到调制解调器已经脱开连接，则将挂断信号送至控制进程。</p>
<p>不管标准输入、标准输出是否重新定向，程序通过读写/dev/tty文件与控制终端交互。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">tcgetpgrp</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcsetpgrp</span><span class="params">(<span class="type">int</span> fd, <span class="type">pid_t</span> pgrp)</span>;</span><br></pre></td></tr></table></figure>

<p>tcgetpgrp返回前台进程组ID，它与在filedes上打开的终端相关。如果进程有一个控制终端，则该进程可以调用tcsetpgrp将前台进程组ID设置为pgrpid。</p>
<p>pgrp值应当是在同一会话期中的一个进程组的ID。fd必须引用该会话期的控制终端。大多数应用程序并不直接调用这两个函数。它们通常由作业控制shell调用。只有定义了_POSIX_JOB_CONTROL，这两个函数才被定义，否则它们返回出错。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v5.4.2
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
